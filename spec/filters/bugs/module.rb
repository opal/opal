opal_filter "Module" do
  fails "Module#< raises a TypeError if the argument is not a class/module"
  fails "Module#< returns false if self is the same as the given module"
  fails "Module#< returns nil if self is not related to the given module"
  fails "Module#< returns true if self is a subclass of or includes the given module"
  fails "Module#<= raises a TypeError if the argument is not a class/module"
  fails "Module#<= returns false if self is a superclass of or is included by the given module"
  fails "Module#<= returns nil if self is not related to the given module"
  fails "Module#<= returns true if self is a subclass of, the same as or includes the given module"
  fails "Module#<=> returns +1 if self is a superclas of or included by the given module"
  fails "Module#<=> returns -1 if self is a subclass of or includes the given module"
  fails "Module#=== returns true when the given Object's class includes self or when the given Object is extended by self"
  fails "Module#> raises a TypeError if the argument is not a class/module"
  fails "Module#> returns false if self is a subclass of or includes the given module"
  fails "Module#> returns false if self is the same as the given module"
  fails "Module#> returns nil if self is not related to the given module"
  fails "Module#> returns true if self is a superclass of or included by the given module"
  fails "Module#>= raises a TypeError if the argument is not a class/module"
  fails "Module#>= returns false if self is a subclass of or includes the given module"
  fails "Module#>= returns nil if self is not related to the given module"
  fails "Module#>= returns true if self is a superclass of, the same as or included by given module"
  fails "Module#alias_method accesses a method defined on Object from Kernel"
  fails "Module#alias_method aliasing special methods keeps initialize private when aliasing"
  fails "Module#alias_method aliasing special methods keeps initialize_clone private when aliasing"
  fails "Module#alias_method aliasing special methods keeps initialize_copy private when aliasing"
  fails "Module#alias_method aliasing special methods keeps initialize_dup private when aliasing"
  fails "Module#alias_method aliasing special methods keeps respond_to_missing? private when aliasing"
  fails "Module#alias_method can call a method with super aliased twice"
  fails "Module#alias_method fails if origin method not found"
  fails "Module#alias_method is a private method"
  fails "Module#alias_method preserves the arguments information of the original methods"
  fails "Module#alias_method raises RuntimeError if frozen"
  fails "Module#alias_method raises a TypeError when the given name can't be converted using to_str"
  fails "Module#alias_method retains method visibility"
  fails "Module#ancestors returns a list of modules included in self (including self)"
  fails "Module#ancestors returns only modules and classes"
  fails "Module#ancestors when called on a singleton class includes the singleton classes of ancestors"
  fails "Module#append_features copies own tainted status to the given module"
  fails "Module#append_features copies own untrusted status to the given module"
  fails "Module#append_features is a private method"
  fails "Module#append_features on Class raises a TypeError if calling after rebinded to Class"
  fails "Module#append_features raises an ArgumentError on a cyclic include"
  fails "Module#append_features when other is frozen raises a RuntimeError before appending self"
  fails "Module#attr applies current visibility to methods created"
  fails "Module#attr applies current visibility to methods created"
  fails "Module#attr converts non string/symbol/fixnum names to strings using to_str"
  fails "Module#attr creates a getter but no setter for all given attribute names"
  fails "Module#attr creates a getter for the given attribute name"
  fails "Module#attr is a private method"
  fails "Module#attr raises a TypeError when the given names can't be converted to strings using to_str"
  fails "Module#attr_accessor allows creating an attr_accessor on an immediate class"
  fails "Module#attr_accessor applies current visibility to methods created"
  fails "Module#attr_accessor converts non string/symbol/fixnum names to strings using to_str"
  fails "Module#attr_accessor is a private method"
  fails "Module#attr_accessor raises a TypeError when the given names can't be converted to strings using to_str"
  fails "Module#attr_reader allows for adding an attr_reader to an immediate"
  fails "Module#attr_reader applies current visibility to methods created"
  fails "Module#attr_reader converts non string/symbol/fixnum names to strings using to_str"
  fails "Module#attr_reader is a private method"
  fails "Module#attr_reader raises a TypeError when the given names can't be converted to strings using to_str"
  fails "Module#attr_writer allows for adding an attr_writer to an immediate"
  fails "Module#attr_writer applies current visibility to methods created"
  fails "Module#attr_writer converts non string/symbol/fixnum names to strings using to_str"
  fails "Module#attr_writer is a private method"
  fails "Module#attr_writer raises a TypeError when the given names can't be converted to strings using to_str"
  fails "Module#class_eval adds methods respecting the lexical constant scope"
  fails "Module#class_eval converts a non-string filename to a string using to_str"
  fails "Module#class_eval converts non string eval-string to string using to_str"
  fails "Module#class_eval defines constants in the receiver's scope"
  fails "Module#class_eval evaluates a given string in the context of self"
  fails "Module#class_eval raises a TypeError when the given eval-string can't be converted to string using to_str"
  fails "Module#class_eval raises a TypeError when the given filename can't be converted to string using to_str"
  fails "Module#class_eval uses the optional filename and lineno parameters for error messages"
  fails "Module#class_exec defines method in the receiver's scope"
  fails "Module#class_exec passes arguments to the block"
  fails "Module#class_exec raises a LocalJumpError when no block is given"
  fails "Module#class_variable_defined? converts a non string/symbol/fixnum name to string using to_str"
  fails "Module#class_variable_defined? raises a TypeError when the given names can't be converted to strings using to_str"
  fails "Module#class_variable_defined? returns false if a class variables with the given name is defined in an extended module"
  fails "Module#class_variable_defined? returns false if the class variable is not defined in a metaclass"
  fails "Module#class_variable_defined? returns true if a class variable with the given name is defined in self"
  fails "Module#class_variable_defined? returns true if a class variable with the given name is defined in the metaclass"
  fails "Module#class_variable_defined? returns true if a class variables with the given name is defined in an included module"
  fails "Module#class_variable_defined? returns true if the class variable is defined in a metaclass"
  fails "Module#class_variable_get returns the value of a class variable with the given name defined in an included module"
  fails "Module#class_variable_set sets the value of a class variable with the given name defined in an included module"
  fails "Module#class_variables does not return class variables defined in extended modules"
  fails "Module#class_variables returns an Array of Symbols of class variable names defined in a metaclass"
  fails "Module#class_variables returns an Array with names of class variables defined in metaclasses"
  fails "Module#class_variables returns an Array with the names of class variables of self"
  fails "Module#const_defined? should not search parent scopes of classes and modules if inherit is false"
  fails "Module#const_get accepts a toplevel scope qualifier"
  fails "Module#const_get calls #to_str to convert the given name to a String"
  fails "Module#const_get does not search the singleton class of a Class or Module"
  fails "Module#const_get raises a NameError if a Symbol is a scoped constant name"
  fails "Module#const_get raises a NameError if the constant is defined in the receiver's supperclass and the inherit flag is false"
  fails "Module#const_get raises a NameError with the not found constant symbol"
  fails "Module#const_get raises a TypeError if conversion to a String by calling #to_str fails"
  fails "Module#const_get should not search parent scopes of classes and modules if inherit is false"
  fails "Module#const_get with dynamically assigned constants searches a module included in the immediate class before the superclass"
  fails "Module#const_get with dynamically assigned constants searches a module included in the superclass"
  fails "Module#const_get with dynamically assigned constants searches the superclass chain"
  fails "Module#const_missing raises NameError and does not include toplevel Object"
  fails "Module#constants doesn't returns inherited constants when passed false"
  fails "Module#constants doesn't returns inherited constants when passed nil"
  fails "Module#constants includes names of constants defined after a module is included"
  fails "Module#constants returns all constants including inherited when passed some object"
  fails "Module#constants returns all constants including inherited when passed true"
  fails "Module#constants returns an array of Symbol names of all constants defined in the module and all included modules"
  fails "Module#constants returns only public constants"
  fails "Module#define_method calls #method_added after the method is added to the Module"
  fails "Module#define_method does not change the arity check style of the original proc"
  fails "Module#define_method passed {  } creates a method that raises an ArgumentError when passed one argument"
  fails "Module#define_method passed {  } creates a method that raises an ArgumentError when passed two arguments"
  fails "Module#define_method passed { |a, *b|  } creates a method that raises an ArgumentError when passed zero arguments"
  fails "Module#define_method passed { |a, b, *c|  } creates a method that raises an ArgumentError when passed one argument and a block"
  fails "Module#define_method passed { |a, b, *c|  } creates a method that raises an ArgumentError when passed one argument"
  fails "Module#define_method passed { |a, b, *c|  } creates a method that raises an ArgumentError when passed zero arguments"
  fails "Module#define_method passed { |a, b|  } creates a method that raises an ArgumentError when passed one argument and a block"
  fails "Module#define_method passed { |a, b|  } creates a method that raises an ArgumentError when passed one argument"
  fails "Module#define_method passed { |a, b|  } creates a method that raises an ArgumentError when passed three arguments"
  fails "Module#define_method passed { |a, b|  } creates a method that raises an ArgumentError when passed zero arguments"
  fails "Module#define_method passed { |a|  } creates a method that raises an ArgumentError when passed two arguments"
  fails "Module#define_method passed { |a|  } creates a method that raises an ArgumentError when passed zero arguments and a block"
  fails "Module#define_method passed { |a|  } creates a method that raises an ArgumentError when passed zero arguments"
  fails "Module#define_method passed { ||  } creates a method that raises an ArgumentError when passed one argument"
  fails "Module#define_method passed { ||  } creates a method that raises an ArgumentError when passed two arguments"
  fails "Module#define_method raises a TypeError when an UnboundMethod from a child class is defined on a parent class"
  fails "Module#define_method raises a TypeError when an UnboundMethod from one class is defined on an unrelated class"
  fails "Module#extend_object does not copy own tainted status to the given object"
  fails "Module#extend_object does not copy own untrusted status to the given object"
  fails "Module#extend_object extends the given object with its constants and methods by default"
  fails "Module#extend_object is a private method"
  fails "Module#extend_object is called even when private"
  fails "Module#extend_object is called when #extend is called on an object"
  fails "Module#extend_object on Class raises a TypeError if calling after rebinded to Class"
  fails "Module#extend_object when given a frozen object raises a RuntimeError before extending the object"
  fails "Module#extended is private in its default implementation"
  fails "Module#include adds all ancestor modules when a previously included module is included again"
  fails "Module#include detects cyclic includes"
  fails "Module#include doesn't include module if it is included in a super class"
  fails "Module#include ignores modules it has already included via module mutual inclusion"
  fails "Module#include preserves ancestor order"
  fails "Module#include raises a TypeError when the argument is not a Module"
  fails "Module#include recursively includes new mixins"
  fails "Module#include? raises a TypeError when no module was given"
  fails "Module#include? returns true if the given module is included by self or one of it's ancestors"
  fails "Module#included is private in its default implementation"
  fails "Module#included_modules returns a list of modules included in self"
  fails "Module#initialize is called on subclasses"
  fails "Module#instance_method gives UnboundMethod method name, Module defined in and Module extracted from"
  fails "Module#instance_method raises a NameError if the method has been undefined"
  fails "Module#instance_method raises a TypeError if not passed a symbol"
  fails "Module#instance_method raises a TypeError if the given name is not a string/symbol"
  fails "Module#instance_method sets the NameError#name attribute to the name of the missing method"
  fails "Module#method_added is a private instance method"
  fails "Module#method_added is called when a new method is defined in self"
  fails "Module#method_added returns nil in the default implementation"
  fails "Module#method_defined? converts the given name to a string using to_str"
  fails "Module#method_defined? raises a TypeError when the given object is not a string/symbol/fixnum"
  fails "Module#method_defined? returns true if a public or private method with the given name is defined in self, self's ancestors or one of self's included modules"
  fails "Module#method_removed is a private instance method"
  fails "Module#method_removed is called when a method is removed from self"
  fails "Module#method_removed returns nil in the default implementation"
  fails "Module#method_undefined is a private instance method"
  fails "Module#method_undefined is called when a method is undefined from self"
  fails "Module#method_undefined returns nil in the default implementation"
  fails "Module#module_eval adds methods respecting the lexical constant scope"
  fails "Module#module_eval converts a non-string filename to a string using to_str"
  fails "Module#module_eval converts non string eval-string to string using to_str"
  fails "Module#module_eval defines constants in the receiver's scope"
  fails "Module#module_eval evaluates a given string in the context of self"
  fails "Module#module_eval raises a TypeError when the given eval-string can't be converted to string using to_str"
  fails "Module#module_eval raises a TypeError when the given filename can't be converted to string using to_str"
  fails "Module#module_eval uses the optional filename and lineno parameters for error messages"
  fails "Module#module_exec defines method in the receiver's scope"
  fails "Module#module_exec passes arguments to the block"
  fails "Module#module_exec raises a LocalJumpError when no block is given"
  fails "Module#module_function as a toggle (no arguments) in a Module body does not affect module_evaled method definitions also if outside the eval itself"
  fails "Module#module_function as a toggle (no arguments) in a Module body doesn't affect definitions when inside an eval even if the definitions are outside of it"
  fails "Module#module_function as a toggle (no arguments) in a Module body functions normally if both toggle and definitions inside a eval"
  fails "Module#module_function as a toggle (no arguments) in a Module body has no effect if inside a module_eval if the definitions are outside of it"
  fails "Module#module_function is a private method"
  fails "Module#module_function on Class raises a TypeError if calling after rebinded to Class"
  fails "Module#module_function with specific method names can make accessible private methods"
  fails "Module#module_function with specific method names makes the instance methods private"
  fails "Module#module_function with specific method names raises a TypeError when the given names can't be converted to string using to_str"
  fails "Module#module_function with specific method names tries to convert the given names to strings using to_str"
  fails "Module#prepend accepts no-arguments"
  fails "Module#prepend allows wrapping methods"
  fails "Module#prepend also prepends included modules"
  fails "Module#prepend calls #prepend_features(self) in reversed order on each module"
  fails "Module#prepend calls prepended after prepend_features"
  fails "Module#prepend causes the prepended module's method to be aliased by alias_method"
  fails "Module#prepend clears any caches"
  fails "Module#prepend depends on prepend_features to add the module"
  fails "Module#prepend detects cyclic prepends"
  fails "Module#prepend does not import constants"
  fails "Module#prepend does not import methods to modules and classes"
  fails "Module#prepend imports instance methods"
  fails "Module#prepend includes prepended modules in ancestors"
  fails "Module#prepend inserts a later prepended module into the chain"
  fails "Module#prepend is a public method"
  fails "Module#prepend keeps the module in the chain when dupping an intermediate module"
  fails "Module#prepend keeps the module in the chain when dupping the class"
  fails "Module#prepend prepends multiple modules in the right order"
  fails "Module#prepend raises a TypeError when the argument is not a Module"
  fails "Module#prepend reports the prepended module as the method owner"
  fails "Module#prepend reports the prepended module as the unbound method owner"
  fails "Module#prepend returns the class it's included into"
  fails "Module#prepend sees an instance of a prepended class as kind of the prepended module"
  fails "Module#prepend supports super when the module is prepended into a singleton class"
  fails "Module#prepend throws a NoMethodError when there is no more superclass"
  fails "Module#prepend works with subclasses"
  fails "Module#prepend_features copies own tainted status to the given module"
  fails "Module#prepend_features copies own untrusted status to the given module"
  fails "Module#prepend_features gets called when self is included in another module/class"
  fails "Module#prepend_features is a private method"
  fails "Module#prepend_features on Class raises a TypeError if calling after rebinded to Class"
  fails "Module#prepend_features raises an ArgumentError on a cyclic prepend"
  fails "Module#prepended is a private method"
  fails "Module#private is a private method"
  fails "Module#private makes a public Object instance method private in Kernel"
  fails "Module#private makes a public Object instance method private in a new module"
  fails "Module#private makes the target method uncallable from other types"
  fails "Module#private raises a NameError when given an undefined name"
  fails "Module#private returns self"
  fails "Module#private without arguments affects evaled method definitions when itself is outside the eval"
  fails "Module#private without arguments affects normally if itself and following method definitions are inside a eval"
  fails "Module#private without arguments affects normally if itself and method definitions are inside a module_eval"
  fails "Module#private without arguments continues setting visibility if the body encounters other visibility setters with arguments"
  fails "Module#private without arguments does not affect method definitions when itself is inside an eval and method definitions are outside"
  fails "Module#private without arguments does not affect module_evaled method definitions when itself is outside the eval"
  fails "Module#private without arguments sets visibility to following method definitions"
  fails "Module#private without arguments stops setting visibility if the body encounters other visibility setters without arguments"
  fails "Module#private_class_method accepts more than one method at a time"
  fails "Module#private_class_method makes a class method private"
  fails "Module#private_class_method makes an existing class method private up the inheritance tree"
  fails "Module#private_class_method makes an existing class method private"
  fails "Module#private_class_method raises a NameError if class method doesn't exist"
  fails "Module#private_class_method raises a NameError when the given name is an instance method"
  fails "Module#private_class_method raises a NameError when the given name is not a method"
  fails "Module#private_constant accepts multiple names"
  fails "Module#private_constant can only be passed constant names defined in the target (self) module"
  fails "Module#private_instance_methods returns a list of private methods in module and its ancestors"
  fails "Module#private_instance_methods when not passed an argument returns a unique list for a class including a module"
  fails "Module#private_instance_methods when not passed an argument returns a unique list for a subclass"
  fails "Module#private_instance_methods when passed false as a parameter, should return only methods defined in that module"
  fails "Module#private_instance_methods when passed true returns a unique list for a class including a module"
  fails "Module#private_instance_methods when passed true returns a unique list for a subclass"
  fails "Module#private_method_defined? accepts symbols for the method name"
  fails "Module#private_method_defined? calls #to_str to convert an Object"
  fails "Module#private_method_defined? raises a TypeError if passed a Fixnum"
  fails "Module#private_method_defined? raises a TypeError if passed an object that defines #to_sym"
  fails "Module#private_method_defined? raises a TypeError if passed an object that does not defined #to_str"
  fails "Module#private_method_defined? raises a TypeError if passed false"
  fails "Module#private_method_defined? raises a TypeError if passed nil"
  fails "Module#private_method_defined? returns true if the named private method is defined by module or its ancestors"
  fails "Module#protected is a private method"
  fails "Module#protected makes a public Object instance method protected in Kernel"
  fails "Module#protected makes a public Object instance method protected in a new module"
  fails "Module#protected makes an existing class method protected"
  fails "Module#protected raises a NameError when given an undefined name"
  fails "Module#protected returns self"
  fails "Module#protected without arguments affects evaled method definitions when itself is outside the eval"
  fails "Module#protected without arguments affects normally if itself and following method definitions are inside a eval"
  fails "Module#protected without arguments affects normally if itself and method definitions are inside a module_eval"
  fails "Module#protected without arguments continues setting visibility if the body encounters other visibility setters with arguments"
  fails "Module#protected without arguments does not affect method definitions when itself is inside an eval and method definitions are outside"
  fails "Module#protected without arguments does not affect module_evaled method definitions when itself is outside the eval"
  fails "Module#protected without arguments sets visibility to following method definitions"
  fails "Module#protected without arguments stops setting visibility if the body encounters other visibility setters without arguments"
  fails "Module#protected_instance_methods default list should be the same as passing true as an argument"
  fails "Module#protected_instance_methods returns a list of protected methods in module and its ancestors"
  fails "Module#protected_instance_methods when not passed an argument returns a unique list for a class including a module"
  fails "Module#protected_instance_methods when not passed an argument returns a unique list for a subclass"
  fails "Module#protected_instance_methods when passed false as a parameter, should return only methods defined in that module"
  fails "Module#protected_instance_methods when passed true returns a unique list for a class including a module"
  fails "Module#protected_instance_methods when passed true returns a unique list for a subclass"
  fails "Module#protected_method_defined? accepts symbols for the method name"
  fails "Module#protected_method_defined? calls #to_str to convert an Object"
  fails "Module#protected_method_defined? raises a TypeError if passed a Fixnum"
  fails "Module#protected_method_defined? raises a TypeError if passed an object that defines #to_sym"
  fails "Module#protected_method_defined? raises a TypeError if passed an object that does not defined #to_str"
  fails "Module#protected_method_defined? raises a TypeError if passed false"
  fails "Module#protected_method_defined? raises a TypeError if passed nil"
  fails "Module#protected_method_defined? returns true if the named protected method is defined by module or its ancestors"
  fails "Module#public is a private method"
  fails "Module#public makes a private Object instance method public in Kernel"
  fails "Module#public makes a private Object instance method public in a new module"
  fails "Module#public raises a NameError when given an undefined name"
  fails "Module#public returns self"
  fails "Module#public without arguments affects evaled method definitions when itself is outside the eval"
  fails "Module#public without arguments affects normally if itself and following method definitions are inside a eval"
  fails "Module#public without arguments does not affect method definitions when itself is inside an eval and method definitions are outside"
  fails "Module#public without arguments does not affect module_evaled method definitions when itself is outside the eval"
  fails "Module#public without arguments stops setting visibility if the body encounters other visibility setters without arguments"
  fails "Module#public_class_method accepts more than one method at a time"
  fails "Module#public_class_method makes an existing class method public up the inheritance tree"
  fails "Module#public_class_method makes an existing class method public"
  fails "Module#public_class_method raises a NameError if class method doesn't exist"
  fails "Module#public_class_method raises a NameError when the given name is an instance method"
  fails "Module#public_class_method raises a NameError when the given name is not a method"
  fails "Module#public_constant accepts multiple names"
  fails "Module#public_instance_method is a public method"
  fails "Module#public_instance_method raises a TypeError when given a name is not Symbol or String"
  fails "Module#public_instance_method requires an argument"
  fails "Module#public_instance_method sets the NameError#name attribute to the name of the missing method"
  fails "Module#public_instance_method when given a public method name accepts if the name is a Symbol or String"
  fails "Module#public_instance_method when given a public method name returns an UnboundMethod corresponding to the defined Module"
  fails "Module#public_instance_methods when passed false as a parameter, should return only methods defined in that module"
  fails "Module#public_method_defined? calls #to_str to convert an Object"
  fails "Module#public_method_defined? raises a TypeError if passed a Fixnum"
  fails "Module#public_method_defined? raises a TypeError if passed an object that defines #to_sym"
  fails "Module#public_method_defined? raises a TypeError if passed an object that does not defined #to_str"
  fails "Module#public_method_defined? raises a TypeError if passed false"
  fails "Module#public_method_defined? raises a TypeError if passed nil"
  fails "Module#public_method_defined? returns false if method is not a public method"
  fails "Module#remove_class_variable raises a NameError when an uninitialized class variable is given"
  fails "Module#remove_class_variable raises a NameError when passed a symbol with no leading @"
  fails "Module#remove_class_variable raises a NameError when passed a symbol with one leading @"
  fails "Module#remove_class_variable removes a class variable defined in a metaclass"
  fails "Module#remove_class_variable removes class variable"
  fails "Module#remove_class_variable returns the value of removing class variable"
  fails "Module#remove_const calls #to_str to convert the given name to a String"
  fails "Module#remove_const is a private method"
  fails "Module#remove_const raises a NameError and does not call #const_missing if the constant is not defined directly in the module"
  fails "Module#remove_const raises a NameError and does not call #const_missing if the constant is not defined"
  fails "Module#remove_const raises a NameError if the name contains non-alphabetic characters except '_'"
  fails "Module#remove_const raises a NameError if the name does not start with a capital letter"
  fails "Module#remove_const raises a NameError if the name starts with a non-alphabetic character"
  fails "Module#remove_const raises a TypeError if conversion to a String by calling #to_str fails"
  fails "Module#remove_method accepts multiple arguments"
  fails "Module#remove_method does not remove any instance methods when argument not given"
  fails "Module#remove_method is a private method"
  fails "Module#remove_method on frozen instance does not raise exceptions when no arguments given"
  fails "Module#remove_method on frozen instance raises a RuntimeError when passed a missing name"
  fails "Module#remove_method on frozen instance raises a RuntimeError when passed a name"
  fails "Module#remove_method on frozen instance raises a TypeError when passed a not name"
  fails "Module#remove_method raises a NameError when attempting to remove a missing method"
  fails "Module#remove_method raises a NameError when attempting to remove method further up the inheritance tree"
  fails "Module#undef_method does not undef any instance methods when argument not given"
  fails "Module#undef_method is a private method"
  fails "Module#undef_method on frozen instance does not raise exceptions when no arguments given"
  fails "Module#undef_method on frozen instance raises a RuntimeError when passed a missing name"
  fails "Module#undef_method on frozen instance raises a RuntimeError when passed a name"
  fails "Module#undef_method on frozen instance raises a TypeError when passed a not name"
  fails "Module#undef_method raises a NameError when passed a missing name"
  fails "Module#undef_method requires multiple arguments"
  fails "Module#undef_method with string removes a method defined in a super class"
  fails "Module#undef_method with symbol removes a method defined in a super class"
  fails "Module.allocate returns a fully-formed instance of Module"
  fails "Module.constants returns Module's constants when given a parameter"
  fails "Module.constants returns an array of Symbol names"
  fails "Module.new creates a new Module and passes it to the provided block"
  fails "Module::Nesting returns the list of Modules nested at the point of call"
  fails "Module::Nesting returns the nesting for module/class declaring the called method"
  fails "passed { |a, b = 1|  } creates a method that raises an ArgumentError when passed three arguments"
  fails "passed { |a, b = 1|  } creates a method that raises an ArgumentError when passed zero arguments"
end
