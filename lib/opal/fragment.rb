# frozen_string_literal: true

module Opal
  # A fragment holds a string of generated javascript that will be written
  # to the destination. It also keeps hold of the original sexp from which
  # it was generated. Using this sexp, when writing fragments in order, a
  # mapping can be created of the original location => target location,
  # aka, source-maps!
  #
  # These are generated by nodes, so will not have to create directly.
  class Fragment
    # String of javascript this fragment holds
    # @return [String]
    attr_reader :code

    # Create fragment with javascript code and optional original [Opal::Sexp].
    #
    # @param code [String] javascript code
    # @param sexp [Opal::Sexp] sexp used for creating fragment
    def initialize(code, scope, sexp = nil)
      @code = code.to_s
      @sexp = sexp
      @scope = scope
    end

    # Inspect the contents of this fragment, f("fooo")
    def inspect
      "f(#{@code.inspect})"
    end

    def source_map_name
      case @sexp.type
      when :top, :begin, :newline, :js_return
        nil
      when :self
        'self'
      when :module
        'module'
      when :class
        'class'
      when :int
        @sexp.children.first
      when :def
        @sexp.children.first
      when :defs
        @sexp.children[1]
      when :send
        @sexp.children[1]
      when :lvar, :lvasgn, :lvdeclare, :ivar, :ivasgn, :gvar, :cvar, :cvasgn, :gvars, :gvasgn
        @sexp.children.first
      else
        # nil
      end
    end

    # Original line this fragment was created from
    # @return [Integer, nil]
    def line
      @sexp.line if @sexp
    end

    # Original column this fragment was created from
    # @return [Integer, nil]
    def column
      @sexp.column if @sexp
    end
  end
end
