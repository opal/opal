require 'set'
require 'pathname'
require 'opal/nodes/base'
require 'opal/nodes/runtime_helpers'
require 'opal/rewriters/break_finder'

module Opal
  module Nodes
    class CallNode < Base
      handle :send

      attr_reader :recvr, :meth, :arglist, :iter

      SPECIALS = {}

      # Operators that get optimized by compiler
      OPERATORS = { :+ => :plus, :- => :minus, :* => :times, :/ => :divide,
                    :< => :lt, :<= => :le, :> => :gt, :>= => :ge }

      def self.add_special(name, options = {}, &handler)
        SPECIALS[name] = options
        define_method("handle_#{name}", &handler)
      end

      def initialize(*)
        super
        @recvr, @meth, *args = *@sexp

        *rest, last_arg = *args

        if last_arg && [:iter, :block_pass].include?(last_arg.type)
          @iter = last_arg
          args = rest
        end

        @arglist = s(:arglist, *args)
      end

      def compile
        # handle some methods specially
        handle_special

        # some special methods need to skip compilation
        return unless compile_default?

        compiler.method_calls << meth.to_sym if record_method?

        # if trying to access an lvar in irb mode
        return compile_irb_var if using_irb?

        default_compile
      end

      private

      def iter_has_break?
        return false unless iter

        finder = Opal::Rewriters::BreakFinder.new
        finder.process(iter)
        finder.found_break?
      end

      def default_compile
        # blocks need to be assigned to temp variables in order to pass them
        block_temp = scope.new_temp if iter

        # can't use self for splats or blocks
        temporary_receiver = scope.new_temp if splat? || block_temp

        add_method temporary_receiver

        add_block block_temp if block_temp

        add_invocation temporary_receiver

        if iter_has_break?
          unshift 'return '
          unshift '(function(){var $brk = Opal.new_brk(); try {'
          line '} catch (err) { if (err === $brk) { return err.$v } else { throw err } }})()'
        end

        scope.queue_temp block_temp if block_temp
      end

      def redefine_this?(temporary_receiver)
        temporary_receiver != nil
      end

      def apply_call_target(temporary_receiver)
        temporary_receiver || receiver_fragment
      end

      def arguments_array?
        splat?
      end

      def add_invocation(temporary_receiver)
        args = arguments_fragment
        if redefine_this?(temporary_receiver) || arguments_array?
          if arguments_array?
            push ".apply("
          else
            push ".call("
          end

          push apply_call_target(temporary_receiver)

          if args.any?
            push ", ", args
          end

          push ")"
        else
          push "(", args, ")"
        end
      end

      def add_method(temporary_receiver)
        if temporary_receiver
          push "(#{temporary_receiver} = ", receiver_fragment, ")#{method_jsid}"
        else
          push receiver_fragment, method_jsid
        end
      end

      def add_block(block_temp)
        unshift "(#{block_temp} = "
        push ", #{block_temp}.$$p = ", expr(iter), ", #{block_temp})"
      end

      def splat?
        arglist.children.any? { |a| a.type == :splat }
      end

      def recv_sexp
        recvr || s(:self)
      end

      def receiver_fragment
        recv recv_sexp
      end

      def arguments_fragment
        expr arglist
      end

      def method_jsid
        mid_to_jsid meth.to_s
      end

      def record_method?
        true
      end

      # Used to generate the code to use this sexp as an ivar var reference
      def compile_irb_var
        with_temp do |tmp|
          lvar = variable(meth)
          call = s(:send, s(:self), meth.intern, s(:arglist))
          push "((#{tmp} = Opal.irb_vars.#{lvar}) == null ? ", expr(call), " : #{tmp})"
        end
      end

      # a variable reference in irb mode in top scope might be a var ref,
      # or it might be a method call
      def using_irb?
        @compiler.irb? and scope.top? and arglist == s(:arglist) and recvr.nil? and iter.nil?
      end

      def sexp_with_arglist
        @sexp.updated(nil, [recvr, meth, arglist])
      end

      # Handle "special" method calls, e.g. require(). Subclasses can override
      # this method. If this method returns nil, then the method will continue
      # to be generated by CallNode.
      def handle_special
        @compile_default = true

        if SPECIALS.include? meth
          @compile_default = false
          __send__("handle_#{meth}")
        elsif RuntimeHelpers.compatible?(recvr, meth, arglist)
          @compile_default = false
          push(RuntimeHelpers.new(sexp_with_arglist, @level, @compiler).compile)
        elsif dot_js_call?
          @compile_default = false
          push process(to_js_call, @level)
        end
      end

      def dot_js_call?
        # .JS
        recvr && recvr.type == :send && recvr.children.last == :JS
      end

      def to_js_call
        js_call_type = meth
        js_call_recvr = recvr.children[0]

        case js_call_type
        when :[]
          # a.JS[property]
          # => s(:jsattr, s(:lvar, :a), property)
          property, *rest = *arglist.children
          if rest.any?
            raise SyntaxError, ".JS[:property] syntax supports only one argument"
          end
          s(:jsattr, js_call_recvr, property)
        when :[]=
          # a.JS[property] = value
          # => s(:jsattrasgn, s(:lvar, :a), property, value)
          property, value, *rest = *arglist.children
          s(:jsattrasgn, js_call_recvr, property, value)
        else
          # a.JS.native_method(param1, param2)
          # => s(:jscall, s(:lvar, :a), :native_method, s(:arglist, param1, param2))
          args = arglist.children
          args += [iter] if iter
          s(:jscall, js_call_recvr, js_call_type, *args)
        end
      end

      def compile_default!
        @compile_default = true
      end

      def compile_default?
        @compile_default
      end

      OPERATORS.each do |operator, name|
        add_special(operator.to_sym) do
          if compiler.inline_operators?
            compiler.method_calls << operator.to_sym if record_method?
            compiler.operator_helpers << operator.to_sym
            lhs, rhs = expr(recvr), expr(arglist)

            push fragment("$rb_#{name}(")
            push lhs
            push fragment(", ")
            push rhs
            push fragment(")")
          else
            compile_default!
          end
        end
      end

      add_special :require do
        compile_default!
        str = DependencyResolver.new(compiler, arglist.children[0]).resolve
        compiler.requires << str unless str.nil?
        push fragment('')
      end

      add_special :require_relative do
        arg = arglist.children[0]
        file = compiler.file
        if arg.type == :str
          dir = File.dirname(file)
          compiler.requires << Pathname(dir).join(arg.children[0]).cleanpath.to_s
        end
        push fragment("self.$require(#{file.inspect}+ '/../' + ")
        push process(arglist)
        push fragment(')')
      end

      add_special :autoload do
        if scope.class_scope?
          compile_default!
          str = DependencyResolver.new(compiler, arglist.children[1]).resolve
          compiler.requires << str unless str.nil?
          push fragment('')
        end
      end

      add_special :require_tree do
        first_arg, *rest = *arglist.children
        if first_arg.type == :str
          relative_path = first_arg.children[0]
          compiler.required_trees << relative_path

          dir = File.dirname(compiler.file)
          full_path = Pathname(dir).join(relative_path).cleanpath.to_s
          first_arg = first_arg.updated(nil, [full_path])
        end
        @arglist = arglist.updated(nil, [first_arg] + rest)
        compile_default!
        push fragment('')
      end

      add_special :block_given? do
        push compiler.handle_block_given_call @sexp
      end

      add_special :__callee__ do
        if scope.def?
          push fragment scope.mid.to_s.inspect
        else
          push fragment 'nil'
        end
      end

      add_special :__method__ do
        if scope.def?
          push fragment scope.mid.to_s.inspect
        else
          push fragment 'nil'
        end
      end

      add_special :debugger do
        push fragment 'debugger'
      end

      add_special :__OPAL_COMPILER_CONFIG__ do
        push fragment "Opal.hash({ arity_check: #{compiler.arity_check?} })"
      end

      class DependencyResolver
        def initialize(compiler, sexp)
          @compiler = compiler
          @sexp = sexp
        end

        def resolve
          handle_part @sexp
        end

        def handle_part(sexp)
          type = sexp.type


          
          if type == :str
            return sexp.children[0]
          elsif type == :send
            recv, meth, *args = sexp.children

            parts = args.map { |s| handle_part s }

            print "dynamic require send type:#{type} meth:#{meth} args:#{args} recv:#{recv}\n"
            
            if ::Parser::AST::Node === recv && recv.type == :const && recv.children.last == :File
              if meth == :expand_path
                return expand_path(*parts)
              elsif meth == :join
                return expand_path parts.join('/')
              elsif meth == :dirname
                return expand_path parts[0].split('/')[0...-1].join('/')
              end
            end
          end
          #print "dynamic require type:#{type} meth:#{sexp}\n"
          msg = "Cannot handle dynamic require type:#{type} sexp:#{sexp}"
          case @compiler.dynamic_require_severity
          when :error
            @compiler.error msg, @sexp.line
          when :warning
            @compiler.warning msg, @sexp.line
          end
        end

        def expand_path(path, base = '')
          "#{base}/#{path}".split("/").inject([]) do |p, part|
            if part == ''
              # we had '//', so ignore
            elsif part == '..'
              p.pop
            else
              p << part
            end

            p
          end.join "/"
        end
      end
    end
  end
end
