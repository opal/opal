(function(global_object) {
  "use strict";

  // @note
  //   A few conventions for the documentation of this file:
  //   1. Always use "//" (in contrast with "/**/")
  //   2. The syntax used is Yardoc (yardoc.org), which is intended for Ruby (se below)
  //   3. `@param` and `@return` types should be preceded by `JS.` when referring to
  //      JavaScript constructors (e.g. `JS.Function`) otherwise Ruby is assumed.
  //   4. `nil` and `null` being unambiguous refer to the respective
  //      objects/values in Ruby and JavaScript
  //   5. This is still WIP :) so please give feedback and suggestions on how
  //      to improve or for alternative solutions
  //
  //   The way the code is digested before going through Yardoc is a secret kept
  //   in the docs repo (https://github.com/opal/docs/tree/master).

  var console;

  // Detect the global object
  if (typeof(globalThis) !== 'undefined') { global_object = globalThis; }
  else if (typeof(global) !== 'undefined') { global_object = global; }
  else if (typeof(window) !== 'undefined') { global_object = window; }

  // Setup a dummy console object if missing
  if (global_object.console == null) {
    global_object.console = {};
  }

  if (typeof(global_object.console) === 'object') {
    console = global_object.console;
  } else {
    console = {};
  }

  if (!('log' in console)) { console.log = function () {}; }
  if (!('warn' in console)) { console.warn = console.log; }

  if (typeof(global_object.Opal) !== 'undefined') {
    console.warn('Opal already loaded. Loading twice can cause troubles, please fix your setup.');
    return global_object.Opal;
  }

  var nil;

  // The actual class for BasicObject
  var BasicObject;

  // The actual Object class.
  // The leading underscore is to avoid confusion with window.Object()
  var _Object;

  // The actual Module class
  var Module;

  // The actual Class class
  var Class;

  // The Opal.Opal class (helpers etc.)
  var _Opal;

  // The Kernel module
  var Kernel;

  // The Opal object that is exposed globally
  var Opal = global_object.Opal = {};

  // This is a useful reference to global object inside ruby files
  Opal.global = global_object;

  // Configure runtime behavior with regards to require and unsupported features
  Opal.config = {
    missing_require_severity: 'error',        // error, warning, ignore
    unsupported_features_severity: 'warning', // error, warning, ignore
    experimental_features_severity: 'warning',// warning, ignore
    enable_stack_trace: true                  // true, false
  };

  // Minify common function calls
  var $call      = Function.prototype.call;
  var $bind      = Function.prototype.bind;
  var $has_own   = Object.hasOwn || $call.bind(Object.prototype.hasOwnProperty);
  var $set_proto = Object.setPrototypeOf;
  var $slice     = $call.bind(Array.prototype.slice);
  var $splice    = $call.bind(Array.prototype.splice);

  // Nil object id is always 4
  var nil_id = 4;

  // Generates even sequential numbers greater than 4
  // (nil_id) to serve as unique ids for ruby objects
  var unique_id = nil_id;

  // Return next unique id
  function $uid() {
    unique_id += 2;
    return unique_id;
  };
  Opal.uid = $uid;

  // Retrieve or assign the id of an object
  Opal.id = function(obj) {
    if (obj.$$is_number) return (obj * 2)+1;
    if (obj.$$id == null) {
      $prop(obj, '$$id', $uid());
    }
    return obj.$$id;
  };

  // Globals table
  var $gvars = Opal.gvars = {};

  // Exit function, this should be replaced by platform specific implementation
  // (See nodejs and chrome for examples)
  Opal.exit = function(status) { if ($gvars.DEBUG) console.log('Exited with status '+status); };

  // keeps track of exceptions for $!
  Opal.exceptions = [];

  // @private
  // Pops an exception from the stack and updates `$!`.
  Opal.pop_exception = function(rescued_exception) {
    var exception = Opal.exceptions.pop();
    if (exception === rescued_exception) {
      // Current $! is raised in the rescue block, so we don't update it
    }
    else if (exception) {
      $gvars["!"] = exception;
    }
    else {
      $gvars["!"] = nil;
    }
  };

  // A helper function for raising things, that gracefully degrades if necessary
  // functionality is not yet loaded.
  function $raise(klass, message) {
    // Raise Exception, so we can know that something wrong is going on.
    if (!klass) klass = Opal.Exception || Error;

    if (Kernel && Kernel.$raise) {
      if (arguments.length > 2) {
        Kernel.$raise(klass.$new.apply(klass, $slice(arguments, 1)));
      }
      else {
        Kernel.$raise(klass, message);
      }
    }
    else if (!klass.$new) {
      throw new klass(message);
    }
    else {
      throw klass.$new(message);
    }
  }

  // Reuse the same object for performance/memory sake
  var prop_options = {
    value: undefined,
    enumerable: false,
    configurable: true,
    writable: true
  };

  function $prop(object, name, initialValue) {
    if (typeof(object) === "string") {
      // Special case for:
      //   s = "string"
      //   def s.m; end
      // String class is the only class that:
      // + compiles to JS primitive
      // + allows method definition directly on instances
      // numbers, true, false and null do not support it.
      object[name] = initialValue;
    } else {
      prop_options.value = initialValue;
      Object.defineProperty(object, name, prop_options);
    }
  }

  Opal.prop = $prop;

  // @deprecated
  Opal.defineProperty = Opal.prop;

  Opal.slice = $slice;

  // Helpers
  // -----

  var $truthy = Opal.truthy = function(val) {
    return false !== val && nil !== val && undefined !== val && null !== val && (!(val instanceof Boolean) || true === val.valueOf());
  };

  Opal.falsy = function(val) {
    return !$truthy(val);
  };

  Opal.type_error = function(object, type, method, coerced) {
    object = object.$$class;

    if (coerced && method) {
      coerced = coerced.$$class;
      $raise(Opal.TypeError,
        "can't convert " + object + " into " + type +
        " (" + object + "#" + method + " gives " + coerced + ")"
      )
    } else {
      $raise(Opal.TypeError,
        "no implicit conversion of " + object + " into " + type
      )
    }
  };

  Opal.coerce_to = function(object, type, method, args) {
    var body;

    if (method === 'to_int' && type === Opal.Integer && object.$$is_number)
      return object < 0 ? Math.ceil(object) : Math.floor(object);

    if (method === 'to_str' && type === Opal.String && object.$$is_string)
      return object;

    if (Opal.is_a(object, type)) return object;

    // Fast path for the most common situation
    if (object['$respond_to?'].$$pristine && object.$method_missing.$$pristine) {
      body = object[$jsid(method)];
      if (body == null || body.$$stub) Opal.type_error(object, type);
      return body.apply(object, args);
    }

    if (!object['$respond_to?'](method)) {
      Opal.type_error(object, type);
    }

    if (args == null) args = [];
    return Opal.send(object, method, args);
  }

  Opal.respond_to = function(obj, jsid, include_all) {
    if (obj == null || !obj.$$class) return false;
    include_all = !!include_all;
    var body = obj[jsid];

    if (obj['$respond_to?'].$$pristine) {
      if (typeof(body) === "function" && !body.$$stub) {
        return true;
      }
      if (!obj['$respond_to_missing?'].$$pristine) {
        return Opal.send(obj, obj['$respond_to_missing?'], [jsid.substr(1), include_all]);
      }
    } else {
      return Opal.send(obj, obj['$respond_to?'], [jsid.substr(1), include_all]);
    }
  }

  // TracePoint support
  // ------------------
  //
  // Support for `TracePoint.trace(:class) do ... end`
  Opal.trace_class = false;
  Opal.tracers_for_class = [];

  function invoke_tracers_for_class(klass_or_module) {
    var i, ii, tracer;

    for(i = 0, ii = Opal.tracers_for_class.length; i < ii; i++) {
      tracer = Opal.tracers_for_class[i];
      tracer.trace_object = klass_or_module;
      tracer.block.$call(tracer);
    }
  }

  function handle_autoload(cref, name) {
    if (!cref.$$autoload[name].loaded) {
      cref.$$autoload[name].loaded = true;
      try {
        Opal.Kernel.$require(cref.$$autoload[name].path);
      } catch (e) {
        cref.$$autoload[name].exception = e;
        throw e;
      }
      cref.$$autoload[name].required = true;
      if (cref.$$const[name] != null) {
        cref.$$autoload[name].success = true;
        return cref.$$const[name];
      }
    } else if (cref.$$autoload[name].loaded && !cref.$$autoload[name].required) {
      if (cref.$$autoload[name].exception) { throw cref.$$autoload[name].exception; }
    }
  }

  // Constants
  // ---------
  //
  // For future reference:
  // - The Rails autoloading guide (http://guides.rubyonrails.org/v5.0/autoloading_and_reloading_constants.html)
  // - @ConradIrwin's 2012 post on “Everything you ever wanted to know about constant lookup in Ruby” (http://cirw.in/blog/constant-lookup.html)
  //
  // Legend of MRI concepts/names:
  // - constant reference (cref): the module/class that acts as a namespace
  // - nesting: the namespaces wrapping the current scope, e.g. nesting inside
  //            `module A; module B::C; end; end` is `[B::C, A]`

  // Get the constant in the scope of the current cref
  function const_get_name(cref, name) {
    if (cref) {
      if (cref.$$const[name] != null) { return cref.$$const[name]; }
      if (cref.$$autoload && cref.$$autoload[name]) {
        return handle_autoload(cref, name);
      }
    }
  }

  // Walk up the nesting array looking for the constant
  function const_lookup_nesting(nesting, name) {
    var i, ii, constant;

    if (nesting.length === 0) return;

    // If the nesting is not empty the constant is looked up in its elements
    // and in order. The ancestors of those elements are ignored.
    for (i = 0, ii = nesting.length; i < ii; i++) {
      constant = nesting[i].$$const[name];
      if (constant != null) {
        return constant;
      } else if (nesting[i].$$autoload && nesting[i].$$autoload[name]) {
        return handle_autoload(nesting[i], name);
      }
    }
  }

  // Walk up the ancestors chain looking for the constant
  function const_lookup_ancestors(cref, name) {
    var i, ii, ancestors;

    if (cref == null) return;

    ancestors = $ancestors(cref);

    for (i = 0, ii = ancestors.length; i < ii; i++) {
      if (ancestors[i].$$const && $has_own(ancestors[i].$$const, name)) {
        return ancestors[i].$$const[name];
      } else if (ancestors[i].$$autoload && ancestors[i].$$autoload[name]) {
        return handle_autoload(ancestors[i], name);
      }
    }
  }

  // Walk up Object's ancestors chain looking for the constant,
  // but only if cref is missing or a module.
  function const_lookup_Object(cref, name) {
    if (cref == null || cref.$$is_module) {
      return const_lookup_ancestors(_Object, name);
    }
  }

  // Call const_missing if nothing else worked
  function const_missing(cref, name) {
    return (cref || _Object).$const_missing(name);
  }

  // Look for the constant just in the current cref or call `#const_missing`
  Opal.const_get_local = function(cref, name, skip_missing) {
    var result;

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      $raise(Opal.TypeError, cref.toString() + " is not a class/module");
    }

    result = const_get_name(cref, name);
    return result != null || skip_missing ? result : const_missing(cref, name);
  };

  // Look for the constant relative to a cref or call `#const_missing` (when the
  // constant is prefixed by `::`).
  Opal.const_get_qualified = function(cref, name, skip_missing) {
    var result, cache, cached, current_version = Opal.const_cache_version;

    if (name == null) {
      // A shortpath for calls like ::String => $$$("String")
      result = const_get_name(_Object, cref);

      if (result != null) return result;
      return Opal.const_get_qualified(_Object, cref, skip_missing);
    }

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      $raise(Opal.TypeError, cref.toString() + " is not a class/module");
    }

    if ((cache = cref.$$const_cache) == null) {
      $prop(cref, '$$const_cache', Object.create(null));
      cache = cref.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null);
      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null || skip_missing ? result : const_missing(cref, name);
  };

  // Initialize the top level constant cache generation counter
  Opal.const_cache_version = 1;

  // Look for the constant in the open using the current nesting and the nearest
  // cref ancestors or call `#const_missing` (when the constant has no :: prefix).
  Opal.const_get_relative = function(nesting, name, skip_missing) {
    var cref = nesting[0], result, current_version = Opal.const_cache_version, cache, cached;

    if ((cache = nesting.$$const_cache) == null) {
      $prop(nesting, '$$const_cache', Object.create(null));
      cache = nesting.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_nesting(nesting, name))     != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null) ||
      ((result = const_lookup_Object(cref, name))         != null);

      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null || skip_missing ? result : const_missing(cref, name);
  };

  // Register the constant on a cref and opportunistically set the name of
  // unnamed classes/modules.
  function $const_set(cref, name, value) {
    var new_const = true;

    if (cref == null || cref === '::') cref = _Object;

    if (value.$$is_a_module) {
      if (value.$$name == null || value.$$name === nil) value.$$name = name;
      if (value.$$base_module == null) value.$$base_module = cref;
    }

    cref.$$const = (cref.$$const || Object.create(null));

    if (name in cref.$$const || ("$$autoload" in cref && name in cref.$$autoload)) {
      new_const = false;
    }

    cref.$$const[name] = value;

    // Add a short helper to navigate constants manually.
    // @example
    //   Opal.$$.Regexp.$$.IGNORECASE
    cref.$$ = cref.$$const;

    Opal.const_cache_version++;

    // Expose top level constants onto the Opal object
    if (cref === _Object) Opal[name] = value;

    // Name new class directly onto current scope (Opal.Foo.Baz = klass)
    $prop(cref, name, value);

    if (new_const && cref.$const_added && !cref.$const_added.$$pristine) {
      cref.$const_added(name);
    }

    return value;
  };

  Opal.const_set = $const_set;

  // Get all the constants reachable from a given cref, by default will include
  // inherited constants.
  Opal.constants = function(cref, inherit) {
    if (inherit == null) inherit = true;

    var module, modules = [cref], i, ii, constants = {}, constant;

    if (inherit) modules = modules.concat($ancestors(cref));
    if (inherit && cref.$$is_module) modules = modules.concat([Opal.Object]).concat($ancestors(Opal.Object));

    for (i = 0, ii = modules.length; i < ii; i++) {
      module = modules[i];

      // Do not show Objects constants unless we're querying Object itself
      if (cref !== _Object && module == _Object) break;

      for (constant in module.$$const) {
        constants[constant] = true;
      }
      if (module.$$autoload) {
        for (constant in module.$$autoload) {
          constants[constant] = true;
        }
      }
    }

    return Object.keys(constants);
  };

  // Remove a constant from a cref.
  Opal.const_remove = function(cref, name) {
    Opal.const_cache_version++;

    if (cref.$$const[name] != null) {
      var old = cref.$$const[name];
      delete cref.$$const[name];
      return old;
    }

    if (cref.$$autoload && cref.$$autoload[name]) {
      delete cref.$$autoload[name];
      return nil;
    }

    $raise(Opal.NameError, "constant "+cref+"::"+cref.$name()+" not defined");
  };

  // Generates a function that is a curried const_get_relative.
  Opal.const_get_relative_factory = function(nesting) {
    return function(name, skip_missing) {
      return Opal.$$(nesting, name, skip_missing);
    }
  }

  // Setup some shortcuts to reduce compiled size
  Opal.$$ = Opal.const_get_relative;
  Opal.$$$ = Opal.const_get_qualified;
  Opal.$r = Opal.const_get_relative_factory;

  function descends_from_bridged_class(klass) {
    if (klass == null) return false;
    if (klass.$$bridge) return klass;
    if (klass.$$super) return descends_from_bridged_class(klass.$$super);
    return false;
  }

  // Modules & Classes
  // -----------------

  // A `class Foo; end` expression in ruby is compiled to call this runtime
  // method which either returns an existing class of the given name, or creates
  // a new class in the given `base` scope.
  //
  // If a constant with the given name exists, then we check to make sure that
  // it is a class and also that the superclasses match. If either of these
  // fail, then we raise a `TypeError`. Note, `superclass` may be null if one
  // was not specified in the ruby code.
  //
  // We pass a constructor to this method of the form `function ClassName() {}`
  // simply so that classes show up with nicely formatted names inside debuggers
  // in the web browser (or node/sprockets).
  //
  // The `scope` is the current `self` value where the class is being created
  // from. We use this to get the scope for where the class should be created.
  // If `scope` is an object (not a class/module), we simple get its class and
  // use that as the scope instead.
  //
  // @param scope        [Object] where the class is being created
  // @param superclass   [Class,null] superclass of the new class (may be null)
  // @param singleton    [Boolean,null] a true value denotes we want to allocate
  //                                    a singleton
  //
  // @return new [Class]  or existing ruby class
  //
  function $allocate_class(name, superclass, singleton) {
    var klass, bridged_descendant;

    if (bridged_descendant = descends_from_bridged_class(superclass)) {
      // Inheritance from bridged classes requires
      // calling original JS constructors
      klass = function() {
        var self = new ($bind.apply(bridged_descendant.$$constructor, $prepend(null, arguments)))();

        // and replacing a __proto__ manually
        $set_proto(self, klass.$$prototype);
        return self;
      }
    } else {
      klass = function(){};
    }

    if (name && name !== nil) {
      $prop(klass, 'displayName', '::'+name);
    }

    $prop(klass, '$$name', name);
    $prop(klass, '$$constructor', klass);
    $prop(klass, '$$prototype', klass.prototype);
    $prop(klass, '$$const', {});
    $prop(klass, '$$is_class', true);
    $prop(klass, '$$is_a_module', true);
    $prop(klass, '$$super', superclass);
    $prop(klass, '$$cvars', {});
    $prop(klass, '$$own_included_modules', []);
    $prop(klass, '$$own_prepended_modules', []);
    $prop(klass, '$$ancestors', []);
    $prop(klass, '$$ancestors_cache_version', null);
    $prop(klass, '$$subclasses', []);
    $prop(klass, '$$cloned_from', []);

    $prop(klass.$$prototype, '$$class', klass);

    // By default if there are no singleton class methods
    // __proto__ is Class.prototype
    // Later singleton methods generate a singleton_class
    // and inject it into ancestors chain
    if (Opal.Class) {
      $set_proto(klass, Opal.Class.prototype);
    }

    if (superclass != null) {
      $set_proto(klass.$$prototype, superclass.$$prototype);

      if (singleton !== true) {
        // Let's not forbid GC from cleaning up our
        // subclasses.
        if (typeof WeakRef !== 'undefined') {
          // First, let's clean up our array from empty objects.
          var i, subclass, rebuilt_subclasses = [];
          for (i = 0; i < superclass.$$subclasses.length; i++) {
            subclass = superclass.$$subclasses[i];
            if (subclass.deref() !== undefined) {
              rebuilt_subclasses.push(subclass);
            }
          }
          // Now, let's add our class.
          rebuilt_subclasses.push(new WeakRef(klass));
          superclass.$$subclasses = rebuilt_subclasses;
        }
        else {
          superclass.$$subclasses.push(klass);
        }
      }

      if (superclass.$$meta) {
        // If superclass has metaclass then we have explicitely inherit it.
        Opal.build_class_singleton_class(klass);
      }
    }

    return klass;
  };
  Opal.allocate_class = $allocate_class;


  function find_existing_class(scope, name) {
    // Try to find the class in the current scope
    var klass = const_get_name(scope, name);

    // If the class exists in the scope, then we must use that
    if (klass) {
      // Make sure the existing constant is a class, or raise error
      if (!klass.$$is_class) {
        $raise(Opal.TypeError, name + " is not a class");
      }

      return klass;
    }
  }

  function ensureSuperclassMatch(klass, superclass) {
    if (klass.$$super !== superclass) {
      $raise(Opal.TypeError, "superclass mismatch for class " + klass.$$name);
    }
  }

  Opal.klass = function(scope, superclass, name) {
    var bridged;

    if (scope == null || scope == '::') {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    // If the superclass is not an Opal-generated class then we're bridging a native JS class
    if (
      superclass != null && (!superclass.hasOwnProperty || (
        superclass.hasOwnProperty && !superclass.hasOwnProperty('$$is_class')
      ))
    ) {
      if (superclass.constructor && superclass.constructor.name == "Function") {
        bridged = superclass;
        superclass = _Object;
      } else {
        $raise(Opal.TypeError, "superclass must be a Class (" + (
          (superclass.constructor && (superclass.constructor.name || superclass.constructor.$$name)) ||
          typeof(superclass)
        ) + " given)");
      }
    }

    var klass = find_existing_class(scope, name);

    if (klass != null) {
      if (superclass) {
        // Make sure existing class has same superclass
        ensureSuperclassMatch(klass, superclass);
      }
    }
    else {
      // Class doesn't exist, create a new one with given superclass...

      // Not specifying a superclass means we can assume it to be Object
      if (superclass == null) {
        superclass = _Object;
      }

      // Create the class object (instance of Class)
      klass = $allocate_class(name, superclass);
      $const_set(scope, name, klass);

      // Call .inherited() hook with new class on the superclass
      if (superclass.$inherited) {
        superclass.$inherited(klass);
      }

      if (bridged) {
        Opal.bridge(bridged, klass);
      }
    }

    if (Opal.trace_class) { invoke_tracers_for_class(klass); }

    return klass;
  };

  // Define new module (or return existing module). The given `scope` is basically
  // the current `self` value the `module` statement was defined in. If this is
  // a ruby module or class, then it is used, otherwise if the scope is a ruby
  // object then that objects real ruby class is used (e.g. if the scope is the
  // main object, then the top level `Object` class is used as the scope).
  //
  // If a module of the given name is already defined in the scope, then that
  // instance is just returned.
  //
  // If there is a class of the given name in the scope, then an error is
  // generated instead (cannot have a class and module of same name in same scope).
  //
  // Otherwise, a new module is created in the scope with the given name, and that
  // new instance is returned back (to be referenced at runtime).
  //
  // @param  scope [Module, Class] class or module this definition is inside
  // @param  id   [String] the name of the new (or existing) module
  //
  // @return [Module]
  function $allocate_module(name) {
    var constructor = function(){};
    var module = constructor;

    if (name)
      $prop(constructor, 'displayName', name+'.constructor');

    $prop(module, '$$name', name);
    $prop(module, '$$prototype', constructor.prototype);
    $prop(module, '$$const', {});
    $prop(module, '$$is_module', true);
    $prop(module, '$$is_a_module', true);
    $prop(module, '$$cvars', {});
    $prop(module, '$$iclasses', []);
    $prop(module, '$$own_included_modules', []);
    $prop(module, '$$own_prepended_modules', []);
    $prop(module, '$$ancestors', [module]);
    $prop(module, '$$ancestors_cache_version', null);
    $prop(module, '$$cloned_from', []);

    $set_proto(module, Opal.Module.prototype);

    return module;
  };
  Opal.allocate_module = $allocate_module;

  function find_existing_module(scope, name) {
    var module = const_get_name(scope, name);
    if (module == null && scope === _Object) module = const_lookup_ancestors(_Object, name);

    if (module) {
      if (!module.$$is_module && module !== _Object) {
        $raise(Opal.TypeError, name + " is not a module");
      }
    }

    return module;
  }

  Opal.module = function(scope, name) {
    var module;

    if (scope == null || scope == '::') {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    module = find_existing_module(scope, name);

    if (module == null) {
      // Module doesnt exist, create a new one...
      module = $allocate_module(name);
      $const_set(scope, name, module);
    }

    if (Opal.trace_class) { invoke_tracers_for_class(module); }

    return module;
  };

  // Return the singleton class for the passed object.
  //
  // If the given object alredy has a singleton class, then it will be stored on
  // the object as the `$$meta` property. If this exists, then it is simply
  // returned back.
  //
  // Otherwise, a new singleton object for the class or object is created, set on
  // the object at `$$meta` for future use, and then returned.
  //
  // @param object [Object] the ruby object
  // @return [Class] the singleton class for object
  Opal.get_singleton_class = function(object) {
    if (object.$$is_number) {
      $raise(Opal.TypeError, "can't define singleton");
    }
    if (object.$$meta) {
      return object.$$meta;
    }

    if (object.hasOwnProperty('$$is_class')) {
      return Opal.build_class_singleton_class(object);
    } else if (object.hasOwnProperty('$$is_module')) {
      return Opal.build_module_singleton_class(object);
    } else {
      return Opal.build_object_singleton_class(object);
    }
  };

  // helper to set $$meta on klass, module or instance
  function set_meta(obj, meta) {
    if (obj.hasOwnProperty('$$meta')) {
      obj.$$meta = meta;
    } else {
      $prop(obj, '$$meta', meta);
    }
    if (obj.$$frozen) {
      // If a object is frozen (sealed), freeze $$meta too.
      // No need to inject $$meta.$$prototype in the prototype chain,
      // as $$meta cannot be modified anyway.
      obj.$$meta.$freeze();
    } else {
      $set_proto(obj, meta.$$prototype);
    }
  };

  // Build the singleton class for an existing class. Class object are built
  // with their singleton class already in the prototype chain and inheriting
  // from their superclass object (up to `Class` itself).
  //
  // NOTE: Actually in MRI a class' singleton class inherits from its
  // superclass' singleton class which in turn inherits from Class.
  //
  // @param klass [Class]
  // @return [Class]
  Opal.build_class_singleton_class = function(klass) {
    if (klass.$$meta) {
      return klass.$$meta;
    }

    // The singleton_class superclass is the singleton_class of its superclass;
    // but BasicObject has no superclass (its `$$super` is null), thus we
    // fallback on `Class`.
    var superclass = klass === BasicObject ? Class : Opal.get_singleton_class(klass.$$super);

    var meta = $allocate_class(null, superclass, true);

    $prop(meta, '$$is_singleton', true);
    $prop(meta, '$$singleton_of', klass);
    set_meta(klass, meta);
    // Restoring ClassName.class
    $prop(klass, '$$class', Opal.Class);

    return meta;
  };

  Opal.build_module_singleton_class = function(mod) {
    if (mod.$$meta) {
      return mod.$$meta;
    }

    var meta = $allocate_class(null, Opal.Module, true);

    $prop(meta, '$$is_singleton', true);
    $prop(meta, '$$singleton_of', mod);
    set_meta(mod, meta);
    // Restoring ModuleName.class
    $prop(mod, '$$class', Opal.Module);

    return meta;
  };

  // Build the singleton class for a Ruby (non class) Object.
  //
  // @param object [Object]
  // @return [Class]
  Opal.build_object_singleton_class = function(object) {
    var superclass = object.$$class,
        klass = $allocate_class(nil, superclass, true);

    $prop(klass, '$$is_singleton', true);
    $prop(klass, '$$singleton_of', object);

    delete klass.$$prototype.$$class;

    set_meta(object, klass);

    return klass;
  };

  Opal.is_method = function(prop) {
    return (prop[0] === '$' && prop[1] !== '$');
  };

  Opal.instance_methods = function(mod) {
    var processed = Object.create(null), results = [], ancestors = $ancestors(mod);

    for (var i = 0, l = ancestors.length; i < l; i++) {
      var ancestor = ancestors[i],
          proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      var props = Object.getOwnPropertyNames(proto);

      for (var j = 0, ll = props.length; j < ll; j++) {
        var prop = props[j];

        if (processed[prop]) {
          continue;
        }
        if (Opal.is_method(prop)) {
          var method = proto[prop];

          if (!method.$$stub) {
            var method_name = prop.slice(1);
            results.push(method_name);
          }
        }
        processed[prop] = true;
      }
    }

    return results;
  };

  Opal.own_instance_methods = function(mod) {
    var results = [],
        proto = mod.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto);

    for (var i = 0, length = props.length; i < length; i++) {
      var prop = props[i];

      if (Opal.is_method(prop)) {
        var method = proto[prop];

        if (!method.$$stub) {
          var method_name = prop.slice(1);
          results.push(method_name);
        }
      }
    }

    return results;
  };

  Opal.methods = function(obj) {
    return Opal.instance_methods(obj.$$meta || obj.$$class);
  };

  Opal.own_methods = function(obj) {
    return obj.$$meta ? Opal.own_instance_methods(obj.$$meta) : [];
  };

  Opal.receiver_methods = function(obj) {
    var mod = Opal.get_singleton_class(obj);
    var singleton_methods = Opal.own_instance_methods(mod);
    var instance_methods = Opal.own_instance_methods(mod.$$super);
    return singleton_methods.concat(instance_methods);
  };

  // Returns an object containing all pairs of names/values
  // for all class variables defined in provided +module+
  // and its ancestors.
  //
  // @param module [Module]
  // @return [Object]
  Opal.class_variables = function(module) {
    var ancestors = $ancestors(module),
        i, length = ancestors.length,
        result = {};

    for (i = length - 1; i >= 0; i--) {
      var ancestor = ancestors[i];

      for (var cvar in ancestor.$$cvars) {
        result[cvar] = ancestor.$$cvars[cvar];
      }
    }

    return result;
  };

  // Sets class variable with specified +name+ to +value+
  // in provided +module+
  //
  // @param module [Module]
  // @param name [String]
  // @param value [Object]
  Opal.class_variable_set = function(module, name, value) {
    var ancestors = $ancestors(module),
        i, length = ancestors.length;

    for (i = length - 2; i >= 0; i--) {
      var ancestor = ancestors[i];

      if ($has_own(ancestor.$$cvars, name)) {
        ancestor.$$cvars[name] = value;
        return value;
      }
    }

    module.$$cvars[name] = value;

    return value;
  };

  // Gets class variable with specified +name+ from provided +module+
  //
  // @param module [Module]
  // @param name [String]
  Opal.class_variable_get = function(module, name, tolerant) {
    if ($has_own(module.$$cvars, name))
      return module.$$cvars[name];

    var ancestors = $ancestors(module),
      i, length = ancestors.length;

    for (i = 0; i < length; i++) {
      var ancestor = ancestors[i];

      if ($has_own(ancestor.$$cvars, name)) {
        return ancestor.$$cvars[name];
      }
    }

    if (!tolerant)
      $raise(Opal.NameError, 'uninitialized class variable '+name+' in '+module.$name());

    return nil;
  }

  function isRoot(proto) {
    return proto.hasOwnProperty('$$iclass') && proto.hasOwnProperty('$$root');
  }

  function own_included_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    while (proto) {
      if (proto.hasOwnProperty('$$class')) {
        // superclass
        break;
      }
      mod = protoToModule(proto);
      if (mod) {
        result.push(mod);
      }
      proto = Object.getPrototypeOf(proto);
    }

    return result;
  }

  function own_prepended_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    if (module.$$prototype.hasOwnProperty('$$dummy')) {
      while (proto) {
        if (proto === module.$$prototype.$$define_methods_on) {
          break;
        }

        mod = protoToModule(proto);
        if (mod) {
          result.push(mod);
        }

        proto = Object.getPrototypeOf(proto);
      }
    }

    return result;
  }


  // The actual inclusion of a module into a class.
  //
  // ## Class `$$parent` and `iclass`
  //
  // To handle `super` calls, every class has a `$$parent`. This parent is
  // used to resolve the next class for a super call. A normal class would
  // have this point to its superclass. However, if a class includes a module
  // then this would need to take into account the module. The module would
  // also have to then point its `$$parent` to the actual superclass. We
  // cannot modify modules like this, because it might be included in more
  // then one class. To fix this, we actually insert an `iclass` as the class'
  // `$$parent` which can then point to the superclass. The `iclass` acts as
  // a proxy to the actual module, so the `super` chain can then search it for
  // the required method.
  //
  // @param module [Module] the module to include
  // @param includer [Module] the target class to include module into
  // @return [null]
  Opal.append_features = function(module, includer) {
    var module_ancestors = $ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(includer) !== -1) {
      $raise(Opal.ArgumentError, 'cyclic include detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $prop(iclass, '$$included', true);
      iclasses.push(iclass);
    }
    var includer_ancestors = $ancestors(includer),
        chain = chain_iclasses(iclasses),
        start_chain_after,
        end_chain_on;

    if (includer_ancestors.indexOf(module) === -1) {
      // first time include

      // includer -> chain.first -> ...chain... -> chain.last -> includer.parent
      start_chain_after = includer.$$prototype;
      end_chain_on = Object.getPrototypeOf(includer.$$prototype);
    } else {
      // The module has been already included,
      // we don't need to put it into the ancestors chain again,
      // but this module may have new included modules.
      // If it's true we need to copy them.
      //
      // The simplest way is to replace ancestors chain from
      //          parent
      //            |
      //   `module` iclass (has a $$root flag)
      //            |
      //   ...previos chain of module.included_modules ...
      //            |
      //  "next ancestor" (has a $$root flag or is a real class)
      //
      // to
      //          parent
      //            |
      //    `module` iclass (has a $$root flag)
      //            |
      //   ...regenerated chain of module.included_modules
      //            |
      //   "next ancestor" (has a $$root flag or is a real class)
      //
      // because there are no intermediate classes between `parent` and `next ancestor`.
      // It doesn't break any prototypes of other objects as we don't change class references.

      var parent = includer.$$prototype, module_iclass = Object.getPrototypeOf(parent);

      while (module_iclass != null) {
        if (module_iclass.$$module === module && isRoot(module_iclass)) {
          break;
        }

        parent = module_iclass;
        module_iclass = Object.getPrototypeOf(module_iclass);
      }

      if (module_iclass) {
        // module has been directly included
        var next_ancestor = Object.getPrototypeOf(module_iclass);

        // skip non-root iclasses (that were recursively included)
        while (next_ancestor.hasOwnProperty('$$iclass') && !isRoot(next_ancestor)) {
          next_ancestor = Object.getPrototypeOf(next_ancestor);
        }

        start_chain_after = parent;
        end_chain_on = next_ancestor;
      } else {
        // module has not been directly included but was in ancestor chain because it was included by another module
        // include it directly
        start_chain_after = includer.$$prototype;
        end_chain_on = Object.getPrototypeOf(includer.$$prototype);
      }
    }

    $set_proto(start_chain_after, chain.first);
    $set_proto(chain.last, end_chain_on);

    // recalculate own_included_modules cache
    includer.$$own_included_modules = own_included_modules(includer);

    Opal.const_cache_version++;
  };

  Opal.prepend_features = function(module, prepender) {
    // Here we change the ancestors chain from
    //
    //   prepender
    //      |
    //    parent
    //
    // to:
    //
    // dummy(prepender)
    //      |
    //  iclass(module)
    //      |
    // iclass(prepender)
    //      |
    //    parent
    var module_ancestors = $ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(prepender) !== -1) {
      $raise(Opal.ArgumentError, 'cyclic prepend detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $prop(iclass, '$$prepended', true);
      iclasses.push(iclass);
    }

    var chain = chain_iclasses(iclasses),
        dummy_prepender = prepender.$$prototype,
        previous_parent = Object.getPrototypeOf(dummy_prepender),
        prepender_iclass,
        start_chain_after,
        end_chain_on;

    if (dummy_prepender.hasOwnProperty('$$dummy')) {
      // The module already has some prepended modules
      // which means that we don't need to make it "dummy"
      prepender_iclass = dummy_prepender.$$define_methods_on;
    } else {
      // Making the module "dummy"
      prepender_iclass = create_dummy_iclass(prepender);
      flush_methods_in(prepender);
      $prop(dummy_prepender, '$$dummy', true);
      $prop(dummy_prepender, '$$define_methods_on', prepender_iclass);

      // Converting
      //   dummy(prepender) -> previous_parent
      // to
      //   dummy(prepender) -> iclass(prepender) -> previous_parent
      $set_proto(dummy_prepender, prepender_iclass);
      $set_proto(prepender_iclass, previous_parent);
    }

    var prepender_ancestors = $ancestors(prepender);

    if (prepender_ancestors.indexOf(module) === -1) {
      // first time prepend

      start_chain_after = dummy_prepender;

      // next $$root or prepender_iclass or non-$$iclass
      end_chain_on = Object.getPrototypeOf(dummy_prepender);
      while (end_chain_on != null) {
        if (
          end_chain_on.hasOwnProperty('$$root') ||
          end_chain_on === prepender_iclass ||
          !end_chain_on.hasOwnProperty('$$iclass')
        ) {
          break;
        }

        end_chain_on = Object.getPrototypeOf(end_chain_on);
      }
    } else {
      $raise(Opal.RuntimeError, "Prepending a module multiple times is not supported");
    }

    $set_proto(start_chain_after, chain.first);
    $set_proto(chain.last, end_chain_on);

    // recalculate own_prepended_modules cache
    prepender.$$own_prepended_modules = own_prepended_modules(prepender);

    Opal.const_cache_version++;
  };

  function flush_methods_in(module) {
    var proto = module.$$prototype,
        props = Object.getOwnPropertyNames(proto);

    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      if (Opal.is_method(prop)) {
        delete proto[prop];
      }
    }
  }

  function create_iclass(module) {
    var iclass = create_dummy_iclass(module);

    if (module.$$is_module) {
      module.$$iclasses.push(iclass);
    }

    return iclass;
  }

  // Dummy iclass doesn't receive updates when the module gets a new method.
  function create_dummy_iclass(module) {
    var iclass = {},
        proto = module.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto),
        length = props.length, i;

    for (i = 0; i < length; i++) {
      var prop = props[i];
      $prop(iclass, prop, proto[prop]);
    }

    $prop(iclass, '$$iclass', true);
    $prop(iclass, '$$module', module);

    return iclass;
  }

  function chain_iclasses(iclasses) {
    var length = iclasses.length, first = iclasses[0];

    $prop(first, '$$root', true);

    if (length === 1) {
      return { first: first, last: first };
    }

    var previous = first;

    for (var i = 1; i < length; i++) {
      var current = iclasses[i];
      $set_proto(previous, current);
      previous = current;
    }


    return { first: iclasses[0], last: iclasses[length - 1] };
  }

  // For performance, some core Ruby classes are toll-free bridged to their
  // native JavaScript counterparts (e.g. a Ruby Array is a JavaScript Array).
  //
  // This method is used to setup a native constructor (e.g. Array), to have
  // its prototype act like a normal Ruby class. Firstly, a new Ruby class is
  // created using the native constructor so that its prototype is set as the
  // target for the new class. Note: all bridged classes are set to inherit
  // from Object.
  //
  // Example:
  //
  //    Opal.bridge(self, Function);
  //
  // @param klass       [Class] the Ruby class to bridge
  // @param constructor [JS.Function] native JavaScript constructor to use
  // @return [Class] returns the passed Ruby class
  //
  Opal.bridge = function(native_klass, klass) {
    if (native_klass.hasOwnProperty('$$bridge')) {
      $raise(Opal.ArgumentError, "already bridged");
    }

    // constructor is a JS function with a prototype chain like:
    // - constructor
    //   - super
    //
    // What we need to do is to inject our class (with its prototype chain)
    // between constructor and super. For example, after injecting ::Object
    // into JS String we get:
    //
    // - constructor (window.String)
    //   - Opal.Object
    //     - Opal.Kernel
    //       - Opal.BasicObject
    //         - super (window.Object)
    //           - null
    //
    $prop(native_klass, '$$bridge', klass);
    $set_proto(native_klass.prototype, (klass.$$super || Opal.Object).$$prototype);
    $prop(klass, '$$prototype', native_klass.prototype);

    $prop(klass.$$prototype, '$$class', klass);
    $prop(klass, '$$constructor', native_klass);
    $prop(klass, '$$bridge', true);
  };

  function protoToModule(proto) {
    if (proto.hasOwnProperty('$$dummy')) {
      return;
    } else if (proto.hasOwnProperty('$$iclass')) {
      return proto.$$module;
    } else if (proto.hasOwnProperty('$$class')) {
      return proto.$$class;
    }
  }

  function own_ancestors(module) {
    return module.$$own_prepended_modules.concat([module]).concat(module.$$own_included_modules);
  }

  // The Array of ancestors for a given module/class
  function $ancestors(module) {
    if (!module) { return []; }

    if (module.$$ancestors_cache_version === Opal.const_cache_version) {
      return module.$$ancestors;
    }

    var result = [], i, mods, length;

    for (i = 0, mods = own_ancestors(module), length = mods.length; i < length; i++) {
      result.push(mods[i]);
    }

    if (module.$$super) {
      for (i = 0, mods = $ancestors(module.$$super), length = mods.length; i < length; i++) {
        result.push(mods[i]);
      }
    }

    module.$$ancestors_cache_version = Opal.const_cache_version;
    module.$$ancestors = result;

    return result;
  };
  Opal.ancestors = $ancestors;

  Opal.included_modules = function(module) {
    var result = [], mod = null, proto = Object.getPrototypeOf(module.$$prototype);

    for (; proto && Object.getPrototypeOf(proto); proto = Object.getPrototypeOf(proto)) {
      mod = protoToModule(proto);
      if (mod && mod.$$is_module && proto.$$iclass && proto.$$included) {
        result.push(mod);
      }
    }

    return result;
  };


  // Method Missing
  // --------------

  // Methods stubs are used to facilitate method_missing in opal. A stub is a
  // placeholder function which just calls `method_missing` on the receiver.
  // If no method with the given name is actually defined on an object, then it
  // is obvious to say that the stub will be called instead, and then in turn
  // method_missing will be called.
  //
  // When a file in ruby gets compiled to javascript, it includes a call to
  // this function which adds stubs for every method name in the compiled file.
  // It should then be safe to assume that method_missing will work for any
  // method call detected.
  //
  // Method stubs are added to the BasicObject prototype, which every other
  // ruby object inherits, so all objects should handle method missing. A stub
  // is only added if the given property name (method name) is not already
  // defined.
  //
  // Note: all ruby methods have a `$` prefix in javascript, so all stubs will
  // have this prefix as well (to make this method more performant).
  //
  //    Opal.add_stubs("foo,bar,baz=");
  //
  // All stub functions will have a private `$$stub` property set to true so
  // that other internal methods can detect if a method is just a stub or not.
  // `Kernel#respond_to?` uses this property to detect a methods presence.
  //
  // @param stubs [Array] an array of method stubs to add
  // @return [undefined]
  Opal.add_stubs = function(stubs) {
    var proto = Opal.BasicObject.$$prototype;
    var stub, existing_method;
    stubs = stubs.split(',');

    for (var i = 0, length = stubs.length; i < length; i++) {
      stub = $jsid(stubs[i]), existing_method = proto[stub];

      if (existing_method == null || existing_method.$$stub) {
        Opal.add_stub_for(proto, stub);
      }
    }
  };

  // Add a method_missing stub function to the given prototype for the
  // given name.
  //
  // @param prototype [Prototype] the target prototype
  // @param stub [String] stub name to add (e.g. "$foo")
  // @return [undefined]
  Opal.add_stub_for = function(prototype, stub) {
    // Opal.stub_for(stub) is the method_missing_stub
    $prop(prototype, stub, Opal.stub_for(stub));
  };

  // Generate the method_missing stub for a given method name.
  //
  // @param method_name [String] The js-name of the method to stub (e.g. "$foo")
  // @return [undefined]
  Opal.stub_for = function(method_name) {
    function method_missing_stub() {
      // Copy any given block onto the method_missing dispatcher
      this.$method_missing.$$p = method_missing_stub.$$p;

      // Set block property to null ready for the next call (stop false-positives)
      method_missing_stub.$$p = null;

      // call method missing with correct args (remove '$' prefix on method name)
      return this.$method_missing.apply(this, $prepend(method_name.slice(1), arguments));
    };

    method_missing_stub.$$stub = true;

    return method_missing_stub;
  };


  // Methods
  // -------

  // Arity count error dispatcher for methods
  //
  // @param actual [Fixnum] number of arguments given to method
  // @param expected [Fixnum] expected number of arguments
  // @param object [Object] owner of the method +meth+
  // @param meth [String] method name that got wrong number of arguments
  // @raise [ArgumentError]
  Opal.ac = function(actual, expected, object, meth) {
    var inspect = '';
    if (object.$$is_a_module) {
      inspect += object.$$name + '.';
    }
    else {
      inspect += object.$$class.$$name + '#';
    }
    inspect += meth;

    $raise(Opal.ArgumentError, '[' + inspect + '] wrong number of arguments (given ' + actual + ', expected ' + expected + ')');
  };

  // Arity count error dispatcher for blocks
  //
  // @param actual [Fixnum] number of arguments given to block
  // @param expected [Fixnum] expected number of arguments
  // @param context [Object] context of the block definition
  // @raise [ArgumentError]
  Opal.block_ac = function(actual, expected, context) {
    var inspect = "`block in " + context + "'";

    $raise(Opal.ArgumentError, inspect + ': wrong number of arguments (given ' + actual + ', expected ' + expected + ')');
  };

  function get_ancestors(obj) {
    if (obj.hasOwnProperty('$$meta') && obj.$$meta !== null) {
      return $ancestors(obj.$$meta);
    } else {
      return $ancestors(obj.$$class);
    }
  };

  // Super dispatcher
  Opal.find_super = function(obj, mid, current_func, defcheck, allow_stubs) {
    var jsid = $jsid(mid), ancestors, ancestor, super_method, method_owner, current_index = -1, i;

    ancestors = get_ancestors(obj);
    method_owner = current_func.$$owner;

    for (i = 0; i < ancestors.length; i++) {
      ancestor = ancestors[i];
      if (ancestor === method_owner || ancestor.$$cloned_from.indexOf(method_owner) !== -1) {
        current_index = i;
        break;
      }
    }

    for (i = current_index + 1; i < ancestors.length; i++) {
      ancestor = ancestors[i];
      var proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      if (proto.hasOwnProperty(jsid)) {
        super_method = proto[jsid];
        break;
      }
    }

    if (!defcheck && super_method && super_method.$$stub && obj.$method_missing.$$pristine) {
      // method_missing hasn't been explicitly defined
      $raise(Opal.NoMethodError, 'super: no superclass method `'+mid+"' for "+obj, mid);
    }

    return (super_method.$$stub && !allow_stubs) ? null : super_method;
  };

  // Iter dispatcher for super in a block
  Opal.find_block_super = function(obj, jsid, current_func, defcheck, implicit) {
    var call_jsid = jsid;

    if (!current_func) {
      $raise(Opal.RuntimeError, "super called outside of method");
    }

    if (implicit && current_func.$$define_meth) {
      $raise(Opal.RuntimeError,
        "implicit argument passing of super from method defined by define_method() is not supported. " +
        "Specify all arguments explicitly"
      );
    }

    if (current_func.$$def) {
      call_jsid = current_func.$$jsid;
    }

    return Opal.find_super(obj, call_jsid, current_func, defcheck);
  };

  // @deprecated
  Opal.find_super_dispatcher = Opal.find_super;

  // @deprecated
  Opal.find_iter_super_dispatcher = Opal.find_block_super;

  function call_lambda(block, arg, ret) {
    try {
      block(arg);
    } catch (e) {
      if (e === ret) {
        return ret.$v;
      }
      throw e;
    }
  }

  // handles yield calls for 1 yielded arg
  Opal.yield1 = function(block, arg) {
    if (typeof(block) !== "function") {
      $raise(Opal.LocalJumpError, "no block given");
    }

    var has_mlhs = block.$$has_top_level_mlhs_arg,
        has_trailing_comma = block.$$has_trailing_comma_in_args,
        is_returning_lambda = block.$$is_lambda && block.$$ret;

    if (block.length > 1 || ((has_mlhs || has_trailing_comma) && block.length === 1)) {
      arg = Opal.to_ary(arg);
    }

    if ((block.length > 1 || (has_trailing_comma && block.length === 1)) && arg.$$is_array) {
      if (is_returning_lambda) {
        return call_lambda(block.apply.bind(block, null), arg, block.$$ret);
      }
      return block.apply(null, arg);
    }
    else {
      if (is_returning_lambda) {
        return call_lambda(block, arg, block.$$ret);
      }
      return block(arg);
    }
  };

  // handles yield for > 1 yielded arg
  Opal.yieldX = function(block, args) {
    if (typeof(block) !== "function") {
      $raise(Opal.LocalJumpError, "no block given");
    }

    if (block.length > 1 && args.length === 1) {
      if (args[0].$$is_array) {
        args = args[0];
      }
    }

    if (block.$$is_lambda && block.$$ret) {
      return call_lambda(block.apply.bind(block, null), args, block.$$ret);
    }
    return block.apply(null, args);
  };

  // Finds the corresponding exception match in candidates.  Each candidate can
  // be a value, or an array of values.  Returns null if not found.
  Opal.rescue = function(exception, candidates) {
    for (var i = 0; i < candidates.length; i++) {
      var candidate = candidates[i];

      if (candidate.$$is_array) {
        var result = Opal.rescue(exception, candidate);

        if (result) {
          return result;
        }
      }
      else if ((Opal.Opal.Raw && candidate === Opal.Opal.Raw.Error) || candidate['$==='](exception)) {
        return candidate;
      }
    }

    return null;
  };

  Opal.is_a = function(object, klass) {
    if (klass != null && object.$$meta === klass || object.$$class === klass) {
      return true;
    }

    if (object.$$is_number && klass.$$is_number_class) {
      return (klass.$$is_integer_class) ? (object % 1) === 0 : true;
    }

    var ancestors = $ancestors(object.$$is_class ? Opal.get_singleton_class(object) : (object.$$meta || object.$$class));

    return ancestors.indexOf(klass) !== -1;
  };

  // Helpers for extracting kwsplats
  // Used for: { **h }
  Opal.to_hash = function(value) {
    if (value.$$is_hash) {
      return value;
    }
    else if (value['$respond_to?']('to_hash', true)) {
      var hash = value.$to_hash();
      if (hash.$$is_hash) {
        return hash;
      }
      else {
        $raise(Opal.TypeError, "Can't convert " + value.$$class +
          " to Hash (" + value.$$class + "#to_hash gives " + hash.$$class + ")");
      }
    }
    else {
      $raise(Opal.TypeError, "no implicit conversion of " + value.$$class + " into Hash");
    }
  };

  // Helpers for implementing multiple assignment
  // Our code for extracting the values and assigning them only works if the
  // return value is a JS array.
  // So if we get an Array subclass, extract the wrapped JS array from it

  // Used for: a, b = something (no splat)
  Opal.to_ary = function(value) {
    if (value.$$is_array) {
      return value;
    }
    else if (value['$respond_to?']('to_ary', true)) {
      var ary = value.$to_ary();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        $raise(Opal.TypeError, "Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_ary gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for: a, b = *something (with splat)
  Opal.to_a = function(value) {
    if (value.$$is_array) {
      // A splatted array must be copied
      return value.slice();
    }
    else if (value['$respond_to?']('to_a', true)) {
      var ary = value.$to_a();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        $raise(Opal.TypeError, "Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_a gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for extracting keyword arguments from arguments passed to
  // JS function.
  //
  // @param parameters [Array]
  // @return [Hash] or undefined
  //
  Opal.extract_kwargs = function(parameters) {
    var kwargs = parameters[parameters.length - 1];
    if (kwargs != null && Opal.respond_to(kwargs, '$to_hash', true)) {
      $splice(parameters, parameters.length - 1);
      return kwargs;
    }
  };

  // Used to get a list of rest keyword arguments. Method takes the given
  // keyword args, i.e. the hash literal passed to the method containing all
  // keyword arguments passed to method, as well as the used args which are
  // the names of required and optional arguments defined. This method then
  // just returns all key/value pairs which have not been used, in a new
  // hash literal.
  //
  // @param given_args [Hash] all kwargs given to method
  // @param used_args [Object<String: true>] all keys used as named kwargs
  // @return [Hash]
  //
  Opal.kwrestargs = function(given_args, used_args) {
    var map = new Map();

    Opal.hash_each(given_args, false, function(key, value) {
      if (!used_args[key]) {
        Opal.hash_put(map, key, value);
      }
      return [false, false];
    });

    return map;
  };

  function apply_blockopts(block, blockopts) {
    if (typeof(blockopts) === 'number') {
      block.$$arity = blockopts;
    }
    else if (typeof(blockopts) === 'object') {
      Object.assign(block, blockopts);
    }
  }

  // Optimization for a costly operation of prepending '$' to method names
  var jsid_cache = new Map();
  function $jsid(name) {
    var jsid = jsid_cache.get(name);
    if (!jsid) {
      jsid = '$' + name;
      jsid_cache.set(name, jsid);
    }
    return jsid;
  }
  Opal.jsid = $jsid;

  function $prepend(first, second) {
    if (!second.$$is_array) second = $slice(second);
    return [first].concat(second);
  }

  // Calls passed method on a ruby object with arguments and block:
  //
  // Can take a method or a method name.
  //
  // 1. When method name gets passed it invokes it by its name
  //    and calls 'method_missing' when object doesn't have this method.
  //    Used internally by Opal to invoke method that takes a block or a splat.
  // 2. When method (i.e. method body) gets passed, it doesn't trigger 'method_missing'
  //    because it doesn't know the name of the actual method.
  //    Used internally by Opal to invoke 'super'.
  //
  // @example
  //   var my_array = [1, 2, 3, 4]
  //   Opal.send(my_array, 'length')                    # => 4
  //   Opal.send(my_array, my_array.$length)            # => 4
  //
  //   Opal.send(my_array, 'reverse!')                  # => [4, 3, 2, 1]
  //   Opal.send(my_array, my_array['$reverse!']')      # => [4, 3, 2, 1]
  //
  // @param recv [Object] ruby object
  // @param method [Function, String] method body or name of the method
  // @param args [Array] arguments that will be passed to the method call
  // @param block [Function] ruby block
  // @param blockopts [Object, Number] optional properties to set on the block
  // @return [Object] returning value of the method call
  Opal.send = function(recv, method, args, block, blockopts) {
    var body;

    if (typeof(method) === 'function') {
      body = method;
      method = null;
    } else if (typeof(method) === 'string') {
      body = recv[$jsid(method)];
    } else {
      $raise(Opal.NameError, "Passed method should be a string or a function");
    }

    return Opal.send2(recv, body, method, args, block, blockopts);
  };

  Opal.send2 = function(recv, body, method, args, block, blockopts) {
    if (body == null && method != null && recv.$method_missing) {
      body = recv.$method_missing;
      args = $prepend(method, args);
    }

    apply_blockopts(block, blockopts);

    if (typeof block === 'function') body.$$p = block;
    return body.apply(recv, args);
  };

  Opal.refined_send = function(refinement_groups, recv, method, args, block, blockopts) {
    var i, j, k, ancestors, ancestor, refinements, refinement, refine_modules, refine_module, body;

    ancestors = get_ancestors(recv);

    // For all ancestors that there are, starting from the closest to the furthest...
    for (i = 0; i < ancestors.length; i++) {
      ancestor = Opal.id(ancestors[i]);

      // For all refinement groups there are, starting from the closest scope to the furthest...
      for (j = 0; j < refinement_groups.length; j++) {
        refinements = refinement_groups[j];

        // For all refinements there are, starting from the last `using` call to the furthest...
        for (k = refinements.length - 1; k >= 0; k--) {
          refinement = refinements[k];
          if (typeof refinement.$$refine_modules === 'undefined') continue;

          // A single module being given as an argument of the `using` call contains multiple
          // refinement modules
          refine_modules = refinement.$$refine_modules;

          // Does this module refine a given call for a given ancestor module?
          if (typeof refine_modules[ancestor] === 'undefined') continue;
          refine_module = refine_modules[ancestor];

          // Does this module define a method we want to call?
          if (typeof refine_module.$$prototype[$jsid(method)] !== 'undefined') {
            body = refine_module.$$prototype[$jsid(method)];
            return Opal.send2(recv, body, method, args, block, blockopts);
          }
        }
      }
    }

    return Opal.send(recv, method, args, block, blockopts);
  };

  Opal.lambda = function(block, blockopts) {
    block.$$is_lambda = true;

    apply_blockopts(block, blockopts);

    return block;
  };

  // Used to define methods on an object. This is a helper method, used by the
  // compiled source to define methods on special case objects when the compiler
  // can not determine the destination object, or the object is a Module
  // instance. This can get called by `Module#define_method` as well.
  //
  // ## Modules
  //
  // Any method defined on a module will come through this runtime helper.
  // The method is added to the module body, and the owner of the method is
  // set to be the module itself. This is used later when choosing which
  // method should show on a class if more than 1 included modules define
  // the same method. Finally, if the module is in `module_function` mode,
  // then the method is also defined onto the module itself.
  //
  // ## Classes
  //
  // This helper will only be called for classes when a method is being
  // defined indirectly; either through `Module#define_method`, or by a
  // literal `def` method inside an `instance_eval` or `class_eval` body. In
  // either case, the method is simply added to the class' prototype. A special
  // exception exists for `BasicObject` and `Object`. These two classes are
  // special because they are used in toll-free bridged classes. In each of
  // these two cases, extra work is required to define the methods on toll-free
  // bridged class' prototypes as well.
  //
  // ## Objects
  //
  // If a simple ruby object is the object, then the method is simply just
  // defined on the object as a singleton method. This would be the case when
  // a method is defined inside an `instance_eval` block.
  //
  // @param obj  [Object, Class] the actual obj to define method for
  // @param jsid [String] the JavaScript friendly method name (e.g. '$foo')
  // @param body [JS.Function] the literal JavaScript function used as method
  // @param blockopts [Object, Number] optional properties to set on the body
  // @return [null]
  //
  Opal.def = function(obj, jsid, body, blockopts) {
    apply_blockopts(body, blockopts);

    // Special case for a method definition in the
    // top-level namespace
    if (obj === Opal.top) {
      return Opal.defn(Opal.Object, jsid, body);
    }
    // if instance_eval is invoked on a module/class, it sets inst_eval_mod
    else if (!obj.$$eval && obj.$$is_a_module) {
      return Opal.defn(obj, jsid, body);
    }
    else {
      return Opal.defs(obj, jsid, body);
    }
  };

  // Define method on a module or class (see Opal.def).
  Opal.defn = function(module, jsid, body) {
    $deny_frozen_access(module);

    body.displayName = jsid;
    body.$$owner = module;

    var name = jsid.substr(1);

    var proto = module.$$prototype;
    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }
    $prop(proto, jsid, body);

    if (module.$$is_module) {
      if (module.$$module_function) {
        Opal.defs(module, jsid, body)
      }

      for (var i = 0, iclasses = module.$$iclasses, length = iclasses.length; i < length; i++) {
        var iclass = iclasses[i];
        $prop(iclass, jsid, body);
      }
    }

    var singleton_of = module.$$singleton_of;
    if (module.$method_added && !module.$method_added.$$stub && !singleton_of) {
      module.$method_added(name);
    }
    else if (singleton_of && singleton_of.$singleton_method_added && !singleton_of.$singleton_method_added.$$stub) {
      singleton_of.$singleton_method_added(name);
    }

    return name;
  };

  // Define a singleton method on the given object (see Opal.def).
  Opal.defs = function(obj, jsid, body, blockopts) {
    apply_blockopts(body, blockopts);

    if (obj.$$is_string || obj.$$is_number) {
      $raise(Opal.TypeError, "can't define singleton");
    }
    return Opal.defn(Opal.get_singleton_class(obj), jsid, body);
  };

  // Since JavaScript has no concept of modules, we create proxy classes
  // called `iclasses` that store copies of methods loaded. We need to
  // update them if we remove a method.
  function remove_method_from_iclasses(obj, jsid) {
    if (obj.$$is_module) {
      for (var i = 0, iclasses = obj.$$iclasses, length = iclasses.length; i < length; i++) {
        var iclass = iclasses[i];
        delete iclass[jsid];
      }
    }
  }

  // Called from #remove_method.
  Opal.rdef = function(obj, jsid) {
    if (!$has_own(obj.$$prototype, jsid)) {
      $raise(Opal.NameError, "method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    delete obj.$$prototype[jsid];

    remove_method_from_iclasses(obj, jsid);

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_removed && !obj.$$prototype.$singleton_method_removed.$$stub) {
        obj.$$prototype.$singleton_method_removed(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_removed && !obj.$method_removed.$$stub) {
        obj.$method_removed(jsid.substr(1));
      }
    }
  };

  // Called from #undef_method.
  Opal.udef = function(obj, jsid) {
    if (!obj.$$prototype[jsid] || obj.$$prototype[jsid].$$stub) {
      $raise(Opal.NameError, "method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    Opal.add_stub_for(obj.$$prototype, jsid);

    remove_method_from_iclasses(obj, jsid);

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_undefined && !obj.$$prototype.$singleton_method_undefined.$$stub) {
        obj.$$prototype.$singleton_method_undefined(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_undefined && !obj.$method_undefined.$$stub) {
        obj.$method_undefined(jsid.substr(1));
      }
    }
  };

  function is_method_body(body) {
    return (typeof(body) === "function" && !body.$$stub);
  }

  Opal.alias = function(obj, name, old) {
    var id     = $jsid(name),
        old_id = $jsid(old),
        body,
        alias;

    // Aliasing on main means aliasing on Object...
    if (typeof obj.$$prototype === 'undefined') {
      obj = Opal.Object;
    }

    body = obj.$$prototype[old_id];

    // When running inside #instance_eval the alias refers to class methods.
    if (obj.$$eval) {
      return Opal.alias(Opal.get_singleton_class(obj), name, old);
    }

    if (!is_method_body(body)) {
      var ancestor = obj.$$super;

      while (typeof(body) !== "function" && ancestor) {
        body     = ancestor[old_id];
        ancestor = ancestor.$$super;
      }

      if (!is_method_body(body) && obj.$$is_module) {
        // try to look into Object
        body = Opal.Object.$$prototype[old_id]
      }

      if (!is_method_body(body)) {
        $raise(Opal.NameError, "undefined method `" + old + "' for class `" + obj.$name() + "'")
      }
    }

    // If the body is itself an alias use the original body
    // to keep the max depth at 1.
    if (body.$$alias_of) body = body.$$alias_of;

    // We need a wrapper because otherwise properties
    // would be overwritten on the original body.
    alias = Opal.wrap_method_body(body);

    // Try to make the browser pick the right name
    alias.displayName  = name;
    alias.$$alias_of   = body;
    alias.$$alias_name = name;

    Opal.defn(obj, id, alias);

    return obj;
  };

  Opal.wrap_method_body = function(body) {
    var wrapped = function() {
      var block = wrapped.$$p;

      wrapped.$$p = null;

      return Opal.send(this, body, arguments, block);
    };

    // Assign the 'length' value with defineProperty because
    // in strict mode the property is not writable.
    // It doesn't work in older browsers (like Chrome 38), where
    // an exception is thrown breaking Opal altogether.
    try {
      Object.defineProperty(wrapped, 'length', { value: body.length });
    } catch {}

    wrapped.$$arity           = body.$$arity == null ? body.length : body.$$arity;
    wrapped.$$parameters      = body.$$parameters;
    wrapped.$$source_location = body.$$source_location;

    return wrapped;
  };

  Opal.alias_gvar = function(new_name, old_name) {
    Object.defineProperty($gvars, new_name, {
      configurable: true,
      enumerable: true,
      get: function() {
        return $gvars[old_name];
      },
      set: function(new_value) {
        $gvars[old_name] = new_value;
      }
    });
    return nil;
  }

  Opal.alias_native = function(obj, name, native_name) {
    var id   = $jsid(name),
        body = obj.$$prototype[native_name];

    if (typeof(body) !== "function" || body.$$stub) {
      $raise(Opal.NameError, "undefined native method `" + native_name + "' for class `" + obj.$name() + "'")
    }

    Opal.defn(obj, id, body);

    return obj;
  };


  // Hashes
  // ------


  // Experiments have shown, that using new Map([[1,2]]) inline is rather slow
  // compared to using new Map() in combination with .set(1,2), because the former
  // creates a new Array for each pair and then discards it. Using .set though
  // would increase the size of the generated code. So lets use a compromise and
  // use a helper function, which allows the compiler to generate compact code
  // and at the same time provides the performance improvement of using .set
  // with a overall smaller overhead than creating arrays for each pair.
  // For primitive keys:
  Opal.hash_new = function () {
    let h = new Map();
    for (let i = 0; i < arguments.length; i += 2) {
      h.set(arguments[i], arguments[i + 1]);
    }
    return h;
  }

  // The same as above, except for complex keys:
  Opal.hash_new2 = function () {
    let h = new Map();
    for (let i = 0; i < arguments.length; i += 2) {
      Opal.hash_put(h, arguments[i], arguments[i + 1]);
    }
    return h;
  }

  Opal.hash_init = function (_hash) {
    console.warn("DEPRECATION: Opal.hash_init is deprecated and is now a no-op.");
  }

  Opal.hash_clone = function(from_hash, to_hash) {
    to_hash.$$none = from_hash.$$none;
    to_hash.$$proc = from_hash.$$proc;

    return Opal.hash_each(from_hash, to_hash, function(key, value) {
      Opal.hash_put(to_hash, key, value);
      return [false, to_hash];
    });
  };

  Opal.hash_put = function(hash, key, value) {
    var type = typeof key;
    if (type === "string" || type === "symbol" || type === "number" || type === "boolean" || type === "bigint") {
      hash.set(key, value)
    } else if (key.$$is_string) {
      hash.set(key.valueOf(), value);
    } else {
      if (!hash.$$keys)
        hash.$$keys = new Map();

      var key_hash = key.$$is_string ? key.valueOf() : (hash.$$by_identity ? Opal.id(key) : key.$hash()),
          keys = hash.$$keys;

      if (!keys.has(key_hash)) {
        keys.set(key_hash, [key]);
        hash.set(key, value);
        return;
      }

      var objects = keys.get(key_hash),
          object;

      for (var i=0; i<objects.length; i++) {
        object = objects[i];
        if (key === object || key['$eql?'](object)) {
          hash.set(object, value);
          return;
        }
      }

      objects.push(key);
      hash.set(key, value);
    }
  };

  Opal.hash_get = function(hash, key) {
    var type = typeof key;
    if (type === "string" || type === "symbol" || type === "number" || type === "boolean" || type === "bigint") {
      return hash.get(key)
    } else if (hash.$$keys) {
      var key_hash = key.$$is_string ? key.valueOf() : (hash.$$by_identity ? Opal.id(key) : key.$hash()),
          objects = hash.$$keys.get(key_hash),
          object;

      if (objects !== undefined) {
        for (var i=0; i<objects.length; i++) {
          object = objects[i];
          if (key === object || key['$eql?'](object))
            return hash.get(object);
        }
      } else if (key.$$is_string) {
        return hash.get(key_hash);
      }
    } else if (key.$$is_string) {
      return hash.get(key.valueOf());
    }
  };

  function $hash_delete_stage2(hash, key) {
    var value = hash.get(key);
    hash.delete(key);
    return value;
  }

  Opal.hash_delete = function(hash, key) {
    var type = typeof key
    if (type === "string" || type === "symbol" || type === "number" || type === "boolean" || type === "bigint") {
      return $hash_delete_stage2(hash, key);
    } else if (hash.$$keys) {
      var key_hash = key.$$is_string ? key.valueOf() : (hash.$$by_identity ? Opal.id(key) : key.$hash()),
          objects = hash.$$keys.get(key_hash),
          object;

      if (objects !== undefined) {
        for (var i=0; i<objects.length; i++) {
          object = objects[i];
          if (key === object || key['$eql?'](object)) {
            objects.splice(i, 1);
            if (objects.length === 0)
              hash.$$keys.delete(key_hash);
            return $hash_delete_stage2(hash, object);
          }
        }
      } else if (key.$$is_string) {
        return $hash_delete_stage2(hash, key_hash);
      }
    } else if (key.$$is_string) {
      return $hash_delete_stage2(hash, key.valueOf());
    }
  };

  Opal.hash_rehash = function(hash) {
    var keys = hash.$$keys;

    if (keys)
      keys.clear();

    Opal.hash_each(hash, false, function(key, value) {
      var type = typeof key;
      if (type === "string" || type === "symbol" || type === "number" || type === "boolean" || type === "bigint")
        return [false, false]; // nothing to rehash

      var key_hash = key.$$is_string ? key.valueOf() : (hash.$$by_identity ? Opal.id(key) : key.$hash());

      if (!keys)
        hash.$$keys = keys = new Map();

      if (!keys.has(key_hash)) {
        keys.set(key_hash, [key]);
        return [false, false];
      }

      var objects = keys.get(key_hash),
          objects_copy = (objects.length === 1) ? objects : $slice(objects),
          object;

      for (var i=0; i<objects_copy.length; i++) {
        object = objects_copy[i];
        if (key === object || key['$eql?'](object)) {
          // got a duplicate, remove it
          objects.splice(objects.indexOf(object), 1);
          hash.delete(object);
        }
      }

      objects.push(key);

      return [false, false]
    });

    return hash;
  };

  Opal.hash = function () {
    var arguments_length = arguments.length,
      args,
      hash,
      i,
      length,
      key,
      value;

    if (arguments_length === 1 && arguments[0].$$is_hash) {
      return arguments[0];
    }

    hash = new Map();

    if (arguments_length === 1) {
      args = arguments[0];

      if (arguments[0].$$is_array) {
        length = args.length;

        for (i = 0; i < length; i++) {
          if (args[i].length !== 2) {
            $raise(Opal.ArgumentError, 'value not of length 2: ' + args[i].$inspect());
          }

          key = args[i][0];
          value = args[i][1];

          Opal.hash_put(hash, key, value);
        }

        return hash;
      } else {
        args = arguments[0];
        for (key in args) {
          if ($has_own(args, key)) {
            value = args[key];

            Opal.hash_put(hash, key, value);
          }
        }

        return hash;
      }
    }

    if (arguments_length % 2 !== 0) {
      $raise(Opal.ArgumentError, 'odd number of arguments for Hash');
    }

    for (i = 0; i < arguments_length; i += 2) {
      key = arguments[i];
      value = arguments[i + 1];

      Opal.hash_put(hash, key, value);
    }

    return hash;
  };

  // A faster Hash creator for hashes that just use symbols and
  // strings as keys. The map and keys array can be constructed at
  // compile time, so they are just added here by the constructor
  // function.
  //
  Opal.hash2 = function(keys, smap) {
    console.warn("DEPRECATION: `Opal.hash2` is deprecated and will be removed in Opal 2.0. Use $hash_new for primitive keys or $hash_new2 for complex keys instead.");

    var hash = new Map();
    for (var i = 0, max = keys.length; i < max; i++) {
      hash.set(keys[i], smap[keys[i]]);
    }
    return hash;
  };

  Opal.hash_each = function (hash, dres, fun) {
    // dres = default result, returned if hash is empty
    // fun is called as fun(key, value) and must return a array with [break, result]
    // if break is true, iteration stops and result is returned
    // if break is false, iteration continues and eventually the last result is returned
    var res;
    for (var i = 0, entry, entries = Array.from(hash.entries()), l = entries.length; i < l; i++) {
      entry = entries[i];
      res = fun(entry[0], entry[1]);
      if (res[0]) return res[1];
    }
    return res ? res[1] : dres;
  };

  // Create a new range instance with first and last values, and whether the
  // range excludes the last value.
  //
  Opal.range = function(first, last, exc) {
    var range         = new Opal.Range();
        range.begin   = first;
        range.end     = last;
        range.excl    = exc;

    return range;
  };

  var reserved_ivar_names = [
    // properties
    "constructor", "displayName", "__count__", "__noSuchMethod__",
    "__parent__", "__proto__",
    // methods
    "hasOwnProperty", "valueOf"
  ];

  // Get the ivar name for a given name.
  // Mostly adds a trailing $ to reserved names.
  //
  Opal.ivar = function(name) {
    if (reserved_ivar_names.indexOf(name) !== -1) {
      name += "$";
    }

    return name;
  };

  // Support for #freeze
  // -------------------

  // helper that can be used from methods
  function $deny_frozen_access(obj) {
    if (obj.$$frozen) {
      $raise(Opal.FrozenError, "can't modify frozen " + (obj.$class()) + ": " + (obj), new Map([["receiver", obj]]));
    }
  };
  Opal.deny_frozen_access = $deny_frozen_access;

  // common #freeze runtime support
  Opal.freeze = function(obj) {
    $prop(obj, "$$frozen", true);

    // set $$id
    if (!obj.hasOwnProperty('$$id')) { $prop(obj, '$$id', $uid()); }

    if (obj.hasOwnProperty('$$meta')) {
      // freeze $$meta if it has already been set
      obj.$$meta.$freeze();
    } else {
      // ensure $$meta can be set lazily, $$meta is frozen when set in runtime.js
      $prop(obj, '$$meta', null);
    }

    // $$comparable is used internally and set multiple times
    // defining it before sealing ensures it can be modified later on
    if (!obj.hasOwnProperty('$$comparable')) { $prop(obj, '$$comparable', null); }

    // seal the Object
    Object.seal(obj);

    return obj;
  };

  // Iterate over every instance variable and call func for each one
  // giving name of the ivar and optionally the property descriptor.
  function $each_ivar(obj, func) {
    var own_props = Object.keys(obj), own_props_length = own_props.length, i, prop;

    for (i = 0; i < own_props_length; i++) {
      prop = own_props[i];

      if (prop[0] === '$') continue;

      func(prop);
    }
  }
  Opal.each_ivar = $each_ivar;

  // freze props, make setters of instance variables throw FrozenError
  Opal.freeze_props = function (obj) {
    var own_props = Object.keys(obj), own_props_length = own_props.length, i, prop, desc,
      dp_template = {
        get: null,
        set: function (_val) { $deny_frozen_access(obj); },
        enumerable: true
      };

    for (i = 0; i < own_props_length; i++) {
      prop = own_props[i];

      if (prop[0] === '$') continue;

      desc = Object.getOwnPropertyDescriptor(obj, prop);

      if (desc && desc.writable) {
        dp_template.get = $return_val(desc.value);
        Object.defineProperty(obj, prop, dp_template);
      }
    }
  };

  // Regexps
  // -------

  // Escape Regexp special chars letting the resulting string be used to build
  // a new Regexp.
  //
  Opal.escape_regexp = function(str) {
    return Opal.escape_metacharacters(str.replace(/([-[\]\/{}()*+?.^$\\| ])/g, '\\$1'))
  };

  Opal.escape_metacharacters = function(str) {
    return str.replace(/[\n]/g, '\\n')
              .replace(/[\r]/g, '\\r')
              .replace(/[\f]/g, '\\f')
              .replace(/[\t]/g, '\\t');
  }

  // Create a global Regexp from a RegExp object and cache the result
  // on the object itself ($$g attribute).
  //
  Opal.global_regexp = function(pattern) {
    if (pattern.global) {
      return pattern; // RegExp already has the global flag
    }
    if (pattern.$$g == null) {
      pattern.$$g = new RegExp(pattern.source, 'g' + pattern.flags);
    } else {
      pattern.$$g.lastIndex = null; // reset lastIndex property
    }
    return pattern.$$g;
  };

  // Transform a regular expression from Ruby syntax to JS syntax.
  Opal.transform_regexp = function(regexp, flags) {
    return Opal.Opal.RegexpTranspiler.$transform_regexp(regexp, flags);
  };

  // Combine multiple regexp parts together
  Opal.regexp = function(parts, flags) {
    var part;

    if (flags == null) flags = '';

    var ignoreCase = flags.includes('i');

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part instanceof RegExp) {
        if (part.ignoreCase !== ignoreCase)
          Opal.Kernel.$warn(
            "ignore case doesn't match for " + part.source.$inspect(),
            new Map([['uplevel',  1]])
          )

        part = part.$$source != null ? part.$$source : part.source;
      }
      if (part == '') part = '(?:)';
      parts[i] = part;
    }

    parts = parts.join('');
    parts = Opal.escape_metacharacters(parts);

    var output = Opal.transform_regexp(parts, flags);

    var regexp = new RegExp(output[0], output[1]);
    if (parts != output[0]) regexp.$$source = parts
    if (flags != output[1]) regexp.$$options = flags;
    return regexp;
  };

  // Regexp has been transformed, so let's annotate the original regexp
  Opal.annotate_regexp = function(regexp, source, options) {
    regexp.$$source = source;
    regexp.$$options = options;
    return regexp;
  }

  // Annotated empty regexp
  Opal.empty_regexp = function(flags) {
    return Opal.annotate_regexp(new RegExp(/(?:)/, flags), '');
  }

  // Require system
  // --------------

  Opal.modules         = {};
  Opal.loaded_features = ['corelib/runtime'];
  Opal.current_dir     = '.';
  Opal.require_table   = {'corelib/runtime': true};

  Opal.normalize = function(path) {
    var parts, part, new_parts = [], SEPARATOR = '/';

    if (Opal.current_dir !== '.') {
      path = Opal.current_dir.replace(/\/*$/, '/') + path;
    }

    path = path.replace(/^\.\//, '');
    path = path.replace(/\.(rb|opal|js)$/, '');
    parts = path.split(SEPARATOR);

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part === '') continue;
      (part === '..') ? new_parts.pop() : new_parts.push(part)
    }

    return new_parts.join(SEPARATOR);
  };

  Opal.loaded = function(paths) {
    var i, l, path;

    for (i = 0, l = paths.length; i < l; i++) {
      path = Opal.normalize(paths[i]);

      if (Opal.require_table[path]) {
        continue;
      }

      Opal.loaded_features.push(path);
      Opal.require_table[path] = true;
    }
  };

  Opal.load_normalized = function(path) {
    Opal.loaded([path]);

    var module = Opal.modules[path];

    if (module) {
      var retval = module(Opal);
      if (typeof Promise !== 'undefined' && retval instanceof Promise) {
        // A special case of require having an async top:
        // We will need to await it.
        return retval.then($return_val(true));
      }
    }
    else {
      var severity = Opal.config.missing_require_severity;
      var message  = 'cannot load such file -- ' + path;

      if (severity === "error") {
        $raise(Opal.LoadError, message);
      }
      else if (severity === "warning") {
        console.warn('WARNING: LoadError: ' + message);
      }
    }

    return true;
  };

  Opal.load = function(path) {
    path = Opal.normalize(path);

    return Opal.load_normalized(path);
  };

  Opal.require = function(path) {
    path = Opal.normalize(path);

    if (Opal.require_table[path]) {
      return false;
    }

    return Opal.load_normalized(path);
  };


  // Strings
  // -------

  // @returns a function proxy for all sorts of String functions
  function string_fun_proxy(target_str, target_fun, str_proxy) {
    return new Proxy(target_fun, {
      apply(trgt, _thisArg, args) {
        let res = trgt.apply(target_str, args);
        if (res === target_str || res === str_proxy) return str_proxy;
        else if (typeof(res) === 'string') return $str(res);
        else if (res != null && typeof(res) === 'object' && res.$$is_string) return $str(res.toString());
        else return res;
      }
    });
  }

  // @returns a function proxy that returns the result 'raw', usefeul for String.toString
  function string_raw_fun_proxy(target_str, target_fun) {
    return new Proxy(target_fun, {
      apply(trgt, _thisArg, args) { return trgt.apply(target_str, args); }
    });
  }

  function str_prop_is_fun(str, prop) {
    return (typeof str[prop] === 'function' && str[prop].constructor === Function);
  }

  let string_proxy_handler = {
    get: function(target_str, prop, str_proxy) {
      if (target_str.$$string) {
        // caught a mutated String
        if (prop === Symbol.toPrimitive || prop === 'toString' || prop === 'valueOf') {
          // special cases, do not box the result
          return string_raw_fun_proxy(target_str.$$string, target_str.$$string['toString']);
        } else if (prop[0] === '$' && prop[1] !== '$' && str_prop_is_fun(target_str, prop)) {
          // a Ruby method, apply to outer String object
          return string_fun_proxy(target_str, target_str[prop], str_proxy);
        } else if (str_prop_is_fun(target_str, prop)) {
          // a JS String function, apply it to mutated String primitive
          return string_fun_proxy(target_str.$$string, target_str.$$string[prop], str_proxy);
        } else if (prop === 'length') {
          // return the mutated String primitives length
          return target_str.$$string.length;
        } else if (typeof(prop) === 'number') {
          // a index access, apply to mutated String
          return target_str.$$string[prop];
        } else {
          // otherwise return property of outer String object, e.g. encoding
          return target_str[prop];
        }
      } else {
        // caught a normal String
        if (prop === Symbol.toPrimitive || prop === 'toString' || prop === 'valueOf') {
          // special cases, do not box the result
          return string_raw_fun_proxy(target_str, target_str['toString']);
        } else if (str_prop_is_fun(target_str, prop)) {
          // apply any method directly
          return string_fun_proxy(target_str, target_str[prop], str_proxy);
        } else {
          // apply any prop directly
          return target_str[prop];
        }
      }
    }
  }

  // @returns a new String object, proxied and mutable.
  function $str(string) {
    return new Proxy(new String(string), string_proxy_handler);
  }

  Opal.str = $str;

  // @returns a new String object with encoding set, proxied and mutable.
  Opal.str_with_enc = function(str, encoding) {
    str = Opal.set_encoding($str(str), encoding);
    str.internal_encoding = str.encoding;
    return str;
  }

  Opal.encodings = Object.create(null);

  // Sets the encoding on a string, will treat string literals as frozen strings
  // raising a FrozenError.
  //
  // @param str [String] the string on which the encoding should be set
  // @param name [String] the canonical name of the encoding
  // @param type [String] possible values are either `"encoding"`, `"internal_encoding"`, or `undefined
  Opal.set_encoding = function(str, name, type) {
    if (typeof type === "undefined") type = "encoding";
    if (typeof str === 'string' || str.$$frozen === true)
      $raise(Opal.FrozenError, "can't modify frozen String");

    var encoding = Opal.find_encoding(name);

    if (encoding === str[type]) { return str; }

    str[type] = encoding;

    return str;
  };

  // Fetches the encoding for the given name or raises ArgumentError.
  Opal.find_encoding = function(name) {
    var register = Opal.encodings;
    var encoding = register[name] || register[name.toUpperCase()];
    if (!encoding) $raise(Opal.ArgumentError, "unknown encoding name - " + name);
    return encoding;
  }

  // @returns a String object with the encoding set from a string literal
  Opal.enc = function(str, name) {
    var dup = $str(str);
    dup = Opal.set_encoding(dup, name);
    dup.internal_encoding = dup.encoding;
    return dup
  }

  // @returns a String object with the internal encoding set to Binary
  Opal.binary = function(str) {
    var dup = $str(str);
    return Opal.set_encoding(dup, "binary", "internal_encoding");
  }

  Opal.fallback_to_s = function(obj) {
    return `#<${obj.$$class.$to_s()}:0x${Opal.id(obj).toString(16)}>`
  }

  Opal.to_s = function(obj) {
    var stringified;
    if (obj == null) {
      return "`"+String(obj)+"`";
    }
    else if (typeof obj === 'string' || (typeof obj === 'object' && obj.$$is_string)) {
      return obj;
    }
    else if (obj.$to_s != null && !obj.$to_s.$$stub) {
      stringified = obj.$to_s();
      if (typeof stringified !== 'string' && !stringified.$$is_string) {
        stringified = Opal.fallback_to_s(obj);
      }
      return stringified;
    }
    else {
      return obj.toString();
    }
  }

  Opal.last_promise = null;
  Opal.promise_unhandled_exception = false;

  // Queue
  // -----

  // Run a block of code, but if it returns a Promise, don't run the next
  // one, but queue it.
  Opal.queue = function(proc) {
    if (Opal.last_promise) {
      // The async path is taken only if anything before returned a
      // Promise(V2).
      Opal.last_promise = Opal.last_promise.then(function() {
        if (!Opal.promise_unhandled_exception) return proc(Opal);
      })['catch'](function(error) {
        if (Opal.respond_to(error, '$full_message')) {
          error = error.$full_message();
        }
        console.error(error);
        // Abort further execution
        Opal.promise_unhandled_exception = true;
        Opal.exit(1);
      });
      return Opal.last_promise;
    }
    else {
      var ret = proc(Opal);
      if (typeof Promise === 'function' && typeof ret === 'object' && ret instanceof Promise) {
        Opal.last_promise = ret;
      }
      return ret;
    }
  }

  // Operator helpers
  // ----------------

  function are_both_numbers(l,r) { return typeof(l) === 'number' && typeof(r) === 'number' }

  Opal.rb_plus   = function(l,r) { return are_both_numbers(l,r) ? l + r : l['$+'](r); }
  Opal.rb_minus  = function(l,r) { return are_both_numbers(l,r) ? l - r : l['$-'](r); }
  Opal.rb_times  = function(l,r) { return are_both_numbers(l,r) ? l * r : l['$*'](r); }
  Opal.rb_divide = function(l,r) { return are_both_numbers(l,r) ? l / r : l['$/'](r); }
  Opal.rb_lt     = function(l,r) { return are_both_numbers(l,r) ? l < r : l['$<'](r); }
  Opal.rb_gt     = function(l,r) { return are_both_numbers(l,r) ? l > r : l['$>'](r); }
  Opal.rb_le     = function(l,r) { return are_both_numbers(l,r) ? l <= r : l['$<='](r); }
  Opal.rb_ge     = function(l,r) { return are_both_numbers(l,r) ? l >= r : l['$>='](r); }

  // Optimized helpers for calls like $truthy((a)['$==='](b)) -> $eqeqeq(a, b)
  function are_both_numbers_or_strings(lhs, rhs) {
    return (typeof lhs === 'number' && typeof rhs === 'number') ||
           (typeof lhs === 'string' && typeof rhs === 'string');
  }

  function $eqeq(lhs, rhs) {
    return are_both_numbers_or_strings(lhs,rhs) ? lhs === rhs : $truthy((lhs)['$=='](rhs));
  };
  Opal.eqeq = $eqeq;
  Opal.eqeqeq = function(lhs, rhs) {
    return are_both_numbers_or_strings(lhs,rhs) ? lhs === rhs : $truthy((lhs)['$==='](rhs));
  };
  Opal.neqeq = function(lhs, rhs) {
    return are_both_numbers_or_strings(lhs,rhs) ? lhs !== rhs : $truthy((lhs)['$!='](rhs));
  };
  Opal.not = function(arg) {
    if (undefined === arg || null === arg || false === arg || nil === arg) return true;
    if (true === arg || arg['$!'].$$pristine) return false;
    return $truthy(arg['$!']());
  }

  // Shortcuts - optimized function generators for simple kinds of functions
  function $return_val(arg) {
    return function() {
      return arg;
    }
  }
  Opal.return_val = $return_val;

  Opal.return_self = function() {
    return this;
  }
  Opal.return_ivar = function(ivar) {
    return function() {
      if (this[ivar] == null) { return nil; }
      return this[ivar];
    }
  }
  Opal.assign_ivar = function(ivar) {
    return function(val) {
      $deny_frozen_access(this);
      return this[ivar] = val;
    }
  }
  Opal.assign_ivar_val = function(ivar, static_val) {
    return function() {
      $deny_frozen_access(this);
      return this[ivar] = static_val;
    }
  }

  // Primitives for handling parameters
  Opal.ensure_kwargs = function(kwargs) {
    if (kwargs == null) {
      return new Map();
    } else if (kwargs.$$is_hash) {
      return kwargs;
    } else {
      $raise(Opal.ArgumentError, 'expected kwargs');
    }
  }

  Opal.get_kwarg = function(kwargs, key) {
    var kwarg = Opal.hash_get(kwargs, key);
    if (kwarg === undefined) {
      $raise(Opal.ArgumentError, 'missing keyword: '+key);
    }
    return kwarg;
  }

  // Arrays of size > 32 elements that contain only strings,
  // symbols, integers and nils are compiled as a self-extracting
  // string.
  Opal.large_array_unpack = function(str) {
    var array = str.split(","), length = array.length, i;
    for (i = 0; i < length; i++) {
      switch(array[i][0]) {
        case undefined:
          array[i] = nil
          break;
        case '-':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          array[i] = +array[i];
      }
    }
    return array;
  }

  // Opal32-checksum algorithm for #hash
  // -----------------------------------
  Opal.opal32_init = $return_val(0x4f70616c);

  function $opal32_ror(n, d) {
    return (n << d)|(n >>> (32 - d));
  };

  Opal.opal32_add = function(hash, next) {
    hash ^= next;
    hash = $opal32_ror(hash, 1);
    return hash;
  };

  // Initialization
  // --------------
  Opal.BasicObject = BasicObject = $allocate_class('BasicObject', null);
  Opal.Object      = _Object     = $allocate_class('Object', Opal.BasicObject);
  Opal.Module      = Module      = $allocate_class('Module', Opal.Object);
  Opal.Class       = Class       = $allocate_class('Class', Opal.Module);
  Opal.Opal        = _Opal       = $allocate_module('Opal');
  Opal.Kernel      = Kernel      = $allocate_module('Kernel');

  $set_proto(Opal.BasicObject, Opal.Class.$$prototype);
  $set_proto(Opal.Object, Opal.Class.$$prototype);
  $set_proto(Opal.Module, Opal.Class.$$prototype);
  $set_proto(Opal.Class, Opal.Class.$$prototype);

  // BasicObject can reach itself, avoid const_set to skip the $$base_module logic
  BasicObject.$$const.BasicObject = BasicObject;

  // Assign basic constants
  $const_set(_Object, "BasicObject",  BasicObject);
  $const_set(_Object, "Object",       _Object);
  $const_set(_Object, "Module",       Module);
  $const_set(_Object, "Class",        Class);
  $const_set(_Object, "Opal",         _Opal);
  $const_set(_Object, "Kernel",       Kernel);

  // Fix booted classes to have correct .class value
  BasicObject.$$class = Class;
  _Object.$$class     = Class;
  Module.$$class      = Class;
  Class.$$class       = Class;
  _Opal.$$class       = Module;
  Kernel.$$class      = Module;

  // Forward .toString() to #to_s
  $prop(_Object.$$prototype, 'toString', function() {
    var to_s = this.$to_s();
    if (to_s.$$is_string && typeof(to_s) === 'object') {
      // a string created using new String('string')
      return to_s.valueOf();
    } else {
      return to_s;
    }
  });

  // Make Kernel#require immediately available as it's needed to require all the
  // other corelib files.
  $prop(_Object.$$prototype, '$require', Opal.require);

  // Instantiate the main object
  Opal.top = new _Object();
  Opal.top.$to_s = Opal.top.$inspect = $return_val('main');
  Opal.top.$define_method = top_define_method;

  // Foward calls to define_method on the top object to Object
  function top_define_method() {
    var block = top_define_method.$$p;
    top_define_method.$$p = null;
    return Opal.send(_Object, 'define_method', arguments, block)
  };

  // Nil
  Opal.NilClass = $allocate_class('NilClass', Opal.Object);
  $const_set(_Object, 'NilClass', Opal.NilClass);
  nil = Opal.nil = new Opal.NilClass();
  nil.$$id = nil_id;
  nil.call = nil.apply = function() { $raise(Opal.LocalJumpError, 'no block given'); };
  nil.$$frozen = true;
  nil.$$comparable = false;
  Object.seal(nil);

  Opal.thrower = function(type) {
    var thrower = {
      $thrower_type: type,
      $throw: function(value, called_from_lambda) {
        if (value == null) value = nil;
        if (this.is_orphan && !called_from_lambda) {
          $raise(Opal.LocalJumpError, 'unexpected ' + type, value, type.$to_sym());
        }
        this.$v = value;
        throw this;
      },
      is_orphan: false
    }
    return thrower;
  };

  // Define a "$@" global variable, which would compute and return a backtrace on demand.
  Object.defineProperty($gvars, "@", {
    enumerable: true,
    configurable: true,
    get: function() {
      if ($truthy($gvars["!"])) return $gvars["!"].$backtrace();
      return nil;
    },
    set: function(bt) {
      if ($truthy($gvars["!"]))
        $gvars["!"].$set_backtrace(bt);
      else
        $raise(Opal.ArgumentError, "$! not set");
    }
  });

  Opal.t_eval_return = Opal.thrower("return");

  TypeError.$$super = Error;

  // If enable-file-source-embed compiler option is enabled, each module loaded will add its
  // sources to this object
  Opal.file_sources = {};
}).call(this);
Opal.loaded(["corelib/runtime.js"]);
Opal.modules["corelib/helpers"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $type_error = Opal.type_error, $coerce_to = Opal.coerce_to, $module = Opal.module, $defs = Opal.defs, $slice = Opal.slice, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $truthy = Opal.truthy, $to_s = Opal.to_s, $Opal = Opal.Opal, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('===,raise,respond_to?,nil?,__send__,<=>,class,coerce_to!,new,to_s,__id__');
  return (function($base) {
    var self = $module($base, 'Opal');

    
    
    $defs(self, '$bridge', function $$bridge(constructor, klass) {
      
      return Opal.bridge(constructor, klass);
    });
    $defs(self, '$coerce_to!', function $Opal_coerce_to$excl$1(object, type, method, $a) {
      var $post_args, args, coerced = nil;

      
      $post_args = $slice(arguments, 3);
      args = $post_args;
      coerced = $coerce_to(object, type, method, args);
      if (!$eqeqeq(type, coerced)) {
        $Kernel.$raise($type_error(object, type, method, coerced))
      };
      return coerced;
    }, -4);
    $defs(self, '$coerce_to?', function $Opal_coerce_to$ques$2(object, type, method, $a) {
      var $post_args, args, coerced = nil;

      
      $post_args = $slice(arguments, 3);
      args = $post_args;
      if (!$truthy(object['$respond_to?'](method))) {
        return nil
      };
      coerced = $coerce_to(object, type, method, args);
      if ($truthy(coerced['$nil?']())) {
        return nil
      };
      if (!$eqeqeq(type, coerced)) {
        $Kernel.$raise($type_error(object, type, method, coerced))
      };
      return coerced;
    }, -4);
    $defs(self, '$try_convert', function $$try_convert(object, type, method) {
      
      
      if ($eqeqeq(type, object)) {
        return object
      };
      if ($truthy(object['$respond_to?'](method))) {
        return object.$__send__(method)
      } else {
        return nil
      };
    });
    $defs(self, '$compare', function $$compare(a, b) {
      var compare = nil;

      
      compare = a['$<=>'](b);
      if ($truthy(compare === nil)) {
        $Kernel.$raise($$$('ArgumentError'), "comparison of " + $to_s(a.$class()) + " with " + $to_s(b.$class()) + " failed")
      };
      return compare;
    });
    $defs(self, '$destructure', function $$destructure(args) {
      
      
      if (args.length == 1) {
        return args[0];
      }
      else if (args.$$is_array) {
        return args;
      }
      else {
        var args_ary = new Array(args.length);
        for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

        return args_ary;
      }
    
    });
    $defs(self, '$respond_to?', function $Opal_respond_to$ques$3(obj, method, include_all) {
      
      
      if (include_all == null) include_all = false;
      
      if (obj == null || !obj.$$class) {
        return false;
      }
    ;
      return obj['$respond_to?'](method, include_all);
    }, -3);
    $defs(self, '$instance_variable_name!', function $Opal_instance_variable_name$excl$4(name) {
      
      
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      if (!$truthy(/^@[a-zA-Z_][a-zA-Z0-9_]*?$/.test(name))) {
        $Kernel.$raise($$$('NameError').$new("'" + $to_s(name) + "' is not allowed as an instance variable name", name))
      };
      return name;
    });
    $defs(self, '$class_variable_name!', function $Opal_class_variable_name$excl$5(name) {
      
      
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      if ($truthy(name.length < 3 || name.slice(0,2) !== '@@')) {
        $Kernel.$raise($$$('NameError').$new("`" + $to_s(name) + "' is not allowed as a class variable name", name))
      };
      return name;
    });
    $defs(self, '$const_name?', function $Opal_const_name$ques$6(const_name) {
      
      
      if (typeof const_name !== 'string') {
        (const_name = $Opal['$coerce_to!'](const_name, $$$('String'), "to_str"))
      }

      return const_name[0] === const_name[0].toUpperCase()
    
    });
    $defs(self, '$const_name!', function $Opal_const_name$excl$7(const_name) {
      var $a, self = this;

      
      if ($truthy((($a = $$$('::', 'String', 'skip_raise')) ? 'constant' : nil))) {
        const_name = $Opal['$coerce_to!'](const_name, $$$('String'), "to_str")
      };
      
      if (!const_name || const_name.length === 0 || const_name[0] != const_name[0].toUpperCase()) {
        self.$raise($$$('NameError'), "wrong constant name " + $to_s(const_name))
      }
    ;
      return const_name;
    });
    $defs(self, '$pristine', function $$pristine(owner_class, $a) {
      var $post_args, method_names;

      
      $post_args = $slice(arguments, 1);
      method_names = $post_args;
      
      var method_name, method;
      for (var i = method_names.length - 1; i >= 0; i--) {
        method_name = method_names[i];
        method = owner_class.$$prototype[Opal.jsid(method_name)];

        if (method && !method.$$stub) {
          method.$$pristine = true;
        }
      }
    ;
      return nil;
    }, -2);
    var inspect_stack = [];
    return $defs(self, '$inspect', function $$inspect(value) {
      var e = nil;

      
      ;
      var pushed = false;
      
      return (function() { try {
      try {
        
        
        if (value === null) {
          // JS null value
          return 'null';
        }
        else if (value === undefined) {
          // JS undefined value
          return 'undefined';
        }
        else if (typeof value.$$class === 'undefined') {
          // JS object / other value that is not bridged
          return Object.prototype.toString.apply(value);
        }
        else if (typeof value.$inspect !== 'function' || value.$inspect.$$stub) {
          // BasicObject and friends
          return "#<" + $to_s(value.$$class) + ":0x" + $to_s(value.$__id__().$to_s(16)) + ">"
        }
        else if (inspect_stack.indexOf(value.$__id__()) !== -1) {
          // inspect recursing inside inspect to find out about the
          // same object
          return "#<" + $to_s(value.$$class) + ":0x" + $to_s(value.$__id__().$to_s(16)) + ">"
        }
        else {
          // anything supporting Opal
          inspect_stack.push(value.$__id__());
          pushed = true;
          return value.$inspect();
        }
      ;
        return nil;
      } catch ($err) {
        if (Opal.rescue($err, [$$$('Exception')])) {(e = $err)
          try {
            return "#<" + $to_s(value.$$class) + ":0x" + $to_s(value.$__id__().$to_s(16)) + ">"
          } finally { Opal.pop_exception($err); }
        } else { throw $err; }
      }
      } finally {
        if (pushed) inspect_stack.pop()
      }; })();;
    }, -1);
  })('::')
};

Opal.modules["corelib/module"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $const_set = Opal.const_set, $Object = Opal.Object, $return_ivar = Opal.return_ivar, $assign_ivar = Opal.assign_ivar, $ivar = Opal.ivar, $deny_frozen_access = Opal.deny_frozen_access, $freeze = Opal.freeze, $prop = Opal.prop, $jsid = Opal.jsid, $each_ivar = Opal.each_ivar, $klass = Opal.klass, $Opal = Opal.Opal, $Kernel = Opal.Kernel, $to_s = Opal.to_s, $defs = Opal.defs, $send = Opal.send, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $Module = Opal.Module, $rb_lt = Opal.rb_lt, $rb_gt = Opal.rb_gt, $slice = Opal.slice, $to_a = Opal.to_a, $hash_new = Opal.hash_new, $return_val = Opal.return_val, $eqeq = Opal.eqeq, $not = Opal.not, $rb_le = Opal.rb_le, $range = Opal.range, $send2 = Opal.send2, $find_super = Opal.find_super, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('try_convert,raise,class,module_eval,to_proc,===,equal?,<,>,nil?,attr_reader,attr_writer,warn,attr_accessor,const_name?,class_variable_name!,pristine,const_name!,=~,new,inject,split,const_get,==,start_with?,!~,owner,!,<=,frozen?,append_features,included,name,cover?,size,merge,compile,proc,any?,prepend_features,prepended,to_s,__id__,constants,include?,copy_class_variables,copy_constants,copy_singleton_methods,class_exec,module_exec,inspect');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Module');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    function ensure_symbol_or_string(name) {
      if (name.$$is_string) {
        return name;
      };
      var converted_name = $Opal.$try_convert(name, $$$('String'), "to_str");
      if (converted_name.$$is_string) {
        return converted_name;
      } else if (converted_name === nil) {
        $Kernel.$raise($$$('TypeError'), $to_s(name) + " is not a symbol nor a string")
      } else {
        $Kernel.$raise($$$('TypeError'), "can't convert " + $to_s((name).$class()) + " to String (" + $to_s((name).$class()) + "#to_str gives " + $to_s((converted_name).$class()))
      }
    }
  ;
    $defs(self, '$allocate', function $$allocate() {
      var self = this;

      
      var module = Opal.allocate_module(nil, function(){});
      // Link the prototype of Module subclasses
      if (self !== Opal.Module) Object.setPrototypeOf(module, self.$$prototype);
      return module;
    
    });
    
    $def(self, '$initialize', function $$initialize() {
      var block = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      ;
      if ((block !== nil)) {
        return $send(self, 'module_eval', [], block.$to_proc())
      } else {
        return nil
      };
    });
    
    $def(self, '$===', function $Module_$eq_eq_eq$1(object) {
      var self = this;

      
      if ($truthy(object == null)) {
        return false
      };
      return Opal.is_a(object, self);;
    });
    
    $def(self, '$<', function $Module_$lt$2(other) {
      var self = this;

      
      if (!$eqeqeq($Module, other)) {
        $Kernel.$raise($$$('TypeError'), "compared with non class/module")
      };
      
      var working = self,
          ancestors,
          i, length;

      if (working === other) {
        return false;
      }

      for (i = 0, ancestors = Opal.ancestors(self), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === other) {
          return true;
        }
      }

      for (i = 0, ancestors = Opal.ancestors(other), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === self) {
          return false;
        }
      }

      return nil;
    ;
    });
    
    $def(self, '$<=', function $Module_$lt_eq$3(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self['$equal?'](other)))) {
        return $ret_or_1
      } else {
        return $rb_lt(self, other)
      }
    });
    
    $def(self, '$>', function $Module_$gt$4(other) {
      var self = this;

      
      if (!$eqeqeq($Module, other)) {
        $Kernel.$raise($$$('TypeError'), "compared with non class/module")
      };
      return $rb_lt(other, self);
    });
    
    $def(self, '$>=', function $Module_$gt_eq$5(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self['$equal?'](other)))) {
        return $ret_or_1
      } else {
        return $rb_gt(self, other)
      }
    });
    
    $def(self, '$<=>', function $Module_$lt_eq_gt$6(other) {
      var self = this, lt = nil;

      
      
      if (self === other) {
        return 0;
      }
    ;
      if (!$eqeqeq($Module, other)) {
        return nil
      };
      lt = $rb_lt(self, other);
      if ($truthy(lt['$nil?']())) {
        return nil
      };
      if ($truthy(lt)) {
        return -1
      } else {
        return 1
      };
    });
    
    $def(self, '$alias_method', function $$alias_method(newname, oldname) {
      var self = this;

      
      $deny_frozen_access(self);
      newname = $coerce_to(newname, $$$('String'), 'to_str');
      oldname = $coerce_to(oldname, $$$('String'), 'to_str');
      Opal.alias(self, newname, oldname);
      return self;
    });
    
    $def(self, '$alias_native', function $$alias_native(mid, jsid) {
      var self = this;

      
      if (jsid == null) jsid = mid;
      $deny_frozen_access(self);
      Opal.alias_native(self, mid, jsid);
      return self;
    }, -2);
    
    $def(self, '$ancestors', function $$ancestors() {
      var self = this;

      return Opal.ancestors(self);
    });
    
    $def(self, '$append_features', function $$append_features(includer) {
      var self = this;

      
      $deny_frozen_access(includer);
      Opal.append_features(self, includer);
      return self;
    });
    
    $def(self, '$attr_accessor', function $$attr_accessor($a) {
      var $post_args, names, self = this;

      
      $post_args = $slice(arguments);
      names = $post_args;
      $send(self, 'attr_reader', $to_a(names));
      return $send(self, 'attr_writer', $to_a(names));
    }, -1);
    
    $def(self, '$attr', function $$attr($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      if (args.length == 2 && (args[1] === true || args[1] === false)) {
        self.$warn("optional boolean argument is obsoleted", $hash_new("uplevel", 1))

        args[1] ? self.$attr_accessor(args[0]) : self.$attr_reader(args[0]);
        return nil;
      }
    ;
      return $send(self, 'attr_reader', $to_a(args));
    }, -1);
    
    $def(self, '$attr_reader', function $$attr_reader($a) {
      var $post_args, names, self = this;

      
      $post_args = $slice(arguments);
      names = $post_args;
      
      $deny_frozen_access(self);

      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = $jsid(name),
            ivar = $ivar(name);

        var body = $return_ivar(ivar);

        // initialize the instance variable as nil
        Opal.prop(proto, ivar, nil);

        body.$$parameters = [];
        body.$$arity = 0;

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, -1);
    
    $def(self, '$attr_writer', function $$attr_writer($a) {
      var $post_args, names, self = this;

      
      $post_args = $slice(arguments);
      names = $post_args;
      
      $deny_frozen_access(self);

      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = $jsid(name + '='),
            ivar = $ivar(name);

        var body = $assign_ivar(ivar)

        body.$$parameters = [['req']];
        body.$$arity = 1;

        // initialize the instance variable as nil
        Opal.prop(proto, ivar, nil);

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, -1);
    
    $def(self, '$autoload', function $$autoload(const$, path) {
      var self = this;

      
      $deny_frozen_access(self);

      if (!$$('Opal')['$const_name?'](const$)) {
        $Kernel.$raise($$$('NameError'), "autoload must be constant name: " + $to_s(const$))
      }

      if (path == "") {
        $Kernel.$raise($$$('ArgumentError'), "empty file name")
      }

      if (!self.$$const.hasOwnProperty(const$)) {
        if (!self.$$autoload) {
          self.$$autoload = {};
        }
        Opal.const_cache_version++;
        self.$$autoload[const$] = { path: path, loaded: false, required: false, success: false, exception: false };

        if (self.$const_added && !self.$const_added.$$pristine) {
          self.$const_added(const$);
        }
      }
      return nil;
    
    });
    
    $def(self, '$autoload?', function $Module_autoload$ques$7(const$) {
      var self = this;

      
      if (self.$$autoload && self.$$autoload[const$] && !self.$$autoload[const$].required && !self.$$autoload[const$].success) {
        return self.$$autoload[const$].path;
      }

      var ancestors = self.$ancestors();

      for (var i = 0, length = ancestors.length; i < length; i++) {
        if (ancestors[i].$$autoload && ancestors[i].$$autoload[const$] && !ancestors[i].$$autoload[const$].required && !ancestors[i].$$autoload[const$].success) {
          return ancestors[i].$$autoload[const$].path;
        }
      }
      return nil;
    
    });
    
    $def(self, '$class_variables', function $$class_variables() {
      var self = this;

      return Object.keys(Opal.class_variables(self));
    });
    
    $def(self, '$class_variable_get', function $$class_variable_get(name) {
      var self = this;

      
      name = $Opal['$class_variable_name!'](name);
      return Opal.class_variable_get(self, name, false);;
    });
    
    $def(self, '$class_variable_set', function $$class_variable_set(name, value) {
      var self = this;

      
      $deny_frozen_access(self);
      name = $Opal['$class_variable_name!'](name);
      return Opal.class_variable_set(self, name, value);;
    });
    
    $def(self, '$class_variable_defined?', function $Module_class_variable_defined$ques$8(name) {
      var self = this;

      
      name = $Opal['$class_variable_name!'](name);
      return Opal.class_variables(self).hasOwnProperty(name);;
    });
    
    $def(self, '$const_added', $return_val(nil));
    $Opal.$pristine(self, "const_added");
    
    $def(self, '$remove_class_variable', function $$remove_class_variable(name) {
      var self = this;

      
      $deny_frozen_access(self);
      name = $Opal['$class_variable_name!'](name);
      
      if (Opal.hasOwnProperty.call(self.$$cvars, name)) {
        var value = self.$$cvars[name];
        delete self.$$cvars[name];
        return value;
      } else {
        $Kernel.$raise($$$('NameError'), "cannot remove " + $to_s(name) + " for " + $to_s(self))
      }
    ;
    });
    
    $def(self, '$constants', function $$constants(inherit) {
      var self = this;

      
      if (inherit == null) inherit = true;
      return Opal.constants(self, inherit);;
    }, -1);
    $defs(self, '$constants', function $$constants(inherit) {
      var self = this;

      
      ;
      
      if (inherit == null) {
        var nesting = (self.$$nesting || []).concat($Object),
            constant, constants = {},
            i, ii;

        for(i = 0, ii = nesting.length; i < ii; i++) {
          for (constant in nesting[i].$$const) {
            constants[constant] = true;
          }
        }
        return Object.keys(constants);
      } else {
        return Opal.constants(self, inherit)
      }
    ;
    }, -1);
    $defs(self, '$nesting', function $$nesting() {
      var self = this;

      return self.$$nesting || [];
    });
    
    $def(self, '$const_defined?', function $Module_const_defined$ques$9(name, inherit) {
      var self = this;

      
      if (inherit == null) inherit = true;
      name = $$('Opal')['$const_name!'](name);
      if (!$truthy(name['$=~']($$$($Opal, 'CONST_NAME_REGEXP')))) {
        $Kernel.$raise($$$('NameError').$new("wrong constant name " + $to_s(name), name))
      };
      
      var module, modules = [self], module_constants, i, ii;

      // Add up ancestors if inherit is true
      if (inherit) {
        modules = modules.concat(Opal.ancestors(self));

        // Add Object's ancestors if it's a module – modules have no ancestors otherwise
        if (self.$$is_module) {
          modules = modules.concat([$Object]).concat(Opal.ancestors($Object));
        }
      }

      for (i = 0, ii = modules.length; i < ii; i++) {
        module = modules[i];
        if (module.$$const[name] != null) { return true; }
        if (
          module.$$autoload &&
          module.$$autoload[name] &&
          !module.$$autoload[name].required &&
          !module.$$autoload[name].success
        ) {
          return true;
        }
      }

      return false;
    ;
    }, -2);
    
    $def(self, '$const_get', function $$const_get(name, inherit) {
      var self = this;

      
      if (inherit == null) inherit = true;
      name = $$('Opal')['$const_name!'](name);
      
      if (name.indexOf('::') === 0 && name !== '::'){
        name = name.slice(2);
      }
    ;
      if ($truthy(name.indexOf('::') != -1 && name != '::')) {
        return $send(name.$split("::"), 'inject', [self], function $$10(o, c){
          
          if (o == null) o = nil;
          if (c == null) c = nil;
          return o.$const_get(c);})
      };
      if (!$truthy(name['$=~']($$$($Opal, 'CONST_NAME_REGEXP')))) {
        $Kernel.$raise($$$('NameError').$new("wrong constant name " + $to_s(name), name))
      };
      
      if (inherit) {
        return Opal.$$([self], name);
      } else {
        return Opal.const_get_local(self, name);
      }
    ;
    }, -2);
    
    $def(self, '$const_missing', function $$const_missing(name) {
      var self = this, full_const_name = nil;

      
      full_const_name = ($eqeq(self, $Object) ? (name) : ($to_s(self) + "::" + $to_s(name)));
      return $Kernel.$raise($$$('NameError').$new("uninitialized constant " + $to_s(full_const_name), name));
    });
    
    $def(self, '$const_set', function $$const_set(name, value) {
      var self = this;

      
      $deny_frozen_access(self);
      name = $Opal['$const_name!'](name);
      if (($truthy(name['$!~']($$$($Opal, 'CONST_NAME_REGEXP'))) || ($truthy(name['$start_with?']("::"))))) {
        $Kernel.$raise($$$('NameError').$new("wrong constant name " + $to_s(name), name))
      };
      $const_set(self, name, value);
      return value;
    });
    
    $def(self, '$public_constant', $return_val(nil));
    
    $def(self, '$define_method', function $$define_method(name, method) {
      var block = $$define_method.$$p || nil, self = this, $ret_or_1 = nil, owner = nil, message = nil;

      $$define_method.$$p = null;
      
      ;
      ;
      
      $deny_frozen_access(self);

      if (method === undefined && block === nil)
        $Kernel.$raise($$$('ArgumentError'), "tried to create a Proc object without a block")

      name = ensure_symbol_or_string(name);
    ;
      if ($truthy(method !== undefined)) {
        
        block = ($eqeqeq($$$('Proc'), ($ret_or_1 = method)) ? (method) : ($eqeqeq($$$('Method'), $ret_or_1) ? (method.$to_proc().$$unbound) : ($eqeqeq($$$('UnboundMethod'), $ret_or_1) ? (Opal.wrap_method_body(method.$$method)) : ($Kernel.$raise($$$('TypeError'), "wrong argument type " + $to_s(method.$class()) + " (expected Proc/Method/UnboundMethod)")))));
        if ($truthy(!method.$$is_proc)) {
          
          owner = method.$owner();
          if (($truthy(owner.$$is_class) && ($not($rb_le(self, owner))))) {
            
            message = ($truthy(owner.$$is_singleton) ? ("can't bind singleton method to a different class") : ("bind argument must be a subclass of " + $to_s(owner)));
            $Kernel.$raise($$$('TypeError'), message);
          };
        };
      };
      
      if (typeof(Proxy) !== 'undefined') {
        var meta = Object.create(null)

        block.$$proxy_target = block
        block = new Proxy(block, {
          apply: function(target, self, args) {
            var old_name = target.$$jsid, old_lambda = target.$$is_lambda;
            target.$$jsid = name;
            target.$$is_lambda = true;
            try {
              return target.apply(self, args);
            } catch(e) {
              if (e === target.$$brk || e === target.$$ret) return e.$v;
              throw e;
            } finally {
              target.$$jsid = old_name;
              target.$$is_lambda = old_lambda;
            }
          }
        })
      }

      block.$$jsid        = name;
      block.$$s           = null;
      block.$$def         = block;
      block.$$define_meth = true;

      return Opal.defn(self, $jsid(name), block);
    ;
    }, -2);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      
      if (!self.hasOwnProperty('$$base_module')) { $prop(self, '$$base_module', null); }

      return $freeze(self);
    ;
    });
    
    $def(self, '$remove_method', function $$remove_method($a) {
      var $post_args, names, self = this;

      
      $post_args = $slice(arguments);
      names = $post_args;
      
      for (var i = 0; i < names.length; i++) {
        var name = ensure_symbol_or_string(names[i]);
        $deny_frozen_access(self);

        Opal.rdef(self, "$" + name);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$singleton_class?', function $Module_singleton_class$ques$11() {
      var self = this;

      return !!self.$$is_singleton;
    });
    
    $def(self, '$include', function $$include($a) {
      var $post_args, mods, self = this;

      
      $post_args = $slice(arguments);
      mods = $post_args;
      
      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + $to_s((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(self);
        (mod).$included(self);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$included_modules', function $$included_modules() {
      var self = this;

      return Opal.included_modules(self);
    });
    
    $def(self, '$include?', function $Module_include$ques$12(mod) {
      var self = this;

      
      if (!mod.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + $to_s((mod).$class()) + " (expected Module)");
      }

      var i, ii, mod2, ancestors = Opal.ancestors(self);

      for (i = 0, ii = ancestors.length; i < ii; i++) {
        mod2 = ancestors[i];
        if (mod2 === mod && mod2 !== self) {
          return true;
        }
      }

      return false;
    
    });
    
    $def(self, '$instance_method', function $$instance_method(name) {
      var self = this;

      
      var meth = self.$$prototype[$jsid(name)];

      if (!meth || meth.$$stub) {
        $Kernel.$raise($$$('NameError').$new("undefined method `" + $to_s(name) + "' for class `" + $to_s(self.$name()) + "'", name));
      }

      return $$$('UnboundMethod').$new(self, meth.$$owner || self, meth, name);
    
    });
    
    $def(self, '$instance_methods', function $$instance_methods(include_super) {
      var self = this;

      
      if (include_super == null) include_super = true;
      
      if ($truthy(include_super)) {
        return Opal.instance_methods(self);
      } else {
        return Opal.own_instance_methods(self);
      }
    ;
    }, -1);
    
    $def(self, '$included', $return_val(nil));
    
    $def(self, '$extended', $return_val(nil));
    
    $def(self, '$extend_object', function $$extend_object(object) {
      
      
      $deny_frozen_access(object);
      return nil;
    });
    
    $def(self, '$method_added', function $$method_added($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$method_removed', function $$method_removed($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$method_undefined', function $$method_undefined($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$module_eval', function $$module_eval($a) {
      var block = $$module_eval.$$p || nil, $post_args, args, $b, self = this, string = nil, file = nil, _lineno = nil, default_eval_options = nil, $ret_or_1 = nil, compiling_options = nil, compiled = nil;

      $$module_eval.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      if (($truthy(block['$nil?']()) && ($truthy(!!Opal.compile)))) {
        
        if (!$truthy($range(1, 3, false)['$cover?'](args.$size()))) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat($to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash_new("file", ($truthy(($ret_or_1 = file)) ? ($ret_or_1) : ("(eval)")), "eval", true);
        compiling_options = (new Map([['arity_check', false]])).$merge(default_eval_options);
        compiled = $Opal.$compile(string, compiling_options);
        block = $send($Kernel, 'proc', [], function $$13(){var self = $$13.$$s == null ? this : $$13.$$s;

          return new Function("Opal,self", "return " + compiled)(Opal, self);}, {$$s: self});
      } else if ($truthy(args['$any?']())) {
        $Kernel.$raise($$$('ArgumentError'), $to_s("wrong number of arguments (" + $to_s(args.$size()) + " for 0)") + "\n\n  NOTE:If you want to enable passing a String argument please add \"require 'opal-parser'\" to your script\n")
      };
      
      var old = block.$$s,
          result;

      block.$$s = null;
      result = block.apply(self, [self]);
      block.$$s = old;

      return result;
    ;
    }, -1);
    
    $def(self, '$module_exec', function $$module_exec($a) {
      var block = $$module_exec.$$p || nil, $post_args, args, self = this;

      $$module_exec.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      
      if (block === nil) {
        $Kernel.$raise($$$('LocalJumpError'), "no block given")
      }

      var block_self = block.$$s, result;

      block.$$s = null;
      result = block.apply(self, args);
      block.$$s = block_self;

      return result;
    ;
    }, -1);
    
    $def(self, '$method_defined?', function $Module_method_defined$ques$14(method) {
      var self = this;

      
      var body = self.$$prototype[$jsid(method)];
      return (!!body) && !body.$$stub;
    
    });
    
    $def(self, '$module_function', function $$module_function($a) {
      var $post_args, methods, self = this;

      
      $post_args = $slice(arguments);
      methods = $post_args;
      
      $deny_frozen_access(self);

      if (methods.length === 0) {
        self.$$module_function = true;
        return nil;
      }
      else {
        for (var i = 0, length = methods.length; i < length; i++) {
          var meth = methods[i],
              id   = $jsid(meth),
              func = self.$$prototype[id];

          Opal.defs(self, id, func);
        }
        return methods.length === 1 ? methods[0] : methods;
      }

      return self;
    ;
    }, -1);
    
    $def(self, '$name', function $$name() {
      var self = this;

      
      if (self.$$full_name) {
        return self.$$full_name;
      }

      var result = [], base = self;

      while (base) {
        // Give up if any of the ancestors is unnamed
        if (base.$$name === nil || base.$$name == null) return nil;

        result.unshift(base.$$name);

        base = base.$$base_module;

        if (base === $Object) {
          break;
        }
      }

      if (result.length === 0) {
        return nil;
      }

      return self.$$full_name = result.join('::');
    
    });
    
    $def(self, '$prepend', function $$prepend($a) {
      var $post_args, mods, self = this;

      
      $post_args = $slice(arguments);
      mods = $post_args;
      
      if (mods.length === 0) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (given 0, expected 1+)")
      }

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + $to_s((mod).$class()) + " (expected Module)");
        }

        (mod).$prepend_features(self);
        (mod).$prepended(self);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$prepend_features', function $$prepend_features(prepender) {
      var self = this;

      
      
      $deny_frozen_access(prepender);

      if (!self.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + $to_s(self.$class()) + " (expected Module)");
      }

      Opal.prepend_features(self, prepender)
    ;
      return self;
    });
    
    $def(self, '$prepended', $return_val(nil));
    
    $def(self, '$remove_const', function $$remove_const(name) {
      var self = this;

      
      $deny_frozen_access(self);
      return Opal.const_remove(self, name);;
    });
    
    $def(self, '$to_s', function $$to_s() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = Opal.Module.$name.call(self)))) {
        return $ret_or_1
      } else {
        return "#<" + $to_s(self.$$is_module ? 'Module' : 'Class') + ":0x" + $to_s(self.$__id__().$to_s(16)) + ">"
      }
    });
    
    $def(self, '$undef_method', function $$undef_method($a) {
      var $post_args, names, self = this;

      
      $post_args = $slice(arguments);
      names = $post_args;
      
      for (var i = 0; i < names.length; i++) {
        var name = ensure_symbol_or_string(names[i]);
        $deny_frozen_access(self);

        Opal.udef(self, "$" + name);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$instance_variables', function $$instance_variables() {
      var self = this, consts = nil;

      
      consts = (Opal.Module.$$nesting = $nesting, self.$constants());
      
      var result = [];

      $each_ivar(self, function(name) {
        if (name !== 'constructor' && !consts['$include?'](name)) {
          result.push('@' + name);
        }
      });

      return result;
    ;
    });
    
    function copyInstanceMethods(from, to) {
      var i, method_names = Opal.own_instance_methods(from);
      for (i = 0; i < method_names.length; i++) {
        var name = method_names[i],
            jsid = $jsid(name),
            body = from.$$prototype[jsid],
            wrapped = Opal.wrap_method_body(body);

        wrapped.$$jsid = name;
        Opal.defn(to, jsid, wrapped);
      }
    }

    function copyIncludedModules(from, to) {
      var modules = from.$$own_included_modules;
      for (var i = modules.length - 1; i >= 0; i--) {
        Opal.append_features(modules[i], to);
      }
    }

    function copyPrependedModules(from, to) {
      var modules = from.$$own_prepended_modules;
      for (var i = modules.length - 1; i >= 0; i--) {
        Opal.prepend_features(modules[i], to);
      }
    }
  ;
    
    $def(self, '$initialize_copy', function $$initialize_copy(other) {
      var self = this;

      
      
      copyInstanceMethods(other, self);
      copyIncludedModules(other, self);
      copyPrependedModules(other, self);
      self.$$cloned_from = other.$$cloned_from.concat(other);
    ;
      self.$copy_class_variables(other);
      return self.$copy_constants(other);
    });
    
    $def(self, '$initialize_dup', function $$initialize_dup(other) {
      var $yield = $$initialize_dup.$$p || nil, self = this;

      $$initialize_dup.$$p = null;
      
      $send2(self, $find_super(self, 'initialize_dup', $$initialize_dup, false, true), 'initialize_dup', [other], $yield);
      return self.$copy_singleton_methods(other);
    });
    
    $def(self, '$copy_class_variables', function $$copy_class_variables(other) {
      var self = this;

      
      for (var name in other.$$cvars) {
        self.$$cvars[name] = other.$$cvars[name];
      }
    
    });
    
    $def(self, '$copy_constants', function $$copy_constants(other) {
      var self = this;

      
      var name, other_constants = other.$$const;

      for (name in other_constants) {
        $const_set(self, name, other_constants[name]);
      }
    
    });
    
    $def(self, '$refine', function $$refine(klass) {
      var block = $$refine.$$p || nil, $a, self = this, refinement_module = nil, m = nil, klass_id = nil;

      $$refine.$$p = null;
      
      ;
      $a = [self, nil, nil], (refinement_module = $a[0]), (m = $a[1]), (klass_id = $a[2]), $a;
      
      klass_id = Opal.id(klass);
      if (typeof self.$$refine_modules === "undefined") {
        self.$$refine_modules = Object.create(null);
      }
      if (typeof self.$$refine_modules[klass_id] === "undefined") {
        m = self.$$refine_modules[klass_id] = $$$('Refinement').$new();
      }
      else {
        m = self.$$refine_modules[klass_id];
      }
      m.refinement_module = refinement_module
      m.refined_class = klass
    ;
      $send(m, 'class_exec', [], block.$to_proc());
      return m;
    });
    
    $def(self, '$refinements', function $$refinements() {
      var self = this;

      
      var refine_modules = self.$$refine_modules, hash = (new Map());;
      if (typeof refine_modules === "undefined") return hash;
      for (var id in refine_modules) {
        hash['$[]='](refine_modules[id].refined_class, refine_modules[id]);
      }
      return hash;
    
    });
    
    $def(self, '$using', function $$using(mod) {
      
      return $Kernel.$raise("Module#using is not permitted in methods")
    });
    $alias(self, "class_eval", "module_eval");
    $alias(self, "class_exec", "module_exec");
    return $alias(self, "inspect", "to_s");
  })('::', null, $nesting);
  return (function($base, $super) {
    var self = $klass($base, $super, 'Refinement');

    var $proto = self.$$prototype;

    $proto.refinement_module = $proto.refined_class = nil;
    
    self.$attr_reader("refined_class");
    return $def(self, '$inspect', function $$inspect() {
      var $yield = $$inspect.$$p || nil, self = this;

      $$inspect.$$p = null;
      if ($truthy(self.refinement_module)) {
        return "#<refinement:" + $to_s(self.refined_class.$inspect()) + "@" + $to_s(self.refinement_module.$inspect()) + ">"
      } else {
        return $send2(self, $find_super(self, 'inspect', $$inspect, false, true), 'inspect', [], $yield)
      }
    });
  })('::', $Module);
};

Opal.modules["corelib/class"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $klass = Opal.klass, $send = Opal.send, $defs = Opal.defs, $def = Opal.def, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $eqeq = Opal.eqeq, $truthy = Opal.truthy, $to_s = Opal.to_s, $hash_new = Opal.hash_new, $rb_plus = Opal.rb_plus, $return_val = Opal.return_val, $slice = Opal.slice, $send2 = Opal.send2, $find_super = Opal.find_super, $Kernel = Opal.Kernel, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,class_eval,to_proc,==,nil?,raise,class,copy_instance_variables,copy_singleton_methods,initialize_clone,frozen?,freeze,initialize_dup,+,subclasses,flatten,map,allocate,name,to_s');
  
  self.$require("corelib/module");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Class');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$new', function $Class_new$1(superclass) {
      var block = $Class_new$1.$$p || nil;

      $Class_new$1.$$p = null;
      
      ;
      if (superclass == null) superclass = $$('Object');
      
      if (!superclass.$$is_class) {
        throw Opal.TypeError.$new("superclass must be a Class");
      }

      var klass = Opal.allocate_class(nil, superclass);
      superclass.$inherited(klass);
      ((block !== nil) ? ($send((klass), 'class_eval', [], block.$to_proc())) : nil)
      return klass;
    ;
    }, -1);
    
    $def(self, '$allocate', function $$allocate() {
      var self = this;

      
      var obj = new self.$$constructor();
      obj.$$id = Opal.uid();
      return obj;
    
    });
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this, copy = nil;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $hash_get($kwargs, "freeze");if (freeze == null) freeze = nil;
      if (!(($truthy(freeze['$nil?']()) || ($eqeq(freeze, true))) || ($eqeq(freeze, false)))) {
        self.$raise($$('ArgumentError'), "unexpected value for freeze: " + $to_s(freeze.$class()))
      };
      copy = Opal.allocate_class(nil, self.$$super);
      copy.$copy_instance_variables(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self, $hash_new("freeze", freeze));
      if (($eqeq(freeze, true) || (($truthy(freeze['$nil?']()) && ($truthy(self['$frozen?']())))))) {
        copy.$freeze()
      };
      return copy;
    }, -1);
    
    $def(self, '$dup', function $$dup() {
      var self = this, copy = nil;

      
      copy = Opal.allocate_class(nil, self.$$super);
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    });
    
    $def(self, '$descendants', function $$descendants() {
      var self = this;

      return $rb_plus(self.$subclasses(), $send(self.$subclasses(), 'map', [], "descendants".$to_proc()).$flatten())
    });
    
    $def(self, '$inherited', $return_val(nil));
    
    $def(self, '$new', function $Class_new$2($a) {
      var block = $Class_new$2.$$p || nil, $post_args, args, self = this;

      $Class_new$2.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      
      var object = self.$allocate();
      Opal.send(object, object.$initialize, args, block);
      return object;
    ;
    }, -1);
    
    $def(self, '$subclasses', function $$subclasses() {
      var self = this;

      
      if (typeof WeakRef !== 'undefined') {
        var i, subclass, out = [];
        for (i = 0; i < self.$$subclasses.length; i++) {
          subclass = self.$$subclasses[i].deref();
          if (subclass !== undefined) {
            out.push(subclass);
          }
        }
        return out;
      }
      else {
        return self.$$subclasses;
      }
    
    });
    
    $def(self, '$superclass', function $$superclass() {
      var self = this;

      return self.$$super || nil;
    });
    
    $def(self, '$to_s', function $$to_s() {
      var $yield = $$to_s.$$p || nil, self = this;

      $$to_s.$$p = null;
      
      var singleton_of = self.$$singleton_of;

      if (singleton_of && singleton_of.$$is_a_module) {
        return "#<Class:" + $to_s((singleton_of).$name()) + ">";
      }
      else if (singleton_of) {
        // a singleton class created from an object
        return "#<Class:#<" + $to_s((singleton_of.$$class).$name()) + ":0x" + $to_s((Opal.id(singleton_of)).$to_s(16)) + ">>";
      }

      return $send2(self, $find_super(self, 'to_s', $$to_s, false, true), 'to_s', [], null);
    
    });
    
    $def(self, '$attached_object', function $$attached_object() {
      var self = this;

      
      if (self.$$singleton_of != null) {
        return self.$$singleton_of;
      }
      else {
        $Kernel.$raise($$$('TypeError'), "`" + $to_s(self) + "' is not a singleton class")
      }
    
    });
    return $alias(self, "inspect", "to_s");
  })('::', null, $nesting);
};

Opal.modules["corelib/basic_object"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $klass = Opal.klass, $slice = Opal.slice, $def = Opal.def, $alias = Opal.alias, $to_s = Opal.to_s, $return_val = Opal.return_val, $Opal = Opal.Opal, $truthy = Opal.truthy, $range = Opal.range, $Kernel = Opal.Kernel, $to_a = Opal.to_a, $hash_new = Opal.hash_new, $send = Opal.send, $eqeq = Opal.eqeq, $rb_ge = Opal.rb_ge, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('==,raise,inspect,pristine,!,nil?,cover?,size,merge,compile,proc,[],first,>=,length,instance_variable_get,any?,new,caller');
  return (function($base, $super) {
    var self = $klass($base, $super, 'BasicObject');

    
    
    
    $def(self, '$initialize', function $$initialize($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$==', function $BasicObject_$eq_eq$1(other) {
      var self = this;

      return self === other;
    });
    
    $def(self, '$eql?', function $BasicObject_eql$ques$2(other) {
      var self = this;

      return self['$=='](other)
    });
    $alias(self, "equal?", "==");
    
    $def(self, '$__id__', function $$__id__() {
      var self = this;

      
      if (self.$$id != null) {
        return self.$$id;
      }
      Opal.prop(self, '$$id', Opal.uid());
      return self.$$id;
    
    });
    
    $def(self, '$__send__', function $$__send__(symbol, $a) {
      var block = $$__send__.$$p || nil, $post_args, args, self = this;

      $$__send__.$$p = null;
      
      ;
      $post_args = $slice(arguments, 1);
      args = $post_args;
      
      if (!symbol.$$is_string) {
        self.$raise($$$('TypeError'), $to_s(self.$inspect()) + " is not a symbol nor a string")
      }

      var func = self[Opal.jsid(symbol)];

      if (func) {
        if (block !== nil) {
          func.$$p = block;
        }

        return func.apply(self, args);
      }

      if (block !== nil) {
        self.$method_missing.$$p = block;
      }

      return self.$method_missing.apply(self, [symbol].concat(args));
    ;
    }, -2);
    
    $def(self, '$!', $return_val(false));
    $Opal.$pristine("!");
    
    $def(self, '$!=', function $BasicObject_$not_eq$3(other) {
      var self = this;

      return self['$=='](other)['$!']()
    });
    
    $def(self, '$instance_eval', function $$instance_eval($a) {
      var block = $$instance_eval.$$p || nil, $post_args, args, $b, self = this, string = nil, file = nil, _lineno = nil, default_eval_options = nil, $ret_or_1 = nil, compiling_options = nil, compiled = nil;

      $$instance_eval.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      if (($truthy(block['$nil?']()) && ($truthy(!!Opal.compile)))) {
        
        if (!$truthy($range(1, 3, false)['$cover?'](args.$size()))) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat($to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash_new("file", ($truthy(($ret_or_1 = file)) ? ($ret_or_1) : ("(eval)")), "eval", true);
        compiling_options = (new Map([['arity_check', false]])).$merge(default_eval_options);
        compiled = $Opal.$compile(string, compiling_options);
        block = $send($Kernel, 'proc', [], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

          return new Function("Opal,self", "return " + compiled)(Opal, self);}, {$$s: self});
      } else if ((($truthy(block['$nil?']()) && ($truthy($rb_ge(args.$length(), 1)))) && ($eqeq(args.$first()['$[]'](0), "@")))) {
        return self.$instance_variable_get(args.$first())
      } else if ($truthy(args['$any?']())) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + $to_s(args.$size()) + " for 0)")
      };
      
      var old = block.$$s,
          result;

      block.$$s = null;

      // Need to pass $$eval so that method definitions know if this is
      // being done on a class/module. Cannot be compiler driven since
      // send(:instance_eval) needs to work.
      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.call(self, self);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.call(self, self);
      }

      block.$$s = old;

      return result;
    ;
    }, -1);
    
    $def(self, '$instance_exec', function $$instance_exec($a) {
      var block = $$instance_exec.$$p || nil, $post_args, args, self = this;

      $$instance_exec.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      if (!$truthy(block)) {
        $Kernel.$raise($$$('ArgumentError'), "no block given")
      };
      
      var block_self = block.$$s,
          result;

      block.$$s = null;

      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.apply(self, args);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.apply(self, args);
      }

      block.$$s = block_self;

      return result;
    ;
    }, -1);
    
    $def(self, '$singleton_method_added', function $$singleton_method_added($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$singleton_method_removed', function $$singleton_method_removed($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$singleton_method_undefined', function $$singleton_method_undefined($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$method_missing', function $$method_missing(symbol, $a) {
      var block = $$method_missing.$$p || nil, $post_args, args, self = this, inspect_result = nil;

      $$method_missing.$$p = null;
      
      ;
      $post_args = $slice(arguments, 1);
      args = $post_args;
      inspect_result = $Opal.$inspect(self);
      return $Kernel.$raise($$$('NoMethodError').$new("undefined method `" + $to_s(symbol) + "' for " + $to_s(inspect_result), symbol, args), nil, $Kernel.$caller(1));
    }, -2);
    $Opal.$pristine(self, "method_missing");
    return $def(self, '$respond_to_missing?', function $BasicObject_respond_to_missing$ques$5(method_name, include_all) {
      
      
      if (include_all == null) include_all = false;
      return false;
    }, -2);
  })('::', null)
};

Opal.modules["corelib/kernel"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $Opal = Opal.Opal, $deny_frozen_access = Opal.deny_frozen_access, $freeze = Opal.freeze, $freeze_props = Opal.freeze_props, $jsid = Opal.jsid, $each_ivar = Opal.each_ivar, $slice = Opal.slice, $module = Opal.module, $return_val = Opal.return_val, $def = Opal.def, $Kernel = Opal.Kernel, $to_s = Opal.to_s, $gvars = Opal.gvars, $send = Opal.send, $to_a = Opal.to_a, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $eqeq = Opal.eqeq, $hash_new = Opal.hash_new, $rb_plus = Opal.rb_plus, $extract_kwargs = Opal.extract_kwargs, $eqeqeq = Opal.eqeqeq, $return_self = Opal.return_self, $rb_le = Opal.rb_le, $rb_lt = Opal.rb_lt, $Object = Opal.Object, $alias = Opal.alias, $klass = Opal.klass, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('!,=~,==,object_id,new,class,raise,coerce_to?,<<,map,caller,nil?,allocate,copy_instance_variables,copy_singleton_methods,initialize_clone,frozen?,freeze,initialize_copy,define_method,singleton_class,to_proc,initialize_dup,for,empty?,pop,call,append_features,extend_object,extended,gets,__id__,include?,each,instance_variables,instance_variable_get,inspect,+,to_s,instance_variable_name!,respond_to?,to_int,to_i,Integer,coerce_to!,===,enum_for,result,shift,write,format,puts,<=,length,[],print,readline,<,first,split,to_str,exception,rand,respond_to_missing?,pristine,try_convert!,expand_path,join,start_with?,new_seed,srand,tag,value,open,is_a?,__send__,yield_self,include');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$=~', $return_val(false));
    
    $def(self, '$!~', function $Kernel_$excl_tilde$1(obj) {
      var self = this;

      return self['$=~'](obj)['$!']()
    });
    
    $def(self, '$===', function $Kernel_$eq_eq_eq$2(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.$object_id()['$=='](other.$object_id())))) {
        return $ret_or_1
      } else {
        return self['$=='](other)
      }
    });
    
    $def(self, '$<=>', function $Kernel_$lt_eq_gt$3(other) {
      var self = this;

      
      // set guard for infinite recursion
      self.$$comparable = true;

      var x = self['$=='](other);

      if (x && x !== nil) {
        return 0;
      }

      return nil;
    
    });
    
    $def(self, '$method', function $$method(name) {
      var self = this;

      
      var meth = self[$jsid(name)];

      if (meth && !meth.$$stub) {
        return $$$('Method').$new(self, meth.$$owner || self.$class(), meth, name);
      }

      var respond_to_missing = self['$respond_to_missing?'];
      if (respond_to_missing.$$pristine || !respond_to_missing.call(self, name, true)) {
        $Kernel.$raise($$$('NameError').$new("undefined method `" + $to_s(name) + "' for class `" + $to_s(self.$class()) + "'", name));
      }

      meth = function wrapper() {
        var method_missing = self.$method_missing;
        if (method_missing == null) {
          $Kernel.$raise($$$('NameError').$new("undefined method `" + $to_s(name) + "' for class `" + $to_s(self.$class()) + "'", name));
        }
        method_missing.$$p = wrapper.$$p;
        return method_missing.apply(self, [name].concat($slice(arguments)));
      };
      meth.$$parameters = [['rest']]
      meth.$$arity = -1;
      return $$$('Method').$new(self, self.$class(), meth, name);
    
    });
    
    $def(self, '$methods', function $$methods(all) {
      var self = this;

      
      if (all == null) all = true;
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.own_methods(self);
      }
    ;
    }, -1);
    
    $def(self, '$public_methods', function $$public_methods(all) {
      var self = this;

      
      if (all == null) all = true;
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.receiver_methods(self);
      }
    ;
    }, -1);
    
    $def(self, '$Array', function $$Array(object) {
      
      
      var coerced;

      if (object === nil) {
        return [];
      }

      if (object.$$is_array) {
        return object;
      }

      coerced = $Opal['$coerce_to?'](object, $$$('Array'), "to_ary");
      if (coerced !== nil) { return coerced; }

      coerced = $Opal['$coerce_to?'](object, $$$('Array'), "to_a");
      if (coerced !== nil) { return coerced; }

      return [object];
    
    });
    
    $def(self, '$at_exit', function $$at_exit() {
      var block = $$at_exit.$$p || nil, $ret_or_1 = nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      $$at_exit.$$p = null;
      
      ;
      $gvars.__at_exit__ = ($truthy(($ret_or_1 = $gvars.__at_exit__)) ? ($ret_or_1) : ([]));
      $gvars.__at_exit__['$<<'](block);
      return block;
    });
    
    $def(self, '$caller', function $$caller(start, length) {
      
      
      if (start == null) start = 1;
      if (length == null) length = nil;
      
      var stack, result;

      stack = new Error().$backtrace();
      result = [];

      for (var i = start + 1, ii = stack.length; i < ii; i++) {
        if (!stack[i].match(/runtime\.js/)) {
          result.push(stack[i]);
        }
      }
      if (length != nil) result = result.slice(0, length);
      return result;
    ;
    }, -1);
    
    $def(self, '$caller_locations', function $$caller_locations($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return $send($send(self, 'caller', $to_a(args)), 'map', [], function $$4(loc){
        
        if (loc == null) loc = nil;
        return $$$($$$($$$('Thread'), 'Backtrace'), 'Location').$new(loc);});
    }, -1);
    
    $def(self, '$class', function $Kernel_class$5() {
      var self = this;

      return self.$$class;
    });
    
    $def(self, '$copy_instance_variables', function $$copy_instance_variables(other) {
      var self = this;

      
      var keys = Object.keys(other), i, ii, name;
      for (i = 0, ii = keys.length; i < ii; i++) {
        name = keys[i];
        if (name.charAt(0) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    });
    
    $def(self, '$copy_singleton_methods', function $$copy_singleton_methods(other) {
      var self = this;

      
      var i, name, names, length;

      if (other.hasOwnProperty('$$meta') && other.$$meta !== null) {
        var other_singleton_class = Opal.get_singleton_class(other);
        var self_singleton_class = Opal.get_singleton_class(self);
        names = Object.getOwnPropertyNames(other_singleton_class.$$prototype);

        for (i = 0, length = names.length; i < length; i++) {
          name = names[i];
          if (Opal.is_method(name)) {
            self_singleton_class.$$prototype[name] = other_singleton_class.$$prototype[name];
          }
        }

        self_singleton_class.$$const = Object.assign({}, other_singleton_class.$$const);
        Object.setPrototypeOf(
          self_singleton_class.$$prototype,
          Object.getPrototypeOf(other_singleton_class.$$prototype)
        );
      }

      for (i = 0, names = Object.getOwnPropertyNames(other), length = names.length; i < length; i++) {
        name = names[i];
        if (name.charAt(0) === '$' && name.charAt(1) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    });
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this, copy = nil;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $hash_get($kwargs, "freeze");if (freeze == null) freeze = nil;
      if (!(($truthy(freeze['$nil?']()) || ($eqeq(freeze, true))) || ($eqeq(freeze, false)))) {
        self.$raise($$('ArgumentError'), "unexpected value for freeze: " + $to_s(freeze.$class()))
      };
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self, $hash_new("freeze", freeze));
      if (($eqeq(freeze, true) || (($truthy(freeze['$nil?']()) && ($truthy(self['$frozen?']())))))) {
        copy.$freeze()
      };
      return copy;
    }, -1);
    
    $def(self, '$initialize_clone', function $$initialize_clone(other, $kwargs) {
      var freeze, self = this;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $hash_get($kwargs, "freeze");if (freeze == null) freeze = nil;
      self.$initialize_copy(other);
      return self;
    }, -2);
    
    $def(self, '$define_singleton_method', function $$define_singleton_method(name, method) {
      var block = $$define_singleton_method.$$p || nil, self = this;

      $$define_singleton_method.$$p = null;
      
      ;
      ;
      return $send(self.$singleton_class(), 'define_method', [name, method], block.$to_proc());
    }, -2);
    
    $def(self, '$dup', function $$dup() {
      var self = this, copy = nil;

      
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    });
    
    $def(self, '$initialize_dup', function $$initialize_dup(other) {
      var self = this;

      return self.$initialize_copy(other)
    });
    
    $def(self, '$enum_for', function $$enum_for($a, $b) {
      var block = $$enum_for.$$p || nil, $post_args, method, args, self = this;

      $$enum_for.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      
      if ($post_args.length > 0) method = $post_args.shift();if (method == null) method = "each";
      args = $post_args;
      return $send($$$('Enumerator'), 'for', [self, method].concat($to_a(args)), block.$to_proc());
    }, -1);
    
    $def(self, '$equal?', function $Kernel_equal$ques$6(other) {
      var self = this;

      return self === other;
    });
    
    $def(self, '$exit', function $$exit(status) {
      var $ret_or_1 = nil, block = nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      
      if (status == null) status = true;
      $gvars.__at_exit__ = ($truthy(($ret_or_1 = $gvars.__at_exit__)) ? ($ret_or_1) : ([]));
      while (!($truthy($gvars.__at_exit__['$empty?']()))) {
      
        block = $gvars.__at_exit__.$pop();
        block.$call();
      };
      
      if (status.$$is_boolean) {
        status = status ? 0 : 1;
      } else {
        status = $coerce_to(status, $$$('Integer'), 'to_int')
      }

      Opal.exit(status);
    ;
      return nil;
    }, -1);
    
    $def(self, '$extend', function $$extend($a) {
      var $post_args, mods, self = this;

      
      $post_args = $slice(arguments);
      mods = $post_args;
      
      if (mods.length == 0) {
        self.$raise($$$('ArgumentError'), "wrong number of arguments (given 0, expected 1+)")
      }

      $deny_frozen_access(self);

      var singleton = self.$singleton_class();

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + $to_s((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(singleton);
        (mod).$extend_object(self);
        (mod).$extended(self);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      
      if (typeof(self) === "object") {
        $freeze_props(self);
        return $freeze(self);
      }
      return self;
    ;
    });
    
    $def(self, '$frozen?', function $Kernel_frozen$ques$7() {
      var self = this;

      
      switch (typeof(self)) {
      case "string":
      case "symbol":
      case "number":
      case "boolean":
        return true;
      case "object":
        return (self.$$frozen || false);
      default:
        return false;
      }
    
    });
    
    $def(self, '$gets', function $$gets($a) {
      var $post_args, args;
      if ($gvars.stdin == null) $gvars.stdin = nil;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return $send($gvars.stdin, 'gets', $to_a(args));
    }, -1);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return self.$__id__()
    });
    
    $def(self, '$initialize_copy', $return_val(nil));
    var inspect_stack = [];
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, ivs = nil, id = nil, pushed = nil, e = nil;

      return (function() { try {
      try {
        
        ivs = "";
        id = self.$__id__();
        if ($truthy((inspect_stack)['$include?'](id))) {
          ivs = " ..."
        } else {
          
          (inspect_stack)['$<<'](id);
          pushed = true;
          $send(self.$instance_variables(), 'each', [], function $$8(i){var self = $$8.$$s == null ? this : $$8.$$s, ivar = nil, inspect = nil;

            
            if (i == null) i = nil;
            ivar = self.$instance_variable_get(i);
            inspect = $$('Opal').$inspect(ivar);
            return (ivs = $rb_plus(ivs, " " + $to_s(i) + "=" + $to_s(inspect)));}, {$$s: self});
        };
        return "#<" + $to_s(self.$class()) + ":0x" + $to_s(id.$to_s(16)) + $to_s(ivs) + ">";
      } catch ($err) {
        if (Opal.rescue($err, [$$('StandardError')])) {(e = $err)
          try {
            return "#<" + $to_s(self.$class()) + ":0x" + $to_s(id.$to_s(16)) + ">"
          } finally { Opal.pop_exception($err); }
        } else { throw $err; }
      }
      } finally {
        ($truthy(pushed) ? ((inspect_stack).$pop()) : nil)
      }; })()
    });
    
    $def(self, '$instance_of?', function $Kernel_instance_of$ques$9(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "class or module required");
      }

      return self.$$class === klass;
    
    });
    
    $def(self, '$instance_variable_defined?', function $Kernel_instance_variable_defined$ques$10(name) {
      var self = this;

      
      name = $Opal['$instance_variable_name!'](name);
      return Opal.hasOwnProperty.call(self, name.substr(1));;
    });
    
    $def(self, '$instance_variable_get', function $$instance_variable_get(name) {
      var self = this;

      
      name = $Opal['$instance_variable_name!'](name);
      
      var ivar = self[Opal.ivar(name.substr(1))];

      return ivar == null ? nil : ivar;
    ;
    });
    
    $def(self, '$instance_variable_set', function $$instance_variable_set(name, value) {
      var self = this;

      
      $deny_frozen_access(self);
      name = $Opal['$instance_variable_name!'](name);
      return self[Opal.ivar(name.substr(1))] = value;;
    });
    
    $def(self, '$remove_instance_variable', function $$remove_instance_variable(name) {
      var self = this;

      
      name = $Opal['$instance_variable_name!'](name);
      
      var key = Opal.ivar(name.substr(1)),
          val;
      if (self.hasOwnProperty(key)) {
        val = self[key];
        delete self[key];
        return val;
      }
    ;
      return $Kernel.$raise($$$('NameError'), "instance variable " + $to_s(name) + " not defined");
    });
    
    $def(self, '$instance_variables', function $$instance_variables() {
      var self = this;

      
      var result = [], name;

      $each_ivar(self, function(name) {
        if (name[name.length-1] === '$') {
          name = name.slice(0, name.length - 1);
        }
        result.push('@' + name);
      });

      return result;
    
    });
    
    $def(self, '$Integer', function $$Integer(value, $a, $b) {
      var $post_args, $kwargs, base, exception;

      
      $post_args = $slice(arguments, 1);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      
      if ($post_args.length > 0) base = $post_args.shift();;
      
      exception = $hash_get($kwargs, "exception");if (exception == null) exception = true;
      
      var i, str, base_digits;

      exception = $truthy(exception);

      if (!value.$$is_string) {
        if (base !== undefined) {
          if (exception) {
            $Kernel.$raise($$$('ArgumentError'), "base specified for non string value")
          } else {
            return nil;
          }
        }
        if (value === nil) {
          if (exception) {
            $Kernel.$raise($$$('TypeError'), "can't convert nil into Integer")
          } else {
            return nil;
          }
        }
        if (value.$$is_number) {
          if (value === Infinity || value === -Infinity || isNaN(value)) {
            if (exception) {
              $Kernel.$raise($$$('FloatDomainError'), value)
            } else {
              return nil;
            }
          }
          return Math.floor(value);
        }
        if (value['$respond_to?']("to_int")) {
          i = value.$to_int();
          if (Opal.is_a(i, $$$('Integer'))) {
            return i;
          }
        }
        if (value['$respond_to?']("to_i")) {
          i = value.$to_i();
          if (Opal.is_a(i, $$$('Integer'))) {
            return i;
          }
        }

        if (exception) {
          $Kernel.$raise($$$('TypeError'), "can't convert " + $to_s(value.$class()) + " into Integer")
        } else {
          return nil;
        }
      }

      if (value === "0") {
        return 0;
      }

      if (base === undefined) {
        base = 0;
      } else {
        base = $coerce_to(base, $$$('Integer'), 'to_int');
        if (base === 1 || base < 0 || base > 36) {
          if (exception) {
            $Kernel.$raise($$$('ArgumentError'), "invalid radix " + $to_s(base))
          } else {
            return nil;
          }
        }
      }

      str = value.toLowerCase();

      str = str.replace(/(\d)_(?=\d)/g, '$1');

      str = str.replace(/^(\s*[+-]?)(0[bodx]?)/, function (_, head, flag) {
        switch (flag) {
        case '0b':
          if (base === 0 || base === 2) {
            base = 2;
            return head;
          }
          // no-break
        case '0':
        case '0o':
          if (base === 0 || base === 8) {
            base = 8;
            return head;
          }
          // no-break
        case '0d':
          if (base === 0 || base === 10) {
            base = 10;
            return head;
          }
          // no-break
        case '0x':
          if (base === 0 || base === 16) {
            base = 16;
            return head;
          }
          // no-break
        }
        if (exception) {
          $Kernel.$raise($$$('ArgumentError'), "invalid value for Integer(): \"" + $to_s(value) + "\"")
        } else {
          return nil;
        }
      });

      base = (base === 0 ? 10 : base);

      base_digits = '0-' + (base <= 10 ? base - 1 : '9a-' + String.fromCharCode(97 + (base - 11)));

      if (!(new RegExp('^\\s*[+-]?[' + base_digits + ']+\\s*$')).test(str)) {
        if (exception) {
          $Kernel.$raise($$$('ArgumentError'), "invalid value for Integer(): \"" + $to_s(value) + "\"")
        } else {
          return nil;
        }
      }

      i = parseInt(str, base);

      if (isNaN(i)) {
        if (exception) {
          $Kernel.$raise($$$('ArgumentError'), "invalid value for Integer(): \"" + $to_s(value) + "\"")
        } else {
          return nil;
        }
      }

      return i;
    ;
    }, -2);
    
    $def(self, '$Float', function $$Float(value, $kwargs) {
      var exception;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      exception = $hash_get($kwargs, "exception");if (exception == null) exception = true;
      
      var str;

      exception = $truthy(exception);

      if (value === nil) {
        if (exception) {
          $Kernel.$raise($$$('TypeError'), "can't convert nil into Float")
        } else {
          return nil;
        }
      }

      if (value.$$is_string) {
        str = value.toString();

        str = str.replace(/(\d)_(?=\d)/g, '$1');

        //Special case for hex strings only:
        if (/^\s*[-+]?0[xX][0-9a-fA-F]+\s*$/.test(str)) {
          return $Kernel.$Integer(str);
        }

        if (!/^\s*[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?\s*$/.test(str)) {
          if (exception) {
            $Kernel.$raise($$$('ArgumentError'), "invalid value for Float(): \"" + $to_s(value) + "\"")
          } else {
            return nil;
          }
        }

        return parseFloat(str);
      }

      if (exception) {
        return $Opal['$coerce_to!'](value, $$$('Float'), "to_f");
      } else {
        return $coerce_to(value, $$$('Float'), 'to_f');
      }
    ;
    }, -2);
    
    $def(self, '$Hash', function $$Hash(arg) {
      
      
      if (($truthy(arg['$nil?']()) || ($eqeq(arg, [])))) {
        return (new Map())
      };
      if ($eqeqeq($$$('Hash'), arg)) {
        return arg
      };
      return $Opal['$coerce_to!'](arg, $$$('Hash'), "to_hash");
    });
    
    $def(self, '$is_a?', function $Kernel_is_a$ques$11(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "class or module required");
      }

      return Opal.is_a(self, klass);
    
    });
    
    $def(self, '$itself', $return_self);
    
    $def(self, '$lambda', function $$lambda() {
      var block = $$lambda.$$p || nil;

      $$lambda.$$p = null;
      
      ;
      return Opal.lambda(block);;
    });
    
    $def(self, '$load', function $$load(file) {
      
      
      file = $Opal['$coerce_to!'](file, $$$('String'), "to_str");
      return Opal.load(file);
    });
    
    $def(self, '$loop', function $$loop() {
      var $yield = $$loop.$$p || nil, self = this, e = nil;

      $$loop.$$p = null;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["loop"], function $$12(){
          return $$$($$$('Float'), 'INFINITY')})
      };
      while ($truthy(true)) {
      
        try {
          Opal.yieldX($yield, [])
        } catch ($err) {
          if (Opal.rescue($err, [$$$('StopIteration')])) {(e = $err)
            try {
              return e.$result()
            } finally { Opal.pop_exception($err); }
          } else { throw $err; }
        };
      };
      return self;
    });
    
    $def(self, '$nil?', $return_val(false));
    
    $def(self, '$printf', function $$printf($a) {
      var $post_args, args, self = this, io = nil;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      $post_args = $slice(arguments);
      args = $post_args;
      if ($truthy(args['$empty?']())) {
        return nil
      };
      io = ($truthy(args[0].$$is_string) ? ($gvars.stdout) : (args.$shift()));
      io.$write($send(self, 'format', $to_a(args)));
      return nil;
    }, -1);
    
    $def(self, '$proc', function $$proc() {
      var block = $$proc.$$p || nil;

      $$proc.$$p = null;
      
      ;
      if (!$truthy(block)) {
        $Kernel.$raise($$$('ArgumentError'), "tried to create Proc object without a block")
      };
      block.$$is_lambda = false;
      return block;
    });
    
    $def(self, '$puts', function $$puts($a) {
      var $post_args, strs;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      $post_args = $slice(arguments);
      strs = $post_args;
      return $send($gvars.stdout, 'puts', $to_a(strs));
    }, -1);
    
    $def(self, '$p', function $$p($a) {
      var $post_args, args;

      
      $post_args = $slice(arguments);
      args = $post_args;
      $send(args, 'each', [], function $$13(obj){        if ($gvars.stdout == null) $gvars.stdout = nil;

        
        if (obj == null) obj = nil;
        return $gvars.stdout.$puts(obj.$inspect());});
      if ($truthy($rb_le(args.$length(), 1))) {
        return args['$[]'](0)
      } else {
        return args
      };
    }, -1);
    
    $def(self, '$print', function $$print($a) {
      var $post_args, strs;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      $post_args = $slice(arguments);
      strs = $post_args;
      return $send($gvars.stdout, 'print', $to_a(strs));
    }, -1);
    
    $def(self, '$readline', function $$readline($a) {
      var $post_args, args;
      if ($gvars.stdin == null) $gvars.stdin = nil;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return $send($gvars.stdin, 'readline', $to_a(args));
    }, -1);
    
    $def(self, '$warn', function $$warn($a, $b) {
      var $post_args, $kwargs, strs, uplevel, $c, $d, self = this, location = nil;
      if ($gvars.VERBOSE == null) $gvars.VERBOSE = nil;
      if ($gvars.stderr == null) $gvars.stderr = nil;

      
      $post_args = $slice(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      strs = $post_args;
      
      uplevel = $hash_get($kwargs, "uplevel");if (uplevel == null) uplevel = nil;
      if ($truthy(uplevel)) {
        
        uplevel = $Opal['$coerce_to!'](uplevel, $$$('Integer'), "to_str");
        if ($truthy($rb_lt(uplevel, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "negative level (" + $to_s(uplevel) + ")")
        };
        location = ($c = ($d = self.$caller($rb_plus(uplevel, 1), 1).$first(), ($d === nil || $d == null) ? nil : $d.$split(":in `")), ($c === nil || $c == null) ? nil : $c.$first());
        if ($truthy(location)) {
          location = $to_s(location) + ": "
        };
        strs = $send(strs, 'map', [], function $$14(s){
          
          if (s == null) s = nil;
          return $to_s(location) + "warning: " + $to_s(s);});
      };
      if (($truthy($gvars.VERBOSE['$nil?']()) || ($truthy(strs['$empty?']())))) {
        return nil
      } else {
        return $send($gvars.stderr, 'puts', $to_a(strs))
      };
    }, -1);
    
    $def(self, '$raise', function $$raise(exception, string, backtrace) {
            if ($gvars["!"] == null) $gvars["!"] = nil;

      
      ;
      if (string == null) string = nil;
      if (backtrace == null) backtrace = nil;
      
      if (exception == null && $gvars["!"] !== nil) {
        throw $gvars["!"];
      }
      if (exception == null) {
        exception = $$$('RuntimeError').$new("");
      }
      else if ($respond_to(exception, '$to_str')) {
        exception = $$$('RuntimeError').$new(exception.$to_str());
      }
      // using respond_to? and not an undefined check to avoid method_missing matching as true
      else if (exception.$$is_class && $respond_to(exception, '$exception')) {
        exception = exception.$exception(string);
      }
      else if (exception.$$is_exception) {
        // exception is fine
      }
      else {
        exception = $$$('TypeError').$new("exception class/object expected");
      }

      if (backtrace !== nil) {
        exception.$set_backtrace(backtrace);
      }

      if ($gvars["!"] !== nil) {
        Opal.exceptions.push($gvars["!"]);
      }

      $gvars["!"] = exception;

      throw exception;
    ;
    }, -1);
    
    $def(self, '$rand', function $$rand(max) {
      
      
      ;
      
      if (max === undefined) {
        return $$$($$$('Random'), 'DEFAULT').$rand();
      }

      if (max.$$is_number) {
        if (max < 0) {
          max = Math.abs(max);
        }

        if (max % 1 !== 0) {
          max = max.$to_i();
        }

        if (max === 0) {
          max = undefined;
        }
      }
    ;
      return $$$($$$('Random'), 'DEFAULT').$rand(max);
    }, -1);
    
    $def(self, '$respond_to?', function $Kernel_respond_to$ques$15(name, include_all) {
      var self = this;

      
      if (include_all == null) include_all = false;
      
      var body = self[$jsid(name)];

      if (typeof(body) === "function" && !body.$$stub) {
        return true;
      }

      if (self['$respond_to_missing?'].$$pristine === true) {
        return false;
      } else {
        return self['$respond_to_missing?'](name, include_all);
      }
    ;
    }, -2);
    
    $def(self, '$respond_to_missing?', function $Kernel_respond_to_missing$ques$16(method_name, include_all) {
      
      
      if (include_all == null) include_all = false;
      return false;
    }, -2);
    $Opal.$pristine(self, "respond_to?", "respond_to_missing?");
    
    $def(self, '$require', function $$require(file) {
      
      
      // As Object.require refers to Kernel.require once Kernel has been loaded the String
      // class may not be available yet, the coercion requires both  String and Array to be loaded.
      if (typeof file !== 'string' && Opal.String && Opal.Array) {
        (file = $Opal['$coerce_to!'](file, $$$('String'), "to_str"))
      }
      return Opal.require(file)
    
    });
    
    $def(self, '$require_relative', function $$require_relative(file) {
      
      
      $Opal['$try_convert!'](file, $$$('String'), "to_str");
      file = $$$('File').$expand_path($$$('File').$join(Opal.current_file, "..", file));
      return Opal.require(file);
    });
    
    $def(self, '$require_tree', function $$require_tree(path, $kwargs) {
      var autoload;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      autoload = $hash_get($kwargs, "autoload");if (autoload == null) autoload = false;
      
      var result = [];

      path = $$$('File').$expand_path(path)
      path = Opal.normalize(path);
      if (path === '.') path = '';
      for (var name in Opal.modules) {
        if ((name)['$start_with?'](path)) {
          if(!autoload) {
            result.push([name, Opal.require(name)]);
          } else {
            result.push([name, true]); // do nothing, delegated to a autoloading
          }
        }
      }

      return result;
    ;
    }, -2);
    
    $def(self, '$singleton_class', function $$singleton_class() {
      var self = this;

      return Opal.get_singleton_class(self);
    });
    
    $def(self, '$sleep', function $$sleep(seconds) {
      
      
      if (seconds == null) seconds = nil;
      
      if (seconds === nil) {
        $Kernel.$raise($$$('TypeError'), "can't convert NilClass into time interval")
      }
      if (!seconds.$$is_number) {
        $Kernel.$raise($$$('TypeError'), "can't convert " + $to_s(seconds.$class()) + " into time interval")
      }
      if (seconds < 0) {
        $Kernel.$raise($$$('ArgumentError'), "time interval must be positive")
      }
      var get_time = Opal.global.performance ?
        function() {return performance.now()} :
        function() {return new Date()}

      var t = get_time();
      while (get_time() - t <= seconds * 1000);
      return Math.round(seconds);
    ;
    }, -1);
    
    $def(self, '$srand', function $$srand(seed) {
      
      
      if (seed == null) seed = $$('Random').$new_seed();
      return $$$('Random').$srand(seed);
    }, -1);
    
    $def(self, '$String', function $$String(str) {
      var $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = $Opal['$coerce_to?'](str, $$$('String'), "to_str")))) {
        return $ret_or_1
      } else {
        return $Opal['$coerce_to!'](str, $$$('String'), "to_s")
      }
    });
    
    $def(self, '$tap', function $$tap() {
      var block = $$tap.$$p || nil, self = this;

      $$tap.$$p = null;
      
      ;
      Opal.yield1(block, self);
      return self;
    });
    
    $def(self, '$to_proc', $return_self);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return Opal.fallback_to_s(self);
    });
    
    $def(self, '$catch', function $Kernel_catch$17(tag) {
      var $yield = $Kernel_catch$17.$$p || nil, $ret_or_1 = nil, e = nil;

      $Kernel_catch$17.$$p = null;
      
      if (tag == null) tag = nil;
      try {
        
        tag = ($truthy(($ret_or_1 = tag)) ? ($ret_or_1) : ($Object.$new()));
        return Opal.yield1($yield, tag);;
      } catch ($err) {
        if (Opal.rescue($err, [$$$('UncaughtThrowError')])) {(e = $err)
          try {
            
            if ($eqeq(e.$tag(), tag)) {
              return e.$value()
            };
            return $Kernel.$raise();
          } finally { Opal.pop_exception($err); }
        } else { throw $err; }
      };
    }, -1);
    
    $def(self, '$throw', function $Kernel_throw$18(tag, obj) {
      
      
      if (obj == null) obj = nil;
      return $Kernel.$raise($$$('UncaughtThrowError').$new(tag, obj));
    }, -2);
    
    $def(self, '$open', function $$open($a) {
      var block = $$open.$$p || nil, $post_args, args;

      $$open.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      return $send($$$('File'), 'open', $to_a(args), block.$to_proc());
    }, -1);
    
    $def(self, '$yield_self', function $$yield_self() {
      var $yield = $$yield_self.$$p || nil, self = this;

      $$yield_self.$$p = null;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["yield_self"], $return_val(1))
      };
      return Opal.yield1($yield, self);;
    });
    $alias(self, "fail", "raise");
    $alias(self, "kind_of?", "is_a?");
    $alias(self, "object_id", "__id__");
    $alias(self, "public_send", "__send__");
    $alias(self, "send", "__send__");
    $alias(self, "then", "yield_self");
    return $alias(self, "to_enum", "enum_for");
  })('::', $nesting);
  return (function($base, $super) {
    var self = $klass($base, $super, 'Object');

    
    
    delete $Object.$$prototype.$require;
    return self.$include($Kernel);
  })('::', null);
};

Opal.modules["corelib/main"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  var $return_val = Opal.return_val, $def = Opal.def, $Object = Opal.Object, $slice = Opal.slice, $Kernel = Opal.Kernel, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('include,raise');
  return (function(self, $parent_nesting) {
    
    
    
    $def(self, '$to_s', $return_val("main"));
    
    $def(self, '$include', function $$include(mod) {
      
      return $Object.$include(mod)
    });
    
    $def(self, '$autoload', function $$autoload($a) {
      var $post_args, args;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return Opal.Object.$autoload.apply(Opal.Object, args);;
    }, -1);
    return $def(self, '$using', function $$using(mod) {
      
      return $Kernel.$raise("main.using is permitted only at toplevel")
    });
  })(Opal.get_singleton_class(self), $nesting)
};

Opal.modules["corelib/error/errno"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $module = Opal.module, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $to_s = Opal.to_s, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $klass = Opal.klass, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('+,errno,class,attr_reader');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Errno');

    var $nesting = [self].concat($parent_nesting), errors = nil, klass = nil;

    
    errors = [["EINVAL", "Invalid argument", 22], ["EEXIST", "File exists", 17], ["EISDIR", "Is a directory", 21], ["EMFILE", "Too many open files", 24], ["ESPIPE", "Illegal seek", 29], ["EACCES", "Permission denied", 13], ["EPERM", "Operation not permitted", 1], ["ENOENT", "No such file or directory", 2], ["ENAMETOOLONG", "File name too long", 36]];
    klass = nil;
    
    var i;
    for (i = 0; i < errors.length; i++) {
      (function() { // Create a closure
        var class_name = errors[i][0];
        var default_message = errors[i][1];
        var errno = errors[i][2];

        klass = Opal.klass(self, Opal.SystemCallError, class_name);
        klass.errno = errno;

        (function(self, $parent_nesting) {
      
      return $def(self, '$new', function $new$1(name) {
        var $yield = $new$1.$$p || nil, self = this, message = nil;

        $new$1.$$p = null;
        
        if (name == null) name = nil;
        message = default_message;
        if ($truthy(name)) {
          message = $rb_plus(message, " - " + $to_s(name))
        };
        return $send2(self, $find_super(self, 'new', $new$1, false, true), 'new', [message], null);
      }, -1)
    })(Opal.get_singleton_class(klass), $nesting)
      })();
    }
  ;
  })('::', $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SystemCallError');

    var $nesting = [self].concat($parent_nesting);

    
    
    $def(self, '$errno', function $$errno() {
      var self = this;

      return self.$class().$errno()
    });
    return (function(self, $parent_nesting) {
      
      return self.$attr_reader("errno")
    })(Opal.get_singleton_class(self), $nesting);
  })('::', $$$('StandardError'), $nesting);
};

Opal.modules["corelib/error"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $klass = Opal.klass, $slice = Opal.slice, $gvars = Opal.gvars, $defs = Opal.defs, $send = Opal.send, $to_a = Opal.to_a, $def = Opal.def, $send2 = Opal.send2, $find_super = Opal.find_super, $truthy = Opal.truthy, $to_s = Opal.to_s, $hash_new = Opal.hash_new, $Kernel = Opal.Kernel, $not = Opal.not, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $Object = Opal.Object, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $module = Opal.module, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('new,map,backtrace,clone,to_s,merge,tty?,[],include?,raise,dup,empty?,!,caller,shift,+,class,join,cause,full_message,==,reverse,split,autoload,attr_reader,inspect,warn');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Exception');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.message = nil;
    
    Opal.prop(self.$$prototype, '$$is_exception', true);
    var stack_trace_limit;
    Error.stackTraceLimit = 100;
    $defs(self, '$new', function $Exception_new$1($a) {
      var $post_args, args, self = this;
      if ($gvars["!"] == null) $gvars["!"] = nil;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      var message   = (args.length > 0) ? args[0] : nil;
      var error     = new self.$$constructor(message);
      error.name    = self.$$name;
      error.message = message;
      error.cause   = $gvars["!"];
      Opal.send(error, error.$initialize, args);

      // Error.captureStackTrace() will use .name and .toString to build the
      // first line of the stack trace so it must be called after the error
      // has been initialized.
      // https://nodejs.org/dist/latest-v6.x/docs/api/errors.html
      if (Opal.config.enable_stack_trace && Error.captureStackTrace) {
        // Passing Kernel.raise will cut the stack trace from that point above
        Error.captureStackTrace(error, stack_trace_limit);
      }

      return error;
    ;
    }, -1);
    stack_trace_limit = self.$new;
    $defs(self, '$exception', function $$exception($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return $send(self, 'new', $to_a(args));
    }, -1);
    
    $def(self, '$initialize', function $$initialize($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return self.message = (args.length > 0) ? args[0] : nil;;
    }, -1);
    
    $def(self, '$copy_instance_variables', function $$copy_instance_variables(other) {
      var $yield = $$copy_instance_variables.$$p || nil, self = this;

      $$copy_instance_variables.$$p = null;
      
      $send2(self, $find_super(self, 'copy_instance_variables', $$copy_instance_variables, false, true), 'copy_instance_variables', [other], $yield);
      
      self.message = other.message;
      self.cause = other.cause;
      self.stack = other.stack;
    ;
    });
    
    // Convert backtrace from any format to Ruby format
    function correct_backtrace(backtrace) {
      var new_bt = [], m;

      for (var i = 0; i < backtrace.length; i++) {
        var loc = backtrace[i];
        if (!loc || !loc.$$is_string) {
          /* Do nothing */
        }
        /* Chromium format */
        else if ((m = loc.match(/^    at (.*?) \((.*?)\)$/))) {
          new_bt.push(m[2] + ":in `" + m[1] + "'");
        }
        else if ((m = loc.match(/^    at (.*?)$/))) {
          new_bt.push(m[1] + ":in `undefined'");
        }
        /* Node format */
        else if ((m = loc.match(/^  from (.*?)$/))) {
          new_bt.push(m[1]);
        }
        /* Mozilla/Apple format */
        else if ((m = loc.match(/^(.*?)@(.*?)$/))) {
          new_bt.push(m[2] + ':in `' + m[1] + "'");
        }
      }

      return new_bt;
    }
  ;
    
    $def(self, '$backtrace', function $$backtrace() {
      var self = this;

      
      if (self.backtrace) {
        // nil is a valid backtrace
        return self.backtrace;
      }

      var backtrace = self.stack;

      if (typeof(backtrace) !== 'undefined' && backtrace.$$is_string) {
        return self.backtrace = correct_backtrace(backtrace.split("\n"));
      }
      else if (backtrace) {
        return self.backtrace = correct_backtrace(backtrace);
      }

      return [];
    
    });
    
    $def(self, '$backtrace_locations', function $$backtrace_locations() {
      var $a, self = this;

      
      if (self.backtrace_locations) return self.backtrace_locations;
      self.backtrace_locations = ($a = self.$backtrace(), ($a === nil || $a == null) ? nil : $send($a, 'map', [], function $$2(loc){
        
        if (loc == null) loc = nil;
        return $$$($$$($$$('Thread'), 'Backtrace'), 'Location').$new(loc);}))
      return self.backtrace_locations;
    
    });
    
    $def(self, '$cause', function $$cause() {
      var self = this;

      return self.cause || nil;
    });
    
    $def(self, '$exception', function $$exception(str) {
      var self = this;

      
      if (str == null) str = nil;
      
      if (str === nil || self === str) {
        return self;
      }

      var cloned = self.$clone();
      cloned.message = str;
      if (self.backtrace) cloned.backtrace = self.backtrace.$dup();
      cloned.stack = self.stack;
      cloned.cause = self.cause;
      return cloned;
    ;
    }, -1);
    
    $def(self, '$message', function $$message() {
      var self = this;

      return self.$to_s()
    });
    
    $def(self, '$full_message', function $$full_message(kwargs) {
      var $a, $b, $c, self = this, $ret_or_1 = nil, highlight = nil, order = nil, bold_underline = nil, bold = nil, reset = nil, bt = nil, first = nil, msg = nil;
      if ($gvars.stderr == null) $gvars.stderr = nil;

      
      if (kwargs == null) kwargs = nil;
      if (!$truthy((($a = $$('Hash', 'skip_raise')) ? 'constant' : nil))) {
        return $to_s(self.message) + "\n" + $to_s(self.stack)
      };
      kwargs = $hash_new("highlight", ($b = $gvars.stderr, ($b === nil || $b == null) ? nil : $b['$tty?']()), "order", "top").$merge(($truthy(($ret_or_1 = kwargs)) ? ($ret_or_1) : ((new Map()))));
      $c = [kwargs['$[]']("highlight"), kwargs['$[]']("order")], (highlight = $c[0]), (order = $c[1]), $c;
      if (!$truthy([true, false]['$include?'](highlight))) {
        $Kernel.$raise($$$('ArgumentError'), "expected true or false as highlight: " + $to_s(highlight))
      };
      if (!$truthy(["top", "bottom"]['$include?'](order))) {
        $Kernel.$raise($$$('ArgumentError'), "expected :top or :bottom as order: " + $to_s(order))
      };
      if ($truthy(highlight)) {
        
        bold_underline = "\u001b[1;4m";
        bold = "\u001b[1m";
        reset = "\u001b[m";
      } else {
        bold_underline = (bold = (reset = ""))
      };
      bt = self.$backtrace().$dup();
      if (($not(bt) || ($truthy(bt['$empty?']())))) {
        bt = self.$caller()
      };
      first = bt.$shift();
      msg = $to_s(first) + ": ";
      msg = $rb_plus(msg, $to_s(bold) + $to_s(self.$to_s()) + " (" + $to_s(bold_underline) + $to_s(self.$class()) + $to_s(reset) + $to_s(bold) + ")" + $to_s(reset) + "\n");
      msg = $rb_plus(msg, $send(bt, 'map', [], function $$3(loc){
        
        if (loc == null) loc = nil;
        return "\tfrom " + $to_s(loc) + "\n";}).$join());
      if ($truthy(self.$cause())) {
        msg = $rb_plus(msg, self.$cause().$full_message($hash_new("highlight", highlight)))
      };
      if ($eqeq(order, "bottom")) {
        
        msg = msg.$split("\n").$reverse().$join("\n");
        msg = $rb_plus($to_s(bold) + "Traceback" + $to_s(reset) + " (most recent call last):\n", msg);
      };
      return msg;
    }, -1);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, as_str = nil;

      
      as_str = self.$to_s();
      if ($truthy(as_str['$empty?']())) {
        return self.$class().$to_s()
      } else {
        return "#<" + $to_s(self.$class().$to_s()) + ": " + $to_s(self.$to_s()) + ">"
      };
    });
    
    $def(self, '$set_backtrace', function $$set_backtrace(backtrace) {
      var self = this;

      
      var valid = true, i, ii;

      if (backtrace === nil) {
        self.backtrace = nil;
        self.stack = '';
      } else if (backtrace.$$is_string) {
        self.backtrace = [backtrace];
        self.stack = '  from ' + backtrace;
      } else {
        if (backtrace.$$is_array) {
          for (i = 0, ii = backtrace.length; i < ii; i++) {
            if (!backtrace[i].$$is_string) {
              valid = false;
              break;
            }
          }
        } else {
          valid = false;
        }

        if (valid === false) {
          $Kernel.$raise($$$('TypeError'), "backtrace must be Array of String")
        }

        self.backtrace = backtrace;
        self.stack = $send((backtrace), 'map', [], function $$4(i){
        
        if (i == null) i = nil;
        return $rb_plus("  from ", i);}).join("\n");
      }

      return backtrace;
    
    });
    return $def(self, '$to_s', function $$to_s() {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.message)) ? (self.message.$to_s()) : ($ret_or_2))))) {
        return $ret_or_1
      } else {
        return self.$class().$to_s()
      }
    });
  })('::', Error, $nesting);
  $klass('::', $$$('Exception'), 'ScriptError');
  $klass('::', $$$('ScriptError'), 'SyntaxError');
  $klass('::', $$$('ScriptError'), 'LoadError');
  $klass('::', $$$('ScriptError'), 'NotImplementedError');
  $klass('::', $$$('Exception'), 'SystemExit');
  $klass('::', $$$('Exception'), 'NoMemoryError');
  $klass('::', $$$('Exception'), 'SignalException');
  $klass('::', $$$('SignalException'), 'Interrupt');
  $klass('::', $$$('Exception'), 'SecurityError');
  $klass('::', $$$('Exception'), 'SystemStackError');
  $klass('::', $$$('Exception'), 'StandardError');
  $klass('::', $$$('StandardError'), 'EncodingError');
  $klass('::', $$$('StandardError'), 'ZeroDivisionError');
  $klass('::', $$$('StandardError'), 'NameError');
  $klass('::', $$$('NameError'), 'NoMethodError');
  $klass('::', $$$('StandardError'), 'RuntimeError');
  $klass('::', $$$('RuntimeError'), 'FrozenError');
  $klass('::', $$$('StandardError'), 'LocalJumpError');
  $klass('::', $$$('StandardError'), 'TypeError');
  $klass('::', $$$('StandardError'), 'ArgumentError');
  $klass('::', $$$('ArgumentError'), 'UncaughtThrowError');
  $klass('::', $$$('StandardError'), 'IndexError');
  $klass('::', $$$('IndexError'), 'StopIteration');
  $klass('::', $$$('StopIteration'), 'ClosedQueueError');
  $klass('::', $$$('IndexError'), 'KeyError');
  $klass('::', $$$('StandardError'), 'RangeError');
  $klass('::', $$$('RangeError'), 'FloatDomainError');
  $klass('::', $$$('StandardError'), 'IOError');
  $klass('::', $$$('IOError'), 'EOFError');
  $klass('::', $$$('StandardError'), 'SystemCallError');
  $klass('::', $$$('StandardError'), 'RegexpError');
  $klass('::', $$$('StandardError'), 'ThreadError');
  $klass('::', $$$('StandardError'), 'FiberError');
  $Object.$autoload("Errno", "corelib/error/errno");
  (function($base, $super) {
    var self = $klass($base, $super, 'FrozenError');

    
    
    self.$attr_reader("receiver");
    return $def(self, '$initialize', function $$initialize(message, $kwargs) {
      var receiver, $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      $kwargs = $ensure_kwargs($kwargs);
      
      receiver = $hash_get($kwargs, "receiver");if (receiver == null) receiver = nil;
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message], null);
      return (self.receiver = receiver);
    }, -2);
  })('::', $$$('RuntimeError'));
  (function($base, $super) {
    var self = $klass($base, $super, 'UncaughtThrowError');

    var $proto = self.$$prototype;

    $proto.tag = nil;
    
    self.$attr_reader("tag", "value");
    return $def(self, '$initialize', function $$initialize(tag, value) {
      var $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      if (value == null) value = nil;
      self.tag = tag;
      self.value = value;
      return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', ["uncaught throw " + $to_s(self.tag.$inspect())], null);
    }, -2);
  })('::', $$$('ArgumentError'));
  (function($base, $super) {
    var self = $klass($base, $super, 'NameError');

    
    
    self.$attr_reader("name");
    return $def(self, '$initialize', function $$initialize(message, name) {
      var $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      if (name == null) name = nil;
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message], null);
      return (self.name = name);
    }, -2);
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'NoMethodError');

    
    
    self.$attr_reader("args");
    return $def(self, '$initialize', function $$initialize(message, name, args) {
      var $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      if (name == null) name = nil;
      if (args == null) args = [];
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message, name], null);
      return (self.args = args);
    }, -2);
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'StopIteration');

    
    return self.$attr_reader("result")
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'KeyError');

    var $proto = self.$$prototype;

    $proto.receiver = $proto.key = nil;
    
    
    $def(self, '$initialize', function $$initialize(message, $kwargs) {
      var receiver, key, $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      $kwargs = $ensure_kwargs($kwargs);
      
      receiver = $hash_get($kwargs, "receiver");if (receiver == null) receiver = nil;
      
      key = $hash_get($kwargs, "key");if (key == null) key = nil;
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message], null);
      self.receiver = receiver;
      return (self.key = key);
    }, -2);
    
    $def(self, '$receiver', function $$receiver() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.receiver))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('ArgumentError'), "no receiver is available")
      }
    });
    return $def(self, '$key', function $$key() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.key))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('ArgumentError'), "no key is available")
      }
    });
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'LocalJumpError');

    
    
    self.$attr_reader("exit_value", "reason");
    return $def(self, '$initialize', function $$initialize(message, exit_value, reason) {
      var $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      if (exit_value == null) exit_value = nil;
      if (reason == null) reason = "noreason";
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message], null);
      self.exit_value = exit_value;
      return (self.reason = reason);
    }, -2);
  })('::', null);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Raw');

      var $nesting = [self].concat($parent_nesting);

      return ($klass($nesting[0], null, 'Error'), nil)
    })($nesting[0], $nesting)
  })('::', $nesting);
  return (function($base) {
    var self = $module($base, 'JS');

    
    return $defs(self, '$const_missing', function $$const_missing(const$) {
      var $yield = $$const_missing.$$p || nil, self = this;

      $$const_missing.$$p = null;
      if ($eqeq(const$, "Error")) {
        
        self.$warn("[Opal] JS::Error class has been renamed to Opal::Raw::Error and will change semantics in Opal 2.1. " + "To ensure forward compatibility, please update your rescue clauses.");
        return $$$($$$($$$('JS'), 'Raw'), 'Error');
      } else {
        return $send2(self, $find_super(self, 'const_missing', $$const_missing, false, true), 'const_missing', [const$], $yield)
      }
    })
  })('::');
};

Opal.modules["corelib/constants"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  var $const_set = Opal.const_set, $to_s = Opal.to_s, nil = Opal.nil, $$$ = Opal.$$$;

  
  $const_set('::', 'RUBY_PLATFORM', "opal");
  $const_set('::', 'RUBY_ENGINE', "opal");
  $const_set('::', 'RUBY_VERSION', "3.2.0");
  $const_set('::', 'RUBY_ENGINE_VERSION', "2.0.0dev");
  $const_set('::', 'RUBY_RELEASE_DATE', "2023-11-16");
  $const_set('::', 'RUBY_PATCHLEVEL', 0);
  $const_set('::', 'RUBY_REVISION', "0");
  $const_set('::', 'RUBY_COPYRIGHT', "opal - Copyright (C) 2011-2023 Adam Beynon and the Opal contributors");
  return $const_set('::', 'RUBY_DESCRIPTION', "opal " + $to_s($$$('RUBY_ENGINE_VERSION')) + " (" + $to_s($$$('RUBY_RELEASE_DATE')) + " revision " + $to_s($$$('RUBY_REVISION')) + ")");
};

Opal.modules["opal/base"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  var $Object = Opal.Object, nil = Opal.nil;

  Opal.add_stubs('require');
  
  $Object.$require("corelib/runtime");
  $Object.$require("corelib/helpers");
  $Object.$require("corelib/module");
  $Object.$require("corelib/class");
  $Object.$require("corelib/basic_object");
  $Object.$require("corelib/kernel");
  $Object.$require("corelib/main");
  $Object.$require("corelib/error");
  return $Object.$require("corelib/constants");
};

Opal.modules["corelib/nil"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $klass = Opal.klass, $Kernel = Opal.Kernel, $to_s = Opal.to_s, $def = Opal.def, $return_val = Opal.return_val, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $NilClass = Opal.NilClass, $slice = Opal.slice, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,name,new,>,length,Rational,to_i');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NilClass');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$prototype.$$meta = self;
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + $to_s(self.$name()))
      });
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$!', $return_val(true));
    
    $def(self, '$&', $return_val(false));
    
    $def(self, '$|', function $NilClass_$$1(other) {
      
      return other !== false && other !== nil;
    });
    
    $def(self, '$^', function $NilClass_$$2(other) {
      
      return other !== false && other !== nil;
    });
    
    $def(self, '$==', function $NilClass_$eq_eq$3(other) {
      
      return other === nil;
    });
    
    $def(self, '$dup', $return_val(nil));
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $hash_get($kwargs, "freeze");if (freeze == null) freeze = true;
      return nil;
    }, -1);
    
    $def(self, '$inspect', $return_val("nil"));
    
    $def(self, '$nil?', $return_val(true));
    
    $def(self, '$singleton_class', function $$singleton_class() {
      
      return $NilClass
    });
    
    $def(self, '$to_a', function $$to_a() {
      
      return []
    });
    
    $def(self, '$to_h', function $$to_h() {
      
      return new Map();
    });
    
    $def(self, '$to_i', $return_val(0));
    
    $def(self, '$to_s', $return_val(""));
    
    $def(self, '$to_c', function $$to_c() {
      
      return $$$('Complex').$new(0, 0)
    });
    
    $def(self, '$rationalize', function $$rationalize($a) {
      var $post_args, args;

      
      $post_args = $slice(arguments);
      args = $post_args;
      if ($truthy($rb_gt(args.$length(), 1))) {
        $Kernel.$raise($$$('ArgumentError'))
      };
      return $Kernel.$Rational(0, 1);
    }, -1);
    
    $def(self, '$to_r', function $$to_r() {
      
      return $Kernel.$Rational(0, 1)
    });
    
    $def(self, '$instance_variables', function $$instance_variables() {
      
      return []
    });
    return $alias(self, "to_f", "to_i");
  })('::', null, $nesting)
};

Opal.modules["corelib/boolean"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $klass = Opal.klass, $Kernel = Opal.Kernel, $to_s = Opal.to_s, $def = Opal.def, $return_self = Opal.return_self, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $slice = Opal.slice, $truthy = Opal.truthy, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,name,==,to_s,__id__');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Boolean');

    var $nesting = [self].concat($parent_nesting);

    
    Opal.prop(self.$$prototype, '$$is_boolean', true);
    
    var properties = ['$$class', '$$meta'];

    for (var i = 0; i < properties.length; i++) {
      Object.defineProperty(self.$$prototype, properties[i], {
        configurable: true,
        enumerable: false,
        get: function() {
          return this == true  ? Opal.TrueClass :
                 this == false ? Opal.FalseClass :
                                 Opal.Boolean;
        }
      });
    }

    Object.defineProperty(self.$$prototype, "$$id", {
      configurable: true,
      enumerable: false,
      get: function() {
        return this == true  ? 2 :
               this == false ? 0 :
                               nil;
      }
    });
  ;
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + $to_s(self.$name()))
      });
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$__id__', function $$__id__() {
      var self = this;

      return self.valueOf() ? 2 : 0;
    });
    
    $def(self, '$!', function $Boolean_$excl$1() {
      var self = this;

      return self != true;
    });
    
    $def(self, '$&', function $Boolean_$$2(other) {
      var self = this;

      return (self == true) ? (other !== false && other !== nil) : false;
    });
    
    $def(self, '$|', function $Boolean_$$3(other) {
      var self = this;

      return (self == true) ? true : (other !== false && other !== nil);
    });
    
    $def(self, '$^', function $Boolean_$$4(other) {
      var self = this;

      return (self == true) ? (other === false || other === nil) : (other !== false && other !== nil);
    });
    
    $def(self, '$==', function $Boolean_$eq_eq$5(other) {
      var self = this;

      return (self == true) === other.valueOf();
    });
    
    $def(self, '$singleton_class', function $$singleton_class() {
      var self = this;

      return self.$$meta;
    });
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return (self == true) ? 'true' : 'false';
    });
    
    $def(self, '$dup', $return_self);
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $hash_get($kwargs, "freeze");if (freeze == null) freeze = true;
      return self;
    }, -1);
    
    $def(self, '$method_missing', function $$method_missing(method, $a) {
      var block = $$method_missing.$$p || nil, $post_args, args, self = this;

      $$method_missing.$$p = null;
      
      ;
      $post_args = $slice(arguments, 1);
      args = $post_args;
      var body = self.$$class.$$prototype[Opal.jsid(method)];
      if (!$truthy(typeof body !== 'undefined' && !body.$$stub)) {
        $send2(self, $find_super(self, 'method_missing', $$method_missing, false, true), 'method_missing', [method].concat($to_a(args)), block)
      };
      return Opal.send(self, body, args, block);
    }, -2);
    
    $def(self, '$respond_to_missing?', function $Boolean_respond_to_missing$ques$6(method, _include_all) {
      var self = this;

      
      if (_include_all == null) _include_all = false;
      var body = self.$$class.$$prototype[Opal.jsid(method)];
      return typeof body !== 'undefined' && !body.$$stub;;
    }, -2);
    $alias(self, "eql?", "==");
    $alias(self, "equal?", "==");
    $alias(self, "inspect", "to_s");
    return $alias(self, "object_id", "__id__");
  })('::', Boolean, $nesting);
  $klass('::', $$$('Boolean'), 'TrueClass');
  return ($klass('::', $$$('Boolean'), 'FalseClass'), nil);
};

Opal.modules["corelib/comparable"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  var $truthy = Opal.truthy, $module = Opal.module, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $to_s = Opal.to_s, $def = Opal.def, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('>,<,===,raise,class,<=>,equal?');
  return (function($base) {
    var self = $module($base, 'Comparable');

    var $ret_or_1 = nil;

    
    
    function normalize(what) {
      if (Opal.is_a(what, Opal.Integer)) { return what; }

      if ($rb_gt(what, 0)) { return 1; }
      if ($rb_lt(what, 0)) { return -1; }
      return 0;
    }

    function fail_comparison(lhs, rhs) {
      var class_name;
      (($eqeqeq(nil, ($ret_or_1 = rhs)) || (($eqeqeq(true, $ret_or_1) || (($eqeqeq(false, $ret_or_1) || (($eqeqeq($$$('Integer'), $ret_or_1) || ($eqeqeq($$$('Float'), $ret_or_1))))))))) ? (class_name = rhs.$inspect()) : (class_name = rhs.$$class))
      $Kernel.$raise($$$('ArgumentError'), "comparison of " + $to_s((lhs).$class()) + " with " + $to_s(class_name) + " failed")
    }

    function cmp_or_fail(lhs, rhs) {
      var cmp = (lhs)['$<=>'](rhs);
      if (!$truthy(cmp)) fail_comparison(lhs, rhs);
      return normalize(cmp);
    }
  ;
    
    $def(self, '$==', function $Comparable_$eq_eq$1(other) {
      var self = this, cmp = nil;

      
      if ($truthy(self['$equal?'](other))) {
        return true
      };
      
      if (self["$<=>"] == Opal.Kernel["$<=>"]) {
        return false;
      }

      // check for infinite recursion
      if (self.$$comparable) {
        self.$$comparable = false;
        return false;
      }
    ;
      if (!$truthy((cmp = self['$<=>'](other)))) {
        return false
      };
      return normalize(cmp) == 0;;
    });
    
    $def(self, '$>', function $Comparable_$gt$2(other) {
      var self = this;

      return cmp_or_fail(self, other) > 0;
    });
    
    $def(self, '$>=', function $Comparable_$gt_eq$3(other) {
      var self = this;

      return cmp_or_fail(self, other) >= 0;
    });
    
    $def(self, '$<', function $Comparable_$lt$4(other) {
      var self = this;

      return cmp_or_fail(self, other) < 0;
    });
    
    $def(self, '$<=', function $Comparable_$lt_eq$5(other) {
      var self = this;

      return cmp_or_fail(self, other) <= 0;
    });
    
    $def(self, '$between?', function $Comparable_between$ques$6(min, max) {
      var self = this;

      
      if ($truthy($rb_lt(self, min))) {
        return false
      };
      if ($truthy($rb_gt(self, max))) {
        return false
      };
      return true;
    });
    return $def(self, '$clamp', function $$clamp(min, max) {
      var self = this;

      
      if (max == null) max = nil;
      
      var c, excl;

      if (max === nil) {
        // We are dealing with a new Ruby 2.7 behaviour that we are able to
        // provide a single Range argument instead of 2 Comparables.

        if (!Opal.is_a(min, Opal.Range)) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + $to_s(min.$class()) + " (expected Range)")
        }

        excl = min.excl;
        max = min.end;
        min = min.begin;

        if (max !== nil && excl) {
          $Kernel.$raise($$$('ArgumentError'), "cannot clamp with an exclusive range")
        }
      }

      if (min !== nil && max !== nil && cmp_or_fail(min, max) > 0) {
        $Kernel.$raise($$$('ArgumentError'), "min argument must be smaller than max argument")
      }

      if (min !== nil) {
        c = cmp_or_fail(self, min);

        if (c == 0) return self;
        if (c < 0) return min;
      }

      if (max !== nil) {
        c = cmp_or_fail(self, max);

        if (c > 0) return max;
      }

      return self;
    ;
    }, -2);
  })('::')
};

Opal.modules["corelib/regexp"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $coerce_to = Opal.coerce_to, $prop = Opal.prop, $freeze = Opal.freeze, $annotate_regexp = Opal.annotate_regexp, $escape_metacharacters = Opal.escape_metacharacters, $klass = Opal.klass, $const_set = Opal.const_set, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $truthy = Opal.truthy, $gvars = Opal.gvars, $slice = Opal.slice, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $to_s = Opal.to_s, $alias = Opal.alias, $send = Opal.send, $regexp = Opal.regexp, $hash_new = Opal.hash_new, $rb_plus = Opal.rb_plus, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $rb_ge = Opal.rb_ge, $to_a = Opal.to_a, $eqeqeq = Opal.eqeqeq, $rb_minus = Opal.rb_minus, $return_ivar = Opal.return_ivar, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('nil?,[],raise,escape,options,source,to_str,new,join,coerce_to!,!,match,coerce_to?,begin,frozen?,uniq,map,scan,to_proc,transform_values,group_by,each_with_index,+,last,=~,==,attr_reader,>=,length,is_a?,include?,names,regexp,named_captures,===,captures,-,inspect,empty?,each,to_a');
  
  $klass('::', $$$('StandardError'), 'RegexpError');
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Regexp');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set(self, 'IGNORECASE', 1);
    $const_set(self, 'EXTENDED', 2);
    $const_set(self, 'MULTILINE', 4);
    $const_set(self, 'FIXEDENCODING', 16);
    $const_set(self, 'NOENCODING', 32);
    Opal.prop(self.$$prototype, '$$is_regexp', true);
    Opal.prop(self.$$prototype, '$$source', null);
    Opal.prop(self.$$prototype, '$$options', null);
    Opal.prop(self.$$prototype, '$$g', null);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$allocate', function $$allocate() {
        var $yield = $$allocate.$$p || nil, self = this, allocated = nil;

        $$allocate.$$p = null;
        
        allocated = $send2(self, $find_super(self, 'allocate', $$allocate, false, true), 'allocate', [], $yield);
        allocated.uninitialized = true;
        return allocated;
      });
      
      $def(self, '$escape', function $$escape(string) {
        
        
        string = $coerce_to(string, $$$('String'), 'to_str');
        return Opal.escape_regexp(string);
      
      });
      
      $def(self, '$last_match', function $$last_match(n) {
                if ($gvars["~"] == null) $gvars["~"] = nil;

        
        if (n == null) n = nil;
        if ($truthy(n['$nil?']())) {
          return $gvars["~"]
        } else if ($truthy($gvars["~"])) {
          return $gvars["~"]['$[]'](n)
        } else {
          return nil
        };
      }, -1);
      
      $def(self, '$union', function $$union($a) {
        var $post_args, parts, self = this;

        
        $post_args = $slice(arguments);
        parts = $post_args;
        
        function exclude_compatible(flags) {
          return (flags || 0) & ~$$('MULTILINE') & ~$$('EXTENDED');
        }
        function compatible_flags(first, second) {
          return exclude_compatible(first) == exclude_compatible(second)
        }

        var is_first_part_array, quoted_validated, part, options, each_part_options;
        if (parts.length == 0) {
          return /(?!)/;
        }
        // return fast if there's only one element
        if (parts.length == 1 && parts[0].$$is_regexp) {
          return parts[0];
        }
        // cover the 2 arrays passed as arguments case
        is_first_part_array = parts[0].$$is_array;
        if (parts.length > 1 && is_first_part_array) {
          $Kernel.$raise($$$('TypeError'), "no implicit conversion of Array into String")
        }
        // deal with splat issues (related to https://github.com/opal/opal/issues/858)
        if (is_first_part_array) {
          parts = parts[0];
        }
        options = undefined;
        quoted_validated = [];
        for (var i=0; i < parts.length; i++) {
          part = parts[i];
          if (part.$$is_string) {
            quoted_validated.push(self.$escape(part));
          }
          else if (part.$$is_regexp) {
            each_part_options = (part).$options();
            if (options != undefined && !compatible_flags(options, each_part_options)) {
              $Kernel.$raise($$$('TypeError'), "All expressions must use the same options")
            }
            options = each_part_options;
            quoted_validated.push('(?:'+(part).$source()+')');
          }
          else {
            quoted_validated.push(self.$escape((part).$to_str()));
          }
        }
      ;
        return self.$new((quoted_validated).$join("|"), options);
      }, -1);
      
      $def(self, '$new', function $new$1(regexp, options) {
        
        
        ;
        
        if (regexp.$$is_regexp) {
          return $annotate_regexp(new RegExp(regexp), regexp.$$source, regexp.$$options);
        }

        regexp = $Opal['$coerce_to!'](regexp, $$$('String'), "to_str");

        if (regexp.charAt(regexp.length - 1) === '\\' && regexp.charAt(regexp.length - 2) !== '\\') {
          $Kernel.$raise($$$('RegexpError'), "too short escape sequence: /" + $to_s(regexp) + "/")
        }

        if (options === undefined || options['$!']()) {
          options = 'u';
        }
        else if (options.$$is_number) {
          var temp = 'u';
          if ($$('IGNORECASE') & options) { temp += 'i'; }
          if ($$('MULTILINE')  & options) { temp += 'm'; }
          options = temp;
        }
        else if (!options.$$is_string) {
          options = 'iu';
        }

        var result = Opal.transform_regexp(regexp, options);
        return Opal.annotate_regexp(new RegExp(result[0], result[1]), $escape_metacharacters(regexp), options);
      ;
      }, -2);
      $alias(self, "compile", "new");
      return $alias(self, "quote", "escape");
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$==', function $Regexp_$eq_eq$2(other) {
      var self = this;

      return other instanceof RegExp && self.$options() == other.$options() && self.$source() == other.$source();
    });
    
    $def(self, '$===', function $Regexp_$eq_eq_eq$3(string) {
      var self = this;

      return self.$match($Opal['$coerce_to?'](string, $$$('String'), "to_str")) !== nil
    });
    
    $def(self, '$=~', function $Regexp_$eq_tilde$4(string) {
      var self = this, $ret_or_1 = nil;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      if ($truthy(($ret_or_1 = self.$match(string)))) {
        return $gvars["~"].$begin(0)
      } else {
        return $ret_or_1
      }
    });
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      
      if (!self.hasOwnProperty('$$g')) { $prop(self, '$$g', null); }

      return $freeze(self);
    ;
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      var regexp_pattern = self.$source();
      var regexp_flags = self.$$options != null ? self.$$options : self.flags;
      regexp_flags = regexp_flags.replace('u', '');
      var chars = regexp_pattern.split('');
      var chars_length = chars.length;
      var char_escaped = false;
      var regexp_pattern_escaped = '';
      for (var i = 0; i < chars_length; i++) {
        var current_char = chars[i];
        if (!char_escaped && current_char == '/') {
          regexp_pattern_escaped += '\\';
        }
        regexp_pattern_escaped += current_char;
        if (current_char == '\\') {
          // does not over escape
          char_escaped = !char_escaped;
        } else {
          char_escaped = false;
        }
      }
      return '/' + regexp_pattern_escaped + '/' + regexp_flags;
    
    });
    
    $def(self, '$match', function $$match(string, pos) {
      var block = $$match.$$p || nil, self = this;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      $$match.$$p = null;
      
      ;
      ;
      
      if (self.uninitialized) {
        $Kernel.$raise($$$('TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        if (string === nil) return ($gvars["~"] = nil);
        var m = self.exec($coerce_to(string, $$$('String'), 'to_str'));
        if (m) {
          ($gvars["~"] = $$$('MatchData').$new(self, m));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        } else {
          return ($gvars["~"] = nil);
        }
      }

      pos = $coerce_to(pos, $$$('Integer'), 'to_int');

      if (string === nil) {
        return ($gvars["~"] = nil);
      }

      string = $coerce_to(string, $$$('String'), 'to_str');

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return ($gvars["~"] = nil);
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      while (true) {
        md = re.exec(string);
        if (md === null) {
          return ($gvars["~"] = nil);
        }
        if (md.index >= pos) {
          ($gvars["~"] = $$$('MatchData').$new(re, md));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        }
        re.lastIndex = md.index + 1;
      }
    ;
    }, -2);
    
    $def(self, '$match?', function $Regexp_match$ques$5(string, pos) {
      var self = this;

      
      ;
      
      if (self.uninitialized) {
        $Kernel.$raise($$$('TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        return string === nil ? false : self.test($coerce_to(string, $$$('String'), 'to_str'));
      }

      pos = $coerce_to(pos, $$$('Integer'), 'to_int');

      if (string === nil) {
        return false;
      }

      string = $coerce_to(string, $$$('String'), 'to_str');

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return false;
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      md = re.exec(string);
      if (md === null || md.index < pos) {
        return false;
      } else {
        return true;
      }
    ;
    }, -2);
    
    $def(self, '$names', function $$names() {
      var self = this;

      return $send(self.$source().$scan($regexp(["\\(?<(\\w+)>"]), $hash_new("no_matchdata", true)), 'map', [], "first".$to_proc()).$uniq()
    });
    
    $def(self, '$named_captures', function $$named_captures() {
      var self = this;

      return $send($send($send(self.$source().$scan($regexp(["\\(?<(\\w+)>"]), $hash_new("no_matchdata", true)), 'map', [], "first".$to_proc()).$each_with_index(), 'group_by', [], "first".$to_proc()), 'transform_values', [], function $$6(i){
        
        if (i == null) i = nil;
        return $send(i, 'map', [], function $$7(j){
          
          if (j == null) j = nil;
          return $rb_plus(j.$last(), 1);});})
    });
    
    $def(self, '$~', function $Regexp_$$8() {
      var self = this;
      if ($gvars._ == null) $gvars._ = nil;

      return self['$=~']($gvars._)
    });
    
    $def(self, '$source', function $$source() {
      var self = this;

      return self.$$source != null ? self.$$source : self.source;
    });
    
    $def(self, '$options', function $$options() {
      var self = this;

      
      if (self.uninitialized) {
        $Kernel.$raise($$$('TypeError'), "uninitialized Regexp")
      }
      var result = 0;
      // should be supported in IE6 according to https://msdn.microsoft.com/en-us/library/7f5z26w4(v=vs.94).aspx
      if (self.$$options != null ? self.$$options.includes('m') : self.multiline) {
        result |= $$('MULTILINE');
      }
      if (self.$$options != null ? self.$$options.includes('i') : self.ignoreCase) {
        result |= $$('IGNORECASE');
      }
      if (self.$$options != null ? self.$$options.includes('x') : false) {
        result |= $$('EXTENDED');
      }
      return result;
    
    });
    
    $def(self, '$casefold?', function $Regexp_casefold$ques$9() {
      var self = this;

      return self.ignoreCase;
    });
    $alias(self, "eql?", "==");
    return $alias(self, "to_s", "source");
  })('::', RegExp, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'MatchData');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.matches = nil;
    
    self.$attr_reader("post_match", "pre_match", "regexp", "string");
    
    $def(self, '$initialize', function $$initialize(regexp, match_groups, $kwargs) {
      var no_matchdata, self = this;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      no_matchdata = $hash_get($kwargs, "no_matchdata");if (no_matchdata == null) no_matchdata = false;
      if (!$truthy(no_matchdata)) {
        $gvars["~"] = self
      };
      self.regexp = regexp;
      self.begin = match_groups.index;
      self.string = match_groups.input;
      self.pre_match = match_groups.input.slice(0, match_groups.index);
      self.post_match = match_groups.input.slice(match_groups.index + match_groups[0].length);
      self.matches = [];
      
      for (var i = 0, length = match_groups.length; i < length; i++) {
        var group = match_groups[i];

        if (group == null) {
          self.matches.push(nil);
        }
        else {
          self.matches.push(group);
        }
      }
    ;
    }, -3);
    
    $def(self, '$match', function $$match(idx) {
      var self = this, match = nil;

      if ($truthy((match = self['$[]'](idx)))) {
        return match
      } else if (($truthy(idx['$is_a?']($$('Integer'))) && ($truthy($rb_ge(idx, self.$length()))))) {
        return $Kernel.$raise($$$('IndexError'), "index " + $to_s(idx) + " out of matches")
      } else {
        return nil
      }
    });
    
    $def(self, '$match_length', function $$match_length(idx) {
      var $a, self = this;

      return ($a = self.$match(idx), ($a === nil || $a == null) ? nil : $a.$length())
    });
    
    $def(self, '$[]', function $MatchData_$$$10($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      if (args[0].$$is_string) {
        if (self.$regexp().$names()['$include?'](args['$[]'](0))['$!']()) {
          $Kernel.$raise($$$('IndexError'), "undefined group name reference: " + $to_s(args['$[]'](0)))
        }
        return self.$named_captures()['$[]'](args['$[]'](0))
      }
      else {
        return $send(self.matches, '[]', $to_a(args))
      }
    ;
    }, -1);
    
    $def(self, '$offset', function $$offset(n) {
      var self = this;

      
      if (n !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "MatchData#offset only supports 0th element")
      }
      return [self.begin, self.begin + self.matches[n].length];
    
    });
    
    $def(self, '$==', function $MatchData_$eq_eq$11(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil;

      
      if (!$eqeqeq($$$('MatchData'), other)) {
        return false
      };
      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = ($truthy(($ret_or_4 = self.string == other.string)) ? (self.regexp.toString() == other.regexp.toString()) : ($ret_or_4)))) ? (self.pre_match == other.pre_match) : ($ret_or_3)))) ? (self.post_match == other.post_match) : ($ret_or_2))))) {
        return self.begin == other.begin;
      } else {
        return $ret_or_1
      };
    });
    
    $def(self, '$begin', function $$begin(n) {
      var self = this;

      
      if (n !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "MatchData#begin only supports 0th element")
      }
      return self.begin;
    
    });
    
    $def(self, '$end', function $$end(n) {
      var self = this;

      
      if (n !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "MatchData#end only supports 0th element")
      }
      return self.begin + self.matches[n].length;
    
    });
    
    $def(self, '$captures', function $$captures() {
      var self = this;

      return self.matches.slice(1)
    });
    
    $def(self, '$named_captures', function $$named_captures() {
      var self = this, matches = nil;

      
      matches = self.$captures();
      return $send(self.$regexp().$named_captures(), 'transform_values', [], function $$12(i){
        
        if (i == null) i = nil;
        return matches['$[]']($rb_minus(i.$last(), 1));});
    });
    
    $def(self, '$names', function $$names() {
      var self = this;

      return self.$regexp().$names()
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      var str = "#<MatchData " + (self.matches[0]).$inspect();

      if (self.$regexp().$names()['$empty?']()) {
        for (var i = 1, length = self.matches.length; i < length; i++) {
          str += " " + i + ":" + (self.matches[i]).$inspect();
        }
      }
      else {
        $send(self.$named_captures(), 'each', [], function $$13(k, v){
        
        if (k == null) k = nil;
        if (v == null) v = nil;
        return                str += " " + k + ":" + v.$inspect();})
      }

      return str + ">";
    
    });
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.matches.length
    });
    
    $def(self, '$to_a', $return_ivar("matches"));
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return self.matches[0]
    });
    
    $def(self, '$values_at', function $$values_at($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      var i, a, index, values = [];

      for (i = 0; i < args.length; i++) {

        if (args[i].$$is_range) {
          a = (args[i]).$to_a();
          a.unshift(i, 1);
          Array.prototype.splice.apply(args, a);
        }

        index = $Opal['$coerce_to!'](args[i], $$$('Integer'), "to_int");

        if (index < 0) {
          index += self.matches.length;
          if (index < 0) {
            values.push(nil);
            continue;
          }
        }

        values.push(self.matches[index]);
      }

      return values;
    ;
    }, -1);
    $alias(self, "eql?", "==");
    return $alias(self, "size", "length");
  })($nesting[0], null, $nesting);
};

Opal.modules["corelib/string"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  var $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $global_regexp = Opal.global_regexp, $prop = Opal.prop, $opal32_init = Opal.opal32_init, $opal32_add = Opal.opal32_add, $transform_regexp = Opal.transform_regexp, $str = Opal.str, $str_with_enc = Opal.str_with_enc, $klass = Opal.klass, $to_s = Opal.to_s, $Kernel = Opal.Kernel, $gvars = Opal.gvars, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $Opal = Opal.Opal, $defs = Opal.defs, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $alias = Opal.alias, $eqeq = Opal.eqeq, $rb_le = Opal.rb_le, $hash_new = Opal.hash_new, $rb_lt = Opal.rb_lt, $rb_plus = Opal.rb_plus, $thrower = Opal.thrower, $not = Opal.not, $const_set = Opal.const_set, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,attr_reader,raise,escape,new,coerce_to?,initialize,===,format,frozen?,dup,respond_to?,to_s,to_str,<=>,==,=~,bytesize,internal_encoding,to_a,each_byte,each,to_proc,byteslice,downcase,nil?,empty?,length,<=,each_char,coerce_to!,class,copy_singleton_methods,initialize_clone,each_codepoint,initialize_dup,enum_for,size,valid_encoding?,chomp,is_a?,find,<,[],bytes,+,each_grapheme_cluster,to_i,each_line,match,match?,map,captures,force_encoding,encoding,!,scrub,next,proc,intern,include?,upcase,unicode_normalize,__id__,pristine');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Comparable'));
    self.$attr_reader("encoding", "internal_encoding");
    
    const MAX_STR_LEN = Number.MAX_SAFE_INTEGER;

    Opal.prop(self.$$prototype, '$$is_string', true);

    var string_id_map = new Map();

    function first_char(str) {
      return String.fromCodePoint(str.codePointAt(0));
    }

    // UTF-16 aware find_index_of, args:
    //   str: string
    //   search: the string to search for in str
    //   search_l: is optional, if given must be search.$length(), do NOT use search.length
    //   last: boolean, optional too, if true returns the last index otherwise the first
    function find_index_of(str, search, search_l, last) {
      let search_f = (search.length === 1) ? search : first_char(search);
      let i = 0, col = [], l = 0, idx = -1;
      for (const c of str) {
        if (col.length > 0) {
          for (const e of col) {
            if (e.l < l) { e.search += c; e.l++; }
            if (e.l === l) {
              if (e.search == search) { if (last) idx = e.index; else return e.index; }
              e.search = null;
            }
          }
          if (!col[0].search) col.shift();
        }
        if (search_f == c) {
          if (search.length === 1) { if (last) idx = i; else return i; }
          else {
            if (l === 0) l = search_l || search.$length();
            if (l === 1) { if (last) idx = i; else return i; }
            else col.push({ index: i, search: c, l: 1 });
          }
        }
        i++;
      }
      return idx;
    }

    // multi byte character aware find_byte_index_of, args:
    //   str: string
    //   search: the string to search for in str
    //   search_l: is optional, if given must be search.$length(), do NOT use search.length
    //   last: boolean, optional too, if true returns the last index otherwise the first
    function find_byte_index_of(str, search, search_l, offset, last) {
      let search_f;
      if (search.length === 0 || search.length === 1) search_f = search;
      else search_f = first_char(search);
      let i = 0, col = [], l = 0, idx = -1, hit_boundary = (offset === 0) ? true : false;
      if (last) l = search_l || search.$length();
      for (const c of str) {
        if (col.length > 0) {
          for (const e of col) {
            if (e.l < l) { e.search += c; e.l++; }
            if (e.l === l) {
              if (e.search == search) { if (last) idx = e.index; else return e.index; }
              e.search = null;
            }
          }
          if (!col[0].search) col.shift();
        }
        if (!(!last && offset > 0 && i < offset)) {
          if (last && ((l < 2 && i > offset) || (i > offset + l))) {
            break;
          } else if (search_f == c) {
            if (search.length === 1) { if (last && i <= offset) idx = i; else return i; }
            else {
              if (l === 0) l = search_l || search.$length();
              if (l === 1) { if (last && i <= offset) idx = i; else return i; }
              else if (!(last && i > offset)) col.push({ index: i, search: c, l: 1 });
            }
          }
        }
        i += c.$bytesize();
        if (offset === i) hit_boundary = true;
      }
      if (!last && i < offset) return -1;
      if (last && offset > i) {
        if (search.length === 0) return i;
        return idx;
      }
      if ((!hit_boundary) && (idx > -1 || search.length === 0))
        self.$raise($$('IndexError'), "offset " + $to_s(offset) + " does not land on character boundary");
      if (search.length === 0) return offset;
      return idx;
    }

    // UTF-16 aware cut_from_end, cuts characters from end
    //   str: the string to cut
    //   cut_l: the length, count of characters to cut
    function cut_from_end(str, cut_l) {
      let i = str.length - 1, curr_cp;
      for (; i >= 0; i--) {
        curr_cp = str.codePointAt(i);
        if (curr_cp >= 0xDC00 && curr_cp <= 0xDFFF) continue; // low surrogate, get the full code point
        cut_l--;
        if (cut_l === 0) break;
      }
      return str.slice(0, i);
    }

    function padding(padstr, width) {
      let result_l = 0,
          result = '',
          p_l = padstr.length,
          padstr_l = p_l === 1 ? p_l : padstr.$length();

      while (result_l < width) {
        result += padstr;
        result_l += padstr_l;
      }

      if (result_l === width) return result;
      if (p_l === padstr_l) return result.slice(0, width);
      return cut_from_end(result, result_l - width);
    }

    function starts_with_low_surrogate(str) {
      if (str.length === 0) return false;
      let cp = str.codePointAt(0);
      if (cp >= 0xDC00 && cp <= 0xDFFF) return true;
      return false;
    }

    function ends_with_high_surrogate(str) {
      if (str.length === 0) return false;
      let cp = str.codePointAt(str.length - 1);
      if (cp >= 0xD800 && cp <= 0xDBFF) return true;
      return false;
    }

    function starts_with(str, prefix) {
      return (str.length >= prefix.length && !ends_with_high_surrogate(prefix) && str.startsWith(prefix));
    }

    function ends_with(str, suffix) {
      return (str.length >= suffix.length && !starts_with_low_surrogate(suffix) && str.endsWith(suffix));
    }

    let GRAPHEME_SEGMENTER; // initialized on demand by #each_grapheme_cluster below using:

    function grapheme_segmenter() {
      if (!GRAPHEME_SEGMENTER) {
        // Leaving the locale parameter as undefined, indicating browsers default locale.
        // Depending on implementation quality and default locale, there is a chance,
        // that grapheme segmentation results differ.
        GRAPHEME_SEGMENTER = new Intl.Segmenter(undefined, { granularity: "grapheme" });
      }
      return GRAPHEME_SEGMENTER;
    }

    function char_class_from_char_sets(sets) {
      function explode_sequences_in_character_set(set_s) {
        var result = [],
            i, len = set_s.length,
            curr_char,
            skip_next_dash,
            code_point_from,
            code_point_upto,
            code_point;
        for (i = 0; i < len; i++) {
          curr_char = set_s[i];
          if (curr_char === '-' && i > 0 && i < (len - 1) && !skip_next_dash) {
            code_point_from = set_s[i - 1].codePointAt(0);
            code_point_upto = set_s[i + 1].codePointAt(0);
            if (code_point_from > code_point_upto) {
              $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + $to_s(code_point_from) + "-" + $to_s(code_point_upto) + "\" in string transliteration")
            }
            for (code_point = code_point_from + 1; code_point < code_point_upto + 1; code_point++) {
              if (code_point >= 0xD800 && code_point <= 0xDFFF) code_point = 0xE000; // exclude surrogate range
              result.push(String.fromCodePoint(code_point));
            }
            skip_next_dash = true;
            i++;
          } else {
            skip_next_dash = (curr_char === '\\');
            result.push(curr_char);
          }
        }
        return result;
      }

      function intersection(setA, setB) {
        if (setA.length === 0) {
          return setB;
        }
        var result = [],
            i, len = setA.length,
            chr;
        for (i = 0; i < len; i++) {
          chr = setA[i];
          if (setB.indexOf(chr) !== -1) {
            result.push(chr);
          }
        }
        return result;
      }

      var i, len, set, set_s, neg, chr, tmp,
          pos_intersection = [],
          neg_intersection = [];

      for (i = 0, len = sets.length; i < len; i++) {
        set = $coerce_to(sets[i], $$$('String'), 'to_str');
        set_s = [];
        for (const c of set) {
          let cd = c.codePointAt(0);
          if (cd < 0xD800 || cd > 0xDFFF) set_s.push(c); // exclude surrogate range
        }
        neg = (set_s[0] === '^' && set_s.length > 1);
        set_s = explode_sequences_in_character_set(neg ? set_s.slice(1) : set_s);
        if (neg) {
          neg_intersection = intersection(neg_intersection, set_s);
        } else {
          pos_intersection = intersection(pos_intersection, set_s);
        }
      }

      if (pos_intersection.length > 0 && neg_intersection.length > 0) {
        tmp = [];
        for (i = 0, len = pos_intersection.length; i < len; i++) {
          chr = pos_intersection[i];
          if (neg_intersection.indexOf(chr) === -1) {
            tmp.push(chr);
          }
        }
        pos_intersection = tmp;
        neg_intersection = [];
      }

      if (pos_intersection.length > 0) {
        return '[' + $$$('Regexp').$escape(pos_intersection.join('')) + ']';
      }

      if (neg_intersection.length > 0) {
        return '[^' + $$$('Regexp').$escape(neg_intersection.join('')) + ']';
      }

      return null;
    }

    function slice_by_string(string, index, length) {
      if (length != null) $Kernel.$raise($$$('TypeError'));
      if (find_index_of(string, index) === -1) return nil;
      return index.toString();
    }

    function slice_by_regexp(string, index, length) {
      let match = string.match(index);
      if (match === null) {
        ($gvars["~"] = nil)
        return nil;
      }
      ($gvars["~"] = $$$('MatchData').$new(index, match))
      if (length == null) return match[0];
      length = $coerce_to(length, $$$('Integer'), 'to_int');
      if (length < 0 && -length < match.length) {
        return match[length += match.length];
      }
      if (length >= 0 && length < match.length) {
        return match[length];
      }
      return nil;
    }

    function slice_by_index_neg(string, index, length) {
      // negative index, walk from the end of the string,
      if (index < -string.length || length < -string.length) return nil;
      let j = string.length - 1, i = -1, result = '', result_l = 0, curr_cp, idx_end, max;
      if (length != null) {
        if (length < 0) max = length;
        else if (length === Infinity || (index + length >= 0)) max = -1;
        else max = index + length - 1;
      }
      for (; j >= 0; j--) {
        curr_cp = string.codePointAt(j);
        if (curr_cp >= 0xDC00 && curr_cp <= 0xDFFF) continue; // low surrogate, get the full code point next
        if (length != null && i <= max) {
          if (!idx_end) idx_end = (curr_cp > 0xDFFF) ? j + 2 : j + 1;
          result_l++;
        }
        if (i === index) {
          if (length === 0 || index === length) return "";
          if (length === 1 || length == null) return String.fromCodePoint(curr_cp);
          break;
        }
        i--;
      }
      if (result_l > 0) {
        result = string.slice(j, idx_end);
        if (length < 0 && ((result_l + length) < 0)) return "";
        return result;
      }
      return nil;
    }

    function slice_by_index_zero(string, length) {
      // special conditions
      if (length === 0 || string.length === 0) return (length != null) ? "" : nil;
      if (length === 1 || length == null) return first_char(string);
      if (length === Infinity) return string.toString();
      // walk the string
      let i = 0, result = '';
      for (const c of string) {
        result += c;
        i++;
        if (i === length) break;
      }
      if (length < 0) {
        // if length is a negative index from a range, we walked to the end, so shorten the result
        if ((i + length) > 0) return cut_from_end(result, -length);
        else return "";
      }
      return result;
    }

    function slice_by_index_pos(string, index, length) {
      let i = 0, result_l = 0, result;
      for (const c of string) {
        if (i < index) {
          i++;
        } else if (i === index) {
          if (length === 1 || length == null) return c;
          if (length === 0) return "";
          result = c;
          i++; result_l++;
        } else if (i > index) {
          if (result_l < length || length < 0) {
            result += c;
            i++; result_l++;
          } else if (length > 0 && result_l >= length) break;
        }
      }
      if (result) {
        if (length < 0) {
          // if length is a negative index from a range, we walked to the end, so shorten the result
          if ((result_l + length) > 0) return cut_from_end(result, -length);
          else return "";
        }
        if (result_l > 0 && index <= i && length > 1) return result;
      }
      // special condition for ruby weirdness
      if (i === index && length != null) return "";
      return nil;
    }

    function slice(string, index, length) {
      if (index.$$is_string) return slice_by_string(string, index, length);
      if (index.$$is_regexp) return slice_by_regexp(string, index, length);

      if (index.$$is_range) {
        if (length) self.$raise($$('TypeError'), "length not allowed if range is given");
        // This part sets index and length, basically converting string[2..3] range
        // to string[2, 1] index + length and letting the range get handled by the
        // index + length code below.
        //
        // For ranges, first index always is a index, possibly negative.
        // Length is either the length, if it can be determined by the indexes of the range,
        // or its a possibly negative index, because the exact string length is not known,
        // or Infinity, with Infinity indicating 'walk to end of string'.
        const range = index;
        const r_end = range.end === nil ? Infinity : $coerce_to(range.end, $$$('Integer'), 'to_int');
        index = range.begin === nil ? 0 : $coerce_to(range.begin, $$$('Integer'), 'to_int');

        if (((index > 0 && r_end > 0) || (index < 0 && r_end < 0)) && index > r_end) {
          length = 0;
        } else if (index === r_end) {
          length = range.excl ? 0 : 1;
        } else {
          const e = range.excl ? 0 : 1;
          if ((!range.excl && r_end === -1) || r_end === Infinity) length = Infinity;
          else if (index == 0 || (index > 0 && r_end < 0)) length = r_end === Infinity ? Infinity : (r_end + e);
          else if (index < 0 && r_end >= 0) length = 0;
          else if ((index < 0 && r_end < 0) || (index > 0 && r_end > 0)) {
            length = r_end === Infinity ? Infinity : (r_end - index + e);
            if (length < 0) length = 0;
          }
        }
      } else {
        index = $coerce_to(index, $$$('Integer'), 'to_int');
        if (length != null) length = $coerce_to(length, $$$('Integer'), 'to_int');
        if (length < 0) return nil;
      }

      if (index > MAX_STR_LEN) self.$raise($$('RangeError'), "index too large");
      if (length !== Infinity && length > MAX_STR_LEN) self.$raise($$('RangeError'), "length too large");
      if (index < 0) return slice_by_index_neg(string, index, length);
      if (index === 0) return slice_by_index_zero(string, length);
      return slice_by_index_pos(string, index, length);
    }

    function raise_if_not_stringish(obj) {
      if (obj === nil) self.$raise($$('TypeError'), "no implicit conversion of nil into String");
      if (typeof obj === "number") self.$raise($$('TypeError'), "no implicit conversion of Integer into String");
      if (obj === true || obj === false) self.$raise($$('TypeError'), "no implicit conversion of " + $to_s(obj) + " into String");
    }

    function case_options_have_ascii(options, allow_fold) {
      let ascii = false, fold = false;
      if (options.length > 0) {
        for(const option of options) {
          if (option == "ascii") ascii = true;
          else if (options == "fold") fold = true;
          else self.$raise($$('ArgumentError'), "unknown option :" + $to_s(option))
        }
        if (!allow_fold) {
          if (fold && ascii) self.$raise($$('ArgumentError'), "too many options");
          if (fold) self.$raise($$('ArgumentError'), ":fold not allowed");
        }
      }
      return ascii;
    }
  ;
    
    (function() {
      'use strict';
      ($def(self, '$__id__', function $$__id__() {
      var $yield = $$__id__.$$p || nil, self = this;

      $$__id__.$$p = null;
      
            if (typeof self === 'object') {
              return $send2(self, $find_super(self, '__id__', $$__id__, false, true), '__id__', [], $yield)
            }
            if (string_id_map.has(self)) {
              return string_id_map.get(self);
            }
            var id = Opal.uid();
            string_id_map.set(self, id);
            return id;
          
    }), $def(self, '$hash', function $$hash() {
      var self = this;

      
            var hash = $opal32_init(), i, length = self.length;
            hash = $opal32_add(hash, 0x5);
            hash = $opal32_add(hash, length);
            for (i = 0; i < length; i++) {
              hash = $opal32_add(hash, self.charCodeAt(i));
            }
            return hash;
          
    }))
    })();
  ;
    $defs(self, '$try_convert', function $$try_convert(what) {
      
      return $Opal['$coerce_to?'](what, $$$('String'), "to_str")
    });
    $defs(self, '$new', function $String_new$1($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      var str = args[0] || "";
      var opts = args[args.length-1];
      str = $coerce_to(str, $$$('String'), 'to_str');
      if (self.$$constructor === String) {
        str = $str(str);
      } else {
        str = new self.$$constructor(str);
      }
      if (opts && opts.$$is_hash) {
        if (opts.has('encoding')) str = str.$force_encoding(opts.get('encoding'));
      }
      if (!str.$initialize.$$pristine) $send((str), 'initialize', $to_a(args));
      return str;
    ;
    }, -1);
    
    $def(self, '$initialize', function $$initialize($a, $b) {
      var $post_args, $kwargs, str, encoding, capacity;

      
      $post_args = $slice(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      
      if ($post_args.length > 0) str = $post_args.shift();;
      
      encoding = $hash_get($kwargs, "encoding");if (encoding == null) encoding = nil;
      
      capacity = $hash_get($kwargs, "capacity");if (capacity == null) capacity = nil;
      return nil;
    }, -1);
    
    $def(self, '$%', function $String_$percent$2(data) {
      var self = this;

      if ($eqeqeq($$$('Array'), data)) {
        return $send(self, 'format', [self].concat($to_a(data)))
      } else {
        return self.$format(self, data)
      }
    });
    
    $def(self, '$*', function $String_$$3(count) {
      var self = this;

      
      count = $coerce_to(count, $$$('Integer'), 'to_int');

      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative argument")
      }

      if (count === 0) {
        return '';
      }

      var result = '',
          string = self.toString();

      // All credit for the bit-twiddling magic code below goes to Mozilla
      // polyfill implementation of String.prototype.repeat() posted here:
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat

      if (string.length * count >= MAX_STR_LEN) {
        $Kernel.$raise($$$('RangeError'), "multiply count must not overflow maximum string size")
      }

      for (;;) {
        if ((count & 1) === 1) {
          result += string;
        }
        count >>>= 1;
        if (count === 0) {
          break;
        }
        string += string;
      }

      return result;
    
    });
    
    $def(self, '$+', function $String_$plus$4(other) {
      var self = this;

      
      other = $coerce_to(other, $$$('String'), 'to_str');
      
      if (other.length === 0 && self.$$class === Opal.String) return self;
      if (self.length === 0 && other.$$class === Opal.String) return other;
      var out = self + other;
      if (self.encoding === out.encoding && other.encoding === out.encoding) return out;
      if (self.encoding.name === "UTF-8" || other.encoding.name === "UTF-8") return out;
      return Opal.enc(out, self.encoding);
    ;
    });
    
    $def(self, '$+@', function $String_$plus$$5() {
      var self = this;

      if ($truthy(self['$frozen?']())) {
        return self.$dup()
      } else {
        return self
      }
    });
    
    $def(self, '$-@', function $String_$minus$$6() {
      var self = this;

      
      if (typeof self === 'string' || self.$$frozen) return self;
      if (self.encoding.name == 'UTF-8' && self.internal_encoding.name == 'UTF-8') return self.toString();
      return self.$dup().$freeze();
    
    });
    
    $def(self, '$<=>', function $String_$lt_eq_gt$7(other) {
      var self = this;

      if ($truthy(other['$respond_to?']("to_str"))) {
        
        other = other.$to_str().$to_s();
        return self > other ? 1 : (self < other ? -1 : 0);;
      } else {
        
        var cmp = other['$<=>'](self);

        if (cmp === nil) {
          return nil;
        }
        else {
          return cmp > 0 ? -1 : (cmp < 0 ? 1 : 0);
        }
      
      }
    });
    
    $def(self, '$==', function $String_$eq_eq$8(other) {
      var self = this;

      
      if (other.$$is_string) {
        return self.toString() === other.toString();
      }
      if ($respond_to(other, '$to_str')) {
        return other['$=='](self);
      }
      return false;
    
    });
    $alias(self, "===", "==");
    
    $def(self, '$=~', function $String_$eq_tilde$9(other) {
      var self = this;

      
      if (other.$$is_string) {
        $Kernel.$raise($$$('TypeError'), "type mismatch: String given");
      }

      return other['$=~'](self);
    
    });
    
    $def(self, '$[]', function $String_$$$10(index, length) {
      var self = this, result = nil;

      
      ;
      result = slice(self, index, length);
      if ($truthy(result)) {
        
        if (self.encoding === Opal.Encoding?.UTF_8) return result;
        return $str_with_enc(result, self.encoding);
      
      };
      return nil;
    }, -2);
    
    $def(self, '$ascii_only?', function $String_ascii_only$ques$11() {
      var self = this;

      
      if (!self.encoding?.ascii) return false;
      return /^[\x00-\x7F]*$/.test(self);
    
    });
    
    $def(self, '$b', function $$b() {
      var self = this;

      return $str_with_enc(self, 'binary');
    });
    
    $def(self, '$byteindex', function $$byteindex(search, offset) {
      var self = this;

      
      if (offset == null) offset = 0;
      
      let index, match, regex;

      if (offset == nil || offset == null) {
        offset = 0;
      } else {
        offset = $coerce_to(offset, $$$('Integer'), 'to_int');
        if (offset < 0) {
          offset += self.$bytesize();
          if (offset < 0) return nil;
        }
      }

      raise_if_not_stringish(search);

      if (search.$$is_regexp) {
        let str, b_size;
        if (offset > 0) {
          // because we cannot do binary RegExp, we byteslice self from offset
          // then exec the regexp on the remaining string, getting the
          // char index, and then measure the bytesize until the char index
          b_size = self.$bytesize();
          if (offset > b_size) return nil;
          str = self.$byteslice(offset, b_size - offset);
        }
        else str = self;
        regex = $global_regexp(search);
        match = regex.exec(str);
        if (match === null) {
          ($gvars["~"] = nil);
          return nil;
        }
        ($gvars["~"] = $$$('MatchData').$new(regex, match));
        index = match.index;
        if (index === 0) return offset;
        return offset + self.$internal_encoding().$bytesize(str, index - 1);
      }
      search = $coerce_to(search, $$$('String'), 'to_str');
      index = find_byte_index_of(self, search, search.$length(), offset, false);
      if (index === -1) return nil;
      return index;
    ;
    }, -2);
    
    $def(self, '$byterindex', function $$byterindex(search, offset) {
      var self = this;

      
      ;
      
      let index, match, regex, _m;

      if (offset == undefined) {
        offset = self.$bytesize();
      } else {
        offset = $coerce_to(offset, $$$('Integer'), 'to_int');
        if (offset < 0) {
          offset += self.$bytesize();
          if (offset < 0) return nil;
        }
      }

      raise_if_not_stringish(search);

      if (search.$$is_regexp) {
        let br_idx, b_length = self.$bytesize();
        if (offset < b_length)
          br_idx = self.$byteslice(0, offset + 1).length - 1;
        match = null;
        regex = $global_regexp(search);
        while (true) {
          _m = regex.exec(self);
          if (_m === null || _m.index > br_idx) break;
          match = _m;
          regex.lastIndex = match.index + 1;
        }
        if (match === null) {
          ($gvars["~"] = nil)
          return nil;
        }
        ($gvars["~"] = $$$('MatchData').$new(regex, match));
        index = match.index;
        if (index === 0) return 0;
        return self.$internal_encoding().$bytesize(self, index - 1);
      }
      search = $coerce_to(search, $$$('String'), 'to_str');
      index = find_byte_index_of(self, search, search.$length(), offset, true);
      if (index === -1) return nil;
      return index;
    ;
    }, -2);
    
    $def(self, '$bytes', function $$bytes() {
      var block = $$bytes.$$p || nil, self = this, res = nil;

      $$bytes.$$p = null;
      
      ;
      res = self.$each_byte().$to_a();
      if (!(block !== nil)) {
        return res
      };
      $send(res, 'each', [], block.$to_proc());
      return self;
    });
    
    $def(self, '$bytesize', function $$bytesize() {
      var self = this;

      return self.$internal_encoding().$bytesize(self, self.length)
    });
    
    $def(self, '$byteslice', function $$byteslice(index, length) {
      var self = this, result = nil;

      
      ;
      
      if (index.$$is_range) {
        if (length) self.$raise($$('TypeError'), "length not allowed if range is given");
        // This part sets index and length, basically converting self[2..3] range
        // to self[2, 1] index + length and letting the range get handled by the
        // index + length code below.
        const range = index;
        const r_end = index.end === nil ? Infinity : $coerce_to(range.end, $$$('Integer'), 'to_int');
        index = range.begin === nil ? 0 : $coerce_to(range.begin, $$$('Integer'), 'to_int');

        if (((index > 0 && r_end > 0) || (index < 0 && r_end <0)) && index > r_end) {
          length = 0;
        } else if (index === r_end) {
          length = range.excl ? 0 : 1;
        } else {
          const e = range.excl ? 0 : 1;
          if ((!range.excl && r_end === -1) || r_end === Infinity) length = Infinity;
          else if (index == 0 || (index > 0 && r_end < 0)) length = r_end === Infinity ? Infinity : (r_end + e);
          else if (index < 0 && r_end >= 0) length = 0;
          else if ((index < 0 && r_end < 0) || (index > 0 && r_end > 0)) {
            length = r_end === Infinity ? Infinity : (r_end - index + e);
            if (length < 0) length = 0;
          }
        }
      } else {
        index = $coerce_to(index, $$$('Integer'), 'to_int');
        if (length != null) length = $coerce_to(length, $$$('Integer'), 'to_int');
        if (length < 0) return nil;
        if (length == null || length === nil) {
          if (self.length === 0) return nil; // no match possible
          length = 1;
        }
      }
      if (index > MAX_STR_LEN) self.$raise($$('RangeError'), "index too large");
      if (length !== Infinity && length > MAX_STR_LEN) self.$raise($$('RangeError'), "length too large");
    ;
      result = self.$internal_encoding().$byteslice(self, index, length);
      if ($truthy(result)) {
        
        if (self.encoding === Opal.Encoding?.UTF_8) return result;
        return $str_with_enc(result, self.encoding);
      
      };
      return result;
    }, -2);
    
    $def(self, '$capitalize', function $$capitalize($a) {
      var $post_args, options, self = this;

      
      $post_args = $slice(arguments);
      options = $post_args;
      
      if (self.length === 0) return '';
      let first = first_char(self);
      if (case_options_have_ascii(options) && first.codePointAt(0) > 127) return self;
      let first_upper = first.toUpperCase();
      if (first_upper.length > first.length && first_upper.codePointAt(0) < 128) {
        first_upper = first_upper[0] + first_upper[1].toLowerCase();
      }
      let capz = first_upper + self.substring(first.length).toLowerCase();
      return capz.$force_encoding(self.encoding);
    ;
    }, -1);
    
    $def(self, '$casecmp', function $$casecmp(other) {
      var self = this;

      
      if (!$truthy(other['$respond_to?']("to_str"))) {
        return nil
      };
      other = ($coerce_to(other, $$$('String'), 'to_str')).$to_s();
      return self.$downcase("ascii")['$<=>'](other.$downcase("ascii"));
    });
    
    $def(self, '$casecmp?', function $String_casecmp$ques$12(other) {
      var self = this, c = nil;

      
      if (!$truthy(other['$respond_to?']("to_str"))) {
        return nil
      };
      other = ($coerce_to(other, $$$('String'), 'to_str')).$to_s();
      c = self.$downcase("fold")['$<=>'](other.$downcase("fold"));
      if ($eqeq(c, 0)) {
        return true
      };
      if ($truthy(c['$nil?']())) {
        return nil
      };
      return false;
    });
    
    $def(self, '$center', function $$center(width, padstr) {
      var self = this, l = nil;

      
      if (padstr == null) padstr = " ";
      width = $coerce_to(width, $$$('Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$$('String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        $Kernel.$raise($$$('ArgumentError'), "zero width padding")
      };
      l = self.$length();
      if ($truthy($rb_le(width, l))) {
        return self
      };
      
      return (padding(padstr, Math.floor((width + l) / 2) - l) +
             self +
             padding(padstr, Math.ceil((width + l) / 2) - l))
             .$force_encoding(self.encoding);
    ;
    }, -2);
    
    $def(self, '$chars', function $$chars() {
      var block = $$chars.$$p || nil, self = this;

      $$chars.$$p = null;
      
      ;
      if ((block !== nil)) {
        return $send(self, 'each_char', [], block.$to_proc())
      };
      return self.$each_char().$to_a();
    });
    
    $def(self, '$chomp', function $$chomp(separator) {
      var self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      if (separator == null) separator = $gvars["/"];
      if ($truthy(separator === nil || self.length === 0)) {
        return self
      };
      separator = $Opal['$coerce_to!'](separator, $$$('String'), "to_str").$to_s();
      
      var result;

      if (separator === "\n") {
        result = self.replace(/\r?\n?$/, '');
      }
      else if (separator.length === 0) {
        result = self.replace(/(\r?\n)+$/, '');
      }
      else if (self.length >= separator.length &&
               !starts_with_low_surrogate(separator) &&
               !ends_with_high_surrogate(separator)) {

        // compare tail with separator
        if (self.substring(self.length - separator.length) === separator) {
          result = self.substring(0, self.length - separator.length);
        }
      }

      if (result != null) {
        return result.$force_encoding(self.encoding);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$chop', function $$chop() {
      var self = this;

      
      var length = self.length, result;

      if (length <= 1) {
        result = "";
      } else if (self.charAt(length - 1) === "\n" && self.charAt(length - 2) === "\r") {
        result = self.substring(0, length - 2);
      } else {
        let cut = self.codePointAt(length - 2) > 0xFFFF ? 2 : 1;
        result = self.substring(0, length - cut);
      }
      return result.$force_encoding(self.encoding);
    
    });
    
    $def(self, '$chr', function $$chr() {
      var self = this;

      
      let result = self.length > 0 ? first_char(self) : '';
      return result.$force_encoding(self.encoding);
    
    });
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this, copy = nil;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $hash_get($kwargs, "freeze");if (freeze == null) freeze = nil;
      if (!(($truthy(freeze['$nil?']()) || ($eqeq(freeze, true))) || ($eqeq(freeze, false)))) {
        self.$raise($$('ArgumentError'), "unexpected value for freeze: " + $to_s(freeze.$class()))
      };
      copy = $str(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self, $hash_new("freeze", freeze));
      if ($eqeq(freeze, true)) {
        if (!copy.$$frozen) copy.$$frozen = true;
      } else if ($truthy(freeze['$nil?']())) {
        if (self.$$frozen) copy.$$frozen = true;
      };
      return copy;
    }, -1);
    
    $def(self, '$codepoints', function $$codepoints() {
      var block = $$codepoints.$$p || nil, self = this;

      $$codepoints.$$p = null;
      
      ;
      if ((block !== nil)) {
        return $send(self, 'each_codepoint', [], block.$to_proc())
      };
      return self.$each_codepoint().$to_a();
    });
    
    $def(self, '$count', function $$count($a) {
      var $post_args, sets, self = this;

      
      $post_args = $slice(arguments);
      sets = $post_args;
      
      if (sets.length === 0) {
        $Kernel.$raise($$$('ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      let char_class = char_class_from_char_sets(sets);
      if (char_class === null) return 0;

      let pattern_flags = $transform_regexp(char_class, 'gu');
      return self.$length() - self.replace(new RegExp(pattern_flags[0], pattern_flags[1]), '').$length();
    ;
    }, -1);
    
    $def(self, '$delete', function $String_delete$13($a) {
      var $post_args, sets, self = this;

      
      $post_args = $slice(arguments);
      sets = $post_args;
      
      if (sets.length === 0) {
        $Kernel.$raise($$$('ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      let char_class = char_class_from_char_sets(sets);
      if (char_class === null) return self;

      let pattern_flags = $transform_regexp(char_class, 'gu');
      return self.replace(new RegExp(pattern_flags[0], pattern_flags[1]), '')
             .$force_encoding(self.encoding);
    ;
    }, -1);
    
    $def(self, '$delete_prefix', function $$delete_prefix(prefix) {
      var self = this;

      
      if (!prefix.$$is_string) {
        prefix = $coerce_to(prefix, $$$('String'), 'to_str');
      }
      if (starts_with(self, prefix)) {
        return self.slice(prefix.length).$force_encoding(self.encoding);
      }
      return self;
    
    });
    
    $def(self, '$delete_suffix', function $$delete_suffix(suffix) {
      var self = this;

      
      if (!suffix.$$is_string) {
        suffix = $coerce_to(suffix, $$$('String'), 'to_str');
      }
      if (ends_with(self, suffix)) {
        return self.slice(0, self.length - suffix.length).$force_encoding(self.encoding);
      }
      return self;
    
    });
    
    $def(self, '$downcase', function $$downcase($a) {
      var $post_args, options, self = this;

      
      $post_args = $slice(arguments);
      options = $post_args;
      
      let str = self;

      if (options.length > 0){
        if (case_options_have_ascii(options, true)) {
          str = str.replace(/[A-Z]+/g, (match)=>{ return match.toLowerCase(); });
        } else if (options.includes('fold')) {
          str = str.toUpperCase(); // ß -> SS
          str = str.toLowerCase(); // SS -> ss
        }
      } else {
        str = str.toLowerCase();
      }
      return str.$force_encoding(self.encoding);
    ;
    }, -1);
    
    $def(self, '$dump', function $$dump() {
      var self = this;

      
      /* eslint-disable no-misleading-character-class */
      let e = "[\\\\\"\x00-\x1F\x7F-\xFF\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f" +
              String.fromCharCode(0xd800) + '-' + String.fromCharCode(0xdfff) + "\ufeff\ufff0-\uffff]",
          escapable = new RegExp(e, 'g'),
          meta = {
            '\u0007': '\\a',
            '\u001b': '\\e',
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '\v': '\\v',
            '"' : '\\"',
            '\\': '\\\\'
          },
          prev_chr = '',
          is_utf8 = (self.encoding == Opal.Encoding.UTF_8),
          escaped = self.replace(escapable, function (chr) {
            if (meta[chr]) return meta[chr];
            const char_code = chr.charCodeAt(0);
            if ((!is_utf8 && char_code <= 0xff) || (is_utf8 && char_code < 0x80)) {
              return '\\x' + ('00' + char_code.toString(16).toUpperCase()).slice(-2);
            } else if (char_code >= 0xD800 && char_code <= 0xDBFF) {
              prev_chr = chr;
              return '';
            } else if (char_code >= 0xDC00 && char_code <= 0xDFFF) {
              return '\\u{' + (prev_chr + chr).codePointAt(0).toString(16).toUpperCase() + '}';
            } else {
              return '\\u' + ('0000' + char_code.toString(16).toUpperCase()).slice(-4);
            }
          });
      return ('"' + escaped.replace(/\#[\$\@\{]/g, '\\$&') + '"').$force_encoding(self.encoding);
      /* eslint-enable no-misleading-character-class */
    
    });
    
    $def(self, '$dup', function $$dup() {
      var self = this, copy = nil;

      
      copy = $str(self);
      copy.$initialize_dup(self);
      return copy;
    });
    
    $def(self, '$each_byte', function $$each_byte() {
      var block = $$each_byte.$$p || nil, self = this;

      $$each_byte.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_byte"], function $$14(){var self = $$14.$$s == null ? this : $$14.$$s;

          return self.$bytesize()}, {$$s: self})
      };
      $send(self.$internal_encoding(), 'each_byte', [self], block.$to_proc());
      return self;
    });
    
    $def(self, '$each_char', function $$each_char() {
      var block = $$each_char.$$p || nil, self = this;

      $$each_char.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_char"], function $$15(){var self = $$15.$$s == null ? this : $$15.$$s;

          return self.$size()}, {$$s: self})
      };
      
      for (let c of self) {
        c = $str_with_enc(c, self.encoding);
        c.encoding = self.encoding;
        Opal.yield1(block, c);
      }
    ;
      return self;
    });
    
    $def(self, '$each_codepoint', function $$each_codepoint() {
      var block = $$each_codepoint.$$p || nil, self = this;

      $$each_codepoint.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_codepoint"], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          return self.$length()}, {$$s: self})
      };
      if (!$truthy(self['$valid_encoding?']())) {
        self.$raise($$('ArgumentError'), "string has invalid encoding")
      };
      for (const c of self) Opal.yield1(block, c.codePointAt(0));
      return self;
    });
    
    $def(self, '$each_grapheme_cluster', function $$each_grapheme_cluster() {
      var block = $$each_grapheme_cluster.$$p || nil, self = this, clusters = nil;

      $$each_grapheme_cluster.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_grapheme_cluster"], function $$17(){var self = $$17.$$s == null ? this : $$17.$$s;

          return self.$length()}, {$$s: self})
      };
      clusters = grapheme_segmenter().segment(self);
      for (const cluster of clusters) Opal.yield1(block, cluster.segment.$force_encoding(self.encoding));
      return self;
    });
    
    $def(self, '$each_line', function $$each_line($a, $b) {
      var block = $$each_line.$$p || nil, $post_args, $kwargs, separator, chomp, self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      $$each_line.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      
      if ($post_args.length > 0) separator = $post_args.shift();if (separator == null) separator = $gvars["/"];
      
      chomp = $hash_get($kwargs, "chomp");if (chomp == null) chomp = false;
      if (!(block !== nil)) {
        return self.$enum_for("each_line", separator, $hash_new("chomp", chomp))
      };
      
      if (separator === nil) {
        Opal.yield1(block, self);

        return self;
      }

      separator = $coerce_to(separator, $$$('String'), 'to_str');

      var a, i, n, length, chomped, trailing, splitted, value;

      if (separator.length === 0) {
        for (a = self.split(/((?:\r?\n){2})(?:(?:\r?\n)*)/), i = 0, n = a.length; i < n; i += 2) {
          if (a[i] || a[i + 1]) {
            value = (a[i] || "") + (a[i + 1] || "");
            if (chomp) {
              value = (value).$chomp("\n");
            }
            Opal.yield1(block, value.$force_encoding(self.encoding));
          }
        }

        return self;
      }

      chomped  = self.$chomp(separator);
      trailing = self.length != chomped.length;

      if (starts_with_low_surrogate(separator) || ends_with_high_surrogate(separator)) {
        splitted = [chomped];
      } else {
        splitted = chomped.split(separator);
      }

      for (i = 0, length = splitted.length; i < length; i++) {
        value = splitted[i];
        if (i < length - 1 || trailing) {
          value += separator;
        }
        if (chomp) {
          value = (value).$chomp(separator);
        }
        Opal.yield1(block, value.$force_encoding(self.encoding));
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$empty?', function $String_empty$ques$18() {
      var self = this;

      return self.length === 0;
    });
    
    $def(self, '$encode', function $$encode(encoding) {
      var self = this;

      return Opal.enc(self, encoding);
    });
    
    $def(self, '$end_with?', function $String_end_with$ques$19($a) {
      var $post_args, suffixes, self = this;

      
      $post_args = $slice(arguments);
      suffixes = $post_args;
      
      for (let i = 0, length = suffixes.length; i < length; i++) {
        let suffix = $coerce_to(suffixes[i], $$$('String'), 'to_str').$to_s();
        if (ends_with(self, suffix)) return true;
      }
    ;
      return false;
    }, -1);
    $alias(self, "eql?", "==");
    $alias(self, "equal?", "===");
    
    $def(self, '$force_encoding', function $$force_encoding(encoding) {
      var self = this;

      
      if (encoding === self.encoding) return self;;
      if (!$truthy(encoding['$is_a?']($$$('Encoding')))) {
        
        encoding = $Opal['$coerce_to!'](encoding, $$$('String'), "to_str");
        encoding = $$$('Encoding').$find(encoding);
        if (encoding === self.encoding) return self;
      
      };
      return Opal.set_encoding(self, encoding.name);;
    });
    
    $def(self, '$getbyte', function $$getbyte(idx) {try { var $t_return = $thrower('return'); 
      var self = this, i = nil;

      
      idx = $Opal['$coerce_to!'](idx, $$$('Integer'), "to_int");
      if ($truthy($rb_lt(idx, 0))) {
        return self.$bytes()['$[]'](idx)
      };
      i = 0;
      $send(self, 'each_byte', [], function $$20(b){
        
        if (b == null) b = nil;
        if ($eqeq(i, idx)) {
          $t_return.$throw(b, $$20.$$is_lambda)
        };
        return (i = $rb_plus(i, 1));}, {$$ret: $t_return});
      return nil;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      } finally {$t_return.is_orphan = true;}
    });
    
    $def(self, '$grapheme_clusters', function $$grapheme_clusters() {
      var block = $$grapheme_clusters.$$p || nil, self = this;

      $$grapheme_clusters.$$p = null;
      
      ;
      if ((block !== nil)) {
        return $send(self, 'each_grapheme_cluster', [], block.$to_proc())
      };
      return self.$each_grapheme_cluster().$to_a();
    });
    
    $def(self, '$gsub', function $$gsub(pattern, replacement) {
      var block = $$gsub.$$p || nil, self = this;

      $$gsub.$$p = null;
      
      ;
      ;
      
      if (replacement === undefined && block === nil) {
        return self.$enum_for("gsub", pattern);
      }

      var result = '', match_data = nil, index = 0, match, _replacement;

      if (pattern.$$is_regexp) {
        pattern = $global_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/gu, '\\$&'), 'gmu');
      }

      var lastIndex;
      while (true) {
        match = pattern.exec(self);

        if (match === null) {
          ($gvars["~"] = nil)
          result += self.slice(index);
          break;
        }

        match_data = $$$('MatchData').$new(pattern, match);

        if (replacement === undefined) {
          lastIndex = pattern.lastIndex;
          _replacement = block(match[0]);
          pattern.lastIndex = lastIndex; // save and restore lastIndex
        }
        else if (replacement.$$is_hash) {
          _replacement = (replacement)['$[]'](match[0]).$to_s();
        }
        else {
          if (!replacement.$$is_string) {
            replacement = $coerce_to(replacement, $$$('String'), 'to_str');
          }
          _replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');
        }

        if (pattern.lastIndex === match.index) {
          result += (self.slice(index, match.index) + _replacement + (self[match.index] || ""));
          pattern.lastIndex += 1;
        }
        else {
          result += (self.slice(index, match.index) + _replacement)
        }
        index = pattern.lastIndex;
      }

      ($gvars["~"] = match_data)
      return result;
    ;
    }, -2);
    
    $def(self, '$hex', function $$hex() {
      var self = this;

      return self.$to_i(16)
    });
    
    $def(self, '$include?', function $String_include$ques$21(other) {
      var self = this;

      
      if (!other.$$is_string) {
        other = $coerce_to(other, $$$('String'), 'to_str');
      }
      if (other.length === 0) return true;
      return find_index_of(self, other) !== -1;
    
    });
    
    $def(self, '$index', function $$index(search, offset) {
      var self = this;

      
      ;
      
      let index;

      if (offset === undefined) offset = 0;
      else offset = $coerce_to(offset, $$$('Integer'), 'to_int');

      if (search.$$is_regexp) {
        let regex = $global_regexp(search);
        if (offset < 0) {
          offset += self.$length();
          if (offset < 0) return nil;
        }
        while (true) {
          let match = regex.exec(self);
          if (match === null) {
            ($gvars["~"] = nil);
            return nil;
          }
          if (match.index >= offset) {
            ($gvars["~"] = $$$('MatchData').$new(regex, match))
            return match.index;
          }
          regex.lastIndex = match.index + 1;
        }
      } else {
        search = $coerce_to(search, $$$('String'), 'to_str');
        if (search.length === 0) {
          let l = self.$length();
          if (offset > l) return nil;
          if (offset < 0) {
            offset += l;
            if (offset < 0) return nil;
          }
          return offset;
        } else {
          let str = self;
          if (offset < 0) {
            offset += self.$length();
            if (offset < 0) return nil;
          }
          if (offset > 0) {
            str = self["$[]"](offset, Infinity);
            if (str.length === 0 || str === nil) return nil;
          }
          index = find_index_of(str, search);
          if (index === -1) return nil;
          return index + offset;
        }
      }

      return nil;
    ;
    }, -2);
    
    $def(self, '$initialize_copy', function $$initialize_copy(other) {
      var self = this;

      
      self.encoding = other.encoding;
      self.internal_encoding = other.internal_encoding;
    
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      /* eslint-disable no-misleading-character-class */
      let escapable = /[\\\"\x00-\x1f\x7F-\xFF\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
          meta = {
            '\u0007': '\\a',
            '\u001b': '\\e',
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '\v': '\\v',
            '"' : '\\"',
            '\\': '\\\\'
          },
          char_code,
          is_binary = self.encoding["$binary?"]() || self.internal_encoding["$binary?"](),
          external_is_utf8 = Opal.Encoding.default_external == Opal.Encoding.UTF_8,
          escaped = self.replace(escapable, function (chr) {
            if (meta[chr]) return meta[chr];
            char_code = chr.charCodeAt(0);
            if (is_binary && char_code <= 0xff) {
              return '\\x' + ('00' + char_code.toString(16).toUpperCase()).slice(-2);
            } else if (external_is_utf8 && char_code >= 0xA0 && char_code <= 0xff) {
              return chr;
            } else {
              return '\\u' + ('0000' + char_code.toString(16).toUpperCase()).slice(-4);
            }
          });
      return '"' + escaped.replace(/\#[\$\@\{]/g, '\\$&') + '"';
      /* eslint-enable no-misleading-character-class */
    
    });
    
    $def(self, '$intern', function $$intern() {
      var self = this;

      return self.toString();
    });
    
    $def(self, '$length', function $$length() {
      var self = this;

      
      let length = 0;
      for (let _c of self) { length++; }
      return length;
    
    });
    
    $def(self, '$lines', function $$lines($a, $b) {
      var block = $$lines.$$p || nil, $post_args, $kwargs, separator, chomp, self = this, e = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      $$lines.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      
      if ($post_args.length > 0) separator = $post_args.shift();if (separator == null) separator = $gvars["/"];
      
      chomp = $hash_get($kwargs, "chomp");if (chomp == null) chomp = false;
      e = $send(self, 'each_line', [separator, $hash_new("chomp", chomp)], block.$to_proc());
      if ($truthy(block)) {
        return self
      } else {
        return e.$to_a()
      };
    }, -1);
    
    $def(self, '$ljust', function $$ljust(width, padstr) {
      var self = this, l = nil;

      
      if (padstr == null) padstr = " ";
      width = $coerce_to(width, $$$('Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$$('String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        $Kernel.$raise($$$('ArgumentError'), "zero width padding")
      };
      l = self.$size();
      if ($truthy($rb_le(width, l))) {
        return self
      };
      return (self + padding(padstr, width - l)).$force_encoding(self.encoding);;
    }, -2);
    
    $def(self, '$lstrip', function $$lstrip() {
      var self = this;

      return self.replace(/^[\x00\x09\x0a-\x0d\x20]*/, '');
    });
    
    $def(self, '$match', function $$match(pattern, pos) {
      var block = $$match.$$p || nil, self = this;

      $$match.$$p = null;
      
      ;
      ;
      if (($eqeqeq($$('String'), pattern) || ($truthy(pattern['$respond_to?']("to_str"))))) {
        pattern = $$$('Regexp').$new(pattern.$to_str())
      };
      if (!$eqeqeq($$$('Regexp'), pattern)) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + $to_s(pattern.$class()) + " (expected Regexp)")
      };
      return $send(pattern, 'match', [self, pos], block.$to_proc());
    }, -2);
    
    $def(self, '$match?', function $String_match$ques$22(pattern, pos) {
      var self = this;

      
      ;
      if (($eqeqeq($$('String'), pattern) || ($truthy(pattern['$respond_to?']("to_str"))))) {
        pattern = $$$('Regexp').$new(pattern.$to_str())
      };
      if (!$eqeqeq($$$('Regexp'), pattern)) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + $to_s(pattern.$class()) + " (expected Regexp)")
      };
      return pattern['$match?'](self, pos);
    }, -2);
    
    $def(self, '$next', function $$next() {
      var self = this;

      
      let i = self.length;
      if (i === 0) return '';

      let result = self,
          first_alphanum_char_index = self.search(/[a-zA-Z0-9]/),
          carry = false,
          code = null,
          prior_code;
      while (i--) {
        code = self.codePointAt(i);
        if (code >= 0xDC00 && code <= 0xDFFF) continue; // low surrogate, get the full code at next iteration
        if ((code >= 48 && code <= 57) ||
          (code >= 65 && code <= 90) ||
          (code >= 97 && code <= 122)) {
          switch (code) {
          case 57:
            carry = true;
            code = 48;
            break;
          case 90:
            carry = true;
            code = 65;
            break;
          case 122:
            carry = true;
            code = 97;
            break;
          default:
            carry = false;
            code += 1;
          }
        } else {
          if (first_alphanum_char_index === -1) {
            if (code === 255 || code === 0x10FFFF) {
              carry = true;
              code = 0;
            } else {
              carry = false;
              if (code === 0xD7FF) code = 0xE000;
              else code += 1;
            }
          } else {
            carry = true;
          }
        }
        result = result.slice(0, i) + String.fromCodePoint(code) + result.slice(i + 1);
        if (carry && (i === 0 || i === first_alphanum_char_index)) {
          switch (code) {
          case 65:
            break;
          case 97:
            break;
          default:
            code += 1;
          }
          if (i === 0) {
            result = String.fromCodePoint(code) + result;
          } else {
            result = result.slice(0, i) + String.fromCodePoint(code) + result.slice(i);
          }
          carry = false;
        }
        if (!carry) break;
      }
      return result.$force_encoding(self.encoding);
    
    });
    
    $def(self, '$oct', function $$oct() {
      var self = this;

      
      var result,
          string = self,
          radix = 8;

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/i, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x') {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          radix = 2;
          break;
        case '0':
        case '0o':
          radix = 8;
          break;
        case '0d':
          radix = 10;
          break;
        case '0x':
          radix = 16;
          break;
        }
        return head + tail;
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    
    });
    
    $def(self, '$ord', function $$ord() {
      var self = this;

      return self.codePointAt(0);
    });
    
    $def(self, '$partition', function $$partition(sep) {
      var self = this;

      
      var i, m;

      if (sep.$$is_regexp) {
        m = sep.exec(self);
        if (m === null) {
          i = -1;
        } else {
          $$$('MatchData').$new(sep, m);
          sep = m[0];
          i = m.index;
        }
      } else {
        sep = $coerce_to(sep, $$$('String'), 'to_str');
        if (starts_with_low_surrogate(sep) || ends_with_high_surrogate(sep)) i = -1;
        else i = self.indexOf(sep);
      }

      if (i === -1) return [self, ''.$force_encoding(sep.encoding), ''.$force_encoding(self.encoding)];

      return [
        self.slice(0, i).$force_encoding(self.encoding),
        self.slice(i, i + sep.length).$force_encoding(sep.encoding),
        self.slice(i + sep.length).$force_encoding(self.encoding)
      ];
    
    });
    
    $def(self, '$reverse', function $$reverse() {
      var self = this;

      
      let res = '';
      for (const c of self) { res = c + res; }
      return res.$force_encoding(self.encoding);
    
    });
    
    $def(self, '$rindex', function $$rindex(search, offset) {
      var self = this;

      
      ;
      
      let index, m, r, _m;

      if (offset === undefined) {
        offset = Infinity; // to avoid calling #size here, to call it only when necessary later on
      } else {
        offset = $coerce_to(offset, $$$('Integer'), 'to_int');
        if (offset < 0) {
          offset += self.$length();
          if (offset < 0) return nil;
        }
      }

      if (search.$$is_regexp) {
        if (offset === Infinity) offset = self.$length();
        m = null;
        r = $global_regexp(search);
        while (true) {
          _m = r.exec(self);
          if (_m === null || _m.index > offset) break;
          m = _m;
          r.lastIndex = m.index + 1;
        }
        if (m === null) {
          ($gvars["~"] = nil)
          return nil;
        } else {
          $$$('MatchData').$new(r, m);
          return m.index;
        }
      } else {
        search = $coerce_to(search, $$$('String'), 'to_str');
        if (search.length === 0) {
          let str_l = self.$length();
          if (offset > str_l) index = str_l;
          else index = offset;
        } else {
          let str = self,
              search_l = search.$length();
          if (offset !== Infinity && offset + search_l < self.$length()) {
            str = self["$[]"](0, offset + search_l);
          }
          index = find_index_of(str, search, search_l, true);
        }
      }

      return index === -1 ? nil : index;
    ;
    }, -2);
    
    $def(self, '$rjust', function $$rjust(width, padstr) {
      var self = this, l = nil;

      
      if (padstr == null) padstr = " ";
      width = $coerce_to(width, $$$('Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$$('String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        $Kernel.$raise($$$('ArgumentError'), "zero width padding")
      };
      l = self.$size();
      if ($truthy($rb_le(width, l))) {
        return self
      };
      return (padding(padstr, width - l) + self).$force_encoding(self.encoding);;
    }, -2);
    
    $def(self, '$rpartition', function $$rpartition(sep) {
      var self = this;

      
      var i, m, r, _m;

      if (sep.$$is_regexp) {
        m = null;
        r = $global_regexp(sep);

        while (true) {
          _m = r.exec(self);
          if (_m === null) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }

        if (m === null) {
          i = -1;
        } else {
          $$$('MatchData').$new(r, m);
          sep = m[0];
          i = m.index;
        }

      } else {
        sep = $coerce_to(sep, $$$('String'), 'to_str');
        if (starts_with_low_surrogate(sep) || ends_with_high_surrogate(sep)) i = -1;
        else i = self.lastIndexOf(sep);
      }

      if (i === -1) return [''.$force_encoding(self.encoding), ''.$force_encoding(sep.encoding), self];

      return [
        self.slice(0, i).$force_encoding(self.encoding),
        self.slice(i, i + sep.length).$force_encoding(sep.encoding),
        self.slice(i + sep.length).$force_encoding(self.encoding)
      ];
    
    });
    
    $def(self, '$rstrip', function $$rstrip() {
      var self = this;

      return self.replace(/[\x00\x09\x0a-\x0d\x20]*$/, '').$force_encoding(self.encoding);
    });
    
    $def(self, '$scan', function $$scan(pattern, $kwargs) {
      var block = $$scan.$$p || nil, no_matchdata, self = this;

      $$scan.$$p = null;
      
      ;
      $kwargs = $ensure_kwargs($kwargs);
      
      no_matchdata = $hash_get($kwargs, "no_matchdata");if (no_matchdata == null) no_matchdata = false;
      
      var result = [],
          match_data = nil,
          match, match_o, captures;

      if (pattern.$$is_regexp) {
        pattern = $global_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/gu, '\\$&'), 'gmu');
      }

      while ((match = pattern.exec(self)) != null) {
        match_data = $$$('MatchData').$new(pattern, match, $hash_new("no_matchdata", no_matchdata));
        if (match.length === 1) {
          match_o = match[0].$force_encoding(self.encoding);
          if (block === nil) result.push(match_o);
          else Opal.yield1(block, match_o);
        } else {
          captures = $send((match_data).$captures(), 'map', [], function $$23(c){var $a, self = $$23.$$s == null ? this : $$23.$$s;

        
        if (c == null) c = nil;
        return ($a = c, ($a === nil || $a == null) ? nil : $a.$force_encoding(self.$encoding()));}, {$$s: self});
          if (block === nil) result.push(captures);
          else Opal.yield1(block, captures);
        }
        if (pattern.lastIndex === match.index) {
          pattern.lastIndex += 1;
        }
      }

      if (!no_matchdata) ($gvars["~"] = match_data);

      return (block !== nil ? self : result);
    ;
    }, -2);
    
    $def(self, '$scrub', function $$scrub(replacement_string) {
      var block = $$scrub.$$p || nil, self = this;

      $$scrub.$$p = null;
      
      ;
      if (replacement_string == null) replacement_string = nil;
      if ($truthy(replacement_string['$is_a?']($$('String')))) {
        
        if (!$truthy(replacement_string['$valid_encoding?']())) {
          self.$raise($$('ArgumentError'), "replacement string has invalid encoding")
        };
        replacement_string = replacement_string.toString();
      } else if ($not(replacement_string['$nil?']())) {
        self.$raise($$('TypeError'), "replacement must be a String")
      };
      return self.$encoding().$scrub(self, replacement_string);
    }, -1);
    
    $def(self, '$singleton_class', function $$singleton_class() {
      var self = this;

      return Opal.get_singleton_class(self);
    });
    $alias(self, "size", "length");
    $alias(self, "slice", "[]");
    
    $def(self, '$split', function $$split(pattern, limit) {
      var block = $$split.$$p || nil, self = this, $ret_or_1 = nil;
      if ($gvars[";"] == null) $gvars[";"] = nil;

      $$split.$$p = null;
      
      ;
      ;
      ;
      
      if (self.length === 0) return (block && block !== nil) ? self : [];

      if (limit === undefined) {
        limit = 0;
      } else {
        limit = $Opal['$coerce_to!'](limit, $$$('Integer'), "to_int");
        if (limit === 1) {
          if (block && block !== nil) {
            Opal.yield1(block, self);
            return self;
          }
          return [self]
        }
        if (limit > MAX_STR_LEN) self.$raise($$('RangeError'), "limit too large");
      }

      if (pattern === undefined || pattern === nil) {
        pattern = ($truthy(($ret_or_1 = $gvars[";"])) ? ($ret_or_1) : (" "));
      }

      var result,
          string = self.toString(),
          index = 0,
          match,
          match_count = 0,
          valid_result_length = 0,
          i, max;

      if (pattern.$$is_regexp) {
        pattern = $global_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str');

        if (!pattern["$valid_encoding?"]()) self.$raise($$('ArgumentError'), "pattern has invalid encoding");
        if (pattern === ' ') {
          pattern = /[\f\n\r\t\v\u0020\u00a0]+/gmu;
          string = string.replace(/^[\f\n\r\t\v\u0020\u00a0]+/u, '');
          if (string.length === 0) return [];
        } else if (pattern.length > 0 && (starts_with_low_surrogate(pattern) || ends_with_high_surrogate(pattern))) {
          result = [string];
        }
      }

      if (!result) {
        result = (pattern.length === 0) ? [...string] : string.split(pattern);

        if (!(result.length === 1 && result[0] === string)) {
          while ((i = result.indexOf(undefined)) !== -1) {
            result.splice(i, 1);
          }

          if (limit === 0) {
            while (result[result.length - 1] === '') {
              result.pop();
            }
          } else {
            if (!pattern.$$is_regexp) {
              pattern = Opal.escape_regexp(pattern);
              let pattern_flags = $transform_regexp(pattern, 'gmu');
              pattern = new RegExp(pattern_flags[0], pattern_flags[1]);
            }

            match = pattern.exec(string);

            if (limit < 0) {
              if (match !== null && match[0] === '' && pattern.source.indexOf('(?=') === -1) {
                for (i = 0, max = match.length; i < max; i++) {
                  result.push('');
                }
              }
            } else  if (match !== null && match[0] === '') {
              valid_result_length = (match.length - 1) * (limit - 1) + limit
              result.splice(valid_result_length - 1, result.length - 1, result.slice(valid_result_length - 1).join(''));
            } else if (limit < result.length) {
              while (match !== null) {
                match_count++;
                index = pattern.lastIndex;
                valid_result_length += match.length
                if (match_count + 1 === limit) {
                  break;
                }
                match = pattern.exec(string);
              }
              result.splice(valid_result_length, result.length - 1, string.slice(index));
            }
          }
        }
      }
      result = result.map((substr)=>substr.$force_encoding(self.encoding));
      if (block && block !== nil) {
        for (const substr of result) {Opal.yield1(block, substr)}
        return self;
      }
      return result;
    ;
    }, -1);
    
    $def(self, '$squeeze', function $$squeeze($a) {
      var $post_args, sets, self = this;

      
      $post_args = $slice(arguments);
      sets = $post_args;
      
      if (sets.length === 0) {
        return self.replace(/(.)\1+/g, '$1').$force_encoding(self.encoding);
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      let pattern_flags = $transform_regexp('(' + char_class + ')\\1+', 'gu');
      return self.replace(new RegExp(pattern_flags[0], pattern_flags[1]), '$1')
                 .$force_encoding(self.encoding);
    ;
    }, -1);
    
    $def(self, '$start_with?', function $String_start_with$ques$24($a) {
      var $post_args, prefixes, self = this;

      
      $post_args = $slice(arguments);
      prefixes = $post_args;
      
      for (var i = 0, length = prefixes.length; i < length; i++) {
        if (prefixes[i].$$is_regexp) {
          var regexp = prefixes[i];
          var match = regexp.exec(self);

          if (match != null && match.index === 0) {
            ($gvars["~"] = $$$('MatchData').$new(regexp, match));
            return true;
          } else {
            ($gvars["~"] = nil)
          }
        } else {
          let prefix = $coerce_to(prefixes[i], $$$('String'), 'to_str').$to_s();
          // this is correct behavior since ruby 3.3
          // specs work when RUBY_VERSION is set to at least 3.3
          if (starts_with(self, prefix) || prefix.length === 0) return true;
        }
      }

      return false;
    ;
    }, -1);
    
    $def(self, '$strip', function $$strip() {
      var self = this;

      return self.replace(/^[\x00\x09\x0a-\x0d\x20]*|[\x00\x09\x0a-\x0d\x20]*$/g, '').$force_encoding(self.encoding);
    });
    
    $def(self, '$sub', function $$sub(pattern, replacement) {
      var block = $$sub.$$p || nil, self = this;

      $$sub.$$p = null;
      
      ;
      ;
      
      if (!pattern.$$is_regexp) {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/gu, '\\$&'));
      }

      var result, match = pattern.exec(self);

      if (match === null) {
        ($gvars["~"] = nil)
        result = self.toString();
      } else {
        $$$('MatchData').$new(pattern, match)

        if (replacement === undefined) {

          if (block === nil) {
            $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (1 for 2)")
          }
          result = self.slice(0, match.index) + block(match[0]) + self.slice(match.index + match[0].length);

        } else if (replacement.$$is_hash) {

          result = self.slice(0, match.index) + (replacement)['$[]'](match[0]).$to_s() + self.slice(match.index + match[0].length);

        } else {

          replacement = $coerce_to(replacement, $$$('String'), 'to_str');

          replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');

          result = self.slice(0, match.index) + replacement + self.slice(match.index + match[0].length);
        }
      }

      return result;
    ;
    }, -2);
    $alias(self, "succ", "next");
    
    $def(self, '$sum', function $$sum(n) {
      var self = this;

      
      if (n == null) n = 16;
      
      n = $coerce_to(n, $$$('Integer'), 'to_int');

      var result = 0,
          length = self.length,
          i = 0;

      for (; i < length; i++) {
        result += self.charCodeAt(i);
      }

      if (n <= 0) {
        return result;
      }

      return result & (Math.pow(2, n) - 1);
    ;
    }, -1);
    
    $def(self, '$swapcase', function $$swapcase($a) {
      var $post_args, options, self = this;

      
      $post_args = $slice(arguments);
      options = $post_args;
      
      if (case_options_have_ascii(options)) {
        return self.replace(/([a-z]+)|([A-Z]+)/g, function($0,$1,$2) {
          return $1 ? $0.toUpperCase() : $0.toLowerCase();
        });
      }
      let str = "", cu;
      for (const c of self) {
          cu = c.toUpperCase();
          str += (cu == c) ? c.toLowerCase() : cu;
      }
      return str.$force_encoding(self.encoding);
    ;
    }, -1);
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      
      if (self.charAt(0) === '_') {
        return 0;
      }

      var result = parseFloat(self.replace(/_/g, ''));

      if (isNaN(result) || result == Infinity || result == -Infinity) {
        return 0;
      }
      else {
        return result;
      }
    
    });
    
    $def(self, '$to_i', function $$to_i(base) {
      var self = this;

      
      if (base == null) base = 10;
      
      let result,
          string = self.toLowerCase(),
          radix = $coerce_to(base, $$$('Integer'), 'to_int');

      if (radix === 1 || radix < 0 || radix > 36) {
        $Kernel.$raise($$$('ArgumentError'), "invalid radix " + $to_s(radix))
      }

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x' && (radix === 0 || radix === 16)) {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          if (radix === 0 || radix === 2) {
            radix = 2;
            return head + tail;
          }
          break;
        case '0':
        case '0o':
          if (radix === 0 || radix === 8) {
            radix = 8;
            return head + tail;
          }
          break;
        case '0d':
          if (radix === 0 || radix === 10) {
            radix = 10;
            return head + tail;
          }
          break;
        case '0x':
          if (radix === 0 || radix === 16) {
            radix = 16;
            return head + tail;
          }
          break;
        }
        return original
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    ;
    }, -1);
    
    $def(self, '$to_proc', function $$to_proc() {
      var $yield = $$to_proc.$$p || nil, self = this, method_name = nil, jsid = nil, proc = nil;

      $$to_proc.$$p = null;
      
      method_name = self.valueOf();
      jsid = Opal.jsid(method_name);
      proc = $send($Kernel, 'proc', [], function $$25($a){var block = $$25.$$p || nil, $post_args, args;

        $$25.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        
        if (args.length === 0) {
          $Kernel.$raise($$$('ArgumentError'), "no receiver given")
        }

        var recv = args[0];

        if (recv == null) recv = nil;

        var body = recv[jsid];

        if (!body) {
          body = recv.$method_missing;
          args[0] = method_name;
        } else {
          args = args.slice(1);
        }

        if (typeof block === 'function') {
          body.$$p = block;
        }

        if (args.length === 0) {
          return body.call(recv);
        } else {
          return body.apply(recv, args);
        }
      ;}, -1);
      proc.$$source_location = nil;
      return proc;
    });
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return self.toString();
    });
    $alias(self, "to_str", "to_s");
    $alias(self, "to_sym", "intern");
    
    function expand_chars(chars) {
      let length = chars.length,
          expanded = [],
          ch, last_ch, start, end,
          c, i = 0, in_range;
      for (; i < length; i++) {
        ch = chars[i];
        if (last_ch == null) {
          last_ch = ch;
          expanded.push(ch);
        }
        else if (ch == '-' && !in_range) {
          if (i > 0 && i < length - 1) {
            in_range = true;
          } else {
            expanded.push('-');
          }
        }
        else if (in_range) {
          start = last_ch.codePointAt(0);
          end = ch.codePointAt(0);
          if (start > end) {
            $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + $to_s(String.fromCodePoint(start)) + "-" + $to_s(String.fromCodePoint(end)) + "\" in string transliteration")
          } else if (start !== end) {
            for (c = start + 1; c < end; c++) {
              expanded.push(String.fromCodePoint(c));
            }
            expanded.push(ch);
          }
          in_range = null;
          last_ch = null;
        } else {
          expanded.push(ch);
        }
      }
      return expanded;
    }

    function common_tr(self, from, to, is_tr_s) {
      from = $coerce_to(from, $$$('String'), 'to_str').$to_s();
      to = $coerce_to(to, $$$('String'), 'to_str').$to_s();

      if (from.length == 0) return self;

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = [...from];
      var from_length = from_chars.length;
      var to_chars = [...to];
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] == '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      from_chars = expand_chars(from_chars);
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      } else {
        if (to_length > 0) {
          to_chars = expand_chars(to_chars);
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }

      let new_str = '',
          sub;

      if (is_tr_s) {
        var last_substitute = null
        for (const ch of self) {
          sub = subs[ch]
          if (inverse) {
            if (sub == null) {
              if (last_substitute == null) {
                new_str += global_sub;
                last_substitute = true;
              }
            } else {
              new_str += ch;
              last_substitute = null;
            }
          } else {
            if (sub != null) {
              if (last_substitute == null || last_substitute !== sub) {
                new_str += sub;
                last_substitute = sub;
              }
            } else {
              new_str += ch;
              last_substitute = null;
            }
          }
        }
      } else {
        for (const ch of self) {
          sub = subs[ch];
          if (inverse) {
            new_str += (sub == null ? global_sub : ch);
          } else {
            new_str += (sub != null ? sub : ch);
          }
        }
      }
      return new_str;
    }
  ;
    
    $def(self, '$tr', function $$tr(from, to) {
      var self = this;

      return common_tr(self, from, to, false);
    });
    
    $def(self, '$tr_s', function $$tr_s(from, to) {
      var self = this;

      return common_tr(self, from, to, true);
    });
    
    $def(self, '$unicode_normalize', function $$unicode_normalize(form) {
      var self = this;

      
      if (form == null) form = "nfc";
      if (!$truthy(["nfc", "nfd", "nfkc", "nfkd"]['$include?'](form))) {
        $Kernel.$raise($$$('ArgumentError'), "Invalid normalization form " + $to_s(form))
      };
      return self.normalize(form.$upcase());
    }, -1);
    
    $def(self, '$unicode_normalized?', function $String_unicode_normalized$ques$26(form) {
      var self = this;

      
      if (form == null) form = "nfc";
      return self.$unicode_normalize(form)['$=='](self);
    }, -1);
    
    $def(self, '$unpack', function $$unpack(format) {
      
      return $Kernel.$raise("To use String#unpack, you must first require 'corelib/string/unpack'.")
    });
    
    $def(self, '$unpack1', function $$unpack1(format) {
      
      return $Kernel.$raise("To use String#unpack1, you must first require 'corelib/string/unpack'.")
    });
    
    $def(self, '$upcase', function $$upcase($a) {
      var $post_args, options, self = this;

      
      $post_args = $slice(arguments);
      options = $post_args;
      
      let result;
      if (case_options_have_ascii(options)) {
        result = self.replace(/[a-z]+/g, (match)=>{ return match.toUpperCase(); });
      } else {
        result = self.toUpperCase();
      }
      return result.$force_encoding(self.encoding)
    ;
    }, -1);
    
    $def(self, '$upto', function $$upto(stop, excl) {
      var block = $$upto.$$p || nil, self = this;

      $$upto.$$p = null;
      
      ;
      if (excl == null) excl = false;
      if (!(block !== nil)) {
        return self.$enum_for("upto", stop, excl)
      };
      
      var a, b, s = self.toString();

      stop = $coerce_to(stop, $$$('String'), 'to_str');

      let str_l = self.$length(),
          stop_l = stop.$length();

      if (str_l === 1 && stop_l === 1) {

        a = self.codePointAt(0);
        b = stop.codePointAt(0);
        if (b >= 0xD800 && b <= 0xDFFF) b = 0; // exclude surrogate range for b

        while (a <= b) {
          if (excl && a === b) break;

          block(String.fromCodePoint(a));

          a += 1;
          if (a >= 0xD800 && a <= 0xDFFF) a = 0xE000; // exclude surrogate range
        }

      } else if (parseInt(s, 10).toString() === s && parseInt(stop, 10).toString() === stop) {

        a = parseInt(s, 10);
        b = parseInt(stop, 10);

        while (a <= b) {
          if (excl && a === b) break;

          block(a.toString());

          a += 1;
        }
      } else {
        let s_l;
        while (str_l <= stop_l && s <= stop) {
          if (excl && s == stop) break;

          block(s);

          s_l = s.length;
          s = s.$next();
          if (s.length !== s_l) str_l = s.$length();
        }

      }
      return self;
    ;
    }, -2);
    
    $def(self, '$valid_encoding?', function $String_valid_encoding$ques$27() {
      var self = this;

      return self.$encoding()['$valid_encoding?'](self)
    });
    
    $def(self, '$instance_variables', function $$instance_variables() {
      
      return []
    });
    $defs(self, '$_load', function $$_load($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return $send(self, 'new', $to_a(args));
    }, -1);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if (typeof self === 'string') { return self; }
      $prop(self, "$$frozen", true);
      return self;
    
    });
    
    $def(self, '$frozen?', function $String_frozen$ques$28() {
      var self = this;

      return typeof self === 'string' || self.$$frozen === true;
    });
    $alias(self, "object_id", "__id__");
    return $Opal.$pristine(self, "initialize");
  })('::', String, $nesting);
  return $const_set($nesting[0], 'Symbol', $$('String'));
};

Opal.modules["corelib/string/mutable"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $klass = Opal.klass, $def = Opal.def, $rb_plus = Opal.rb_plus, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $alias = Opal.alias, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('replace,+,capitalize,chomp,each,<<,chop,downcase,args,gsub,to_proc,lstrip,succ,succ!,reverse,squeeze,strip,sub,block,swapcase,tr,tr_s,upcase,join,raise,encode,unicode_normalize');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    function $deny_frozen_access(str) {
      if (typeof str === 'string' || str.$$frozen === true) {
          $raise(Opal.FrozenError, "can't modify frozen String: " + str.$inspect());
      }
    }
  ;
    
    $def(self, '$replace', function $$replace(other, return_nil) {
      var self = this;

      
      if (return_nil == null) return_nil = false;
      
      $deny_frozen_access(self);

      var oldstr = self.toString();
      var newstr = other.toString();

      if (oldstr === newstr) return return_nil ? nil : self;

      self.$$string = newstr

      return self;
    ;
    }, -2);
    
    $def(self, '$<<', function $String_$lt$lt$1(other) {
      var self = this;

      return self.$replace($rb_plus(self, other))
    });
    
    $def(self, '$capitalize!', function $String_capitalize$excl$2() {
      var self = this;

      return self.$replace(self.$capitalize(), true)
    });
    
    $def(self, '$chomp!', function $String_chomp$excl$3($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return self.$replace($send(self, 'chomp', $to_a(args)), true);
    }, -1);
    
    $def(self, '$concat', function $$concat($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      $send(args, 'each', [], function $$4(arg){var self = $$4.$$s == null ? this : $$4.$$s;

        
        if (arg == null) arg = nil;
        return self['$<<'](arg);}, {$$s: self});
      return self;
    }, -1);
    
    $def(self, '$chop!', function $String_chop$excl$5() {
      var self = this;

      return self.$replace(self.$chop(), true)
    });
    
    $def(self, '$downcase!', function $String_downcase$excl$6($a) {
      var $post_args, $fwd_rest, self = this;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return self.$replace($send(self, 'downcase', $to_a(self.$args())), true);
    }, -1);
    
    $def(self, '$gsub!', function $String_gsub$excl$7($a) {
      var block = $String_gsub$excl$7.$$p || nil, $post_args, args, self = this;

      $String_gsub$excl$7.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      return self.$replace($send(self, 'gsub', $to_a(args), block.$to_proc()), true);
    }, -1);
    
    $def(self, '$lstrip!', function $String_lstrip$excl$8() {
      var self = this;

      return self.$replace(self.$lstrip(), true)
    });
    
    $def(self, '$succ!', function $String_succ$excl$9() {
      var self = this;

      return self.$replace(self.$succ())
    });
    $alias(self, "next!", "succ!");
    
    $def(self, '$reverse!', function $String_reverse$excl$10($a) {
      var $post_args, $fwd_rest, self = this;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return self.$replace(self.$reverse());
    }, -1);
    
    $def(self, '$squeeze!', function $String_squeeze$excl$11($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return self.$replace($send(self, 'squeeze', $to_a(args)), true);
    }, -1);
    
    $def(self, '$strip!', function $String_strip$excl$12() {
      var self = this;

      return self.$replace(self.$strip(), true)
    });
    
    $def(self, '$sub!', function $String_sub$excl$13($a) {
      var $post_args, $fwd_rest, self = this;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return self.$replace($send(self, 'sub', $to_a(self.$args()), self.$block().$to_proc()), true);
    }, -1);
    
    $def(self, '$swapcase!', function $String_swapcase$excl$14() {
      var self = this;

      return self.$replace(self.$swapcase(), true)
    });
    
    $def(self, '$tr!', function $String_tr$excl$15($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return self.$replace($send(self, 'tr', $to_a(args)), true);
    }, -1);
    
    $def(self, '$tr_s!', function $String_tr_s$excl$16($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return self.$replace($send(self, 'tr_s', $to_a(args)), true);
    }, -1);
    
    $def(self, '$upcase!', function $String_upcase$excl$17($a) {
      var $post_args, $fwd_rest, self = this;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return self.$replace(self.$upcase(), true);
    }, -1);
    
    $def(self, '$concat', function $$concat($a) {
      var $post_args, strs, self = this;

      
      $post_args = $slice(arguments);
      strs = $post_args;
      return self.$replace($rb_plus([self], strs).$join());
    }, -1);
    
    $def(self, '$prepend', function $$prepend($a) {
      var $post_args, strs, self = this;

      
      $post_args = $slice(arguments);
      strs = $post_args;
      return self.$replace($rb_plus(strs, [self]).$join());
    }, -1);
    
    $def(self, '$[]=', function $String_$$$eq$18($a) {
      var $post_args, $fwd_rest, self = this;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return self.$raise($$('NotImplementedError'));
    }, -1);
    
    $def(self, '$clear', function $$clear($a) {
      var $post_args, $fwd_rest, self = this;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return self.$replace("");
    }, -1);
    
    $def(self, '$encode!', function $String_encode$excl$19($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return self.$replace($send(self, 'encode', $to_a(args)));
    }, -1);
    return $def(self, '$unicode_normalize!', function $String_unicode_normalize$excl$20($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return self.$replace($send(self, 'unicode_normalize', $to_a(args)));
    }, -1);
  })($nesting[0], null, $nesting)
};

Opal.modules["corelib/enumerable"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $yield1 = Opal.yield1, $yieldX = Opal.yieldX, $deny_frozen_access = Opal.deny_frozen_access, $module = Opal.module, $send = Opal.send, $slice = Opal.slice, $to_a = Opal.to_a, $Opal = Opal.Opal, $thrower = Opal.thrower, $def = Opal.def, $Kernel = Opal.Kernel, $return_val = Opal.return_val, $rb_gt = Opal.rb_gt, $rb_times = Opal.rb_times, $to_s = Opal.to_s, $rb_lt = Opal.rb_lt, $eqeq = Opal.eqeq, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $rb_divide = Opal.rb_divide, $rb_le = Opal.rb_le, $lambda = Opal.lambda, $not = Opal.not, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('each,public_send,destructure,to_enum,enumerator_size,new,yield,raise,slice_when,!,enum_for,flatten,map,to_proc,compact,to_a,warn,proc,==,nil?,respond_to?,coerce_to!,>,*,try_convert,<,+,-,ceil,/,size,select,__send__,length,<=,[],push,<<,[]=,===,inspect,<=>,first,reverse,sort,take,sort_by,compare,call,dup,sort!,map!,include?,-@,key?,values,transform_values,group_by,fetch,to_h,coerce_to?,class,zip,detect,find_all,collect_concat,collect,inject,entries');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Enumerable');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    function comparableForPattern(value) {
      if (value.length === 0) {
        value = [nil];
      }

      if (value.length > 1) {
        value = [value];
      }

      return value;
    }
  ;
    
    $def(self, '$all?', function $Enumerable_all$ques$1(pattern) {try { var $t_return = $thrower('return'); 
      var block = $Enumerable_all$ques$1.$$p || nil, self = this;

      $Enumerable_all$ques$1.$$p = null;
      
      ;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$2($a){var $post_args, value, comparable = nil;

          
          $post_args = $slice(arguments);
          value = $post_args;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            return nil
          } else {
            $t_return.$throw(false, $$2.$$is_lambda)
          };}, {$$arity: -1, $$ret: $t_return})
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$3($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            return nil
          } else {
            $t_return.$throw(false, $$3.$$is_lambda)
          };}, {$$arity: -1, $$ret: $t_return})
      } else {
        $send(self, 'each', [], function $$4($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if ($truthy($Opal.$destructure(value))) {
            return nil
          } else {
            $t_return.$throw(false, $$4.$$is_lambda)
          };}, {$$arity: -1, $$ret: $t_return})
      };
      return true;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      } finally {$t_return.is_orphan = true;}
    }, -1);
    
    $def(self, '$any?', function $Enumerable_any$ques$5(pattern) {try { var $t_return = $thrower('return'); 
      var block = $Enumerable_any$ques$5.$$p || nil, self = this;

      $Enumerable_any$ques$5.$$p = null;
      
      ;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$6($a){var $post_args, value, comparable = nil;

          
          $post_args = $slice(arguments);
          value = $post_args;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            $t_return.$throw(true, $$6.$$is_lambda)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$7($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            $t_return.$throw(true, $$7.$$is_lambda)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else {
        $send(self, 'each', [], function $$8($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if ($truthy($Opal.$destructure(value))) {
            $t_return.$throw(true, $$8.$$is_lambda)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      };
      return false;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      } finally {$t_return.is_orphan = true;}
    }, -1);
    
    $def(self, '$chunk', function $$chunk() {
      var block = $$chunk.$$p || nil, self = this;

      $$chunk.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'to_enum', ["chunk"], function $$9(){var self = $$9.$$s == null ? this : $$9.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      return $send($$$('Enumerator'), 'new', [], function $$10(yielder){var self = $$10.$$s == null ? this : $$10.$$s;

        
        if (yielder == null) yielder = nil;
        
        var previous = nil, accumulate = [];

        function releaseAccumulate() {
          if (accumulate.length > 0) {
            yielder.$yield(previous, accumulate)
          }
        }

        self.$each.$$p = function(value) {
          var key = $yield1(block, value);

          if (key === nil) {
            releaseAccumulate();
            accumulate = [];
            previous = nil;
          } else {
            if (previous === nil || previous === key) {
              accumulate.push(value);
            } else {
              releaseAccumulate();
              accumulate = [value];
            }

            previous = key;
          }
        }

        self.$each();

        releaseAccumulate();
      ;}, {$$s: self});
    });
    
    $def(self, '$chunk_while', function $$chunk_while() {
      var block = $$chunk_while.$$p || nil, self = this;

      $$chunk_while.$$p = null;
      
      ;
      if (!(block !== nil)) {
        $Kernel.$raise($$$('ArgumentError'), "no block given")
      };
      return $send(self, 'slice_when', [], function $$11(before, after){
        
        if (before == null) before = nil;
        if (after == null) after = nil;
        return Opal.yieldX(block, [before, after])['$!']();});
    });
    
    $def(self, '$collect', function $$collect() {
      var block = $$collect.$$p || nil, self = this;

      $$collect.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect"], function $$12(){var self = $$12.$$s == null ? this : $$12.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        var value = $yieldX(block, arguments);

        result.push(value);
      };

      self.$each();

      return result;
    ;
    });
    
    $def(self, '$collect_concat', function $$collect_concat() {
      var block = $$collect_concat.$$p || nil, self = this;

      $$collect_concat.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect_concat"], function $$13(){var self = $$13.$$s == null ? this : $$13.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      return $send(self, 'map', [], block.$to_proc()).$flatten(1);
    });
    
    $def(self, '$compact', function $$compact() {
      var self = this;

      return self.$to_a().$compact()
    });
    
    $def(self, '$count', function $$count(object) {
      var block = $$count.$$p || nil, self = this, result = nil;

      $$count.$$p = null;
      
      ;
      ;
      result = 0;
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      if ($truthy(object != null)) {
        block = $send($Kernel, 'proc', [], function $$14($a){var $post_args, args;

          
          $post_args = $slice(arguments);
          args = $post_args;
          return $Opal.$destructure(args)['$=='](object);}, -1)
      } else if ($truthy(block['$nil?']())) {
        block = $send($Kernel, 'proc', [], $return_val(true))
      };
      $send(self, 'each', [], function $$15($a){var $post_args, args;

        
        $post_args = $slice(arguments);
        args = $post_args;
        if ($truthy($yieldX(block, args))) {
          return result++;
        } else {
          return nil
        };}, -1);
      return result;
    }, -1);
    
    $def(self, '$cycle', function $$cycle(n) {
      var block = $$cycle.$$p || nil, self = this;

      $$cycle.$$p = null;
      
      ;
      if (n == null) n = nil;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["cycle", n], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          if ($truthy(n['$nil?']())) {
            if ($truthy(self['$respond_to?']("size"))) {
              return $$$($$$('Float'), 'INFINITY')
            } else {
              return nil
            }
          } else {
            
            n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, {$$s: self})
      };
      if (!$truthy(n['$nil?']())) {
        
        n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
        if ($truthy(n <= 0)) {
          return nil
        };
      };
      
      var all = [], i, length, value;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        all.push(param);
      }

      self.$each();

      if (all.length === 0) {
        return nil;
      }

      if (n === nil) {
        while (true) {
          for (i = 0, length = all.length; i < length; i++) {
            value = $yield1(block, all[i]);
          }
        }
      }
      else {
        while (n > 1) {
          for (i = 0, length = all.length; i < length; i++) {
            value = $yield1(block, all[i]);
          }

          n--;
        }
      }
    ;
    }, -1);
    
    $def(self, '$detect', function $$detect(ifnone) {try { var $t_return = $thrower('return'); 
      var block = $$detect.$$p || nil, self = this;

      $$detect.$$p = null;
      
      ;
      ;
      if (!(block !== nil)) {
        return self.$enum_for("detect", ifnone)
      };
      $send(self, 'each', [], function $$17($a){var $post_args, args, value = nil;

        
        $post_args = $slice(arguments);
        args = $post_args;
        value = $Opal.$destructure(args);
        if ($truthy(Opal.yield1(block, value))) {
          $t_return.$throw(value, $$17.$$is_lambda)
        } else {
          return nil
        };}, {$$arity: -1, $$ret: $t_return});
      
      if (ifnone !== undefined) {
        if (typeof(ifnone) === 'function') {
          return ifnone();
        } else {
          return ifnone;
        }
      }
    ;
      return nil;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      } finally {$t_return.is_orphan = true;}
    }, -1);
    
    $def(self, '$drop', function $$drop(number) {
      var self = this;

      
      number = $coerce_to(number, $$$('Integer'), 'to_int');
      if ($truthy(number < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "attempt to drop negative size")
      };
      
      var result  = [],
          current = 0;

      self.$each.$$p = function() {
        if (number <= current) {
          result.push($Opal.$destructure(arguments));
        }

        current++;
      };

      self.$each()

      return result;
    ;
    });
    
    $def(self, '$drop_while', function $$drop_while() {
      var block = $$drop_while.$$p || nil, self = this;

      $$drop_while.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("drop_while")
      };
      
      var result   = [],
          dropping = true;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        if (dropping) {
          var value = $yield1(block, param);

          if (!$truthy(value)) {
            dropping = false;
            result.push(param);
          }
        }
        else {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    });
    
    $def(self, '$each_cons', function $$each_cons(n) {
      var block = $$each_cons.$$p || nil, self = this;

      $$each_cons.$$p = null;
      
      ;
      if ($truthy(arguments.length != 1)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + $to_s(arguments.length) + " for 1)")
      };
      n = $Opal.$try_convert(n, $$$('Integer'), "to_int");
      if ($truthy(n <= 0)) {
        $Kernel.$raise($$$('ArgumentError'), "invalid size")
      };
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_cons", n], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s, enum_size = nil;

          
          enum_size = self.$enumerator_size();
          if ($truthy(enum_size['$nil?']())) {
            return nil
          } else if (($eqeq(enum_size, 0) || ($truthy($rb_lt(enum_size, n))))) {
            return 0
          } else {
            return $rb_plus($rb_minus(enum_size, n), 1)
          };}, {$$s: self})
      };
      
      var buffer = [];

      self.$each.$$p = function() {
        var element = $Opal.$destructure(arguments);
        buffer.push(element);
        if (buffer.length > n) {
          buffer.shift();
        }
        if (buffer.length == n) {
          $yield1(block, buffer.slice(0, n));
        }
      }

      self.$each();

      return self;
    ;
    });
    
    $def(self, '$each_entry', function $$each_entry($a) {
      var block = $$each_entry.$$p || nil, $post_args, data, self = this;

      $$each_entry.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      data = $post_args;
      if (!(block !== nil)) {
        return $send(self, 'to_enum', ["each_entry"].concat($to_a(data)), function $$19(){var self = $$19.$$s == null ? this : $$19.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      self.$each.$$p = function() {
        var item = $Opal.$destructure(arguments);

        $yield1(block, item);
      }

      self.$each.apply(self, data);

      return self;
    ;
    }, -1);
    
    $def(self, '$each_slice', function $$each_slice(n) {
      var block = $$each_slice.$$p || nil, self = this;

      $$each_slice.$$p = null;
      
      ;
      n = $coerce_to(n, $$$('Integer'), 'to_int');
      if ($truthy(n <= 0)) {
        $Kernel.$raise($$$('ArgumentError'), "invalid slice size")
      };
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_slice", n], function $$20(){var self = $$20.$$s == null ? this : $$20.$$s;

          if ($truthy(self['$respond_to?']("size"))) {
            return $rb_divide(self.$size(), n).$ceil()
          } else {
            return nil
          }}, {$$s: self})
      };
      
      var slice = []

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        slice.push(param);

        if (slice.length === n) {
          $yield1(block, slice);
          slice = [];
        }
      };

      self.$each();

      // our "last" group, if smaller than n then won't have been yielded
      if (slice.length > 0) {
        $yield1(block, slice);
      }
    ;
      return self;
    });
    
    $def(self, '$each_with_index', function $$each_with_index($a) {
      var block = $$each_with_index.$$p || nil, $post_args, args, self = this;

      $$each_with_index.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_with_index"].concat($to_a(args)), function $$21(){var self = $$21.$$s == null ? this : $$21.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      var index = 0;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        block(param, index);

        index++;
      };

      self.$each.apply(self, args);
    ;
      return self;
    }, -1);
    
    $def(self, '$each_with_object', function $$each_with_object(object) {
      var block = $$each_with_object.$$p || nil, self = this;

      $$each_with_object.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_with_object", object], function $$22(){var self = $$22.$$s == null ? this : $$22.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        block(param, object);
      };

      self.$each();
    ;
      return object;
    });
    
    $def(self, '$entries', function $$entries($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      var result = [];

      self.$each.$$p = function() {
        result.push($Opal.$destructure(arguments));
      };

      self.$each.apply(self, args);

      return result;
    ;
    }, -1);
    
    $def(self, '$filter_map', function $$filter_map() {
      var block = $$filter_map.$$p || nil, self = this;

      $$filter_map.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["filter_map"], function $$23(){var self = $$23.$$s == null ? this : $$23.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      return $send($send(self, 'map', [], block.$to_proc()), 'select', [], "itself".$to_proc());
    });
    
    $def(self, '$find_all', function $$find_all() {
      var block = $$find_all.$$p || nil, self = this;

      $$find_all.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["find_all"], function $$24(){var self = $$24.$$s == null ? this : $$24.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if ($truthy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    });
    
    $def(self, '$find_index', function $$find_index(object) {try { var $t_return = $thrower('return'); 
      var block = $$find_index.$$p || nil, self = this, index = nil;

      $$find_index.$$p = null;
      
      ;
      ;
      if ($truthy(object === undefined && block === nil)) {
        return self.$enum_for("find_index")
      };
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      index = 0;
      if ($truthy(object != null)) {
        $send(self, 'each', [], function $$25($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if ($eqeq($Opal.$destructure(value), object)) {
            $t_return.$throw(index, $$25.$$is_lambda)
          };
          return index += 1;;}, {$$arity: -1, $$ret: $t_return})
      } else {
        $send(self, 'each', [], function $$26($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            $t_return.$throw(index, $$26.$$is_lambda)
          };
          return index += 1;;}, {$$arity: -1, $$ret: $t_return})
      };
      return nil;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      } finally {$t_return.is_orphan = true;}
    }, -1);
    
    $def(self, '$first', function $$first(number) {try { var $t_return = $thrower('return'); 
      var self = this, result = nil, current = nil;

      
      ;
      if ($truthy(number === undefined)) {
        return $send(self, 'each', [], function $$27(value){
          
          if (value == null) value = nil;
          $t_return.$throw(value, $$27.$$is_lambda);}, {$$ret: $t_return})
      } else {
        
        result = [];
        number = $coerce_to(number, $$$('Integer'), 'to_int');
        if ($truthy(number < 0)) {
          $Kernel.$raise($$$('ArgumentError'), "attempt to take negative size")
        };
        if ($truthy(number == 0)) {
          return []
        };
        current = 0;
        $send(self, 'each', [], function $$28($a){var $post_args, args;

          
          $post_args = $slice(arguments);
          args = $post_args;
          result.push($Opal.$destructure(args));
          if ($truthy(number <= ++current)) {
            $t_return.$throw(result, $$28.$$is_lambda)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return});
        return result;
      };} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      } finally {$t_return.is_orphan = true;}
    }, -1);
    
    $def(self, '$grep', function $$grep(pattern) {
      var block = $$grep.$$p || nil, self = this, result = nil;

      $$grep.$$p = null;
      
      ;
      result = [];
      $send(self, 'each', [], function $$29($a){var $post_args, value, cmp = nil;

        
        $post_args = $slice(arguments);
        value = $post_args;
        cmp = comparableForPattern(value);
        if (!$truthy($send(pattern, '__send__', ["==="].concat($to_a(cmp))))) {
          return nil
        };
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]
          };
          value = Opal.yieldX(block, $to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)
        };
        return result.$push(value);}, -1);
      return result;
    });
    
    $def(self, '$grep_v', function $$grep_v(pattern) {
      var block = $$grep_v.$$p || nil, self = this, result = nil;

      $$grep_v.$$p = null;
      
      ;
      result = [];
      $send(self, 'each', [], function $$30($a){var $post_args, value, cmp = nil;

        
        $post_args = $slice(arguments);
        value = $post_args;
        cmp = comparableForPattern(value);
        if ($truthy($send(pattern, '__send__', ["==="].concat($to_a(cmp))))) {
          return nil
        };
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]
          };
          value = Opal.yieldX(block, $to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)
        };
        return result.$push(value);}, -1);
      return result;
    });
    
    $def(self, '$group_by', function $$group_by() {
      var block = $$group_by.$$p || nil, $a, self = this, hash = nil, $ret_or_1 = nil;

      $$group_by.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["group_by"], function $$31(){var self = $$31.$$s == null ? this : $$31.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      hash = (new Map());
      
      var result;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        ($truthy(($ret_or_1 = hash['$[]'](value))) ? ($ret_or_1) : (($a = [value, []], $send(hash, '[]=', $a), $a[$a.length - 1])))['$<<'](param);
      }

      self.$each();

      if (result !== undefined) {
        return result;
      }
    ;
      return hash;
    });
    
    $def(self, '$include?', function $Enumerable_include$ques$32(obj) {try { var $t_return = $thrower('return'); 
      var self = this;

      
      $send(self, 'each', [], function $$33($a){var $post_args, args;

        
        $post_args = $slice(arguments);
        args = $post_args;
        if ($eqeq($Opal.$destructure(args), obj)) {
          $t_return.$throw(true, $$33.$$is_lambda)
        } else {
          return nil
        };}, {$$arity: -1, $$ret: $t_return});
      return false;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      } finally {$t_return.is_orphan = true;}
    });
    
    $def(self, '$inject', function $$inject(object, sym) {
      var block = $$inject.$$p || nil, self = this;

      $$inject.$$p = null;
      
      ;
      ;
      ;
      
      var result = object;

      if (block !== nil && sym === undefined) {
        self.$each.$$p = function() {
          var value = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          value = $yieldX(block, [result, value]);

          result = value;
        };
      }
      else {
        if (sym === undefined) {
          if (!$$$('Symbol')['$==='](object)) {
            $Kernel.$raise($$$('TypeError'), $to_s(object.$inspect()) + " is not a Symbol");
          }

          sym    = object;
          result = undefined;
        }

        self.$each.$$p = function() {
          var value = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          result = (result).$__send__(sym, value);
        };
      }

      self.$each();

      return result == undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$lazy', function $$lazy() {
      var self = this;

      return $send($$$($$$('Enumerator'), 'Lazy'), 'new', [self, self.$enumerator_size()], function $$34(enum$, $a){var $post_args, args;

        
        if (enum$ == null) enum$ = nil;
        $post_args = $slice(arguments, 1);
        args = $post_args;
        return $send(enum$, 'yield', $to_a(args));}, -2)
    });
    
    $def(self, '$enumerator_size', function $$enumerator_size() {
      var self = this;

      if ($truthy(self['$respond_to?']("size"))) {
        return self.$size()
      } else {
        return nil
      }
    });
    
    $def(self, '$max', function $$max(n) {
      var block = $$max.$$p || nil, self = this;

      $$max.$$p = null;
      
      ;
      ;
      
      if (n === undefined || n === nil) {
        var result, value;

        self.$each.$$p = function() {
          var item = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = item;
            return;
          }

          if (block !== nil) {
            value = $yieldX(block, [item, result]);
          } else {
            value = (item)['$<=>'](result);
          }

          if (value === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed");
          }

          if (value > 0) {
            result = item;
          }
        }

        self.$each();

        if (result === undefined) {
          return nil;
        } else {
          return result;
        }
      }

      n = $coerce_to(n, $$$('Integer'), 'to_int');
    ;
      return $send(self, 'sort', [], block.$to_proc()).$reverse().$first(n);
    }, -1);
    
    $def(self, '$max_by', function $$max_by(n) {
      var block = $$max_by.$$p || nil, self = this;

      $$max_by.$$p = null;
      
      ;
      if (n == null) n = nil;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["max_by", n], function $$35(){var self = $$35.$$s == null ? this : $$35.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      if (!$truthy(n['$nil?']())) {
        return $send(self, 'sort_by', [], block.$to_proc()).$reverse().$take(n)
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) > 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$min', function $$min(n) {
      var block = $$min.$$p || nil, self = this;

      $$min.$$p = null;
      
      ;
      if (n == null) n = nil;
      if (!$truthy(n['$nil?']())) {
        if ((block !== nil)) {
          return $send(self, 'sort', [], function $$36(a, b){
            
            if (a == null) a = nil;
            if (b == null) b = nil;
            return Opal.yieldX(block, [a, b]);;}).$take(n)
        } else {
          return self.$sort().$take(n)
        }
      };
      
      var result;

      if (block !== nil) {
        self.$each.$$p = function() {
          var param = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          var value = block(param, result);

          if (value === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed");
          }

          if (value < 0) {
            result = param;
          }
        };
      }
      else {
        self.$each.$$p = function() {
          var param = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          if ($Opal.$compare(param, result) < 0) {
            result = param;
          }
        };
      }

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$min_by', function $$min_by(n) {
      var block = $$min_by.$$p || nil, self = this;

      $$min_by.$$p = null;
      
      ;
      if (n == null) n = nil;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["min_by", n], function $$37(){var self = $$37.$$s == null ? this : $$37.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      if (!$truthy(n['$nil?']())) {
        return $send(self, 'sort_by', [], block.$to_proc()).$take(n)
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) < 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$minmax', function $$minmax() {
      var block = $$minmax.$$p || nil, self = this, $ret_or_1 = nil;

      $$minmax.$$p = null;
      
      ;
      block = ($truthy(($ret_or_1 = block)) ? ($ret_or_1) : ($send($Kernel, 'proc', [], function $$38(a, b){
        
        if (a == null) a = nil;
        if (b == null) b = nil;
        return a['$<=>'](b);})));
      
      var min = nil, max = nil, first_time = true;

      self.$each.$$p = function() {
        var element = $Opal.$destructure(arguments);
        if (first_time) {
          min = max = element;
          first_time = false;
        } else {
          var min_cmp = block.$call(min, element);

          if (min_cmp === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed")
          } else if (min_cmp > 0) {
            min = element;
          }

          var max_cmp = block.$call(max, element);

          if (max_cmp === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed")
          } else if (max_cmp < 0) {
            max = element;
          }
        }
      }

      self.$each();

      return [min, max];
    ;
    });
    
    $def(self, '$minmax_by', function $$minmax_by() {
      var block = $$minmax_by.$$p || nil, self = this;

      $$minmax_by.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["minmax_by"], function $$39(){var self = $$39.$$s == null ? this : $$39.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      var min_result = nil,
          max_result = nil,
          min_by,
          max_by;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if ((min_by === undefined) || (value)['$<=>'](min_by) < 0) {
          min_result = param;
          min_by     = value;
        }

        if ((max_by === undefined) || (value)['$<=>'](max_by) > 0) {
          max_result = param;
          max_by     = value;
        }
      };

      self.$each();

      return [min_result, max_result];
    ;
    });
    
    $def(self, '$none?', function $Enumerable_none$ques$40(pattern) {try { var $t_return = $thrower('return'); 
      var block = $Enumerable_none$ques$40.$$p || nil, self = this;

      $Enumerable_none$ques$40.$$p = null;
      
      ;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$41($a){var $post_args, value, comparable = nil;

          
          $post_args = $slice(arguments);
          value = $post_args;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            $t_return.$throw(false, $$41.$$is_lambda)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$42($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            $t_return.$throw(false, $$42.$$is_lambda)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else {
        $send(self, 'each', [], function $$43($a){var $post_args, value, item = nil;

          
          $post_args = $slice(arguments);
          value = $post_args;
          item = $Opal.$destructure(value);
          if ($truthy(item)) {
            $t_return.$throw(false, $$43.$$is_lambda)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      };
      return true;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      } finally {$t_return.is_orphan = true;}
    }, -1);
    
    $def(self, '$one?', function $Enumerable_one$ques$44(pattern) {try { var $t_return = $thrower('return'); 
      var block = $Enumerable_one$ques$44.$$p || nil, self = this, count = nil;

      $Enumerable_one$ques$44.$$p = null;
      
      ;
      ;
      count = 0;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$45($a){var $post_args, value, comparable = nil;

          
          $post_args = $slice(arguments);
          value = $post_args;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            
            count = $rb_plus(count, 1);
            if ($truthy($rb_gt(count, 1))) {
              $t_return.$throw(false, $$45.$$is_lambda)
            } else {
              return nil
            };
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$46($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if (!$truthy(Opal.yieldX(block, $to_a(value)))) {
            return nil
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            $t_return.$throw(false, $$46.$$is_lambda)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else {
        $send(self, 'each', [], function $$47($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if (!$truthy($Opal.$destructure(value))) {
            return nil
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            $t_return.$throw(false, $$47.$$is_lambda)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      };
      return count['$=='](1);} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      } finally {$t_return.is_orphan = true;}
    }, -1);
    
    $def(self, '$partition', function $$partition() {
      var block = $$partition.$$p || nil, self = this;

      $$partition.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["partition"], function $$48(){var self = $$48.$$s == null ? this : $$48.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      var truthy = [], falsy = [], result;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if ($truthy(value)) {
          truthy.push(param);
        }
        else {
          falsy.push(param);
        }
      };

      self.$each();

      return [truthy, falsy];
    ;
    });
    
    $def(self, '$reject', function $$reject() {
      var block = $$reject.$$p || nil, self = this;

      $$reject.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reject"], function $$49(){var self = $$49.$$s == null ? this : $$49.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if (!$truthy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    });
    
    $def(self, '$reverse_each', function $$reverse_each() {
      var block = $$reverse_each.$$p || nil, self = this;

      $$reverse_each.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reverse_each"], function $$50(){var self = $$50.$$s == null ? this : $$50.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        result.push(arguments);
      };

      self.$each();

      for (var i = result.length - 1; i >= 0; i--) {
        $yieldX(block, result[i]);
      }

      return result;
    ;
    });
    
    $def(self, '$slice_before', function $$slice_before(pattern) {
      var block = $$slice_before.$$p || nil, self = this;

      $$slice_before.$$p = null;
      
      ;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        $Kernel.$raise($$$('ArgumentError'), "both pattern and block are given")
      };
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + $to_s(arguments.length) + " expected 1)")
      };
      return $send($$$('Enumerator'), 'new', [], function $$51(e){var self = $$51.$$s == null ? this : $$51.$$s;

        
        if (e == null) e = nil;
        
        var slice = [];

        if (block !== nil) {
          if (pattern === undefined) {
            self.$each.$$p = function() {
              var param = $Opal.$destructure(arguments),
                  value = $yield1(block, param);

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
          else {
            self.$each.$$p = function() {
              var param = $Opal.$destructure(arguments),
                  value = block(param, pattern.$dup());

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
        }
        else {
          self.$each.$$p = function() {
            var param = $Opal.$destructure(arguments),
                value = pattern['$==='](param);

            if ($truthy(value) && slice.length > 0) {
              e['$<<'](slice);
              slice = [];
            }

            slice.push(param);
          };
        }

        self.$each();

        if (slice.length > 0) {
          e['$<<'](slice);
        }
      ;}, {$$s: self});
    }, -1);
    
    $def(self, '$slice_after', function $$slice_after(pattern) {
      var block = $$slice_after.$$p || nil, self = this;

      $$slice_after.$$p = null;
      
      ;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        $Kernel.$raise($$$('ArgumentError'), "both pattern and block are given")
      };
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + $to_s(arguments.length) + " expected 1)")
      };
      if ($truthy(pattern !== undefined)) {
        block = $send($Kernel, 'proc', [], function $$52(e){
          
          if (e == null) e = nil;
          return pattern['$==='](e);})
      };
      return $send($$$('Enumerator'), 'new', [], function $$53(yielder){var self = $$53.$$s == null ? this : $$53.$$s;

        
        if (yielder == null) yielder = nil;
        
        var accumulate;

        self.$each.$$p = function() {
          var element = $Opal.$destructure(arguments),
              end_chunk = $yield1(block, element);

          if (accumulate == null) {
            accumulate = [];
          }

          if ($truthy(end_chunk)) {
            accumulate.push(element);
            yielder.$yield(accumulate);
            accumulate = null;
          } else {
            accumulate.push(element)
          }
        }

        self.$each();

        if (accumulate != null) {
          yielder.$yield(accumulate);
        }
      ;}, {$$s: self});
    }, -1);
    
    $def(self, '$slice_when', function $$slice_when() {
      var block = $$slice_when.$$p || nil, self = this;

      $$slice_when.$$p = null;
      
      ;
      if (!(block !== nil)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1)")
      };
      return $send($$$('Enumerator'), 'new', [], function $$54(yielder){var self = $$54.$$s == null ? this : $$54.$$s;

        
        if (yielder == null) yielder = nil;
        
        var slice = nil, last_after = nil;

        self.$each_cons.$$p = function() {
          var params = $Opal.$destructure(arguments),
              before = params[0],
              after = params[1],
              match = $yieldX(block, [before, after]);

          last_after = after;

          if (slice === nil) {
            slice = [];
          }

          if ($truthy(match)) {
            slice.push(before);
            yielder.$yield(slice);
            slice = [];
          } else {
            slice.push(before);
          }
        }

        self.$each_cons(2);

        if (slice !== nil) {
          slice.push(last_after);
          yielder.$yield(slice);
        }
      ;}, {$$s: self});
    });
    
    $def(self, '$sort', function $$sort() {
      var block = $$sort.$$p || nil, self = this, ary = nil;

      $$sort.$$p = null;
      
      ;
      ary = self.$to_a();
      if (!(block !== nil)) {
        block = $lambda(function $$55(a, b){
          
          if (a == null) a = nil;
          if (b == null) b = nil;
          return a['$<=>'](b);})
      };
      return $send(ary, 'sort', [], block.$to_proc());
    });
    
    $def(self, '$sort_by', function $$sort_by() {
      var block = $$sort_by.$$p || nil, self = this, dup = nil;

      $$sort_by.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["sort_by"], function $$56(){var self = $$56.$$s == null ? this : $$56.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      dup = $send(self, 'map', [], function $$57(){var arg = nil;

        
        arg = $Opal.$destructure(arguments);
        return [Opal.yield1(block, arg), arg];});
      $send(dup, 'sort!', [], function $$58(a, b){
        
        if (a == null) a = nil;
        if (b == null) b = nil;
        return (a[0])['$<=>'](b[0]);});
      return $send(dup, 'map!', [], function $$59(i){
        
        if (i == null) i = nil;
        return i[1];;});
    });
    
    $def(self, '$sum', function $$sum(initial) {
      var $yield = $$sum.$$p || nil, self = this, result = nil, compensation = nil;

      $$sum.$$p = null;
      
      if (initial == null) initial = 0;
      result = initial;
      compensation = 0;
      $send(self, 'each', [], function $$60($a){var $post_args, args, item = nil, y = nil, t = nil;

        
        $post_args = $slice(arguments);
        args = $post_args;
        item = (($yield !== nil) ? (Opal.yieldX($yield, $to_a(args))) : ($Opal.$destructure(args)));
        if (($not([$$$($$$('Float'), 'INFINITY'), $$$($$$('Float'), 'INFINITY')['$-@']()]['$include?'](item)) && ($truthy(item['$respond_to?']("-"))))) {
          
          y = $rb_minus(item, compensation);
          t = $rb_plus(result, y);
          compensation = $rb_minus($rb_minus(t, result), y);
          return (result = t);
        } else {
          return (result = $rb_plus(result, item))
        };}, -1);
      return result;
    }, -1);
    
    $def(self, '$take', function $$take(num) {
      var self = this;

      return self.$first(num)
    });
    
    $def(self, '$take_while', function $$take_while() {try { var $t_return = $thrower('return'); 
      var block = $$take_while.$$p || nil, self = this, result = nil;

      $$take_while.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return self.$enum_for("take_while")
      };
      result = [];
      return $send(self, 'each', [], function $$61($a){var $post_args, args, value = nil;

        
        $post_args = $slice(arguments);
        args = $post_args;
        value = $Opal.$destructure(args);
        if (!$truthy(Opal.yield1(block, value))) {
          $t_return.$throw(result, $$61.$$is_lambda)
        };
        return result.push(value);;}, {$$arity: -1, $$ret: $t_return});} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      } finally {$t_return.is_orphan = true;}
    });
    
    $def(self, '$uniq', function $$uniq() {
      var block = $$uniq.$$p || nil, self = this, hash = nil;

      $$uniq.$$p = null;
      
      ;
      hash = (new Map());
      $send(self, 'each', [], function $$62($a){var $post_args, args, $b, value = nil, produced = nil;

        
        $post_args = $slice(arguments);
        args = $post_args;
        value = $Opal.$destructure(args);
        produced = ((block !== nil) ? (Opal.yield1(block, value)) : (value));
        if ($truthy(hash['$key?'](produced))) {
          return nil
        } else {
          return ($b = [produced, value], $send(hash, '[]=', $b), $b[$b.length - 1])
        };}, -1);
      return hash.$values();
    });
    
    $def(self, '$tally', function $$tally(hash) {
      var self = this, out = nil;

      
      ;
      if (hash && hash !== nil) { $deny_frozen_access(hash); };
      out = $send($send(self, 'group_by', [], "itself".$to_proc()), 'transform_values', [], "count".$to_proc());
      if ($truthy(hash)) {
        
        $send(out, 'each', [], function $$63(k, v){var $a;

          
          if (k == null) k = nil;
          if (v == null) v = nil;
          return ($a = [k, $rb_plus(hash.$fetch(k, 0), v)], $send(hash, '[]=', $a), $a[$a.length - 1]);});
        return hash;
      } else {
        return out
      };
    }, -1);
    
    $def(self, '$to_h', function $$to_h($a) {
      var block = $$to_h.$$p || nil, $post_args, args, self = this;

      $$to_h.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      if ((block !== nil)) {
        return $send($send(self, 'map', [], block.$to_proc()), 'to_h', $to_a(args))
      };
      
      var hash = (new Map());

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);
        var ary = $Opal['$coerce_to?'](param, $$$('Array'), "to_ary"), key, val;
        if (!ary.$$is_array) {
          $Kernel.$raise($$$('TypeError'), "wrong element type " + $to_s((param).$class()) + " (expected array)")
        }
        if (ary.length !== 2) {
          $Kernel.$raise($$$('ArgumentError'), "element has wrong array length (expected 2, was " + $to_s((ary).$length()) + ")")
        }
        key = ary[0];
        val = ary[1];

        Opal.hash_put(hash, key, val);
      };

      self.$each.apply(self, args);

      return hash;
    ;
    }, -1);
    
    $def(self, '$to_set', function $$to_set($a, $b) {
      var block = $$to_set.$$p || nil, $post_args, klass, args, self = this;

      $$to_set.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      
      if ($post_args.length > 0) klass = $post_args.shift();if (klass == null) klass = $$('Set');
      args = $post_args;
      return $send(klass, 'new', [self].concat($to_a(args)), block.$to_proc());
    }, -1);
    
    $def(self, '$zip', function $$zip($a) {
      var block = $$zip.$$p || nil, $post_args, others, self = this;

      $$zip.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      others = $post_args;
      return $send(self.$to_a(), 'zip', $to_a(others));
    }, -1);
    $alias(self, "find", "detect");
    $alias(self, "filter", "find_all");
    $alias(self, "flat_map", "collect_concat");
    $alias(self, "map", "collect");
    $alias(self, "member?", "include?");
    $alias(self, "reduce", "inject");
    $alias(self, "select", "find_all");
    return $alias(self, "to_a", "entries");
  })('::', $nesting)
};

Opal.modules["corelib/enumerator/arithmetic_sequence"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $klass = Opal.klass, $truthy = Opal.truthy, $to_a = Opal.to_a, $eqeq = Opal.eqeq, $Kernel = Opal.Kernel, $to_s = Opal.to_s, $def = Opal.def, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $rb_le = Opal.rb_le, $rb_ge = Opal.rb_ge, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $eqeqeq = Opal.eqeqeq, $not = Opal.not, $rb_times = Opal.rb_times, $rb_divide = Opal.rb_divide, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('is_a?,==,raise,respond_to?,class,attr_reader,begin,end,exclude_end?,>,step,<,<=,>=,-@,_lesser_than_end?,<<,+,-,===,%,_greater_than_begin?,reverse,!,include?,*,to_i,abs,/,hash,inspect');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'ArithmeticSequence');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.step_arg2 = $proto.receiver_num = $proto.step_arg1 = $proto.step = $proto.range = $proto.topfx = $proto.bypfx = $proto.creation_method = $proto.skipped_arg = nil;
      
      Opal.prop(self.$$prototype, '$$is_arithmetic_seq', true);
      var inf = Infinity;
      
      $def(self, '$initialize', function $$initialize(range, step, creation_method) {
        var $a, self = this, $ret_or_1 = nil;

        
        ;
        if (creation_method == null) creation_method = "step";
        self.creation_method = creation_method;
        if ($truthy(range['$is_a?']($$$('Array')))) {
          
          $a = [].concat($to_a(range)), (self.step_arg1 = ($a[0] == null ? nil : $a[0])), (self.step_arg2 = ($a[1] == null ? nil : $a[1])), (self.topfx = ($a[2] == null ? nil : $a[2])), (self.bypfx = ($a[3] == null ? nil : $a[3])), $a;
          self.receiver_num = step;
          self.step = 1;
          self.range = ($truthy(self.step_arg2) ? (((self.step = self.step_arg2), Opal.Range.$new(self.receiver_num, self.step_arg1, false))) : ($truthy(self.step_arg1) ? (Opal.Range.$new(self.receiver_num, self.step_arg1, false)) : (Opal.Range.$new(self.receiver_num, nil, false))));
        } else {
          
          if (!$truthy(step)) {
            self.skipped_arg = true
          };
          $a = [range, ($truthy(($ret_or_1 = step)) ? ($ret_or_1) : (1))], (self.range = $a[0]), (self.step = $a[1]), $a;
        };
        self.object = self;
        if ($eqeq(self.step, 0)) {
          $Kernel.$raise($$('ArgumentError'), "step can't be 0")
        };
        if ($truthy(self.step['$respond_to?']("to_int"))) {
          return nil
        } else {
          return $Kernel.$raise($$('ArgumentError'), $to_s("no implicit conversion of " + $to_s(self.step.$class()) + " ") + "into Integer")
        };
      }, -2);
      self.$attr_reader("step");
      
      $def(self, '$begin', function $$begin() {
        var self = this;

        return self.range.$begin()
      });
      
      $def(self, '$end', function $$end() {
        var self = this;

        return self.range.$end()
      });
      
      $def(self, '$exclude_end?', function $ArithmeticSequence_exclude_end$ques$1() {
        var self = this;

        return self.range['$exclude_end?']()
      });
      
      $def(self, '$_lesser_than_end?', function $ArithmeticSequence__lesser_than_end$ques$2(val) {
        var self = this, end_ = nil, $ret_or_1 = nil;

        
        end_ = ($truthy(($ret_or_1 = self.$end())) ? ($ret_or_1) : (inf));
        if ($truthy($rb_gt(self.$step(), 0))) {
          if ($truthy(self['$exclude_end?']())) {
            return $rb_lt(val, end_)
          } else {
            return $rb_le(val, end_)
          }
        } else if ($truthy(self['$exclude_end?']())) {
          return $rb_gt(val, end_)
        } else {
          return $rb_ge(val, end_)
        };
      });
      
      $def(self, '$_greater_than_begin?', function $ArithmeticSequence__greater_than_begin$ques$3(val) {
        var self = this, begin_ = nil, $ret_or_1 = nil;

        
        begin_ = ($truthy(($ret_or_1 = self.$begin())) ? ($ret_or_1) : ((inf)['$-@']()));
        if ($truthy($rb_gt(self.$step(), 0))) {
          return $rb_gt(val, begin_)
        } else {
          return $rb_lt(val, begin_)
        };
      });
      
      $def(self, '$first', function $$first(count) {
        var self = this, iter = nil, $ret_or_1 = nil, out = nil;

        
        ;
        iter = ($truthy(($ret_or_1 = self.$begin())) ? ($ret_or_1) : ((inf)['$-@']()));
        if (!$truthy(count)) {
          return ($truthy(self['$_lesser_than_end?'](iter)) ? (iter) : (nil))
        };
        out = [];
        while ($truthy(($truthy(($ret_or_1 = self['$_lesser_than_end?'](iter))) ? ($rb_gt(count, 0)) : ($ret_or_1)))) {
        
          out['$<<'](iter);
          iter = $rb_plus(iter, self.$step());
          count = $rb_minus(count, 1);
        };
        return out;
      }, -1);
      
      $def(self, '$each', function $$each() {
        var block = $$each.$$p || nil, self = this, $ret_or_1 = nil, iter = nil;

        $$each.$$p = null;
        
        ;
        if (!(block !== nil)) {
          return self
        };
        if ($eqeqeq(nil, ($ret_or_1 = self.$begin()))) {
          $Kernel.$raise($$('TypeError'), "nil can't be coerced into Integer")
        } else {
          nil
        };
        iter = ($truthy(($ret_or_1 = self.$begin())) ? ($ret_or_1) : ((inf)['$-@']()));
        while ($truthy(self['$_lesser_than_end?'](iter))) {
        
          Opal.yield1(block, iter);
          iter = $rb_plus(iter, self.$step());
        };
        return self;
      });
      
      $def(self, '$last', function $$last(count) {
        var self = this, $ret_or_1 = nil, iter = nil, out = nil;

        
        ;
        if (($eqeqeq(inf, ($ret_or_1 = self.$end())) || ($eqeqeq((inf)['$-@'](), $ret_or_1)))) {
          $Kernel.$raise($$$('FloatDomainError'), self.$end())
        } else if ($eqeqeq(nil, $ret_or_1)) {
          $Kernel.$raise($$$('RangeError'), "cannot get the last element of endless arithmetic sequence")
        } else {
          nil
        };
        iter = $rb_minus(self.$end(), $rb_minus(self.$end(), self.$begin())['$%'](self.$step()));
        if (!$truthy(self['$_lesser_than_end?'](iter))) {
          iter = $rb_minus(iter, self.$step())
        };
        if (!$truthy(count)) {
          return ($truthy(self['$_greater_than_begin?'](iter)) ? (iter) : (nil))
        };
        out = [];
        while ($truthy(($truthy(($ret_or_1 = self['$_greater_than_begin?'](iter))) ? ($rb_gt(count, 0)) : ($ret_or_1)))) {
        
          out['$<<'](iter);
          iter = $rb_minus(iter, self.$step());
          count = $rb_minus(count, 1);
        };
        return out.$reverse();
      }, -1);
      
      $def(self, '$size', function $$size() {
        var self = this, step_sign = nil, iter = nil;

        
        step_sign = ($truthy($rb_gt(self.$step(), 0)) ? (1) : (-1));
        if ($not(self['$_lesser_than_end?'](self.$begin()))) {
          return 0
        } else if ($truthy([(inf)['$-@'](), inf]['$include?'](self.$step()))) {
          return 1
        } else if (($truthy([$rb_times((inf)['$-@'](), step_sign), nil]['$include?'](self.$begin())) || ($truthy([$rb_times(inf, step_sign), nil]['$include?'](self.$end()))))) {
          return inf;
        } else {
          
          iter = $rb_minus(self.$end(), $rb_minus(self.$end(), self.$begin())['$%'](self.$step()));
          if (!$truthy(self['$_lesser_than_end?'](iter))) {
            iter = $rb_minus(iter, self.$step())
          };
          return $rb_plus($rb_divide($rb_minus(iter, self.$begin()), self.$step()).$abs().$to_i(), 1);
        };
      });
      
      $def(self, '$==', function $ArithmeticSequence_$eq_eq$4(other) {
        var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil;

        if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = ($truthy(($ret_or_4 = self.$class()['$=='](other.$class()))) ? (self.$begin()['$=='](other.$begin())) : ($ret_or_4)))) ? (self.$end()['$=='](other.$end())) : ($ret_or_3)))) ? (self.$step()['$=='](other.$step())) : ($ret_or_2))))) {
          return self['$exclude_end?']()['$=='](other['$exclude_end?']())
        } else {
          return $ret_or_1
        }
      });
      
      $def(self, '$hash', function $$hash() {
        var self = this;

        return [$$('ArithmeticSequence'), self.$begin(), self.$end(), self.$step(), self['$exclude_end?']()].$hash()
      });
      
      $def(self, '$inspect', function $$inspect() {
        var self = this, args = nil;

        if ($truthy(self.receiver_num)) {
          
          args = ($truthy(self.step_arg2) ? ("(" + $to_s(self.topfx) + $to_s(self.step_arg1.$inspect()) + ", " + $to_s(self.bypfx) + $to_s(self.step_arg2.$inspect()) + ")") : ($truthy(self.step_arg1) ? ("(" + $to_s(self.topfx) + $to_s(self.step_arg1.$inspect()) + ")") : nil));
          return "(" + $to_s(self.receiver_num.$inspect()) + "." + $to_s(self.creation_method) + $to_s(args) + ")";
        } else {
          
          args = ($truthy(self.skipped_arg) ? (nil) : ("(" + $to_s(self.step) + ")"));
          return "((" + $to_s(self.range.$inspect()) + ")." + $to_s(self.creation_method) + $to_s(args) + ")";
        }
      });
      $alias(self, "===", "==");
      return $alias(self, "eql?", "==");
    })(self, self, $nesting)
  })('::', null, $nesting)
};

Opal.modules["corelib/enumerator/chain"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $slice = Opal.slice, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $thrower = Opal.thrower, $to_s = Opal.to_s, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('to_enum,size,each,<<,to_proc,include?,+,reverse_each,respond_to?,rewind,inspect');
  return (function($base, $super) {
    var self = $klass($base, $super, 'Enumerator');

    
    return (function($base, $super) {
      var self = $klass($base, $super, 'Chain');

      var $proto = self.$$prototype;

      $proto.enums = $proto.iterated = nil;
      
      
      $def(self, '$initialize', function $$initialize($a) {
        var $post_args, enums, self = this;

        
        $post_args = $slice(arguments);
        enums = $post_args;
        $deny_frozen_access(self);
        self.enums = enums;
        self.iterated = [];
        return (self.object = self);
      }, -1);
      
      $def(self, '$each', function $$each($a) {
        var block = $$each.$$p || nil, $post_args, args, self = this;

        $$each.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        if (!(block !== nil)) {
          return $send(self, 'to_enum', ["each"].concat($to_a(args)), function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

            return self.$size()}, {$$s: self})
        };
        $send(self.enums, 'each', [], function $$2(enum$){var self = $$2.$$s == null ? this : $$2.$$s;
          if (self.iterated == null) self.iterated = nil;

          
          if (enum$ == null) enum$ = nil;
          self.iterated['$<<'](enum$);
          return $send(enum$, 'each', $to_a(args), block.$to_proc());}, {$$s: self});
        return self;
      }, -1);
      
      $def(self, '$size', function $$size($a) {try { var $t_return = $thrower('return'); 
        var $post_args, args, self = this, accum = nil;

        
        $post_args = $slice(arguments);
        args = $post_args;
        accum = 0;
        $send(self.enums, 'each', [], function $$3(enum$){var size = nil;

          
          if (enum$ == null) enum$ = nil;
          size = $send(enum$, 'size', $to_a(args));
          if ($truthy([nil, $$$($$$('Float'), 'INFINITY')]['$include?'](size))) {
            $t_return.$throw(size, $$3.$$is_lambda)
          };
          return (accum = $rb_plus(accum, size));}, {$$ret: $t_return});
        return accum;} catch($e) {
          if ($e === $t_return) return $e.$v;
          throw $e;
        } finally {$t_return.is_orphan = true;}
      }, -1);
      
      $def(self, '$rewind', function $$rewind() {
        var self = this;

        
        $send(self.iterated, 'reverse_each', [], function $$4(enum$){
          
          if (enum$ == null) enum$ = nil;
          if ($truthy(enum$['$respond_to?']("rewind"))) {
            return enum$.$rewind()
          } else {
            return nil
          };});
        self.iterated = [];
        return self;
      });
      return $def(self, '$inspect', function $$inspect() {
        var self = this;

        return "#<Enumerator::Chain: " + $to_s(self.enums.$inspect()) + ">"
      });
    })(self, self)
  })('::', null)
};

Opal.modules["corelib/enumerator/generator"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $def = Opal.def, $slice = Opal.slice, $send = Opal.send, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,raise,new,to_proc');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Generator');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.block = nil;
      
      self.$include($$$('Enumerable'));
      
      $def(self, '$initialize', function $$initialize() {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        $deny_frozen_access(self);
        if (!$truthy(block)) {
          $Kernel.$raise($$$('LocalJumpError'), "no block given")
        };
        return (self.block = block);
      });
      return $def(self, '$each', function $$each($a) {
        var block = $$each.$$p || nil, $post_args, args, self = this, yielder = nil;

        $$each.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        yielder = $send($$('Yielder'), 'new', [], block.$to_proc());
        
        try {
          args.unshift(yielder);

          Opal.yieldX(self.block, args);
        }
        catch (e) {
          if (e && e.$thrower_type == "breaker") {
            return e.$v;
          }
          else {
            throw e;
          }
        }
      ;
        return self;
      }, -1);
    })($nesting[0], null, $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["corelib/enumerator/lazy"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $yield1 = Opal.yield1, $yieldX = Opal.yieldX, $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $slice = Opal.slice, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $defs = Opal.defs, $Kernel = Opal.Kernel, $send = Opal.send, $def = Opal.def, $return_self = Opal.return_self, $Opal = Opal.Opal, $rb_lt = Opal.rb_lt, $eqeqeq = Opal.eqeqeq, $rb_plus = Opal.rb_plus, $to_s = Opal.to_s, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,each,new,enumerator_size,yield,respond_to?,try_convert,<,===,+,for,class,to_proc,destructure,inspect,to_a,find_all,collect_concat,collect,enum_for');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Lazy');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.enumerator = nil;
      
      $klass(self, $$$('Exception'), 'StopLazyError');
      $defs(self, '$for', function $Lazy_for$1(object, $a) {
        var $post_args, $fwd_rest, $yield = $Lazy_for$1.$$p || nil, self = this, lazy = nil;

        $Lazy_for$1.$$p = null;
        
        $post_args = $slice(arguments, 1);
        $fwd_rest = $post_args;
        lazy = $send2(self, $find_super(self, 'for', $Lazy_for$1, false, true), 'for', [object].concat($to_a($fwd_rest)), $yield);
        lazy.enumerator = object;
        return lazy;
      }, -2);
      
      $def(self, '$initialize', function $$initialize(object, size) {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        if (size == null) size = nil;
        $deny_frozen_access(self);
        if (!(block !== nil)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy new without a block")
        };
        self.enumerator = object;
        return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [size], function $$2(yielder, $a){var $post_args, each_args;

          
          if (yielder == null) yielder = nil;
          $post_args = $slice(arguments, 1);
          each_args = $post_args;
          try {
            return $send(object, 'each', $to_a(each_args), function $$3($b){var $post_args, args;

              
              $post_args = $slice(arguments);
              args = $post_args;
              
            args.unshift(yielder);

            $yieldX(block, args);
          ;}, -1)
          } catch ($err) {
            if (Opal.rescue($err, [$$('StopLazyError')])) {
              try {
                return nil
              } finally { Opal.pop_exception($err); }
            } else { throw $err; }
          };}, -2);
      }, -2);
      
      $def(self, '$lazy', $return_self);
      
      $def(self, '$collect', function $$collect() {
        var block = $$collect.$$p || nil, self = this;

        $$collect.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$('Lazy'), 'new', [self, self.$enumerator_size()], function $$4(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          
          var value = $yieldX(block, args);

          enum$.$yield(value);
        ;}, -2);
      });
      
      $def(self, '$collect_concat', function $$collect_concat() {
        var block = $$collect_concat.$$p || nil, self = this;

        $$collect_concat.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$5(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          
          var value = $yieldX(block, args);

          if ((value)['$respond_to?']("force") && (value)['$respond_to?']("each")) {
            $send((value), 'each', [], function $$6(v){
            
            if (v == null) v = nil;
            return enum$.$yield(v);})
          }
          else {
            var array = $Opal.$try_convert(value, $$$('Array'), "to_ary");

            if (array === nil) {
              enum$.$yield(value);
            }
            else {
              $send((value), 'each', [], function $$7(v){
            
            if (v == null) v = nil;
            return enum$.$yield(v);});
            }
          }
        ;}, -2);
      });
      
      $def(self, '$drop', function $$drop(n) {
        var self = this, current_size = nil, set_size = nil, dropped = nil;

        
        n = $coerce_to(n, $$$('Integer'), 'to_int');
        if ($truthy($rb_lt(n, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "attempt to drop negative size")
        };
        current_size = self.$enumerator_size();
        set_size = ($eqeqeq($$$('Integer'), current_size) ? (($truthy($rb_lt(n, current_size)) ? (n) : (current_size))) : (current_size));
        dropped = 0;
        return $send($$('Lazy'), 'new', [self, set_size], function $$8(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          if ($truthy($rb_lt(dropped, n))) {
            return (dropped = $rb_plus(dropped, 1))
          } else {
            return $send(enum$, 'yield', $to_a(args))
          };}, -2);
      });
      
      $def(self, '$drop_while', function $$drop_while() {
        var block = $$drop_while.$$p || nil, self = this, succeeding = nil;

        $$drop_while.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy drop_while without a block")
        };
        succeeding = true;
        return $send($$('Lazy'), 'new', [self, nil], function $$9(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          if ($truthy(succeeding)) {
            
            var value = $yieldX(block, args);

            if (!$truthy(value)) {
              succeeding = false;

              $send(enum$, 'yield', $to_a(args));
            }
          
          } else {
            return $send(enum$, 'yield', $to_a(args))
          };}, -2);
      });
      
      $def(self, '$enum_for', function $$enum_for($a, $b) {
        var block = $$enum_for.$$p || nil, $post_args, method, args, self = this;

        $$enum_for.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        
        if ($post_args.length > 0) method = $post_args.shift();if (method == null) method = "each";
        args = $post_args;
        return $send(self.$class(), 'for', [self, method].concat($to_a(args)), block.$to_proc());
      }, -1);
      
      $def(self, '$find_all', function $$find_all() {
        var block = $$find_all.$$p || nil, self = this;

        $$find_all.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy select without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$10(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          
          var value = $yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', $to_a(args));
          }
        ;}, -2);
      });
      
      $def(self, '$grep', function $$grep(pattern) {
        var block = $$grep.$$p || nil, self = this;

        $$grep.$$p = null;
        
        ;
        if ($truthy(block)) {
          return $send($$('Lazy'), 'new', [self, nil], function $$11(enum$, $a){var $post_args, args;

            
            if (enum$ == null) enum$ = nil;
            $post_args = $slice(arguments, 1);
            args = $post_args;
            
            var param = $Opal.$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              value = $yield1(block, param);

              enum$.$yield($yield1(block, param));
            }
          ;}, -2)
        } else {
          return $send($$('Lazy'), 'new', [self, nil], function $$12(enum$, $a){var $post_args, args;

            
            if (enum$ == null) enum$ = nil;
            $post_args = $slice(arguments, 1);
            args = $post_args;
            
            var param = $Opal.$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              enum$.$yield(param);
            }
          ;}, -2)
        };
      });
      
      $def(self, '$reject', function $$reject() {
        var block = $$reject.$$p || nil, self = this;

        $$reject.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy reject without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$13(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          
          var value = $yieldX(block, args);

          if (!$truthy(value)) {
            $send(enum$, 'yield', $to_a(args));
          }
        ;}, -2);
      });
      
      $def(self, '$take', function $$take(n) {
        var self = this, current_size = nil, set_size = nil, taken = nil;

        
        n = $coerce_to(n, $$$('Integer'), 'to_int');
        if ($truthy($rb_lt(n, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "attempt to take negative size")
        };
        current_size = self.$enumerator_size();
        set_size = ($eqeqeq($$$('Integer'), current_size) ? (($truthy($rb_lt(n, current_size)) ? (n) : (current_size))) : (current_size));
        taken = 0;
        return $send($$('Lazy'), 'new', [self, set_size], function $$14(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          if ($truthy($rb_lt(taken, n))) {
            
            $send(enum$, 'yield', $to_a(args));
            return (taken = $rb_plus(taken, 1));
          } else {
            return $Kernel.$raise($$('StopLazyError'))
          };}, -2);
      });
      
      $def(self, '$take_while', function $$take_while() {
        var block = $$take_while.$$p || nil, self = this;

        $$take_while.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy take_while without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$15(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          
          var value = $yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', $to_a(args));
          }
          else {
            $Kernel.$raise($$('StopLazyError'));
          }
        ;}, -2);
      });
      
      $def(self, '$inspect', function $$inspect() {
        var self = this;

        return "#<" + $to_s(self.$class()) + ": " + $to_s(self.enumerator.$inspect()) + ">"
      });
      $alias(self, "force", "to_a");
      $alias(self, "filter", "find_all");
      $alias(self, "flat_map", "collect_concat");
      $alias(self, "map", "collect");
      $alias(self, "select", "find_all");
      return $alias(self, "to_enum", "enum_for");
    })(self, self, $nesting)
  })('::', null, $nesting)
};

Opal.modules["corelib/enumerator/yielder"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $klass = Opal.klass, $def = Opal.def, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('yield,proc');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super) {
      var self = $klass($base, $super, 'Yielder');

      var $proto = self.$$prototype;

      $proto.block = nil;
      
      
      $def(self, '$initialize', function $$initialize() {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        self.block = block;
        return self;
      });
      
      $def(self, '$yield', function $Yielder_yield$1($a) {
        var $post_args, values, self = this;

        
        $post_args = $slice(arguments);
        values = $post_args;
        
        var value = Opal.yieldX(self.block, values);

        if (value && value.$thrower_type == "break") {
          throw value;
        }

        return value;
      ;
      }, -1);
      
      $def(self, '$<<', function $Yielder_$lt$lt$2(value) {
        var self = this;

        
        self.$yield(value);
        return self;
      });
      return $def(self, '$to_proc', function $$to_proc() {
        var self = this;

        return $send(self, 'proc', [], function $$3($a){var $post_args, values, self = $$3.$$s == null ? this : $$3.$$s;

          
          $post_args = $slice(arguments);
          values = $post_args;
          return $send(self, 'yield', $to_a(values));}, {$$arity: -1, $$s: self})
      });
    })($nesting[0], null)
  })($nesting[0], null, $nesting)
};

Opal.modules["corelib/enumerator"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $slice = Opal.slice, $coerce_to = Opal.coerce_to, $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $defs = Opal.defs, $truthy = Opal.truthy, $send = Opal.send, $not = Opal.not, $def = Opal.def, $rb_plus = Opal.rb_plus, $to_a = Opal.to_a, $Opal = Opal.Opal, $send2 = Opal.send2, $find_super = Opal.find_super, $rb_ge = Opal.rb_ge, $Kernel = Opal.Kernel, $rb_le = Opal.rb_le, $to_s = Opal.to_s, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,allocate,new,to_proc,!,respond_to?,empty?,nil?,+,class,__send__,call,enum_for,size,destructure,map,>=,length,raise,[],peek_values,<=,next_values,inspect,any?,each_with_object,autoload');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.size = $proto.args = $proto.object = $proto.method = $proto.values = $proto.cursor = nil;
    
    self.$include($$$('Enumerable'));
    self.$$prototype.$$is_enumerator = true;
    $defs(self, '$for', function $Enumerator_for$1(object, $a, $b) {
      var block = $Enumerator_for$1.$$p || nil, $post_args, method, args, self = this;

      $Enumerator_for$1.$$p = null;
      
      ;
      $post_args = $slice(arguments, 1);
      
      if ($post_args.length > 0) method = $post_args.shift();if (method == null) method = "each";
      args = $post_args;
      
      var obj = self.$allocate();

      obj.object = object;
      obj.size   = block;
      obj.method = method;
      obj.args   = args;
      obj.cursor = 0;

      return obj;
    ;
    }, -2);
    
    $def(self, '$initialize', function $$initialize($a) {
      var block = $$initialize.$$p || nil, $post_args, $fwd_rest, self = this;

      $$initialize.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      $deny_frozen_access(self);
      self.cursor = 0;
      if ($truthy(block)) {
        
        self.object = $send($$('Generator'), 'new', [], block.$to_proc());
        self.method = "each";
        self.args = [];
        self.size = arguments[0] || nil;
        if (($truthy(self.size) && ($not(self.size['$respond_to?']("call"))))) {
          return (self.size = $coerce_to(self.size, $$$('Integer'), 'to_int'))
        } else {
          return nil
        };
      } else {
        
        self.object = arguments[0];
        self.method = arguments[1] || "each";
        self.args = $slice(arguments, 2);
        return (self.size = nil);
      };
    }, -1);
    
    $def(self, '$each', function $$each($a) {
      var block = $$each.$$p || nil, $post_args, args, self = this;

      $$each.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      if (($truthy(block['$nil?']()) && ($truthy(args['$empty?']())))) {
        return self
      };
      args = $rb_plus(self.args, args);
      if ($truthy(block['$nil?']())) {
        return $send(self.$class(), 'new', [self.object, self.method].concat($to_a(args)))
      };
      return $send(self.object, '__send__', [self.method].concat($to_a(args)), block.$to_proc());
    }, -1);
    
    $def(self, '$size', function $$size() {
      var self = this;

      if ($truthy(self.size['$respond_to?']("call"))) {
        return $send(self.size, 'call', $to_a(self.args))
      } else {
        return self.size
      }
    });
    
    $def(self, '$with_index', function $$with_index(offset) {
      var block = $$with_index.$$p || nil, self = this;

      $$with_index.$$p = null;
      
      ;
      if (offset == null) offset = 0;
      offset = ($truthy(offset) ? ($coerce_to(offset, $$$('Integer'), 'to_int')) : (0));
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["with_index", offset], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var result, index = offset;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = block(param, index);

        index++;

        return value;
      }

      return self.$each();
    ;
    }, -1);
    
    $def(self, '$each_with_index', function $$each_with_index() {
      var block = $$each_with_index.$$p || nil, self = this;

      $$each_with_index.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_with_index"], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

          return self.$size()}, {$$s: self})
      };
      $send2(self, $find_super(self, 'each_with_index', $$each_with_index, false, true), 'each_with_index', [], block);
      return self.object;
    });
    
    $def(self, '$rewind', function $$rewind() {
      var self = this;

      
      self.cursor = 0;
      return self;
    });
    
    $def(self, '$peek_values', function $$peek_values() {
      var self = this, $ret_or_1 = nil;

      
      self.values = ($truthy(($ret_or_1 = self.values)) ? ($ret_or_1) : ($send(self, 'map', [], function $$4($a){var $post_args, i;

        
        $post_args = $slice(arguments);
        i = $post_args;
        return i;}, -1)));
      if ($truthy($rb_ge(self.cursor, self.values.$length()))) {
        $Kernel.$raise($$$('StopIteration'), "iteration reached an end")
      };
      return self.values['$[]'](self.cursor);
    });
    
    $def(self, '$peek', function $$peek() {
      var self = this, values = nil;

      
      values = self.$peek_values();
      if ($truthy($rb_le(values.$length(), 1))) {
        return values['$[]'](0)
      } else {
        return values
      };
    });
    
    $def(self, '$next_values', function $$next_values() {
      var self = this, out = nil;

      
      out = self.$peek_values();
      self.cursor = $rb_plus(self.cursor, 1);
      return out;
    });
    
    $def(self, '$next', function $$next() {
      var self = this, values = nil;

      
      values = self.$next_values();
      if ($truthy($rb_le(values.$length(), 1))) {
        return values['$[]'](0)
      } else {
        return values
      };
    });
    
    $def(self, '$feed', function $$feed(arg) {
      var self = this;

      return self.$raise($$('NotImplementedError'), "Opal doesn't support Enumerator#feed")
    });
    
    $def(self, '$+', function $Enumerator_$plus$5(other) {
      var self = this;

      return $$$($$$('Enumerator'), 'Chain').$new(self, other)
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, result = nil;

      
      result = "#<" + $to_s(self.$class()) + ": " + $to_s(self.object.$inspect()) + ":" + $to_s(self.method);
      if ($truthy(self.args['$any?']())) {
        result = $rb_plus(result, "(" + $to_s(self.args.$inspect()['$[]']($$$('Range').$new(1, -2))) + ")")
      };
      return $rb_plus(result, ">");
    });
    $alias(self, "with_object", "each_with_object");
    self.$autoload("ArithmeticSequence", "corelib/enumerator/arithmetic_sequence");
    self.$autoload("Chain", "corelib/enumerator/chain");
    self.$autoload("Generator", "corelib/enumerator/generator");
    self.$autoload("Lazy", "corelib/enumerator/lazy");
    return self.$autoload("Yielder", "corelib/enumerator/yielder");
  })('::', null, $nesting);
};

Opal.modules["corelib/numeric"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $def = Opal.def, $to_ary = Opal.to_ary, $to_s = Opal.to_s, $return_self = Opal.return_self, $rb_minus = Opal.rb_minus, $rb_times = Opal.rb_times, $rb_lt = Opal.rb_lt, $eqeq = Opal.eqeq, $rb_divide = Opal.rb_divide, $return_val = Opal.return_val, $Opal = Opal.Opal, $slice = Opal.slice, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $not = Opal.not, $send = Opal.send, $rb_ge = Opal.rb_ge, $rb_le = Opal.rb_le, $rb_plus = Opal.rb_plus, $rb_gt = Opal.rb_gt, $alias = Opal.alias, self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,instance_of?,class,Float,respond_to?,coerce,__send__,raise,equal?,-,*,div,<,-@,ceil,to_f,denominator,to_r,==,floor,/,%,Complex,zero?,numerator,abs,arg,coerce_to!,round,<=>,compare,is_a?,!,new,enum_for,to_proc,negative?,>=,<=,+,to_i,truncate,>,angle,conj,imag,rect');
  
  self.$require("corelib/comparable");
  return (function($base, $super) {
    var self = $klass($base, $super, 'Numeric');

    
    
    self.$include($$$('Comparable'));
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
        return [other, self]
      };
      return [$Kernel.$Float(other), $Kernel.$Float(self)];
    });
    
    $def(self, '$__coerced__', function $$__coerced__(method, other) {
      var $a, $b, self = this, a = nil, b = nil;

      if ($truthy(other['$respond_to?']("coerce"))) {
        
        $b = other.$coerce(self), $a = $to_ary($b), (a = ($a[0] == null ? nil : $a[0])), (b = ($a[1] == null ? nil : $a[1])), $b;
        return a.$__send__(method, b);
      } else 
      switch (method.valueOf()) {
        case "+":
        case "-":
        case "*":
        case "/":
        case "%":
        case "&":
        case "|":
        case "^":
        case "**":
          return $Kernel.$raise($$$('TypeError'), $to_s(other.$class()) + " can't be coerced into Numeric")
        case ">":
        case ">=":
        case "<":
        case "<=":
        case "<=>":
          return $Kernel.$raise($$$('ArgumentError'), "comparison of " + $to_s(self.$class()) + " with " + $to_s(other.$class()) + " failed")
        default:
          return nil
      }
    });
    
    $def(self, '$<=>', function $Numeric_$lt_eq_gt$1(other) {
      var self = this;

      
      if ($truthy(self['$equal?'](other))) {
        return 0
      };
      return nil;
    });
    
    $def(self, '$+@', $return_self);
    
    $def(self, '$-@', function $Numeric_$minus$$2() {
      var self = this;

      return $rb_minus(0, self)
    });
    
    $def(self, '$%', function $Numeric_$percent$3(other) {
      var self = this;

      return $rb_minus(self, $rb_times(other, self.$div(other)))
    });
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      if ($truthy($rb_lt(self, 0))) {
        return self['$-@']()
      } else {
        return self
      }
    });
    
    $def(self, '$abs2', function $$abs2() {
      var self = this;

      return $rb_times(self, self)
    });
    
    $def(self, '$angle', function $$angle() {
      var self = this;

      if ($truthy($rb_lt(self, 0))) {
        return $$$($$$('Math'), 'PI')
      } else {
        return 0
      }
    });
    
    $def(self, '$ceil', function $$ceil(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      return self.$to_f().$ceil(ndigits);
    }, -1);
    
    $def(self, '$conj', $return_self);
    
    $def(self, '$denominator', function $$denominator() {
      var self = this;

      return self.$to_r().$denominator()
    });
    
    $def(self, '$div', function $$div(other) {
      var self = this;

      
      if ($eqeq(other, 0)) {
        $Kernel.$raise($$$('ZeroDivisionError'), "divided by o")
      };
      return $rb_divide(self, other).$floor();
    });
    
    $def(self, '$divmod', function $$divmod(other) {
      var self = this;

      return [self.$div(other), self['$%'](other)]
    });
    
    $def(self, '$fdiv', function $$fdiv(other) {
      var self = this;

      return $rb_divide(self.$to_f(), other)
    });
    
    $def(self, '$floor', function $$floor(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      return self.$to_f().$floor(ndigits);
    }, -1);
    
    $def(self, '$i', function $$i() {
      var self = this;

      return $Kernel.$Complex(0, self)
    });
    
    $def(self, '$imag', $return_val(0));
    
    $def(self, '$integer?', $return_val(false));
    
    $def(self, '$nonzero?', function $Numeric_nonzero$ques$4() {
      var self = this;

      if ($truthy(self['$zero?']())) {
        return nil
      } else {
        return self
      }
    });
    
    $def(self, '$numerator', function $$numerator() {
      var self = this;

      return self.$to_r().$numerator()
    });
    
    $def(self, '$polar', function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    });
    
    $def(self, '$quo', function $$quo(other) {
      var self = this;

      return $rb_divide($Opal['$coerce_to!'](self, $$$('Rational'), "to_r"), other)
    });
    
    $def(self, '$real', $return_self);
    
    $def(self, '$real?', $return_val(true));
    
    $def(self, '$rect', function $$rect() {
      var self = this;

      return [self, 0]
    });
    
    $def(self, '$round', function $$round(digits) {
      var self = this;

      
      ;
      return self.$to_f().$round(digits);
    }, -1);
    
    $def(self, '$step', function $$step($a, $b, $c) {
      var block = $$step.$$p || nil, $post_args, $kwargs, limit, step, to, by, self = this, counter = nil;

      $$step.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      
      if ($post_args.length > 0) limit = $post_args.shift();;
      
      if ($post_args.length > 0) step = $post_args.shift();;
      
      to = $hash_get($kwargs, "to");;
      
      by = $hash_get($kwargs, "by");;
      
      if (limit !== undefined && to !== undefined) {
        $Kernel.$raise($$$('ArgumentError'), "to is given twice")
      }

      if (step !== undefined && by !== undefined) {
        $Kernel.$raise($$$('ArgumentError'), "step is given twice")
      }

      if (to !== undefined) {
        limit = to;
      }

      if (by !== undefined) {
        step = by;
      }

      if (limit === undefined) {
        limit = nil;
      }

      function validateParameters() {
        if (step === nil) {
          $Kernel.$raise($$$('TypeError'), "step must be numeric")
        }

        if (step != null && step['$=='](0)) {
          $Kernel.$raise($$$('ArgumentError'), "step can't be 0")
        }

        if (step === nil || step == null) {
          step = 1;
        }

        var sign = step['$<=>'](0);

        if (sign === nil) {
          $Kernel.$raise($$$('ArgumentError'), "0 can't be coerced into " + $to_s(step.$class()))
        }

        if (limit === nil || limit == null) {
          limit = sign > 0 ? $$$($$$('Float'), 'INFINITY') : $$$($$$('Float'), 'INFINITY')['$-@']();
        }

        $Opal.$compare(self, limit)
      }

      function stepFloatSize() {
        if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else if (step === Infinity || step === -Infinity) {
          return 1;
        } else {
          var abs = Math.abs, floor = Math.floor,
              err = (abs(self) + abs(limit) + abs(limit - self)) / abs(step) * $$$($$$('Float'), 'EPSILON');

          if (err === Infinity || err === -Infinity) {
            return 0;
          } else {
            if (err > 0.5) {
              err = 0.5;
            }

            return floor((limit - self) / step + err) + 1
          }
        }
      }

      function stepSize() {
        validateParameters();

        if (step === 0) {
          return Infinity;
        }

        if (step % 1 !== 0) {
          return stepFloatSize();
        } else if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else {
          var ceil = Math.ceil, abs = Math.abs,
              lhs = abs(self - limit) + 1,
              rhs = abs(step);

          return ceil(lhs / rhs);
        }
      }

    ;
      if (!(block !== nil)) {
        if ((($not(limit) || ($truthy(limit['$is_a?']($$$('Numeric'))))) && (($not(step) || ($truthy(step['$is_a?']($$$('Numeric')))))))) {
          return $$$($$$('Enumerator'), 'ArithmeticSequence').$new([limit, step, ($truthy(to) ? ("to: ") : nil), ($truthy(by) ? ("by: ") : nil)], self)
        } else {
          return $send(self, 'enum_for', ["step", limit, step], (stepSize).$to_proc())
        }
      };
      
      validateParameters();

      var isDesc = step['$negative?'](),
          isInf = step['$=='](0) ||
                  (limit === Infinity && !isDesc) ||
                  (limit === -Infinity && isDesc);

      if (self.$$is_number && step.$$is_number && limit.$$is_number) {
        if (self % 1 === 0 && (isInf || limit % 1 === 0) && step % 1 === 0) {
          var value = self;

          if (isInf) {
            for (;; value += step) {
              block(value);
            }
          } else if (isDesc) {
            for (; value >= limit; value += step) {
              block(value);
            }
          } else {
            for (; value <= limit; value += step) {
              block(value);
            }
          }

          return self;
        } else {
          var begin = self.$to_f().valueOf();
          step = step.$to_f().valueOf();
          limit = limit.$to_f().valueOf();

          var n = stepFloatSize();

          if (!isFinite(step)) {
            if (n !== 0) block(begin);
          } else if (step === 0) {
            while (true) {
              block(begin);
            }
          } else {
            for (var i = 0; i < n; i++) {
              var d = i * step + self;
              if (step >= 0 ? limit < d : limit > d) {
                d = limit;
              }
              block(d);
            }
          }

          return self;
        }
      }
    ;
      counter = self;
      while ($truthy(isDesc ? $rb_ge(counter, limit) : $rb_le(counter, limit))) {
      
        Opal.yield1(block, counter);
        counter = $rb_plus(counter, step);
      };
    }, -1);
    
    $def(self, '$to_c', function $$to_c() {
      var self = this;

      return $Kernel.$Complex(self, 0)
    });
    
    $def(self, '$to_int', function $$to_int() {
      var self = this;

      return self.$to_i()
    });
    
    $def(self, '$truncate', function $$truncate(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      return self.$to_f().$truncate(ndigits);
    }, -1);
    
    $def(self, '$zero?', function $Numeric_zero$ques$5() {
      var self = this;

      return self['$=='](0)
    });
    
    $def(self, '$positive?', function $Numeric_positive$ques$6() {
      var self = this;

      return $rb_gt(self, 0)
    });
    
    $def(self, '$negative?', function $Numeric_negative$ques$7() {
      var self = this;

      return $rb_lt(self, 0)
    });
    
    $def(self, '$dup', $return_self);
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $hash_get($kwargs, "freeze");if (freeze == null) freeze = true;
      return self;
    }, -1);
    
    $def(self, '$finite?', $return_val(true));
    
    $def(self, '$infinite?', $return_val(nil));
    $alias(self, "arg", "angle");
    $alias(self, "conjugate", "conj");
    $alias(self, "imaginary", "imag");
    $alias(self, "magnitude", "abs");
    $alias(self, "modulo", "%");
    $alias(self, "phase", "arg");
    return $alias(self, "rectangular", "rect");
  })('::', null);
};

Opal.modules["corelib/array"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  var $truthy = Opal.truthy, $falsy = Opal.falsy, $yield1 = Opal.yield1, $hash_get = Opal.hash_get, $hash_put = Opal.hash_put, $hash_delete = Opal.hash_delete, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $deny_frozen_access = Opal.deny_frozen_access, $freeze = Opal.freeze, $opal32_init = Opal.opal32_init, $opal32_add = Opal.opal32_add, $klass = Opal.klass, $slice = Opal.slice, $defs = Opal.defs, $Kernel = Opal.Kernel, $to_s = Opal.to_s, $def = Opal.def, $Opal = Opal.Opal, $eqeqeq = Opal.eqeqeq, $send2 = Opal.send2, $find_super = Opal.find_super, $send = Opal.send, $rb_gt = Opal.rb_gt, $rb_times = Opal.rb_times, $eqeq = Opal.eqeq, $rb_minus = Opal.rb_minus, $to_a = Opal.to_a, $to_ary = Opal.to_ary, $gvars = Opal.gvars, $rb_ge = Opal.rb_ge, $assign_ivar = Opal.assign_ivar, $rb_lt = Opal.rb_lt, $return_self = Opal.return_self, $neqeq = Opal.neqeq, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,to_a,warn,raise,replace,respond_to?,to_ary,coerce_to?,join,to_str,===,<=>,==,object_id,inspect,enum_for,class,bsearch_index,to_proc,nil?,coerce_to!,>,*,enumerator_size,empty?,size,map,equal?,dup,each,reduce,-,[],dig,eql?,length,exclude_end?,flatten,frozen?,__id__,sort_by,&,to_s,new,item,max,min,!,>=,**,delete_if,rotate,rand,at,keep_if,shuffle!,<,sort,!=,times,[]=,<<,uniq,|,values,is_a?,end,begin,upto,reject,push,select,select!,collect,collect!,unshift,pristine,singleton_class');
  
  self.$require("corelib/enumerable");
  self.$require("corelib/numeric");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Enumerable'));
    Opal.prop(self.$$prototype, '$$is_array', true);
    
    // Recent versions of V8 (> 7.1) only use an optimized implementation when Array.prototype is unmodified.
    // For instance, "array-splice.tq" has a "fast path" (ExtractFastJSArray, defined in "src/codegen/code-stub-assembler.cc")
    // but it's only enabled when "IsPrototypeInitialArrayPrototype()" is true.
    //
    // Older versions of V8 were using relatively fast JS-with-extensions code even when Array.prototype is modified:
    // https://github.com/v8/v8/blob/7.0.1/src/js/array.js#L599-L642
    //
    // In short, Array operations are slow in recent versions of V8 when the Array.prototype has been tampered.
    // So, when possible, we are using faster open-coded version to boost the performance.

    // As of V8 8.4, depending on the size of the array, this is up to ~25x times faster than Array#shift()
    // Implementation is heavily inspired by: https://github.com/nodejs/node/blob/ba684805b6c0eded76e5cd89ee00328ac7a59365/lib/internal/util.js#L341-L347
    function shiftNoArg(list) {
      var r = list[0];
      var index = 1;
      var length = list.length;
      for (; index < length; index++) {
        list[index - 1] = list[index];
      }
      list.pop();
      return r;
    }

    function toArraySubclass(obj, klass) {
      if (klass.$$name === Opal.Array) {
        return obj;
      } else {
        return klass.$allocate().$replace((obj).$to_a());
      }
    }

    // A helper for keep_if and delete_if, filter is either Opal.truthy
    // or Opal.falsy.
    function filterIf(self, filter, block) {
      var value, raised = null, updated = new Array(self.length);

      for (var i = 0, i2 = 0; i < self.length; i++) {
        if (!raised) {
          try {
            value = $yield1(block, self[i])
          } catch(error) {
            raised = error;
          }
        }

        if (raised || filter(value)) {
          updated[i2] = self[i]
          i2 += 1;
        }
      }

      if (i2 !== i) {
        self.splice.apply(self, [0, updated.length].concat(updated));
        self.splice(i2, updated.length);
      }

      if (raised) throw raised;
    }

    function convertToArray(array) {
      if (!array.$$is_array) {
        array = $coerce_to(array, $$$('Array'), 'to_ary');
      }
      return (array).$to_a();
    }

    function fast_push(arr, objects) {
      // push.apply() for arrays longer than 32767 may cause various argument errors in browsers
      // but it is significantly faster than a for loop, which pushes each element separately
      // but apply() has a overhead by itself, for a small number of elements
      // the for loop is significantly faster
      // this is using the best option depending on objects.length
      var length = objects.length;
      if (length > 6 && length < 32767) {
        arr.push.apply(arr, objects);
      } else {
        for (var i = 0; i < length; i++) {
          arr.push(objects[i]);
        }
      }
    }
  ;
    $defs(self, '$[]', function $Array_$$$1($a) {
      var $post_args, objects, self = this;

      
      $post_args = $slice(arguments);
      objects = $post_args;
      return toArraySubclass(objects, self);;
    }, -1);
    
    $def(self, '$initialize', function $$initialize(size, obj) {
      var block = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      ;
      if (size == null) size = nil;
      if (obj == null) obj = nil;
      
      $deny_frozen_access(self);

      if (obj !== nil && block !== nil) {
        $Kernel.$warn("warning: block supersedes default value argument")
      }

      if (size > $$$($$$('Integer'), 'MAX')) {
        $Kernel.$raise($$$('ArgumentError'), "array size too big")
      }

      if (arguments.length > 2) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + $to_s(arguments.length) + " for 0..2)")
      }

      if (arguments.length === 0) {
        if (self.length > 0) self.splice(0, self.length);
        return self;
      }

      if (arguments.length === 1) {
        if (size.$$is_array) {
          self.$replace(size.$to_a())
          return self;
        } else if (size['$respond_to?']("to_ary")) {
          self.$replace(size.$to_ary())
          return self;
        }
      }

      size = $coerce_to(size, $$$('Integer'), 'to_int');

      if (size < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size")
      }

      self.splice(0, self.length);
      var i, value;

      if (block === nil) {
        for (i = 0; i < size; i++) {
          self.push(obj);
        }
      }
      else {
        for (i = 0, value; i < size; i++) {
          value = block(i);
          self[i] = value;
        }
      }

      return self;
    ;
    }, -1);
    $defs(self, '$try_convert', function $$try_convert(obj) {
      
      return $Opal['$coerce_to?'](obj, $$$('Array'), "to_ary")
    });
    
    $def(self, '$&', function $Array_$$2(other) {
      var self = this;

      
      other = convertToArray(other)

      if (self.length === 0 || other.length === 0) {
        return [];
      }

      var result = [], hash = (new Map()), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if ($hash_delete(hash, item) !== undefined) {
          result.push(item);
        }
      }

      return result;
    
    });
    
    $def(self, '$|', function $Array_$$3(other) {
      var self = this;

      
      other = convertToArray(other);
      
      var hash = (new Map()), i, length, item;

      for (i = 0, length = self.length; i < length; i++) {
        $hash_put(hash, self[i], true);
      }

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      return hash.$keys();
    ;
    });
    
    $def(self, '$*', function $Array_$$4(other) {
      var self = this;

      
      if ($truthy(other['$respond_to?']("to_str"))) {
        return self.$join(other.$to_str())
      };
      other = $coerce_to(other, $$$('Integer'), 'to_int');
      if ($truthy(other < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "negative argument")
      };
      
      var result = [],
          converted = self.$to_a();

      for (var i = 0; i < other; i++) {
        result = result.concat(converted);
      }

      return result;
    ;
    });
    
    $def(self, '$+', function $Array_$plus$5(other) {
      var self = this;

      
      other = convertToArray(other);
      return self.concat(other);;
    });
    
    $def(self, '$-', function $Array_$minus$6(other) {
      var self = this;

      
      other = convertToArray(other);
      if ($truthy(self.length === 0)) {
        return []
      };
      if ($truthy(other.length === 0)) {
        return self.slice()
      };
      
      var result = [], hash = (new Map()), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if ($hash_get(hash, item) === undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    });
    
    $def(self, '$<<', function $Array_$lt$lt$7(object) {
      var self = this;

      
      $deny_frozen_access(self);
      self.push(object);
      return self;
    });
    
    $def(self, '$<=>', function $Array_$lt_eq_gt$8(other) {
      var self = this;

      
      if ($eqeqeq($$$('Array'), other)) {
        other = other.$to_a()
      } else if ($truthy(other['$respond_to?']("to_ary"))) {
        other = other.$to_ary().$to_a()
      } else {
        return nil
      };
      
      if (self === other) {
        return 0;
      }

      var count = Math.min(self.length, other.length);

      for (var i = 0; i < count; i++) {
        var tmp = (self[i])['$<=>'](other[i]);

        if (tmp !== 0) {
          return tmp;
        }
      }

      return (self.length)['$<=>'](other.length);
    ;
    });
    
    $def(self, '$==', function $Array_$eq_eq$9(other) {
      var self = this;

      
      var recursed = {};

      function _eqeq(array, other) {
        var i, length, a, b;

        if (array === other)
          return true;

        if (!other.$$is_array) {
          if ($respond_to(other, '$to_ary')) {
            return (other)['$=='](array);
          } else {
            return false;
          }
        }

        if (array.$$constructor !== Array)
          array = (array).$to_a();
        if (other.$$constructor !== Array)
          other = (other).$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    
    });
    
    function $array_slice_range(self, index) {
      var size = self.length,
          exclude, from, to, result;

      exclude = index.excl;
      from    = index.begin === nil ? 0 : $coerce_to(index.begin, Opal.Integer, 'to_int');
      to      = index.end === nil ? -1 : $coerce_to(index.end, Opal.Integer, 'to_int');

      if (from < 0) {
        from += size;

        if (from < 0) {
          return nil;
        }
      }

      if (index.excl_rev && index.begin !== nil) {
        from += 1;
      }

      if (from > size) {
        return nil;
      }

      if (to < 0) {
        to += size;

        if (to < 0) {
          return [];
        }
      }

      if (!exclude || index.end === nil) {
        to += 1;
      }

      result = self.slice(from, to);
      return result;
    }

    function $array_slice_arithmetic_seq(self, index) {
      var array, out = [], i = 0, pseudorange;

      if (index.step < 0) {
        pseudorange = {
          begin: index.range.end,
          end: index.range.begin,
          excl: false,
          excl_rev: index.range.excl
        };
        array = $array_slice_range(self, pseudorange).$reverse();
      }
      else {
        array = $array_slice_range(self, index.range);
      }

      while (i < array.length) {
        out.push(array[i]);
        i += Math.abs(index.step);
      }

      return out;
    }

    function $array_slice_index_length(self, index, length) {
      var size = self.length,
          exclude, from, to, result;

      index = $coerce_to(index, Opal.Integer, 'to_int');

      if (index < 0) {
        index += size;

        if (index < 0) {
          return nil;
        }
      }

      if (length === undefined) {
        if (index >= size || index < 0) {
          return nil;
        }

        return self[index];
      }
      else {
        length = $coerce_to(length, Opal.Integer, 'to_int');

        if (length < 0 || index > size || index < 0) {
          return nil;
        }

        result = self.slice(index, index + length);
      }
      return result;
    }
  ;
    
    $def(self, '$[]', function $Array_$$$10(index, length) {
      var self = this;

      
      ;
      
      if (index.$$is_range) {
        return $array_slice_range(self, index);
      }
      else if (index.$$is_arithmetic_seq) {
        return $array_slice_arithmetic_seq(self, index);
      }
      else {
        return $array_slice_index_length(self, index, length);
      }
    ;
    }, -2);
    
    $def(self, '$[]=', function $Array_$$$eq$11(index, value, extra) {
      var self = this, data = nil, length = nil;

      
      ;
      $deny_frozen_access(self);
      data = nil;
      
      var i, size = self.length;

      if (index.$$is_range) {
        if (value.$$is_array)
          data = value.$to_a();
        else if (value['$respond_to?']("to_ary"))
          data = value.$to_ary().$to_a();
        else
          data = [value];

        var exclude = index.excl,
            from    = index.begin === nil ? 0 : $coerce_to(index.begin, Opal.Integer, 'to_int'),
            to      = index.end === nil ? -1 : $coerce_to(index.end, Opal.Integer, 'to_int');

        if (from < 0) {
          from += size;

          if (from < 0) {
            $Kernel.$raise($$$('RangeError'), $to_s(index.$inspect()) + " out of range");
          }
        }

        if (to < 0) {
          to += size;
        }

        if (!exclude || index.end === nil) {
          to += 1;
        }

        if (from > size) {
          for (i = size; i < from; i++) {
            self[i] = nil;
          }
        }

        if (to < 0) {
          self.splice.apply(self, [from, 0].concat(data));
        }
        else {
          self.splice.apply(self, [from, to - from].concat(data));
        }

        return value;
      } else {
        if (extra === undefined) {
          (length = 1)
        } else {
          length = value;
          value  = extra;

          if (value.$$is_array)
            data = value.$to_a();
          else if (value['$respond_to?']("to_ary"))
            data = value.$to_ary().$to_a();
          else
            data = [value];
        }

        var old;

        index  = $coerce_to(index, $$$('Integer'), 'to_int');
        length = $coerce_to(length, $$$('Integer'), 'to_int');

        if (index < 0) {
          old    = index;
          index += size;

          if (index < 0) {
            $Kernel.$raise($$$('IndexError'), "index " + $to_s(old) + " too small for array; minimum " + $to_s(-self.length));
          }
        }

        if (length < 0) {
          $Kernel.$raise($$$('IndexError'), "negative length (" + $to_s(length) + ")")
        }

        if (index > size) {
          for (i = size; i < index; i++) {
            self[i] = nil;
          }
        }

        if (extra === undefined) {
          self[index] = value;
        }
        else {
          self.splice.apply(self, [index, length].concat(data));
        }

        return value;
      }
    ;
    }, -3);
    
    $def(self, '$any?', function $Array_any$ques$12(pattern) {
      var block = $Array_any$ques$12.$$p || nil, self = this;

      $Array_any$ques$12.$$p = null;
      
      ;
      ;
      if (self.length === 0) return false;
      return $send2(self, $find_super(self, 'any?', $Array_any$ques$12, false, true), 'any?', [pattern], block);
    }, -1);
    
    $def(self, '$assoc', function $$assoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        if (item = self[i], item.length && (item[0])['$=='](object)) {
          return item;
        }
      }

      return nil;
    
    });
    
    $def(self, '$at', function $$at(index) {
      var self = this;

      
      index = $coerce_to(index, $$$('Integer'), 'to_int')

      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      return self[index];
    
    });
    
    $def(self, '$bsearch_index', function $$bsearch_index() {
      var block = $$bsearch_index.$$p || nil, self = this;

      $$bsearch_index.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("bsearch_index")
      };
      
      var min = 0,
          max = self.length,
          mid,
          val,
          ret,
          smaller = false,
          satisfied = nil;

      while (min < max) {
        mid = min + Math.floor((max - min) / 2);
        val = self[mid];
        ret = $yield1(block, val);

        if (ret === true) {
          satisfied = mid;
          smaller = true;
        }
        else if (ret === false || ret === nil) {
          smaller = false;
        }
        else if (ret.$$is_number) {
          if (ret === 0) { return mid; }
          smaller = (ret < 0);
        }
        else {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + $to_s((ret).$class()) + " (must be numeric, true, false or nil)")
        }

        if (smaller) { max = mid; } else { min = mid + 1; }
      }

      return satisfied;
    ;
    });
    
    $def(self, '$bsearch', function $$bsearch() {
      var block = $$bsearch.$$p || nil, self = this, index = nil;

      $$bsearch.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("bsearch")
      };
      index = $send(self, 'bsearch_index', [], block.$to_proc());
      
      if (index != null && index.$$is_number) {
        return self[index];
      } else {
        return index;
      }
    ;
    });
    
    $def(self, '$cycle', function $$cycle(n) {
      var block = $$cycle.$$p || nil, self = this;

      $$cycle.$$p = null;
      
      ;
      if (n == null) n = nil;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["cycle", n], function $$13(){var self = $$13.$$s == null ? this : $$13.$$s;

          if ($truthy(n['$nil?']())) {
            return $$$($$$('Float'), 'INFINITY')
          } else {
            
            n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, {$$s: self})
      };
      if (($truthy(self['$empty?']()) || ($eqeq(n, 0)))) {
        return nil
      };
      
      var i, length, value;

      if (n === nil) {
        while (true) {
          for (i = 0, length = self.length; i < length; i++) {
            value = $yield1(block, self[i]);
          }
        }
      }
      else {
        n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
        if (n <= 0) {
          return self;
        }

        while (n > 0) {
          for (i = 0, length = self.length; i < length; i++) {
            value = $yield1(block, self[i]);
          }

          n--;
        }
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$clear', function $$clear() {
      var self = this;

      
      $deny_frozen_access(self);
      self.splice(0, self.length);
      return self;
    });
    
    $def(self, '$count', function $$count(object) {
      var block = $$count.$$p || nil, self = this;

      $$count.$$p = null;
      
      ;
      ;
      if (($truthy(object !== undefined) || ($truthy(block)))) {
        return $send2(self, $find_super(self, 'count', $$count, false, true), 'count', [object], block)
      } else {
        return self.$size()
      };
    }, -1);
    
    $def(self, '$initialize_copy', function $$initialize_copy(other) {
      var self = this;

      return self.$replace(other)
    });
    
    $def(self, '$collect', function $$collect() {
      var block = $$collect.$$p || nil, self = this;

      $$collect.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect"], function $$14(){var self = $$14.$$s == null ? this : $$14.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var result = [];

      for (var i = 0; i < self.length; i++) {
        var value = $yield1(block, self[i]);
        result[i] = value;
      }

      return result;
    ;
    });
    
    $def(self, '$collect!', function $Array_collect$excl$15() {
      var block = $Array_collect$excl$15.$$p || nil, self = this;

      $Array_collect$excl$15.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect!"], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      for (var i = 0; i < self.length; i++) {
        var value = $yield1(block, self[i]);
        self[i] = value;
      }
    ;
      return self;
    });
    
    function binomial_coefficient(n, k) {
      if (n === k || k === 0) {
        return 1;
      }

      if (k > 0 && n > k) {
        return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k);
      }

      return 0;
    }
  ;
    
    $def(self, '$combination', function $$combination(n) {
      var $yield = $$combination.$$p || nil, self = this, num = nil;

      $$combination.$$p = null;
      
      num = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["combination", num], function $$17(){var self = $$17.$$s == null ? this : $$17.$$s;

          return binomial_coefficient(self.length, num)}, {$$s: self})
      };
      
      var i, length, stack, chosen, lev, done, next;

      if (num === 0) {
        Opal.yield1($yield, [])
      } else if (num === 1) {
        for (i = 0, length = self.length; i < length; i++) {
          Opal.yield1($yield, [self[i]])
        }
      }
      else if (num === self.length) {
        Opal.yield1($yield, self.slice())
      }
      else if (num >= 0 && num < self.length) {
        stack = [];
        for (i = 0; i <= num + 1; i++) {
          stack.push(0);
        }

        chosen = [];
        lev = 0;
        done = false;
        stack[0] = -1;

        while (!done) {
          chosen[lev] = self[stack[lev+1]];
          while (lev < num - 1) {
            lev++;
            next = stack[lev+1] = stack[lev] + 1;
            chosen[lev] = self[next];
          }
          Opal.yield1($yield, chosen.slice())
          lev++;
          do {
            done = (lev === 0);
            stack[lev]++;
            lev--;
          } while ( stack[lev+1] + num === self.length + lev + 1 );
        }
      }
    ;
      return self;
    });
    
    $def(self, '$repeated_combination', function $$repeated_combination(n) {
      var $yield = $$repeated_combination.$$p || nil, self = this, num = nil;

      $$repeated_combination.$$p = null;
      
      num = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["repeated_combination", num], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s;

          return binomial_coefficient(self.length + num - 1, num);}, {$$s: self})
      };
      
      function iterate(max, from, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = from; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, i, buffer, self);
          buffer.pop();
        }
      }

      if (num >= 0) {
        iterate(num, 0, [], self);
      }
    ;
      return self;
    });
    
    $def(self, '$compact', function $$compact() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length, item; i < length; i++) {
        item = self[i];
        if (item !== nil && item != null) {
          result.push(item);
        }
      }

      return result;
    
    });
    
    $def(self, '$compact!', function $Array_compact$excl$19() {
      var self = this;

      
      $deny_frozen_access(self);

      var original = self.length;

      for (var i = 0, length = self.length, item; i < length; i++) {
        item = self[i];
        if (item === nil || item == null) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }

      return self.length === original ? nil : self;
    
    });
    
    $def(self, '$concat', function $$concat($a) {
      var $post_args, others, self = this;

      
      $post_args = $slice(arguments);
      others = $post_args;
      $deny_frozen_access(self);
      others = $send(others, 'map', [], function $$20(other){var self = $$20.$$s == null ? this : $$20.$$s;

        
        if (other == null) other = nil;
        other = convertToArray(other);
        if ($truthy(other['$equal?'](self))) {
          other = other.$dup()
        };
        return other;}, {$$s: self});
      $send(others, 'each', [], function $$21(other){var self = $$21.$$s == null ? this : $$21.$$s;

        
        if (other == null) other = nil;
        
        for (var i = 0, length = other.length; i < length; i++) {
          self.push(other[i]);
        }
      ;}, {$$s: self});
      return self;
    }, -1);
    
    $def(self, '$delete', function $Array_delete$22(object) {
      var $yield = $Array_delete$22.$$p || nil, self = this;

      $Array_delete$22.$$p = null;
      
      var original = self.length;

      for (var i = 0, length = original; i < length; i++) {
        if ((self[i])['$=='](object)) {
          $deny_frozen_access(self);

          self.splice(i, 1);

          length--;
          i--;
        }
      }

      if (self.length === original) {
        if (($yield !== nil)) {
          return Opal.yieldX($yield, []);
        }
        return nil;
      }
      return object;
    
    });
    
    $def(self, '$delete_at', function $$delete_at(index) {
      var self = this;

      
      $deny_frozen_access(self);

      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      var result = self[index];

      self.splice(index, 1);

      return result;
    
    });
    
    $def(self, '$delete_if', function $$delete_if() {
      var block = $$delete_if.$$p || nil, self = this;

      $$delete_if.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["delete_if"], function $$23(){var self = $$23.$$s == null ? this : $$23.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      filterIf(self, $falsy, block)
    ;
      return self;
    });
    
    $def(self, '$difference', function $$difference($a) {
      var $post_args, arrays, self = this;

      
      $post_args = $slice(arguments);
      arrays = $post_args;
      return $send(arrays, 'reduce', [self.$to_a().$dup()], function $$24(a, b){
        
        if (a == null) a = nil;
        if (b == null) b = nil;
        return $rb_minus(a, b);});
    }, -1);
    
    $def(self, '$dig', function $$dig(idx, $a) {
      var $post_args, idxs, self = this, item = nil;

      
      $post_args = $slice(arguments, 1);
      idxs = $post_args;
      item = self['$[]'](idx);
      
      if (item === nil || idxs.length === 0) {
        return item;
      }
    ;
      if (!$truthy(item['$respond_to?']("dig"))) {
        $Kernel.$raise($$$('TypeError'), $to_s(item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', $to_a(idxs));
    }, -2);
    
    $def(self, '$drop', function $$drop(number) {
      var self = this;

      
      number = $coerce_to(number, $$$('Integer'), 'to_int');

      if (number < 0) {
        $Kernel.$raise($$$('ArgumentError'))
      }

      return self.slice(number);
    
    });
    
    $def(self, '$dup', function $$dup() {
      var $yield = $$dup.$$p || nil, self = this;

      $$dup.$$p = null;
      
      
      if (self.$$class === Opal.Array &&
          self.$$class.$allocate.$$pristine &&
          self.$copy_instance_variables.$$pristine &&
          self.$initialize_dup.$$pristine) {
        return self.slice(0);
      }
    ;
      return $send2(self, $find_super(self, 'dup', $$dup, false, true), 'dup', [], $yield);
    });
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each"], function $$25(){var self = $$25.$$s == null ? this : $$25.$$s;

          return self.$size()}, {$$s: self})
      };
      
      for (var i = 0; i < self.length; i++) {
        $yield1(block, self[i]);
      }
    ;
      return self;
    });
    
    $def(self, '$each_index', function $$each_index() {
      var block = $$each_index.$$p || nil, self = this;

      $$each_index.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_index"], function $$26(){var self = $$26.$$s == null ? this : $$26.$$s;

          return self.$size()}, {$$s: self})
      };
      
      for (var i = 0; i < self.length; i++) {
        $yield1(block, i);
      }
    ;
      return self;
    });
    
    $def(self, '$empty?', function $Array_empty$ques$27() {
      var self = this;

      return self.length === 0;
    });
    
    $def(self, '$eql?', function $Array_eql$ques$28(other) {
      var self = this;

      
      var recursed = {};

      function _eql(array, other) {
        var i, length, a, b;

        if (!other.$$is_array) {
          return false;
        }

        other = other.$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eql(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eql(self, other);
    
    });
    
    $def(self, '$fetch', function $$fetch(index, defaults) {
      var block = $$fetch.$$p || nil, self = this;

      $$fetch.$$p = null;
      
      ;
      ;
      
      var original = index;

      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (index < 0) {
        index += self.length;
      }

      if (index >= 0 && index < self.length) {
        return self[index];
      }

      if (block !== nil && defaults != null) {
        self.$warn("warning: block supersedes default value argument")
      }

      if (block !== nil) {
        return block(original);
      }

      if (defaults != null) {
        return defaults;
      }

      if (self.length === 0) {
        $Kernel.$raise($$$('IndexError'), "index " + $to_s(original) + " outside of array bounds: 0...0")
      }
      else {
        $Kernel.$raise($$$('IndexError'), "index " + $to_s(original) + " outside of array bounds: -" + $to_s(self.length) + "..." + $to_s(self.length));
      }
    ;
    }, -2);
    
    $def(self, '$fill', function $$fill($a) {
      var block = $$fill.$$p || nil, $post_args, args, $b, $c, self = this, one = nil, two = nil, obj = nil, left = nil, right = nil;

      $$fill.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      
      $deny_frozen_access(self);

      var i, length, value;
    ;
      if ($truthy(block)) {
        
        if ($truthy(args.length > 2)) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + $to_s(args.$length()) + " for 0..2)")
        };
        $c = args, $b = $to_ary($c), (one = ($b[0] == null ? nil : $b[0])), (two = ($b[1] == null ? nil : $b[1])), $c;
      } else {
        
        if ($truthy(args.length == 0)) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1..3)")
        } else if ($truthy(args.length > 3)) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + $to_s(args.$length()) + " for 1..3)")
        };
        $c = args, $b = $to_ary($c), (obj = ($b[0] == null ? nil : $b[0])), (one = ($b[1] == null ? nil : $b[1])), (two = ($b[2] == null ? nil : $b[2])), $c;
      };
      if ($eqeqeq($$$('Range'), one)) {
        
        if ($truthy(two)) {
          $Kernel.$raise($$$('TypeError'), "length invalid with range")
        };
        left = one.begin === nil ? 0 : $coerce_to(one.begin, $$$('Integer'), 'to_int');
        if ($truthy(left < 0)) {
          left += this.length
        };
        if ($truthy(left < 0)) {
          $Kernel.$raise($$$('RangeError'), $to_s(one.$inspect()) + " out of range")
        };
        right = one.end === nil ? -1 : $coerce_to(one.end, $$$('Integer'), 'to_int');
        if ($truthy(right < 0)) {
          right += this.length
        };
        if (!$truthy(one['$exclude_end?']())) {
          right += 1
        };
        if ($truthy(right <= left)) {
          return self
        };
      } else if ($truthy(one)) {
        
        left = $coerce_to(one, $$$('Integer'), 'to_int');
        if ($truthy(left < 0)) {
          left += this.length
        };
        if ($truthy(left < 0)) {
          left = 0
        };
        if ($truthy(two)) {
          
          right = $coerce_to(two, $$$('Integer'), 'to_int');
          if ($truthy(right == 0)) {
            return self
          };
          right += left;
        } else {
          right = this.length
        };
      } else {
        
        left = 0;
        right = this.length;
      };
      if ($truthy(left > this.length)) {
        
        for (i = this.length; i < right; i++) {
          self[i] = nil;
        }
      
      };
      if ($truthy(right > this.length)) {
        this.length = right
      };
      if ($truthy(block)) {
        
        for (length = this.length; left < right; left++) {
          value = block(left);
          self[left] = value;
        }
      
      } else {
        
        for (length = this.length; left < right; left++) {
          self[left] = obj;
        }
      
      };
      return self;
    }, -1);
    
    $def(self, '$first', function $$first(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[0];
      }

      count = $coerce_to(count, $$$('Integer'), 'to_int');

      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size");
      }

      return self.slice(0, count);
    ;
    }, -1);
    
    $def(self, '$flatten', function $$flatten(level) {
      var self = this;

      
      ;
      
      function _flatten(array, level) {
        var result = [],
            i, length,
            item, ary;

        array = (array).$to_a();

        for (i = 0, length = array.length; i < length; i++) {
          item = array[i];

          if (!$respond_to(item, '$to_ary', true)) {
            result.push(item);
            continue;
          }

          ary = (item).$to_ary();

          if (ary === nil) {
            result.push(item);
            continue;
          }

          if (!ary.$$is_array) {
            $Kernel.$raise($$$('TypeError'));
          }

          if (ary === self) {
            $Kernel.$raise($$$('ArgumentError'));
          }

          switch (level) {
          case undefined:
            result = result.concat(_flatten(ary));
            break;
          case 0:
            result.push(ary);
            break;
          default:
            fast_push(result, _flatten(ary, level - 1));
          }
        }
        return result;
      }

      if (level !== undefined) {
        level = $coerce_to(level, $$$('Integer'), 'to_int');
      }

      return _flatten(self, level);
    ;
    }, -1);
    
    $def(self, '$flatten!', function $Array_flatten$excl$29(level) {
      var self = this;

      
      ;
      
      $deny_frozen_access(self);

      var flattened = self.$flatten(level);

      if (self.length == flattened.length) {
        for (var i = 0, length = self.length; i < length; i++) {
          if (self[i] !== flattened[i]) {
            break;
          }
        }

        if (i == length) {
          return nil;
        }
      }

      self.$replace(flattened);
    ;
      return self;
    }, -1);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      return $freeze(self);;
    });
    var $hash_ids;
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      
      var top = ($hash_ids === undefined),
          result = $opal32_init(),
          hash_id = self.$object_id(),
          item, i, key, values;

      result = $opal32_add(result, 0xA);
      result = $opal32_add(result, self.length);

      if (top) {
        $hash_ids = new Map();
      }
      // return early for recursive structures
      else if ($hash_ids.has(hash_id)) {
        return $opal32_add(result, 0x01010101);
      }

      try {
        if (!top) {
          values = $hash_ids.values();
          for (item of values) {
            if (self['$eql?'](item)) {
              return $opal32_add(result, 0x01010101);
            }
          }
        }

        $hash_ids.set(hash_id, self);

        for (i = 0; i < self.length; i++) {
          item = self[i];
          result = $opal32_add(result, item.$hash());
        }

        return result;
      } finally {
        if (top) {
          $hash_ids = undefined;
        }
      }
    
    });
    
    $def(self, '$include?', function $Array_include$ques$30(member) {
      var self = this;

      
      for (var i = 0, length = self.length; i < length; i++) {
        if ($eqeq(self[i], member)) {
          return true;
        }
      }

      return false;
    
    });
    
    $def(self, '$index', function $$index(object) {
      var block = $$index.$$p || nil, self = this;

      $$index.$$p = null;
      
      ;
      ;
      
      var i, length, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = 0, length = self.length; i < length; i++) {
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = 0; i < self.length; i++) {
          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else {
        return self.$enum_for("index");
      }

      return nil;
    ;
    }, -1);
    
    $def(self, '$insert', function $$insert(index, $a) {
      var $post_args, objects, self = this;

      
      $post_args = $slice(arguments, 1);
      objects = $post_args;
      
      $deny_frozen_access(self);

      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (objects.length > 0) {
        if (index < 0) {
          index += self.length + 1;

          if (index < 0) {
            $Kernel.$raise($$$('IndexError'), $to_s(index) + " is out of bounds");
          }
        }
        if (index > self.length) {
          for (var i = self.length; i < index; i++) {
            self.push(nil);
          }
        }

        self.splice.apply(self, [index, 0].concat(objects));
      }
    ;
      return self;
    }, -2);
    var inspect_stack = [];
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      
      var result = [],
      id = self.$__id__(),
      pushed = true;
    ;
      
      return (function() { try {
      
      
        if (inspect_stack.indexOf(id) !== -1) {
          pushed = false;
          return '[...]';
        }
        inspect_stack.push(id)

        for (var i = 0, length = self.length; i < length; i++) {
          var item = self['$[]'](i);

          result.push($$('Opal').$inspect(item));
        }

        return '[' + result.join(', ') + ']';
      ;
      return nil;
      } finally {
        if (pushed) inspect_stack.pop()
      }; })();;
    });
    
    $def(self, '$intersection', function $$intersection($a) {
      var $post_args, arrays, self = this, largest = nil, intersection_of_args = nil;

      
      $post_args = $slice(arguments);
      arrays = $post_args;
      
      if (arrays.length === 0) {
        return self.$to_a().$dup();
      }
      arrays = arrays.map(convertToArray);
      if (self.length === 0) {
        return [];
      }
    ;
      arrays = $send(arrays, 'sort_by', [], "length".$to_proc());
      if ($truthy(self.length < arrays[0].length)) {
        return $send(arrays, 'reduce', [self], "&".$to_proc())
      };
      largest = arrays.pop();
      intersection_of_args = $send(arrays, 'reduce', [largest], "&".$to_proc());
      return self['$&'](intersection_of_args);
    }, -1);
    
    $def(self, '$intersect?', function $Array_intersect$ques$31(other) {
      var self = this;

      
      var small, large, hash = (new Map()), i, length;
      if (self.length < other.length) {
        small = self;
        large = other;
      } else {
        small = other;
        large = self;
      }

      for (i = 0, length = small.length; i < length; i++) {
        $hash_put(hash, small[i], true);
      }

      for (i = 0, length = large.length; i < length; i++) {
        if ($hash_get(hash, large[i])) {
          return true;
        }
      }
      return false;
    
    });
    
    $def(self, '$join', function $$join(sep) {
      var self = this;
      if ($gvars[","] == null) $gvars[","] = nil;

      
      if (sep == null) sep = nil;
      if ($truthy(self.length === 0)) {
        return ""
      };
      if ($truthy(sep === nil)) {
        sep = $gvars[","]
      };
      
      var result = [];
      var i, length, item, tmp;

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];

        if ($respond_to(item, '$to_str')) {
          tmp = (item).$to_str();

          if (tmp !== nil) {
            result.push((tmp).$to_s());

            continue;
          }
        }

        if ($respond_to(item, '$to_ary')) {
          tmp = (item).$to_ary();

          if (tmp === self) {
            $Kernel.$raise($$$('ArgumentError'));
          }

          if (tmp !== nil) {
            result.push((tmp).$join(sep));

            continue;
          }
        }

        if ($respond_to(item, '$to_s')) {
          tmp = (item).$to_s();

          if (tmp !== nil) {
            result.push(tmp);

            continue;
          }
        }

        $Kernel.$raise($$$('NoMethodError').$new($to_s($$('Opal').$inspect(self.$item())) + " doesn't respond to #to_str, #to_ary or #to_s", "to_str"));
      }

      if (sep === nil) {
        return result.join('');
      }
      else {
        return result.join($Opal['$coerce_to!'](sep, $$$('String'), "to_str").$to_s());
      }
    ;
    }, -1);
    
    $def(self, '$keep_if', function $$keep_if() {
      var block = $$keep_if.$$p || nil, self = this;

      $$keep_if.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["keep_if"], function $$32(){var self = $$32.$$s == null ? this : $$32.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      filterIf(self, $truthy, block)
    ;
      return self;
    });
    
    $def(self, '$last', function $$last(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[self.length - 1];
      }

      count = $coerce_to(count, $$$('Integer'), 'to_int');

      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size");
      }

      if (count > self.length) {
        count = self.length;
      }

      return self.slice(self.length - count, self.length);
    ;
    }, -1);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.length;
    });
    
    $def(self, '$max', function $$max(n) {
      var block = $$max.$$p || nil, self = this;

      $$max.$$p = null;
      
      ;
      ;
      return $send(self.$each(), 'max', [n], block.$to_proc());
    }, -1);
    
    $def(self, '$min', function $$min() {
      var block = $$min.$$p || nil, self = this;

      $$min.$$p = null;
      
      ;
      return $send(self.$each(), 'min', [], block.$to_proc());
    });
    
    // Returns the product of from, from-1, ..., from - how_many + 1.
    function descending_factorial(from, how_many) {
      var count = how_many >= 0 ? 1 : 0;
      while (how_many) {
        count *= from;
        from--;
        how_many--;
      }
      return count;
    }
  ;
    
    $def(self, '$permutation', function $$permutation(num) {
      var block = $$permutation.$$p || nil, self = this, perm = nil, used = nil;

      $$permutation.$$p = null;
      
      ;
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["permutation", num], function $$33(){var self = $$33.$$s == null ? this : $$33.$$s;

          return descending_factorial(self.length, num === undefined ? self.length : num);}, {$$s: self})
      };
      
      var permute, offensive, output;

      if (num === undefined) {
        num = self.length;
      }
      else {
        num = $coerce_to(num, $$$('Integer'), 'to_int');
      }

      if (num < 0 || self.length < num) {
        // no permutations, yield nothing
      }
      else if (num === 0) {
        // exactly one permutation: the zero-length array
        Opal.yield1(block, [])
      }
      else if (num === 1) {
        // this is a special, easy case
        for (var i = 0; i < self.length; i++) {
          Opal.yield1(block, [self[i]])
        }
      }
      else {
        // this is the general case
        (perm = $$('Array').$new(num));
        (used = $$('Array').$new(self.length, false));

        permute = function(num, perm, index, used, blk) {
          self = this;
          for(var i = 0; i < self.length; i++){
            if(used['$[]'](i)['$!']()) {
              perm[index] = i;
              if(index < num - 1) {
                used[i] = true;
                permute.call(self, num, perm, index + 1, used, blk);
                used[i] = false;
              }
              else {
                output = [];
                for (var j = 0; j < perm.length; j++) {
                  output.push(self[perm[j]]);
                }
                $yield1(blk, output);
              }
            }
          }
        }

        if ((block !== nil)) {
          // offensive (both definitions) copy.
          offensive = self.slice();
          permute.call(offensive, num, perm, 0, used, block);
        }
        else {
          permute.call(self, num, perm, 0, used, block);
        }
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$repeated_permutation', function $$repeated_permutation(n) {
      var $yield = $$repeated_permutation.$$p || nil, self = this, num = nil;

      $$repeated_permutation.$$p = null;
      
      num = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["repeated_permutation", num], function $$34(){var self = $$34.$$s == null ? this : $$34.$$s;

          if ($truthy($rb_ge(num, 0))) {
            return self.$size()['$**'](num)
          } else {
            return 0
          }}, {$$s: self})
      };
      
      function iterate(max, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = 0; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, buffer, self);
          buffer.pop();
        }
      }

      iterate(num, [], self.slice());
    ;
      return self;
    });
    
    $def(self, '$pop', function $$pop(count) {
      var self = this;

      
      ;
      $deny_frozen_access(self);
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil
        };
        return self.pop();
      };
      count = $coerce_to(count, $$$('Integer'), 'to_int');
      if ($truthy(count < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size")
      };
      if ($truthy(self.length === 0)) {
        return []
      };
      if ($truthy(count === 1)) {
        return [self.pop()];
      } else if ($truthy(count > self.length)) {
        return self.splice(0, self.length);
      } else {
        return self.splice(self.length - count, self.length);
      };
    }, -1);
    
    $def(self, '$product', function $$product($a) {
      var block = $$product.$$p || nil, $post_args, args, self = this;

      $$product.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      
      var result = (block !== nil) ? null : [],
          n = args.length + 1,
          counters = new Array(n),
          lengths  = new Array(n),
          arrays   = new Array(n),
          i, m, subarray, len, resultlen = 1;

      arrays[0] = self;
      for (i = 1; i < n; i++) {
        arrays[i] = $coerce_to(args[i - 1], $$$('Array'), 'to_ary');
      }

      for (i = 0; i < n; i++) {
        len = arrays[i].length;
        if (len === 0) {
          return result || self;
        }
        resultlen *= len;
        if (resultlen > 2147483647) {
          $Kernel.$raise($$$('RangeError'), "too big to product")
        }
        lengths[i] = len;
        counters[i] = 0;
      }

      outer_loop: for (;;) {
        subarray = [];
        for (i = 0; i < n; i++) {
          subarray.push(arrays[i][counters[i]]);
        }
        if (result) {
          result.push(subarray);
        } else {
          Opal.yield1(block, subarray)
        }
        m = n - 1;
        counters[m]++;
        while (counters[m] === lengths[m]) {
          counters[m] = 0;
          if (--m < 0) break outer_loop;
          counters[m]++;
        }
      }

      return result || self;
    ;
    }, -1);
    
    $def(self, '$push', function $$push($a) {
      var $post_args, objects, self = this;

      
      $post_args = $slice(arguments);
      objects = $post_args;
      
      $deny_frozen_access(self);

      fast_push(self, objects);
    ;
      return self;
    }, -1);
    
    $def(self, '$rassoc', function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        item = self[i];

        if (item.length && item[1] !== undefined) {
          if ((item[1])['$=='](object)) {
            return item;
          }
        }
      }

      return nil;
    
    });
    
    $def(self, '$reject', function $$reject() {
      var block = $$reject.$$p || nil, self = this;

      $$reject.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reject"], function $$35(){var self = $$35.$$s == null ? this : $$35.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var result = [];

      for (var i = 0, value; i < self.length; i++) {
        value = block(self[i]);

        if (value === false || value === nil) {
          result.push(self[i]);
        }
      }
      return result;
    ;
    });
    
    $def(self, '$reject!', function $Array_reject$excl$36() {
      var block = $Array_reject$excl$36.$$p || nil, self = this, original = nil;

      $Array_reject$excl$36.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reject!"], function $$37(){var self = $$37.$$s == null ? this : $$37.$$s;

          return self.$size()}, {$$s: self})
      };
      $deny_frozen_access(self);
      original = self.$length();
      $send(self, 'delete_if', [], block.$to_proc());
      if ($eqeq(self.$length(), original)) {
        return nil
      } else {
        return self
      };
    });
    
    $def(self, '$replace', function $$replace(other) {
      var self = this;

      
      $deny_frozen_access(self);
      other = convertToArray(other);
      
      if (self.length > 0) self.splice(0, self.length);
      fast_push(self, other);
    ;
      return self;
    });
    
    $def(self, '$reverse', function $$reverse() {
      var self = this;

      return self.slice(0).reverse();
    });
    
    $def(self, '$reverse!', function $Array_reverse$excl$38() {
      var self = this;

      
      $deny_frozen_access(self);
      return self.reverse();;
    });
    
    $def(self, '$reverse_each', function $$reverse_each() {
      var block = $$reverse_each.$$p || nil, self = this;

      $$reverse_each.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reverse_each"], function $$39(){var self = $$39.$$s == null ? this : $$39.$$s;

          return self.$size()}, {$$s: self})
      };
      
      for (var i = self.length - 1; i >= 0; i--) {
        $yield1(block, self[i]);
      }
    ;
      return self;
    });
    
    $def(self, '$rindex', function $$rindex(object) {
      var block = $$rindex.$$p || nil, self = this;

      $$rindex.$$p = null;
      
      ;
      ;
      
      var i, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }

          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else if (object == null) {
        return self.$enum_for("rindex");
      }

      return nil;
    ;
    }, -1);
    
    $def(self, '$rotate', function $$rotate(n) {
      var self = this;

      
      if (n == null) n = 1;
      
      var ary, idx, firstPart, lastPart;

      n = $coerce_to(n, $$$('Integer'), 'to_int')

      if (self.length === 1) {
        return self.slice();
      }
      if (self.length === 0) {
        return [];
      }

      ary = self.slice();
      idx = n % ary.length;

      firstPart = ary.slice(idx);
      lastPart = ary.slice(0, idx);
      return firstPart.concat(lastPart);
    ;
    }, -1);
    
    $def(self, '$rotate!', function $Array_rotate$excl$40(cnt) {
      var self = this, ary = nil;

      
      if (cnt == null) cnt = 1;
      
      $deny_frozen_access(self);

      if (self.length === 0 || self.length === 1) {
        return self;
      }
      cnt = $coerce_to(cnt, $$$('Integer'), 'to_int');
    ;
      ary = self.$rotate(cnt);
      return self.$replace(ary);
    }, -1);
    (function($base, $super) {
      var self = $klass($base, $super, 'SampleRandom');

      var $proto = self.$$prototype;

      $proto.rng = nil;
      
      
      $def(self, '$initialize', $assign_ivar("rng"));
      return $def(self, '$rand', function $$rand(size) {
        var self = this, random = nil;

        
        random = $coerce_to(self.rng.$rand(size), $$$('Integer'), 'to_int');
        if ($truthy(random < 0)) {
          $Kernel.$raise($$$('RangeError'), "random value must be >= 0")
        };
        if (!$truthy(random < size)) {
          $Kernel.$raise($$$('RangeError'), "random value must be less than Array size")
        };
        return random;
      });
    })(self, null);
    
    $def(self, '$sample', function $$sample(count, options) {
      var self = this, o = nil, rng = nil;

      
      ;
      ;
      if ($truthy(count === undefined)) {
        return self.$at($Kernel.$rand(self.length))
      };
      if ($truthy(options === undefined)) {
        if ($truthy((o = $Opal['$coerce_to?'](count, $$$('Hash'), "to_hash")))) {
          
          options = o;
          count = nil;
        } else {
          
          options = nil;
          count = $coerce_to(count, $$$('Integer'), 'to_int');
        }
      } else {
        
        count = $coerce_to(count, $$$('Integer'), 'to_int');
        options = $coerce_to(options, $$$('Hash'), 'to_hash');
      };
      if (($truthy(count) && ($truthy(count < 0)))) {
        $Kernel.$raise($$$('ArgumentError'), "count must be greater than 0")
      };
      if ($truthy(options)) {
        rng = options['$[]']("random")
      };
      rng = (($truthy(rng) && ($truthy(rng['$respond_to?']("rand")))) ? ($$('SampleRandom').$new(rng)) : ($Kernel));
      if (!$truthy(count)) {
        return self[rng.$rand(self.length)]
      };
      

      var abandon, spin, result, i, j, k, targetIndex, oldValue;

      if (count > self.length) {
        count = self.length;
      }

      switch (count) {
        case 0:
          return [];
          break;
        case 1:
          return [self[rng.$rand(self.length)]];
          break;
        case 2:
          i = rng.$rand(self.length);
          j = rng.$rand(self.length - 1);
          if (i <= j) {
            j++;
          }
          return [self[i], self[j]];
          break;
        default:
          if (self.length / count > 3) {
            abandon = false;
            spin = 0;

            result = $$('Array').$new(count);
            i = 1;

            result[0] = rng.$rand(self.length);
            while (i < count) {
              k = rng.$rand(self.length);
              j = 0;

              while (j < i) {
                while (k === result[j]) {
                  spin++;
                  if (spin > 100) {
                    abandon = true;
                    break;
                  }
                  k = rng.$rand(self.length);
                }
                if (abandon) { break; }

                j++;
              }

              if (abandon) { break; }

              result[i] = k;

              i++;
            }

            if (!abandon) {
              i = 0;
              while (i < count) {
                result[i] = self[result[i]];
                i++;
              }

              return result;
            }
          }

          result = self.slice();

          for (var c = 0; c < count; c++) {
            targetIndex = rng.$rand(self.length - c) + c;
            oldValue = result[c];
            result[c] = result[targetIndex];
            result[targetIndex] = oldValue;
          }

          return count === self.length ? result : (result)['$[]'](0, count);
      }
    ;
    }, -1);
    
    $def(self, '$select', function $$select() {
      var block = $$select.$$p || nil, self = this;

      $$select.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["select"], function $$41(){var self = $$41.$$s == null ? this : $$41.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var result = [];

      for (var i = 0, item, value; i < self.length; i++) {
        item = self[i];

        value = $yield1(block, item);

        if ($truthy(value)) {
          result.push(item);
        }
      }

      return result;
    ;
    });
    
    $def(self, '$select!', function $Array_select$excl$42() {
      var block = $Array_select$excl$42.$$p || nil, self = this;

      $Array_select$excl$42.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["select!"], function $$43(){var self = $$43.$$s == null ? this : $$43.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self)

      var original = self.length;
      $send(self, 'keep_if', [], block.$to_proc());
      return self.length === original ? nil : self;
    ;
    });
    
    $def(self, '$shift', function $$shift(count) {
      var self = this;

      
      ;
      $deny_frozen_access(self);
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil
        };
        return shiftNoArg(self);
      };
      count = $coerce_to(count, $$$('Integer'), 'to_int');
      if ($truthy(count < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size")
      };
      if ($truthy(self.length === 0)) {
        return []
      };
      return self.splice(0, count);;
    }, -1);
    
    $def(self, '$shuffle', function $$shuffle(rng) {
      var self = this;

      
      ;
      return self.$dup().$to_a()['$shuffle!'](rng);
    }, -1);
    
    $def(self, '$shuffle!', function $Array_shuffle$excl$44(rng) {
      var self = this;

      
      ;
      
      $deny_frozen_access(self);

      var randgen, i = self.length, j, tmp;

      if (rng !== undefined) {
        rng = $Opal['$coerce_to?'](rng, $$$('Hash'), "to_hash");

        if (rng !== nil) {
          rng = rng['$[]']("random");

          if (rng !== nil && rng['$respond_to?']("rand")) {
            randgen = rng;
          }
        }
      }

      while (i) {
        if (randgen) {
          j = randgen.$rand(i).$to_int();

          if (j < 0) {
            $Kernel.$raise($$$('RangeError'), "random number too small " + $to_s(j))
          }

          if (j >= i) {
            $Kernel.$raise($$$('RangeError'), "random number too big " + $to_s(j))
          }
        }
        else {
          j = self.$rand(i);
        }

        tmp = self[--i];
        self[i] = self[j];
        self[j] = tmp;
      }

      return self;
    ;
    }, -1);
    
    $def(self, '$slice!', function $Array_slice$excl$45(index, length) {
      var self = this, result = nil, range = nil, range_start = nil, range_end = nil, start = nil;

      
      ;
      $deny_frozen_access(self);
      result = nil;
      if ($truthy(length === undefined)) {
        if ($eqeqeq($$$('Range'), index)) {
          
          range = index;
          result = self['$[]'](range);
          range_start = range.begin === nil ? 0 : $coerce_to(range.begin, $$$('Integer'), 'to_int');
          range_end = range.end === nil ? -1 : $coerce_to(range.end, $$$('Integer'), 'to_int');
          
          if (range_start < 0) {
            range_start += self.length;
          }

          if (range_end < 0) {
            range_end += self.length;
          } else if (range_end >= self.length) {
            range_end = self.length - 1;
            if (range.excl) {
              range_end += 1;
            }
          }

          var range_length = range_end - range_start;
          if (range.excl && range.end !== nil) {
            range_end -= 1;
          } else {
            range_length += 1;
          }

          if (range_start < self.length && range_start >= 0 && range_end < self.length && range_end >= 0 && range_length > 0) {
            self.splice(range_start, range_length);
          }
        ;
        } else {
          
          start = $coerce_to(index, $$$('Integer'), 'to_int');
          
          if (start < 0) {
            start += self.length;
          }

          if (start < 0 || start >= self.length) {
            return nil;
          }

          result = self[start];

          if (start === 0) {
            self.shift();
          } else {
            self.splice(start, 1);
          }
        ;
        }
      } else {
        
        start = $coerce_to(index, $$$('Integer'), 'to_int');
        length = $coerce_to(length, $$$('Integer'), 'to_int');
        
        if (length < 0) {
          return nil;
        }

        var end = start + length;

        result = self['$[]'](start, length);

        if (start < 0) {
          start += self.length;
        }

        if (start + length > self.length) {
          length = self.length - start;
        }

        if (start < self.length && start >= 0) {
          self.splice(start, length);
        }
      ;
      };
      return result;
    }, -2);
    
    $def(self, '$sort', function $$sort() {
      var block = $$sort.$$p || nil, self = this;

      $$sort.$$p = null;
      
      ;
      if (!$truthy(self.length > 1)) {
        return self
      };
      
      if (block === nil) {
        block = function(a, b) {
          return (a)['$<=>'](b);
        };
      }

      return self.slice().sort(function(x, y) {
        var ret = block(x, y);

        if (ret === nil) {
          $Kernel.$raise($$$('ArgumentError'), "comparison of " + $to_s((x).$inspect()) + " with " + $to_s((y).$inspect()) + " failed");
        }

        return $rb_gt(ret, 0) ? 1 : ($rb_lt(ret, 0) ? -1 : 0);
      });
    ;
    });
    
    $def(self, '$sort!', function $Array_sort$excl$46() {
      var block = $Array_sort$excl$46.$$p || nil, self = this;

      $Array_sort$excl$46.$$p = null;
      
      ;
      
      $deny_frozen_access(self)

      var result;

      if ((block !== nil)) {
        result = $send((self.slice()), 'sort', [], block.$to_proc());
      }
      else {
        result = (self.slice()).$sort();
      }

      self.length = 0;
      for(var i = 0, length = result.length; i < length; i++) {
        self.push(result[i]);
      }

      return self;
    ;
    });
    
    $def(self, '$sort_by!', function $Array_sort_by$excl$47() {
      var block = $Array_sort_by$excl$47.$$p || nil, self = this;

      $Array_sort_by$excl$47.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["sort_by!"], function $$48(){var self = $$48.$$s == null ? this : $$48.$$s;

          return self.$size()}, {$$s: self})
      };
      $deny_frozen_access(self);
      return self.$replace($send(self, 'sort_by', [], block.$to_proc()));
    });
    
    $def(self, '$take', function $$take(count) {
      var self = this;

      
      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'));
      }

      return self.slice(0, count);
    
    });
    
    $def(self, '$take_while', function $$take_while() {
      var block = $$take_while.$$p || nil, self = this;

      $$take_while.$$p = null;
      
      ;
      
      var result = [];

      for (var i = 0, item, value; i < self.length; i++) {
        item = self[i];

        value = block(item);

        if (value === false || value === nil) {
          return result;
        }

        result.push(item);
      }

      return result;
    ;
    });
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      
      if (self.$$class === Opal.Array) {
        return self;
      }
      else {
        return Opal.Array.$new(self);
      }
    
    });
    
    $def(self, '$to_ary', $return_self);
    
    $def(self, '$to_h', function $$to_h() {
      var block = $$to_h.$$p || nil, self = this, array = nil;

      $$to_h.$$p = null;
      
      ;
      array = self;
      if ((block !== nil)) {
        array = $send(array, 'map', [], block.$to_proc())
      };
      
      var i, len = array.length, ary, key, val, hash = (new Map());

      for (i = 0; i < len; i++) {
        ary = $Opal['$coerce_to?'](array[i], $$$('Array'), "to_ary");
        if (!ary.$$is_array) {
          $Kernel.$raise($$$('TypeError'), "wrong element type " + $to_s((array[i]).$class()) + " at " + $to_s(i) + " (expected array)")
        }
        if (ary.length !== 2) {
          $Kernel.$raise($$$('ArgumentError'), "element has wrong array length at " + $to_s(i) + " (expected 2, was " + $to_s((ary).$length()) + ")")
        }
        key = ary[0];
        val = ary[1];
        $hash_put(hash, key, val);
      }

      return hash;
    ;
    });
    
    $def(self, '$transpose', function $$transpose() {
      var self = this, result = nil, max = nil;

      
      if ($truthy(self['$empty?']())) {
        return []
      };
      result = [];
      max = nil;
      $send(self, 'each', [], function $$49(row){var $ret_or_1 = nil;

        
        if (row == null) row = nil;
        row = convertToArray(row);
        max = ($truthy(($ret_or_1 = max)) ? ($ret_or_1) : (row.length));
        if ($neqeq(row.length, max)) {
          $Kernel.$raise($$$('IndexError'), "element size differs (" + $to_s(row.length) + " should be " + $to_s(max) + ")")
        };
        return $send((row.length), 'times', [], function $$50(i){var $a, entry = nil;

          
          if (i == null) i = nil;
          entry = ($truthy(($ret_or_1 = result['$[]'](i))) ? ($ret_or_1) : (($a = [i, []], $send(result, '[]=', $a), $a[$a.length - 1])));
          return entry['$<<'](row.$at(i));});});
      return result;
    });
    
    $def(self, '$union', function $$union($a) {
      var $post_args, arrays, self = this;

      
      $post_args = $slice(arguments);
      arrays = $post_args;
      return $send(arrays, 'reduce', [self.$uniq()], function $$51(a, b){
        
        if (a == null) a = nil;
        if (b == null) b = nil;
        return a['$|'](b);});
    }, -1);
    
    $def(self, '$uniq', function $$uniq() {
      var block = $$uniq.$$p || nil, self = this;

      $$uniq.$$p = null;
      
      ;
      
      var hash = (new Map()), i, length, item, key;

      if (block === nil) {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          if ($hash_get(hash, item) === undefined) {
            $hash_put(hash, item, item);
          }
        }
      }
      else {
        for (i = 0; i < self.length; i++) {
          item = self[i];
          key = $yield1(block, item);
          if ($hash_get(hash, key) === undefined) {
            $hash_put(hash, key, item);
          }
        }
      }

      return (hash).$values();
    ;
    });
    
    $def(self, '$uniq!', function $Array_uniq$excl$52() {
      var block = $Array_uniq$excl$52.$$p || nil, self = this;

      $Array_uniq$excl$52.$$p = null;
      
      ;
      
      $deny_frozen_access(self);

      var hash = (new Map()), i, item, key, delete_indexes = [];

      for (i = 0; i < self.length; i++) {
        item = self[i];
        key = (block === nil ? item : $yield1(block, item));

        if ($hash_get(hash, key) === undefined) {
          $hash_put(hash, key, item);
        } else {
          delete_indexes.push(i);
        }
      }

      for (i = delete_indexes.length - 1; i >= 0; i--) {
        self.splice(delete_indexes[i], 1);
      }

      return delete_indexes.length === 0 ? nil : self;
    ;
    });
    
    $def(self, '$unshift', function $$unshift($a) {
      var $post_args, objects, self = this;

      
      $post_args = $slice(arguments);
      objects = $post_args;
      
      $deny_frozen_access(self);

      var selfLength = self.length
      var objectsLength = objects.length
      if (objectsLength == 0) return self;
      var index = selfLength - objectsLength
      for (var i = 0; i < objectsLength; i++) {
        self.push(self[index + i])
      }
      var len = selfLength - 1
      while (len - objectsLength >= 0) {
        self[len] = self[len - objectsLength]
        len--
      }
      for (var j = 0; j < objectsLength; j++) {
        self[j] = objects[j]
      }
      return self;
    ;
    }, -1);
    
    $def(self, '$values_at', function $$values_at($a) {
      var $post_args, args, self = this, out = nil;

      
      $post_args = $slice(arguments);
      args = $post_args;
      out = [];
      $send(args, 'each', [], function $$53(elem){var self = $$53.$$s == null ? this : $$53.$$s, finish = nil, start = nil, i = nil;

        
        if (elem == null) elem = nil;
        if ($truthy(elem['$is_a?']($$$('Range')))) {
          
          finish = elem.$end() === nil ? -1 : $coerce_to(elem.$end(), $$$('Integer'), 'to_int');
          start = elem.$begin() === nil ? 0 : $coerce_to(elem.$begin(), $$$('Integer'), 'to_int');
          
          if (start < 0) {
            start = start + self.length;
            return nil;
          }
        ;
          
          if (finish < 0) {
            finish = finish + self.length;
          }
          if (elem['$exclude_end?']() && elem.$end() !== nil) {
            finish--;
          }
          if (finish < start) {
            return nil;
          }
        ;
          return $send(start, 'upto', [finish], function $$54(i){var self = $$54.$$s == null ? this : $$54.$$s;

            
            if (i == null) i = nil;
            return out['$<<'](self.$at(i));}, {$$s: self});
        } else {
          
          i = $coerce_to(elem, $$$('Integer'), 'to_int');
          return out['$<<'](self.$at(i));
        };}, {$$s: self});
      return out;
    }, -1);
    
    $def(self, '$zip', function $$zip($a) {
      var block = $$zip.$$p || nil, $post_args, others, self = this, $ret_or_1 = nil;

      $$zip.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      others = $post_args;
      
      var result = [], size = self.length, part, o, i, j, jj;

      for (j = 0, jj = others.length; j < jj; j++) {
        o = others[j];
        if (o.$$is_array) {
          continue;
        }
        if (o.$$is_range || o.$$is_enumerator) {
          others[j] = o.$take(size);
          continue;
        }
        others[j] = ($truthy(($ret_or_1 = $Opal['$coerce_to?'](o, $$$('Array'), "to_ary"))) ? ($ret_or_1) : ($Opal['$coerce_to!'](o, $$$('Enumerator'), "to_enum", "each"))).$to_a();
      }

      for (i = 0; i < size; i++) {
        part = [self[i]];

        for (j = 0, jj = others.length; j < jj; j++) {
          o = others[j][i];

          if (o == null) {
            o = nil;
          }

          part[j + 1] = o;
        }

        result[i] = part;
      }

      if (block !== nil) {
        for (i = 0; i < size; i++) {
          Opal.yield1(block, result[i]);
        }

        return nil;
      }

      return result;
    ;
    }, -1);
    $defs(self, '$inherited', function $$inherited(klass) {
      
      
      klass.$$prototype.$to_a = function() {
        return this.slice(0, this.length);
      }
    
    });
    
    $def(self, '$instance_variables', function $$instance_variables() {
      var $yield = $$instance_variables.$$p || nil, self = this;

      $$instance_variables.$$p = null;
      return $send($send2(self, $find_super(self, 'instance_variables', $$instance_variables, false, true), 'instance_variables', [], $yield), 'reject', [], function $$55(ivar){var $ret_or_1 = nil;

        
        if (ivar == null) ivar = nil;
        if ($truthy(($ret_or_1 = /^@\d+$/.test(ivar)))) {
          return $ret_or_1
        } else {
          return ivar['$==']("@length")
        };})
    });
    
    $def(self, '$pack', function $$pack($a) {
      var $post_args, args;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return $Kernel.$raise("To use Array#pack, you must first require 'corelib/array/pack'.");
    }, -1);
    $alias(self, "append", "push");
    $alias(self, "filter", "select");
    $alias(self, "filter!", "select!");
    $alias(self, "map", "collect");
    $alias(self, "map!", "collect!");
    $alias(self, "prepend", "unshift");
    $alias(self, "size", "length");
    $alias(self, "slice", "[]");
    $alias(self, "to_s", "inspect");
    $Opal.$pristine(self.$singleton_class(), "allocate");
    return $Opal.$pristine(self, "copy_instance_variables", "initialize_dup");
  })('::', Array, $nesting);
};

Opal.modules["corelib/hash"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $yield1 = Opal.yield1, $hash_clone = Opal.hash_clone, $hash_delete = Opal.hash_delete, $hash_each = Opal.hash_each, $hash_get = Opal.hash_get, $hash_put = Opal.hash_put, $deny_frozen_access = Opal.deny_frozen_access, $freeze = Opal.freeze, $opal32_init = Opal.opal32_init, $opal32_add = Opal.opal32_add, $klass = Opal.klass, $slice = Opal.slice, $Opal = Opal.Opal, $Kernel = Opal.Kernel, $to_s = Opal.to_s, $defs = Opal.defs, $def = Opal.def, $send = Opal.send, $rb_ge = Opal.rb_ge, $rb_gt = Opal.rb_gt, $truthy = Opal.truthy, $to_a = Opal.to_a, $hash_new = Opal.hash_new, $return_self = Opal.return_self, $not = Opal.not, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,coerce_to?,[],merge!,allocate,raise,inspect,coerce_to!,each,fetch,>=,>,==,lambda?,abs,arity,enum_for,size,respond_to?,class,dig,except!,dup,delete,new,map,to_proc,flatten,frozen?,eql?,default,default_proc,default_proc=,default=,to_h,proc,!,select,select!,has_key?,indexes,index,length,[]=,has_value?');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Enumerable'));
    self.$$prototype.$$is_hash = true;
    $defs(self, '$[]', function $Hash_$$$1($a) {
      var $post_args, argv, self = this;

      
      $post_args = $slice(arguments);
      argv = $post_args;
      
      var hash, argc = argv.length, arg, i;

      if (argc === 1) {
        hash = $Opal['$coerce_to?'](argv['$[]'](0), $$$('Hash'), "to_hash");
        if (hash !== nil) {
          return self.$allocate()['$merge!'](hash);
        }

        argv = $Opal['$coerce_to?'](argv['$[]'](0), $$$('Array'), "to_ary");
        if (argv === nil) {
          $Kernel.$raise($$$('ArgumentError'), "odd number of arguments for Hash");
        }

        argc = argv.length;
        hash = self.$allocate();

        for (i = 0; i < argc; i++) {
          arg = argv[i];
          if (!arg.$$is_array)
            $Kernel.$raise($$$('ArgumentError'), "invalid element " + $to_s((arg).$inspect()) + " for Hash");
          if (arg.length === 1) {
            hash.$store(arg[0], nil);
          } else if (arg.length === 2) {
            hash.$store(arg[0], arg[1]);
          } else {
            $Kernel.$raise($$$('ArgumentError'), "invalid number of elements (" + $to_s(arg.length) + " for " + $to_s((arg).$inspect()) + "), must be 1..2");
          }
        }

        return hash;
      }

      if (argc % 2 !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "odd number of arguments for Hash")
      }

      hash = self.$allocate();

      for (i = 0; i < argc; i += 2) {
        hash.$store(argv[i], argv[i + 1]);
      }

      return hash;
    ;
    }, -1);
    $defs(self, '$allocate', function $$allocate() {
      var self = this;

      
      var hash = new self.$$constructor();

      hash.$$none = nil;
      hash.$$proc = nil;

      return hash;
    
    });
    $defs(self, '$try_convert', function $$try_convert(obj) {
      
      return $Opal['$coerce_to?'](obj, $$$('Hash'), "to_hash")
    });
    
    $def(self, '$initialize', function $$initialize(defaults) {
      var block = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      ;
      ;
      
      $deny_frozen_access(self);

      if (defaults !== undefined && block !== nil) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (1 for 0)")
      }
      self.$$none = (defaults === undefined ? nil : defaults);
      self.$$proc = block;

      return self;
    ;
    }, -1);
    
    $def(self, '$==', function $Hash_$eq_eq$2(other) {
      var self = this;

      
      if (self === other) {
        return true;
      }

      if (!other.$$is_hash) {
        return false;
      }

      if (self.size !== other.size) {
        return false;
      }

      var entry, other_value;
      for (entry of self) {
        other_value = $hash_get(other, entry[0]);
        if (other_value === undefined || !entry[1]['$eql?'](other_value)) {
          return false;
        }
      }
      return true;
    
    });
    
    $def(self, '$>=', function $Hash_$gt_eq$3(other) {
      var self = this, result = nil;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      
      if (self.size < other.size) {
        return false;
      }
    ;
      result = true;
      $send(other, 'each', [], function $$4(other_key, other_val){var self = $$4.$$s == null ? this : $$4.$$s, val = nil;

        
        if (other_key == null) other_key = nil;
        if (other_val == null) other_val = nil;
        val = self.$fetch(other_key, null);
        
        if (val == null || val !== other_val) {
          result = false;
          return;
        }
      ;}, {$$s: self});
      return result;
    });
    
    $def(self, '$>', function $Hash_$gt$5(other) {
      var self = this;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      
      if (self.size <= other.size) {
        return false;
      }
    ;
      return $rb_ge(self, other);
    });
    
    $def(self, '$<', function $Hash_$lt$6(other) {
      var self = this;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      return $rb_gt(other, self);
    });
    
    $def(self, '$<=', function $Hash_$lt_eq$7(other) {
      var self = this;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      return $rb_ge(other, self);
    });
    
    $def(self, '$[]', function $Hash_$$$8(key) {
      var self = this;

      
      var value = $hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      return self.$default(key);
    
    });
    
    $def(self, '$[]=', function $Hash_$$$eq$9(key, value) {
      var self = this;

      
      $deny_frozen_access(self);

      $hash_put(self, key, value);
      return value;
    
    });
    
    $def(self, '$assoc', function $$assoc(object) {
      var self = this;

      
      var entry;
      for (entry of self) {
        if ((entry[0])['$=='](object)) {
          return [entry[0], entry[1]];
        }
      }
      return nil;
    
    });
    
    $def(self, '$clear', function $$clear() {
      var self = this;

      
      $deny_frozen_access(self);

      self.clear();
      if (self.$$keys)
        self.$$keys.clear();

      return self;
    
    });
    
    $def(self, '$clone', function $$clone() {
      var self = this;

      
      var hash = self.$class().$new();
      $hash_clone(self, hash);
      return self["$frozen?"]() ? hash.$freeze() : hash;
    
    });
    
    $def(self, '$compact', function $$compact() {
      var self = this;

      
      var hash = new Map();

      self.forEach((value, key, s) => {
        if (value !== nil && value != null)
          $hash_put(hash, key, value);
      });

      return hash;
    
    });
    
    $def(self, '$compact!', function $Hash_compact$excl$10() {
      var self = this;

      
      $deny_frozen_access(self);

      var result = nil;

      return $hash_each(self, result, function(key, value) {
        if (value === nil || value == null) {
          $hash_delete(self, key);
          result = self;
        }
        return [false, result];
      });
    
    });
    
    $def(self, '$compare_by_identity', function $$compare_by_identity() {
      var self = this;

      
      $deny_frozen_access(self);

      if (!self.$$by_identity) {
        self.$$by_identity = true;

        if (self.size !== 0)
          Opal.hash_rehash(self);
      }

      return self;
    
    });
    
    $def(self, '$compare_by_identity?', function $Hash_compare_by_identity$ques$11() {
      var self = this;

      return self.$$by_identity === true;
    });
    
    $def(self, '$default', function $Hash_default$12(key) {
      var self = this;

      
      ;
      
      if (key !== undefined && self.$$proc !== nil && self.$$proc !== undefined) {
        return self.$$proc.$call(self, key);
      }
      if (self.$$none === undefined) {
        return nil;
      }
      return self.$$none;
    ;
    }, -1);
    
    $def(self, '$default=', function $Hash_default$eq$13(object) {
      var self = this;

      
      $deny_frozen_access(self);

      self.$$proc = nil;
      self.$$none = object;

      return object;
    
    });
    
    $def(self, '$default_proc', function $$default_proc() {
      var self = this;

      
      if (self.$$proc !== undefined) {
        return self.$$proc;
      }
      return nil;
    
    });
    
    $def(self, '$default_proc=', function $Hash_default_proc$eq$14(default_proc) {
      var self = this;

      
      $deny_frozen_access(self);

      var proc = default_proc;

      if (proc !== nil) {
        proc = $Opal['$coerce_to!'](proc, $$$('Proc'), "to_proc");

        if ((proc)['$lambda?']() && (proc).$arity().$abs() !== 2) {
          $Kernel.$raise($$$('TypeError'), "default_proc takes two arguments");
        }
      }

      self.$$none = nil;
      self.$$proc = proc;

      return default_proc;
    
    });
    
    $def(self, '$delete', function $Hash_delete$15(key) {
      var block = $Hash_delete$15.$$p || nil, self = this;

      $Hash_delete$15.$$p = null;
      
      ;
      
      $deny_frozen_access(self);
      var value = $hash_delete(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return Opal.yield1(block, key);
      }

      return nil;
    ;
    });
    
    $def(self, '$delete_if', function $$delete_if() {
      var block = $$delete_if.$$p || nil, self = this;

      $$delete_if.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["delete_if"], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      return $hash_each(self, self, function(key, value) {
        var obj = block(key, value);

        if (obj !== false && obj !== nil) {
          $hash_delete(self, key);
        }
        return [false, self];
      });
    ;
    });
    
    $def(self, '$dig', function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      $post_args = $slice(arguments, 1);
      keys = $post_args;
      item = self['$[]'](key);
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if (!$truthy(item['$respond_to?']("dig"))) {
        $Kernel.$raise($$$('TypeError'), $to_s(item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', $to_a(keys));
    }, -2);
    
    $def(self, '$dup', function $$dup() {
      var self = this;

      return $hash_clone(self, self.$class().$new());
    });
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["each"], function $$17(){var self = $$17.$$s == null ? this : $$17.$$s;

          return self.$size()}, {$$s: self})
      };
      
      return $hash_each(self, self, function(key, value) {
        $yield1(block, [key, value]);
        return [false, self];
      });
    ;
    });
    
    $def(self, '$each_key', function $$each_key() {
      var block = $$each_key.$$p || nil, self = this;

      $$each_key.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["each_key"], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s;

          return self.$size()}, {$$s: self})
      };
      
      return $hash_each(self, self, function(key, value) {
        block(key);
        return [false, self];
      });
    ;
    });
    
    $def(self, '$each_value', function $$each_value() {
      var block = $$each_value.$$p || nil, self = this;

      $$each_value.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["each_value"], function $$19(){var self = $$19.$$s == null ? this : $$19.$$s;

          return self.$size()}, {$$s: self})
      };
      
      return $hash_each(self, self, function(key, value) {
        block(value);
        return [false, self];
      });
    ;
    });
    
    $def(self, '$empty?', function $Hash_empty$ques$20() {
      var self = this;

      return self.size === 0;
    });
    
    $def(self, '$except', function $$except($a) {
      var $post_args, keys, self = this;

      
      $post_args = $slice(arguments);
      keys = $post_args;
      return $send(self.$dup(), 'except!', $to_a(keys));
    }, -1);
    
    $def(self, '$except!', function $Hash_except$excl$21($a) {
      var $post_args, keys, self = this;

      
      $post_args = $slice(arguments);
      keys = $post_args;
      $send(keys, 'each', [], function $$22(key){var self = $$22.$$s == null ? this : $$22.$$s;

        
        if (key == null) key = nil;
        return self.$delete(key);}, {$$s: self});
      return self;
    }, -1);
    
    $def(self, '$fetch', function $$fetch(key, defaults) {
      var block = $$fetch.$$p || nil, self = this;

      $$fetch.$$p = null;
      
      ;
      ;
      
      var value = $hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return block(key);
      }

      if (defaults !== undefined) {
        return defaults;
      }
    ;
      return $Kernel.$raise($$$('KeyError').$new("key not found: " + $to_s(key.$inspect()), $hash_new("key", key, "receiver", self)));
    }, -2);
    
    $def(self, '$fetch_values', function $$fetch_values($a) {
      var block = $$fetch_values.$$p || nil, $post_args, keys, self = this;

      $$fetch_values.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      keys = $post_args;
      return $send(keys, 'map', [], function $$23(key){var self = $$23.$$s == null ? this : $$23.$$s;

        
        if (key == null) key = nil;
        return $send(self, 'fetch', [key], block.$to_proc());}, {$$s: self});
    }, -1);
    
    $def(self, '$flatten', function $$flatten(level) {
      var self = this;

      
      if (level == null) level = 1;
      level = $Opal['$coerce_to!'](level, $$$('Integer'), "to_int");
      
      var result = [];

      return $hash_each(self, result, function(key, value) {
        result.push(key);

        if (value.$$is_array) {
          if (level === 1) {
            result.push(value);
            return [false, result];
          }

          result = result.concat((value).$flatten(level - 2));
          return [false, result];
        }

        result.push(value);
        return [false, result];
      });
    ;
    }, -1);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      return $freeze(self);;
    });
    
    $def(self, '$has_key?', function $Hash_has_key$ques$24(key) {
      var self = this;

      return $hash_get(self, key) !== undefined;
    });
    
    $def(self, '$has_value?', function $Hash_has_value$ques$25(value) {
      var self = this;

      
      var val, values = self.values();
      for (val of values) {
        if ((val)['$=='](value)) {
          return true;
        }
      }
      return false;
    
    });
    var $hash_ids;
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      
      var top = ($hash_ids === undefined),
          hash_id = self.$object_id(),
          result = $opal32_init(),
          key, item, i, values, entry,
          size = self.size, ary = new Int32Array(size);

      result = $opal32_add(result, 0x4);
      result = $opal32_add(result, size);

      if (top) {
        $hash_ids = new Map();
      }
      else if ($hash_ids.has(hash_id)) {
        return $opal32_add(result, 0x01010101);
      }

      try {
        if (!top) {
          values = $hash_ids.values();
          for (item of values) {
            if (self['$eql?'](item)) {
              return $opal32_add(result, 0x01010101);
            }
          }
        }

        $hash_ids.set(hash_id, self);
        i = 0;

        for (entry of self) {
          ary[i] = [0x70414952, entry[0], entry[1]].$hash();
          i++;
        }

        ary = ary.sort();

        for (i = 0; i < ary.length; i++) {
          result = $opal32_add(result, ary[i]);
        }

        return result;
      } finally {
        if (top) {
          $hash_ids = undefined;
        }
      }
    
    });
    
    $def(self, '$index', function $$index(object) {
      var self = this;

      
      var entry;
      for (entry of self) {
        if ((entry[1])['$=='](object)) {
          return entry[0];
        }
      }
      return nil;
    
    });
    
    $def(self, '$indexes', function $$indexes($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      var result = [];

      for (var i = 0, length = args.length, key, value; i < length; i++) {
        key = args[i];
        value = $hash_get(self, key);

        if (value === undefined) {
          result.push(self.$default());
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, -1);
    var inspect_ids;
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      
      var top = (inspect_ids === undefined),
          hash_id = self.$object_id(),
          result = [];
    ;
      
      return (function() { try {
      
      
        if (top) {
          inspect_ids = {};
        }

        if (inspect_ids.hasOwnProperty(hash_id)) {
          return '{...}';
        }

        inspect_ids[hash_id] = true;

        $hash_each(self, false, function(key, value) {
          value = $$('Opal').$inspect(value)
          key = $$('Opal').$inspect(key)

          result.push(key + '=>' + value);
          return [false, false];
        })

        return '{' + result.join(', ') + '}';
      ;
      return nil;
      } finally {
        if (top) inspect_ids = undefined
      }; })();;
    });
    
    $def(self, '$invert', function $$invert() {
      var self = this;

      
      var hash = new Map();

      return $hash_each(self, hash, function(key, value) {
        $hash_put(hash, value, key);
        return [false, hash];
      });
    
    });
    
    $def(self, '$keep_if', function $$keep_if() {
      var block = $$keep_if.$$p || nil, self = this;

      $$keep_if.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["keep_if"], function $$26(){var self = $$26.$$s == null ? this : $$26.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      return $hash_each(self, self, function(key, value) {
        var obj = block(key, value);

        if (obj === false || obj === nil) {
          $hash_delete(self, key);
        }
        return [false, self];
      });
    ;
    });
    
    $def(self, '$keys', function $$keys() {
      var self = this;

      return Array.from(self.keys());
    });
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.size;
    });
    
    $def(self, '$merge', function $$merge($a) {
      var block = $$merge.$$p || nil, $post_args, others, self = this;

      $$merge.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      others = $post_args;
      return $send(self.$dup(), 'merge!', $to_a(others), block.$to_proc());
    }, -1);
    
    $def(self, '$merge!', function $Hash_merge$excl$27($a) {
      var block = $Hash_merge$excl$27.$$p || nil, $post_args, others, self = this;

      $Hash_merge$excl$27.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      others = $post_args;
      
      $deny_frozen_access(self);

      var i, j, other;
      for (i = 0; i < others.length; ++i) {
        other = $Opal['$coerce_to!'](others[i], $$$('Hash'), "to_hash");

        if (block === nil) {
          $hash_each(other, false, function(key, value) {
            $hash_put(self, key, value);
            return [false, false];
          });
        } else {
          $hash_each(other, false, function(key, value) {
            var val = $hash_get(self, key);

            if (val === undefined) {
              $hash_put(self, key, value);
              return [false, false];
            }

            $hash_put(self, key, block(key, val, value));
            return [false, false];
          });
        }
      }

      return self;
    ;
    }, -1);
    
    $def(self, '$rassoc', function $$rassoc(object) {
      var self = this;

      
      var entry;
      for (entry of self) {
        if ((entry[1])['$=='](object)) {
          return [entry[0], entry[1]];
        }
      }
      return nil;
    
    });
    
    $def(self, '$rehash', function $$rehash() {
      var self = this;

      
      $deny_frozen_access(self);
      return Opal.hash_rehash(self);
    
    });
    
    $def(self, '$reject', function $$reject() {
      var block = $$reject.$$p || nil, self = this;

      $$reject.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["reject"], function $$28(){var self = $$28.$$s == null ? this : $$28.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var hash = new Map();

      self.forEach((value, key, s) => {
        var obj = block(key, value);

        if (obj === false || obj === nil) {
          $hash_put(hash, key, value);
        }
      });

      return hash;
    ;
    });
    
    $def(self, '$reject!', function $Hash_reject$excl$29() {
      var block = $Hash_reject$excl$29.$$p || nil, self = this;

      $Hash_reject$excl$29.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["reject!"], function $$30(){var self = $$30.$$s == null ? this : $$30.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      var result = nil;

      return $hash_each(self, result, function(key, value) {
        var obj = block(key, value);

        if (obj !== false && obj !== nil) {
          $hash_delete(self, key);
          result = self;
        }
        return [false, result];
      });
    ;
    });
    
    $def(self, '$replace', function $$replace(other) {
      var self = this;

      
      $deny_frozen_access(self);;
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      
      self.$clear();

      $hash_each(other, false, function(key, value) {
        $hash_put(self, key, value);
        return [false, false];
      });
    ;
      if ($truthy(other.$default_proc())) {
        self['$default_proc='](other.$default_proc())
      } else {
        self['$default='](other.$default())
      };
      return self;
    });
    
    $def(self, '$select', function $$select() {
      var block = $$select.$$p || nil, self = this;

      $$select.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["select"], function $$31(){var self = $$31.$$s == null ? this : $$31.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var hash = new Map();

      self.forEach((value, key, s) => {
        var obj = block(key, value);

        if (obj !== false && obj !== nil) {
          $hash_put(hash, key, value);
        }
      });

      return hash;
    ;
    });
    
    $def(self, '$select!', function $Hash_select$excl$32() {
      var block = $Hash_select$excl$32.$$p || nil, self = this;

      $Hash_select$excl$32.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["select!"], function $$33(){var self = $$33.$$s == null ? this : $$33.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      var result = nil;

      return $hash_each(self, result, function(key, value) {
        var obj = block(key, value);

        if (obj === false || obj === nil) {
          $hash_delete(self, key);
          result = self;
        }
        return [false, result];
      });
    ;
    });
    
    $def(self, '$shift', function $$shift() {
      var self = this;

      
      $deny_frozen_access(self);

      return $hash_each(self, nil, function(key, value) {
        return [true, [key, $hash_delete(self, key)]];
      });
    
    });
    
    $def(self, '$slice', function $$slice($a) {
      var $post_args, keys, self = this;

      
      $post_args = $slice(arguments);
      keys = $post_args;
      
      var result = new Map();

      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i], value = $hash_get(self, key);

        if (value !== undefined) {
          $hash_put(result, key, value);
        }
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      return Array.from(self);
    });
    
    $def(self, '$to_h', function $$to_h() {
      var block = $$to_h.$$p || nil, self = this;

      $$to_h.$$p = null;
      
      ;
      if ((block !== nil)) {
        return $send(self, 'map', [], block.$to_proc()).$to_h()
      };
      
      if (self.$$class === Opal.Hash) {
        return self;
      }

      var hash = new Map();

      $hash_clone(self, hash);

      return hash;
    ;
    });
    
    $def(self, '$to_hash', $return_self);
    
    $def(self, '$to_proc', function $$to_proc() {
      var self = this;

      return $send(self, 'proc', [], function $$34(key){var self = $$34.$$s == null ? this : $$34.$$s;

        
        ;
        
        if (key == null) {
          $Kernel.$raise($$$('ArgumentError'), "no key given")
        }
      ;
        return self['$[]'](key);}, {$$arity: -1, $$s: self})
    });
    
    $def(self, '$transform_keys', function $$transform_keys(keys_hash) {
      var block = $$transform_keys.$$p || nil, self = this;

      $$transform_keys.$$p = null;
      
      ;
      if (keys_hash == null) keys_hash = nil;
      if (($not(block) && ($not(keys_hash)))) {
        return $send(self, 'enum_for', ["transform_keys"], function $$35(){var self = $$35.$$s == null ? this : $$35.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var result = new Map();

      self.forEach((value, key, s) => {
        var new_key;
        if (keys_hash !== nil)
          new_key = $hash_get(keys_hash, key);
        if (new_key === undefined && block && block !== nil)
          new_key = block(key);
        if (new_key === undefined)
          new_key = key // key not modified
        $hash_put(result, new_key, value);
      });

      return result;
    ;
    }, -1);
    
    $def(self, '$transform_keys!', function $Hash_transform_keys$excl$36(keys_hash) {
      var block = $Hash_transform_keys$excl$36.$$p || nil, self = this;

      $Hash_transform_keys$excl$36.$$p = null;
      
      ;
      if (keys_hash == null) keys_hash = nil;
      if (($not(block) && ($not(keys_hash)))) {
        return $send(self, 'enum_for', ["transform_keys!"], function $$37(){var self = $$37.$$s == null ? this : $$37.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      var modified_keys = new Map();

      return $hash_each(self, self, function(key, value) {
        var new_key;
        if (keys_hash !== nil)
          new_key = $hash_get(keys_hash, key);
        if (new_key === undefined && block && block !== nil)
          new_key = block(key);
        if (new_key === undefined)
          return [false, self]; // key not modified
        if (!$hash_get(modified_keys, key))
          $hash_delete(self, key);
        $hash_put(self, new_key, value);
        $hash_put(modified_keys, new_key, true)
        return [false, self];
      });
    ;
    }, -1);
    
    $def(self, '$transform_values', function $$transform_values() {
      var block = $$transform_values.$$p || nil, self = this;

      $$transform_values.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["transform_values"], function $$38(){var self = $$38.$$s == null ? this : $$38.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var result = new Map();

      self.forEach((value, key, s) => $hash_put(result, key, block(value)));

      return result;
    ;
    });
    
    $def(self, '$transform_values!', function $Hash_transform_values$excl$39() {
      var block = $Hash_transform_values$excl$39.$$p || nil, self = this;

      $Hash_transform_values$excl$39.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["transform_values!"], function $$40(){var self = $$40.$$s == null ? this : $$40.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      return $hash_each(self, self, function(key, value) {
        $hash_put(self, key, block(value));
        return [false, self];
      });
    ;
    });
    
    $def(self, '$values', function $$values() {
      var self = this;

      return Array.from(self.values());
    });
    $alias(self, "each_pair", "each");
    $alias(self, "eql?", "==");
    $alias(self, "filter", "select");
    $alias(self, "filter!", "select!");
    $alias(self, "include?", "has_key?");
    $alias(self, "indices", "indexes");
    $alias(self, "key", "index");
    $alias(self, "key?", "has_key?");
    $alias(self, "member?", "has_key?");
    $alias(self, "size", "length");
    $alias(self, "store", "[]=");
    $alias(self, "to_s", "inspect");
    $alias(self, "update", "merge!");
    $alias(self, "value?", "has_value?");
    return $alias(self, "values_at", "indexes");
  })('::', Map, $nesting);
};

Opal.modules["corelib/number"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $klass = Opal.klass, $Opal = Opal.Opal, $Kernel = Opal.Kernel, $to_s = Opal.to_s, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $not = Opal.not, $rb_lt = Opal.rb_lt, $alias = Opal.alias, $send2 = Opal.send2, $find_super = Opal.find_super, $send = Opal.send, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $eqeq = Opal.eqeq, $return_self = Opal.return_self, $rb_divide = Opal.rb_divide, $to_ary = Opal.to_ary, $rb_times = Opal.rb_times, $rb_le = Opal.rb_le, $rb_ge = Opal.rb_ge, $return_val = Opal.return_val, $const_set = Opal.const_set, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,bridge,raise,name,class,Float,respond_to?,coerce_to!,__id__,__coerced__,===,>,!,**,new,<,to_f,==,nan?,infinite?,enum_for,+,-,gcd,lcm,%,/,frexp,to_i,ldexp,rationalize,*,<<,to_r,truncate,-@,size,<=,>=,inspect,angle,to_s,is_a?,abs,next,coerce_to?');
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Number');

    var $nesting = [self].concat($parent_nesting);

    
    $Opal.$bridge(Number, self);
    Opal.prop(self.$$prototype, '$$is_number', true);
    self.$$is_number_class = true;
    var number_id_map = new Map();
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + $to_s(self.$name()))
      });
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this;

      
      if (other === nil) {
        $Kernel.$raise($$$('TypeError'), "can't convert " + $to_s(other.$class()) + " into Float");
      }
      else if (other.$$is_string) {
        return [$Kernel.$Float(other), self];
      }
      else if (other['$respond_to?']("to_f")) {
        return [$Opal['$coerce_to!'](other, $$$('Float'), "to_f"), self];
      }
      else if (other.$$is_number) {
        return [other, self];
      }
      else {
        $Kernel.$raise($$$('TypeError'), "can't convert " + $to_s(other.$class()) + " into Float");
      }
    
    });
    
    $def(self, '$__id__', function $$__id__() {
      var self = this;

      
      // Binary-safe integers
      if (self|0 === self) {
        return (self * 2) + 1;
      }
      else {
        if (number_id_map.has(self)) {
          return number_id_map.get(self);
        }
        var id = Opal.uid();
        number_id_map.set(self, id);
        return id;
      }
    
    });
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      
      // Binary-safe integers
      if (self|0 === self) {
        return self.$__id__()
      }
      else {
        return self.toString().$hash();
      }
    
    });
    
    $def(self, '$+', function $Number_$plus$1(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self + other;
      }
      else {
        return self.$__coerced__("+", other);
      }
    
    });
    
    $def(self, '$-', function $Number_$minus$2(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self - other;
      }
      else {
        return self.$__coerced__("-", other);
      }
    
    });
    
    $def(self, '$*', function $Number_$$3(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self * other;
      }
      else {
        return self.$__coerced__("*", other);
      }
    
    });
    
    $def(self, '$/', function $Number_$slash$4(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self / other;
      }
      else {
        return self.$__coerced__("/", other);
      }
    
    });
    
    $def(self, '$%', function $Number_$percent$5(other) {
      var self = this;

      
      if (other.$$is_number) {
        if (other == -Infinity) {
          return other;
        }
        else if (other == 0) {
          $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0");
        }
        else if (other < 0 || self < 0) {
          return (self % other + other) % other;
        }
        else {
          return self % other;
        }
      }
      else {
        return self.$__coerced__("%", other);
      }
    
    });
    
    $def(self, '$&', function $Number_$$6(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self & other;
      }
      else {
        return self.$__coerced__("&", other);
      }
    
    });
    
    $def(self, '$|', function $Number_$$7(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self | other;
      }
      else {
        return self.$__coerced__("|", other);
      }
    
    });
    
    $def(self, '$^', function $Number_$$8(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self ^ other;
      }
      else {
        return self.$__coerced__("^", other);
      }
    
    });
    
    $def(self, '$<', function $Number_$lt$9(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self < other;
      }
      else {
        return self.$__coerced__("<", other);
      }
    
    });
    
    $def(self, '$<=', function $Number_$lt_eq$10(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self <= other;
      }
      else {
        return self.$__coerced__("<=", other);
      }
    
    });
    
    $def(self, '$>', function $Number_$gt$11(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self > other;
      }
      else {
        return self.$__coerced__(">", other);
      }
    
    });
    
    $def(self, '$>=', function $Number_$gt_eq$12(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self >= other;
      }
      else {
        return self.$__coerced__(">=", other);
      }
    
    });
    
    var spaceship_operator = function(self, other) {
      if (other.$$is_number) {
        if (isNaN(self) || isNaN(other)) {
          return nil;
        }

        if (self > other) {
          return 1;
        } else if (self < other) {
          return -1;
        } else {
          return 0;
        }
      }
      else {
        return self.$__coerced__("<=>", other);
      }
    }
  ;
    
    $def(self, '$<=>', function $Number_$lt_eq_gt$13(other) {
      var self = this;

      try {
        return spaceship_operator(self, other);
      } catch ($err) {
        if (Opal.rescue($err, [$$$('ArgumentError')])) {
          try {
            return nil
          } finally { Opal.pop_exception($err); }
        } else { throw $err; }
      }
    });
    
    $def(self, '$<<', function $Number_$lt$lt$14(count) {
      var self = this;

      
      count = $Opal['$coerce_to!'](count, $$$('Integer'), "to_int");
      return count > 0 ? self << count : self >> -count;
    });
    
    $def(self, '$>>', function $Number_$gt$gt$15(count) {
      var self = this;

      
      count = $Opal['$coerce_to!'](count, $$$('Integer'), "to_int");
      return count > 0 ? self >> count : self << -count;
    });
    
    $def(self, '$[]', function $Number_$$$16(bit) {
      var self = this;

      
      bit = $Opal['$coerce_to!'](bit, $$$('Integer'), "to_int");
      
      if (bit < 0) {
        return 0;
      }
      if (bit >= 32) {
        return self < 0 ? 1 : 0;
      }
      return (self >> bit) & 1;
    ;
    });
    
    $def(self, '$+@', function $Number_$plus$$17() {
      var self = this;

      return +self;
    });
    
    $def(self, '$-@', function $Number_$minus$$18() {
      var self = this;

      return -self;
    });
    
    $def(self, '$~', function $Number_$$19() {
      var self = this;

      return ~self;
    });
    
    $def(self, '$**', function $Number_$$$20(other) {
      var self = this;

      if ($eqeqeq($$$('Integer'), other)) {
        if (($not($$$('Integer')['$==='](self)) || ($truthy($rb_gt(other, 0))))) {
          return Math.pow(self, other);
        } else {
          return $$$('Rational').$new(self, 1)['$**'](other)
        }
      } else if (($truthy($rb_lt(self, 0)) && (($eqeqeq($$$('Float'), other) || ($eqeqeq($$$('Rational'), other)))))) {
        return $$$('Complex').$new(self, 0)['$**'](other.$to_f())
      } else if ($truthy(other.$$is_number != null)) {
        return Math.pow(self, other);
      } else {
        return self.$__coerced__("**", other)
      }
    });
    
    $def(self, '$==', function $Number_$eq_eq$21(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self.valueOf() === other.valueOf();
      }
      else if (other['$respond_to?']("==")) {
        return other['$=='](self);
      }
      else {
        return false;
      }
    
    });
    $alias(self, "===", "==");
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      return Math.abs(self);
    });
    
    $def(self, '$abs2', function $$abs2() {
      var self = this;

      return Math.abs(self * self);
    });
    
    $def(self, '$allbits?', function $Number_allbits$ques$22(mask) {
      var self = this;

      
      mask = $Opal['$coerce_to!'](mask, $$$('Integer'), "to_int");
      return (self & mask) == mask;;
    });
    
    $def(self, '$anybits?', function $Number_anybits$ques$23(mask) {
      var self = this;

      
      mask = $Opal['$coerce_to!'](mask, $$$('Integer'), "to_int");
      return (self & mask) !== 0;;
    });
    
    $def(self, '$angle', function $$angle() {
      var self = this;

      
      if ($truthy(self['$nan?']())) {
        return self
      };
      
      if (self == 0) {
        if (1 / self > 0) {
          return 0;
        }
        else {
          return Math.PI;
        }
      }
      else if (self < 0) {
        return Math.PI;
      }
      else {
        return 0;
      }
    ;
    });
    
    $def(self, '$bit_length', function $$bit_length() {
      var self = this;

      
      if (!$eqeqeq($$$('Integer'), self)) {
        $Kernel.$raise($$$('NoMethodError').$new("undefined method `bit_length` for " + $to_s(self) + ":Float", "bit_length"))
      };
      
      if (self === 0 || self === -1) {
        return 0;
      }

      var result = 0,
          value  = self < 0 ? ~self : self;

      while (value != 0) {
        result   += 1;
        value  >>>= 1;
      }

      return result;
    ;
    });
    
    $def(self, '$ceil', function $$ceil(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.ceil(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$chr', function $$chr(encoding) {
      var self = this;

      
      ;
      return Opal.enc(String.fromCodePoint(self), encoding || "BINARY");;
    }, -1);
    
    $def(self, '$denominator', function $$denominator() {
      var $yield = $$denominator.$$p || nil, self = this;

      $$denominator.$$p = null;
      if (($truthy(self['$nan?']()) || ($truthy(self['$infinite?']())))) {
        return 1
      } else {
        return $send2(self, $find_super(self, 'denominator', $$denominator, false, true), 'denominator', [], $yield)
      }
    });
    
    $def(self, '$downto', function $$downto(stop) {
      var block = $$downto.$$p || nil, self = this;

      $$downto.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["downto", stop], function $$24(){var self = $$24.$$s == null ? this : $$24.$$s;

          
          if (!$eqeqeq($$$('Numeric'), stop)) {
            $Kernel.$raise($$$('ArgumentError'), "comparison of " + $to_s(self.$class()) + " with " + $to_s(stop.$class()) + " failed")
          };
          if ($truthy($rb_gt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(self, stop), 1)
          };}, {$$s: self})
      };
      
      if (!stop.$$is_number) {
        $Kernel.$raise($$$('ArgumentError'), "comparison of " + $to_s(self.$class()) + " with " + $to_s(stop.$class()) + " failed")
      }
      for (var i = self; i >= stop; i--) {
        block(i);
      }
    ;
      return self;
    });
    
    $def(self, '$equal?', function $Number_equal$ques$25(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self['$=='](other)))) {
        return $ret_or_1
      } else {
        return isNaN(self) && isNaN(other);
      }
    });
    
    $def(self, '$even?', function $Number_even$ques$26() {
      var self = this;

      return self % 2 === 0;
    });
    
    $def(self, '$floor', function $$floor(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.floor(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$gcd', function $$gcd(other) {
      var self = this;

      
      if (!$eqeqeq($$$('Integer'), other)) {
        $Kernel.$raise($$$('TypeError'), "not an integer")
      };
      
      var min = Math.abs(self),
          max = Math.abs(other);

      while (min > 0) {
        var tmp = min;

        min = max % min;
        max = tmp;
      }

      return max;
    ;
    });
    
    $def(self, '$gcdlcm', function $$gcdlcm(other) {
      var self = this;

      return [self.$gcd(other), self.$lcm(other)]
    });
    
    $def(self, '$integer?', function $Number_integer$ques$27() {
      var self = this;

      return self % 1 === 0;
    });
    
    $def(self, '$is_a?', function $Number_is_a$ques$28(klass) {
      var $yield = $Number_is_a$ques$28.$$p || nil, self = this;

      $Number_is_a$ques$28.$$p = null;
      
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Float')) && ($eqeqeq($$$('Float'), self)))) {
        return true
      };
      return $send2(self, $find_super(self, 'is_a?', $Number_is_a$ques$28, false, true), 'is_a?', [klass], $yield);
    });
    
    $def(self, '$instance_of?', function $Number_instance_of$ques$29(klass) {
      var $yield = $Number_instance_of$ques$29.$$p || nil, self = this;

      $Number_instance_of$ques$29.$$p = null;
      
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Float')) && ($eqeqeq($$$('Float'), self)))) {
        return true
      };
      return $send2(self, $find_super(self, 'instance_of?', $Number_instance_of$ques$29, false, true), 'instance_of?', [klass], $yield);
    });
    
    $def(self, '$lcm', function $$lcm(other) {
      var self = this;

      
      if (!$eqeqeq($$$('Integer'), other)) {
        $Kernel.$raise($$$('TypeError'), "not an integer")
      };
      
      if (self == 0 || other == 0) {
        return 0;
      }
      else {
        return Math.abs(self * other / self.$gcd(other));
      }
    ;
    });
    
    $def(self, '$next', function $$next() {
      var self = this;

      return self + 1;
    });
    
    $def(self, '$nobits?', function $Number_nobits$ques$30(mask) {
      var self = this;

      
      mask = $Opal['$coerce_to!'](mask, $$$('Integer'), "to_int");
      return (self & mask) == 0;;
    });
    
    $def(self, '$nonzero?', function $Number_nonzero$ques$31() {
      var self = this;

      return self == 0 ? nil : self;
    });
    
    $def(self, '$numerator', function $$numerator() {
      var $yield = $$numerator.$$p || nil, self = this;

      $$numerator.$$p = null;
      if (($truthy(self['$nan?']()) || ($truthy(self['$infinite?']())))) {
        return self
      } else {
        return $send2(self, $find_super(self, 'numerator', $$numerator, false, true), 'numerator', [], $yield)
      }
    });
    
    $def(self, '$odd?', function $Number_odd$ques$32() {
      var self = this;

      return self % 2 !== 0;
    });
    
    $def(self, '$ord', $return_self);
    
    $def(self, '$pow', function $$pow(b, m) {
      var self = this;

      
      ;
      
      if (self == 0) {
        $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
      }

      if (m === undefined) {
        return self['$**'](b);
      } else {
        if (!($$$('Integer')['$==='](b))) {
          $Kernel.$raise($$$('TypeError'), "Integer#pow() 2nd argument not allowed unless a 1st argument is integer")
        }

        if (b < 0) {
          $Kernel.$raise($$$('TypeError'), "Integer#pow() 1st argument cannot be negative when 2nd argument specified")
        }

        if (!($$$('Integer')['$==='](m))) {
          $Kernel.$raise($$$('TypeError'), "Integer#pow() 2nd argument not allowed unless all arguments are integers")
        }

        if (m === 0) {
          $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
        }

        return self['$**'](b)['$%'](m)
      }
    ;
    }, -2);
    
    $def(self, '$pred', function $$pred() {
      var self = this;

      return self - 1;
    });
    
    $def(self, '$quo', function $$quo(other) {
      var $yield = $$quo.$$p || nil, self = this;

      $$quo.$$p = null;
      if ($eqeqeq($$$('Integer'), self)) {
        return $send2(self, $find_super(self, 'quo', $$quo, false, true), 'quo', [other], $yield)
      } else {
        return $rb_divide(self, other)
      }
    });
    
    $def(self, '$rationalize', function $$rationalize(eps) {
      var $a, $b, self = this, f = nil, n = nil;

      
      ;
      
      if (arguments.length > 1) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + $to_s(arguments.length) + " for 0..1)");
      }
    ;
      if ($eqeqeq($$$('Integer'), self)) {
        return $$$('Rational').$new(self, 1)
      } else if ($truthy(self['$infinite?']())) {
        return $Kernel.$raise($$$('FloatDomainError'), "Infinity")
      } else if ($truthy(self['$nan?']())) {
        return $Kernel.$raise($$$('FloatDomainError'), "NaN")
      } else if ($truthy(eps == null)) {
        
        $b = $$$('Math').$frexp(self), $a = $to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (n = ($a[1] == null ? nil : $a[1])), $b;
        f = $$$('Math').$ldexp(f, $$$($$$('Float'), 'MANT_DIG')).$to_i();
        n = $rb_minus(n, $$$($$$('Float'), 'MANT_DIG'));
        return $$$('Rational').$new($rb_times(2, f), (1)['$<<']($rb_minus(1, n))).$rationalize($$$('Rational').$new(1, (1)['$<<']($rb_minus(1, n))));
      } else {
        return self.$to_r().$rationalize(eps)
      };
    }, -1);
    
    $def(self, '$remainder', function $$remainder(y) {
      var self = this;

      return $rb_minus(self, $rb_times(y, $rb_divide(self, y).$truncate()))
    });
    
    $def(self, '$round', function $$round(ndigits) {
      var $a, $b, self = this, _ = nil, exp = nil;

      
      ;
      if ($eqeqeq($$$('Integer'), self)) {
        
        if ($truthy(ndigits == null)) {
          return self
        };
        if (($eqeqeq($$$('Float'), ndigits) && ($truthy(ndigits['$infinite?']())))) {
          $Kernel.$raise($$$('RangeError'), "Infinity")
        };
        ndigits = $Opal['$coerce_to!'](ndigits, $$$('Integer'), "to_int");
        if ($truthy($rb_lt(ndigits, $$$($$$('Integer'), 'MIN')))) {
          $Kernel.$raise($$$('RangeError'), "out of bounds")
        };
        if ($truthy(ndigits >= 0)) {
          return self
        };
        ndigits = ndigits['$-@']();
        
        if (0.415241 * ndigits - 0.125 > self.$size()) {
          return 0;
        }

        var f = Math.pow(10, ndigits),
            x = Math.floor((Math.abs(self) + f / 2) / f) * f;

        return self < 0 ? -x : x;
      ;
      } else {
        
        if (($truthy(self['$nan?']()) && ($truthy(ndigits == null)))) {
          $Kernel.$raise($$$('FloatDomainError'), "NaN")
        };
        ndigits = $Opal['$coerce_to!'](ndigits || 0, $$$('Integer'), "to_int");
        if ($truthy($rb_le(ndigits, 0))) {
          if ($truthy(self['$nan?']())) {
            $Kernel.$raise($$$('RangeError'), "NaN")
          } else if ($truthy(self['$infinite?']())) {
            $Kernel.$raise($$$('FloatDomainError'), "Infinity")
          }
        } else if ($eqeq(ndigits, 0)) {
          return Math.round(self)
        } else if (($truthy(self['$nan?']()) || ($truthy(self['$infinite?']())))) {
          return self
        };
        $b = $$$('Math').$frexp(self), $a = $to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (exp = ($a[1] == null ? nil : $a[1])), $b;
        if ($truthy($rb_ge(ndigits, $rb_minus($rb_plus($$$($$$('Float'), 'DIG'), 2), ($truthy($rb_gt(exp, 0)) ? ($rb_divide(exp, 4)) : ($rb_minus($rb_divide(exp, 3), 1))))))) {
          return self
        };
        if ($truthy($rb_lt(ndigits, ($truthy($rb_gt(exp, 0)) ? ($rb_plus($rb_divide(exp, 3), 1)) : ($rb_divide(exp, 4)))['$-@']()))) {
          return 0
        };
        return Math.round(self * Math.pow(10, ndigits)) / Math.pow(10, ndigits);;
      };
    }, -1);
    
    $def(self, '$times', function $$times() {
      var block = $$times.$$p || nil, self = this;

      $$times.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["times"], function $$33(){var self = $$33.$$s == null ? this : $$33.$$s;

          return self}, {$$s: self})
      };
      
      for (var i = 0; i < self; i++) {
        block(i);
      }
    ;
      return self;
    });
    
    $def(self, '$to_f', $return_self);
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      return self < 0 ? Math.ceil(self) : Math.floor(self);
    });
    
    $def(self, '$to_r', function $$to_r() {
      var $a, $b, self = this, f = nil, e = nil;

      if ($eqeqeq($$$('Integer'), self)) {
        return $$$('Rational').$new(self, 1)
      } else {
        
        $b = $$$('Math').$frexp(self), $a = $to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (e = ($a[1] == null ? nil : $a[1])), $b;
        f = $$$('Math').$ldexp(f, $$$($$$('Float'), 'MANT_DIG')).$to_i();
        e = $rb_minus(e, $$$($$$('Float'), 'MANT_DIG'));
        return $rb_times(f, $$$($$$('Float'), 'RADIX')['$**'](e)).$to_r();
      }
    });
    
    $def(self, '$to_s', function $$to_s(base) {
      var self = this;

      
      if (base == null) base = 10;
      base = $Opal['$coerce_to!'](base, $$$('Integer'), "to_int");
      if (($truthy($rb_lt(base, 2)) || ($truthy($rb_gt(base, 36))))) {
        $Kernel.$raise($$$('ArgumentError'), "invalid radix " + $to_s(base))
      };
      if (($eqeq(self, 0) && ($truthy(1/self === -Infinity)))) {
        return "-0.0"
      };
      return self.toString(base);;
    }, -1);
    
    $def(self, '$truncate', function $$truncate(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = parseInt(f * factor, 10) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$digits', function $$digits(base) {
      var self = this;

      
      if (base == null) base = 10;
      if ($truthy($rb_lt(self, 0))) {
        $Kernel.$raise($$$($$$('Math'), 'DomainError'), "out of domain")
      };
      base = $Opal['$coerce_to!'](base, $$$('Integer'), "to_int");
      if ($truthy($rb_lt(base, 2))) {
        $Kernel.$raise($$$('ArgumentError'), "invalid radix " + $to_s(base))
      };
      
      if (self != parseInt(self)) $Kernel.$raise($$$('NoMethodError'), "undefined method `digits' for " + $to_s(self.$inspect()))

      var value = self, result = [];

      if (self == 0) {
        return [0];
      }

      while (value != 0) {
        result.push(value % base);
        value = parseInt(value / base, 10);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$divmod', function $$divmod(other) {
      var $yield = $$divmod.$$p || nil, self = this;

      $$divmod.$$p = null;
      if (($truthy(self['$nan?']()) || ($truthy(other['$nan?']())))) {
        return $Kernel.$raise($$$('FloatDomainError'), "NaN")
      } else if ($truthy(self['$infinite?']())) {
        return $Kernel.$raise($$$('FloatDomainError'), "Infinity")
      } else {
        return $send2(self, $find_super(self, 'divmod', $$divmod, false, true), 'divmod', [other], $yield)
      }
    });
    
    $def(self, '$upto', function $$upto(stop) {
      var block = $$upto.$$p || nil, self = this;

      $$upto.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["upto", stop], function $$34(){var self = $$34.$$s == null ? this : $$34.$$s;

          
          if (!$eqeqeq($$$('Numeric'), stop)) {
            $Kernel.$raise($$$('ArgumentError'), "comparison of " + $to_s(self.$class()) + " with " + $to_s(stop.$class()) + " failed")
          };
          if ($truthy($rb_lt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(stop, self), 1)
          };}, {$$s: self})
      };
      
      if (!stop.$$is_number) {
        $Kernel.$raise($$$('ArgumentError'), "comparison of " + $to_s(self.$class()) + " with " + $to_s(stop.$class()) + " failed")
      }
      for (var i = self; i <= stop; i++) {
        block(i);
      }
    ;
      return self;
    });
    
    $def(self, '$zero?', function $Number_zero$ques$35() {
      var self = this;

      return self == 0;
    });
    
    $def(self, '$size', $return_val(4));
    
    $def(self, '$nan?', function $Number_nan$ques$36() {
      var self = this;

      return isNaN(self);
    });
    
    $def(self, '$finite?', function $Number_finite$ques$37() {
      var self = this;

      return self != Infinity && self != -Infinity && !isNaN(self);
    });
    
    $def(self, '$infinite?', function $Number_infinite$ques$38() {
      var self = this;

      
      if (self == Infinity) {
        return +1;
      }
      else if (self == -Infinity) {
        return -1;
      }
      else {
        return nil;
      }
    
    });
    
    $def(self, '$positive?', function $Number_positive$ques$39() {
      var self = this;

      return self != 0 && (self == Infinity || 1 / self > 0);
    });
    
    $def(self, '$negative?', function $Number_negative$ques$40() {
      var self = this;

      return self == -Infinity || 1 / self < 0;
    });
    
    function numberToUint8Array(num) {
      var uint8array = new Uint8Array(8);
      new DataView(uint8array.buffer).setFloat64(0, num, true);
      return uint8array;
    }

    function uint8ArrayToNumber(arr) {
      return new DataView(arr.buffer).getFloat64(0, true);
    }

    function incrementNumberBit(num) {
      var arr = numberToUint8Array(num);
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] === 0xff) {
          arr[i] = 0;
        } else {
          arr[i]++;
          break;
        }
      }
      return uint8ArrayToNumber(arr);
    }

    function decrementNumberBit(num) {
      var arr = numberToUint8Array(num);
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] === 0) {
          arr[i] = 0xff;
        } else {
          arr[i]--;
          break;
        }
      }
      return uint8ArrayToNumber(arr);
    }
  ;
    
    $def(self, '$next_float', function $$next_float() {
      var self = this;

      
      if ($eqeq(self, $$$($$$('Float'), 'INFINITY'))) {
        return $$$($$$('Float'), 'INFINITY')
      };
      if ($truthy(self['$nan?']())) {
        return $$$($$$('Float'), 'NAN')
      };
      if ($truthy($rb_ge(self, 0))) {
        return incrementNumberBit(Math.abs(self));
      } else {
        return decrementNumberBit(self);
      };
    });
    
    $def(self, '$prev_float', function $$prev_float() {
      var self = this;

      
      if ($eqeq(self, $$$($$$('Float'), 'INFINITY')['$-@']())) {
        return $$$($$$('Float'), 'INFINITY')['$-@']()
      };
      if ($truthy(self['$nan?']())) {
        return $$$($$$('Float'), 'NAN')
      };
      if ($truthy($rb_gt(self, 0))) {
        return decrementNumberBit(self);
      } else {
        return -incrementNumberBit(Math.abs(self));
      };
    });
    $alias(self, "arg", "angle");
    $alias(self, "eql?", "==");
    $alias(self, "fdiv", "/");
    $alias(self, "inspect", "to_s");
    $alias(self, "kind_of?", "is_a?");
    $alias(self, "magnitude", "abs");
    $alias(self, "modulo", "%");
    $alias(self, "object_id", "__id__");
    $alias(self, "phase", "angle");
    $alias(self, "succ", "next");
    return $alias(self, "to_int", "to_i");
  })('::', $$$('Numeric'), $nesting);
  $const_set('::', 'Fixnum', $$$('Number'));
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Integer');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    self.$$is_integer_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + $to_s(self.$name()))
      });
      
      Opal.udef(self, '$' + "new");;
      
      $def(self, '$sqrt', function $$sqrt(n) {
        
        
        n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
        
        if (n < 0) {
          $Kernel.$raise($$$($$$('Math'), 'DomainError'), "Numerical argument is out of domain - \"isqrt\"")
        }

        return parseInt(Math.sqrt(n), 10);
      ;
      });
      return $def(self, '$try_convert', function $$try_convert(object) {
        var self = this;

        return $$('Opal')['$coerce_to?'](object, self, "to_int")
      });
    })(Opal.get_singleton_class(self), $nesting);
    $const_set(self, 'MAX', Math.pow(2, 30) - 1);
    return $const_set(self, 'MIN', -Math.pow(2, 30));
  })('::', $$$('Numeric'), $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Float');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + $to_s(self.$name()))
      });
      
      Opal.udef(self, '$' + "new");;
      return $def(self, '$===', function $eq_eq_eq$41(other) {
        
        return !!other.$$is_number;
      });
    })(Opal.get_singleton_class(self), $nesting);
    $const_set(self, 'INFINITY', Infinity);
    $const_set(self, 'MAX', Number.MAX_VALUE);
    $const_set(self, 'MIN', Number.MIN_VALUE);
    $const_set(self, 'NAN', NaN);
    $const_set(self, 'DIG', 15);
    $const_set(self, 'MANT_DIG', 53);
    $const_set(self, 'RADIX', 2);
    return $const_set(self, 'EPSILON', Number.EPSILON || 2.2204460492503130808472633361816E-16);
  })('::', $$$('Numeric'), $nesting);
};

Opal.modules["corelib/range"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $def = Opal.def, $not = Opal.not, $send2 = Opal.send2, $find_super = Opal.find_super, $lambda = Opal.lambda, $send = Opal.send, $rb_ge = Opal.rb_ge, $rb_gt = Opal.rb_gt, $eqeq = Opal.eqeq, $rb_le = Opal.rb_le, $rb_lt = Opal.rb_lt, $to_s = Opal.to_s, $eqeqeq = Opal.eqeqeq, $return_ivar = Opal.return_ivar, $rb_minus = Opal.rb_minus, $Opal = Opal.Opal, $rb_divide = Opal.rb_divide, $rb_plus = Opal.rb_plus, $rb_times = Opal.rb_times, $thrower = Opal.thrower, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,attr_reader,raise,nil?,<=>,cover?,!,begin,end,exclude_end?,then,call,>=,>,==,max,<=,<,enum_for,size,upto,to_proc,respond_to?,class,succ,===,eql?,try_convert,is_a?,any?,last,to_a,-,coerce_to!,ceil,/,new,loop,+,*,each_with_index,%,step,bsearch,inspect,[],hash,include?');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Range');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.begin = $proto.end = $proto.excl = nil;
    
    self.$include($$$('Enumerable'));
    self.$$prototype.$$is_range = true;
    self.$attr_reader("begin", "end");
    
    $def(self, '$initialize', function $$initialize(first, last, exclude) {
      var self = this;

      
      if (exclude == null) exclude = false;
      if ($truthy(self.begin)) {
        $Kernel.$raise($$$('NameError'), "'initialize' called twice")
      };
      if (!(($truthy(first['$<=>'](last)) || ($truthy(first['$nil?']()))) || ($truthy(last['$nil?']())))) {
        $Kernel.$raise($$$('ArgumentError'), "bad value for range")
      };
      self.begin = first;
      self.end = last;
      return (self.excl = exclude);
    }, -3);
    
    $def(self, '$===', function $Range_$eq_eq_eq$1(value) {
      var self = this;

      
      if ($truthy(value.$$is_range)) {
        return false
      };
      return self['$cover?'](value);
    });
    
    function is_infinite(self) {
      if (self.begin === nil || self.end === nil ||
          self.begin === -Infinity || self.end === Infinity ||
          self.begin === Infinity || self.end === -Infinity) return true;
      return false;
    }
  ;
    
    $def(self, '$count', function $$count() {
      var block = $$count.$$p || nil, self = this;

      $$count.$$p = null;
      
      ;
      if (($not((block !== nil)) && ($truthy(is_infinite(self))))) {
        return $$$($$$('Float'), 'INFINITY')
      };
      return $send2(self, $find_super(self, 'count', $$count, false, true), 'count', [], block);
    });
    
    $def(self, '$to_a', function $$to_a() {
      var $yield = $$to_a.$$p || nil, self = this;

      $$to_a.$$p = null;
      
      if ($truthy(is_infinite(self))) {
        $Kernel.$raise($$$('TypeError'), "cannot convert endless range to an array")
      };
      return $send2(self, $find_super(self, 'to_a', $$to_a, false, true), 'to_a', [], $yield);
    });
    
    $def(self, '$cover?', function $Range_cover$ques$2(value) {
      var self = this, compare = nil, val_begin = nil, val_end = nil, val_excl = nil, cmp = nil, val_max = nil, $ret_or_1 = nil, end_cmp = nil;

      
      compare = $lambda(function $$3(a, b){var $ret_or_1 = nil;

        
        if (a == null) a = nil;
        if (b == null) b = nil;
        if ($truthy(($ret_or_1 = a['$<=>'](b)))) {
          return $ret_or_1
        } else {
          return 1
        };});
      if ($truthy(value.$$is_range)) {
        
        val_begin = value.$begin();
        val_end = value.$end();
        val_excl = value['$exclude_end?']();
        if ((((($truthy(self.begin) && ($truthy(val_begin['$nil?']()))) || (($truthy(self.end) && ($truthy(val_end['$nil?']()))))) || ((($truthy(val_begin) && ($truthy(val_end))) && ($truthy($send(compare.$call(val_begin, val_end), 'then', [], function $$4(c){
          
          if (c == null) c = nil;
          if ($truthy(val_excl)) {
            return $rb_ge(c, 0)
          } else {
            return $rb_gt(c, 0)
          };})))))) || (($truthy(val_begin) && ($not(self['$cover?'](val_begin))))))) {
          return false
        };
        cmp = compare.$call(self.end, val_end);
        if ($eqeq(self.excl, val_excl)) {
          return $rb_ge(cmp, 0)
        };
        if ($truthy(self.excl)) {
          return $rb_gt(cmp, 0)
        };
        if ($truthy($rb_ge(cmp, 0))) {
          return true
        };
        val_max = value.$max();
        return ($truthy(($ret_or_1 = val_max['$nil?']()['$!']())) ? ($rb_le(compare.$call(val_max, self.end), 0)) : ($ret_or_1));
      };
      if (($truthy(self.begin) && ($truthy($rb_gt(compare.$call(self.begin, value), 0))))) {
        return false
      };
      if ($truthy(self.end['$nil?']())) {
        return true
      };
      end_cmp = compare.$call(value, self.end);
      if ($truthy(self.excl)) {
        return $rb_lt(end_cmp, 0)
      } else {
        return $rb_le(end_cmp, 0)
      };
    });
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this, current = nil, last = nil, $ret_or_1 = nil;

      $$each.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each"], function $$5(){var self = $$5.$$s == null ? this : $$5.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var i, limit;

      if (self.begin.$$is_number && self.end.$$is_number) {
        if (self.begin % 1 !== 0 || self.end % 1 !== 0) {
          $Kernel.$raise($$$('TypeError'), "can't iterate from Float")
        }

        for (i = self.begin, limit = self.end + ($truthy(self.excl) ? (0) : (1)); i < limit; i++) {
          block(i);
        }

        return self;
      }

      if (self.begin.$$is_string && self.end.$$is_string) {
        $send(self.begin, 'upto', [self.end, self.excl], block.$to_proc())
        return self;
      }
    ;
      current = self.begin;
      last = self.end;
      if (!$truthy(current['$respond_to?']("succ"))) {
        $Kernel.$raise($$$('TypeError'), "can't iterate from " + $to_s(current.$class()))
      };
      while ($truthy(($truthy(($ret_or_1 = self.end['$nil?']())) ? ($ret_or_1) : ($rb_lt(current['$<=>'](last), 0))))) {
      
        Opal.yield1(block, current);
        current = current.$succ();
      };
      if (($not(self.excl) && ($eqeq(current, last)))) {
        Opal.yield1(block, current)
      };
      return self;
    });
    
    $def(self, '$eql?', function $Range_eql$ques$6(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      
      if (!$eqeqeq($$$('Range'), other)) {
        return false
      };
      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.excl['$==='](other['$exclude_end?']()))) ? (self.begin['$eql?'](other.$begin())) : ($ret_or_2))))) {
        return self.end['$eql?'](other.$end())
      } else {
        return $ret_or_1
      };
    });
    
    $def(self, '$exclude_end?', $return_ivar("excl"));
    
    $def(self, '$first', function $$first(n) {
      var $yield = $$first.$$p || nil, self = this;

      $$first.$$p = null;
      
      ;
      if ($truthy(self.begin['$nil?']())) {
        $Kernel.$raise($$$('RangeError'), "cannot get the minimum of beginless range")
      };
      if ($truthy(n == null)) {
        return self.begin
      };
      return $send2(self, $find_super(self, 'first', $$first, false, true), 'first', [n], $yield);
    }, -1);
    
    $def(self, '$include?', function $Range_include$ques$7(val) {
      var $yield = $Range_include$ques$7.$$p || nil, self = this, cmp = nil, $ret_or_1 = nil;

      $Range_include$ques$7.$$p = null;
      
      if ((((($truthy(self.begin.$$is_number || self.end.$$is_number) || ($truthy(self.begin['$is_a?']($$$('Time'))))) || ($truthy(self.end['$is_a?']($$$('Time'))))) || ($truthy($$$('Integer').$try_convert(self.begin)))) || ($truthy($$$('Integer').$try_convert(self.end))))) {
        return self['$cover?'](val)
      };
      if ($truthy(self.begin.$$is_string || self.end.$$is_string)) {
        if ($truthy(self.begin.$$is_string && self.end.$$is_string)) {
          return $send(self.begin.$upto(self.end, self.excl), 'any?', [], function $$8(s){
            
            if (s == null) s = nil;
            return s['$=='](val);})
        } else if ($truthy(self.begin['$nil?']())) {
          
          cmp = val['$<=>'](self.end);
          return ($truthy(($ret_or_1 = cmp['$nil?']()['$!']())) ? (($truthy(self.excl) ? ($rb_lt(cmp, 0)) : ($rb_le(cmp, 0)))) : ($ret_or_1));
        } else if ($truthy(self.end['$nil?']())) {
          
          cmp = self.begin['$<=>'](val);
          return ($truthy(($ret_or_1 = cmp['$nil?']()['$!']())) ? ($rb_le(cmp, 0)) : ($ret_or_1));
        }
      };
      return $send2(self, $find_super(self, 'include?', $Range_include$ques$7, false, true), 'include?', [val], $yield);
    });
    
    $def(self, '$last', function $$last(n) {
      var self = this;

      
      ;
      if ($truthy(self.end['$nil?']())) {
        $Kernel.$raise($$$('RangeError'), "cannot get the maximum of endless range")
      };
      if ($truthy(n == null)) {
        return self.end
      };
      return self.$to_a().$last(n);
    }, -1);
    
    $def(self, '$max', function $$max() {
      var $yield = $$max.$$p || nil, self = this;

      $$max.$$p = null;
      if ($truthy(self.end['$nil?']())) {
        return $Kernel.$raise($$$('RangeError'), "cannot get the maximum of endless range")
      } else if (($yield !== nil)) {
        return $send2(self, $find_super(self, 'max', $$max, false, true), 'max', [], $yield)
      } else if (($not(self.begin['$nil?']()) && (($truthy($rb_gt(self.begin, self.end)) || (($truthy(self.excl) && ($eqeq(self.begin, self.end)))))))) {
        return nil
      } else {
        return self.excl ? self.end - 1 : self.end
      }
    });
    
    $def(self, '$min', function $$min() {
      var $yield = $$min.$$p || nil, self = this;

      $$min.$$p = null;
      if ($truthy(self.begin['$nil?']())) {
        return $Kernel.$raise($$$('RangeError'), "cannot get the minimum of beginless range")
      } else if (($yield !== nil)) {
        return $send2(self, $find_super(self, 'min', $$min, false, true), 'min', [], $yield)
      } else if (($not(self.end['$nil?']()) && (($truthy($rb_gt(self.begin, self.end)) || (($truthy(self.excl) && ($eqeq(self.begin, self.end)))))))) {
        return nil
      } else {
        return self.begin
      }
    });
    
    $def(self, '$size', function $$size() {
      
      
      var b = this.begin, e = this.end;

      // If begin is Numeric
      if ($$$('Numeric')['$==='](b)) {
        // If end is Numeric
        if ($$$('Numeric')['$==='](e)) {
          // Calculating size based on whether range is exclusive or inclusive
          var size = $rb_minus(e, b);
          if (size < 0) {
            return 0;
          }
          if (!this.excl) {
            size += 1;
          }
          return ($$$('Float')['$==='](b) || $$$('Float')['$==='](e)) ? Math.floor(size) : size;
        }
        // If end is nil
        else if (e === nil) {
          return Infinity;
        }
      }
      // If begin is nil
      else if (b === nil) {
        // If end is Numeric
        if ($$$('Numeric')['$==='](e)) {
          return Infinity;
        }
      }

      // If neither begin nor end is Numeric
      return nil;
    
    });
    
    $def(self, '$step', function $$step(n) {
      var $yield = $$step.$$p || nil, self = this, $ret_or_1 = nil, i = nil;

      $$step.$$p = null;
      
      ;
      
      function coerceStepSize() {
        if (n == null) {
          n = 1;
        }
        else if (!n.$$is_number) {
          n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int")
        }

        if (n < 0) {
          $Kernel.$raise($$$('ArgumentError'), "step can't be negative")
        } else if (n === 0) {
          $Kernel.$raise($$$('ArgumentError'), "step can't be 0")
        }
      }

      function enumeratorSize() {
        if (!self.begin['$respond_to?']("succ")) {
          return nil;
        }

        if (self.begin.$$is_string && self.end.$$is_string) {
          return nil;
        }

        if (n % 1 === 0) {
          return $rb_divide(self.$size(), n).$ceil();
        } else {
          // n is a float
          var begin = self.begin, end = self.end,
              abs = Math.abs, floor = Math.floor,
              err = (abs(begin) + abs(end) + abs(end - begin)) / abs(n) * $$$($$$('Float'), 'EPSILON'),
              size;

          if (err > 0.5) {
            err = 0.5;
          }

          if (self.excl) {
            size = floor((end - begin) / n - err);
            if (size * n + begin < end) {
              size++;
            }
          } else {
            size = floor((end - begin) / n + err) + 1
          }

          return size;
        }
      }
    ;
      if (!($yield !== nil)) {
        if (((($truthy(self.begin['$is_a?']($$('Numeric'))) || ($truthy(self.begin['$nil?']()))) && (($truthy(self.end['$is_a?']($$('Numeric'))) || ($truthy(self.end['$nil?']()))))) && ($not(($truthy(($ret_or_1 = self.begin['$nil?']())) ? (self.end['$nil?']()) : ($ret_or_1)))))) {
          return $$$($$$('Enumerator'), 'ArithmeticSequence').$new(self, n, "step")
        } else {
          return $send(self, 'enum_for', ["step", n], function $$9(){
            
            coerceStepSize();
            return enumeratorSize();
          })
        }
      };
      coerceStepSize();
      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {
        
        i = 0;
        (function(){try { var $t_break = $thrower('break'); return $send(self, 'loop', [], function $$10(){var self = $$10.$$s == null ? this : $$10.$$s, current = nil;
          if (self.begin == null) self.begin = nil;
          if (self.excl == null) self.excl = nil;
          if (self.end == null) self.end = nil;

          
          current = $rb_plus(self.begin, $rb_times(i, n));
          if ($truthy(self.excl)) {
            if ($truthy($rb_ge(current, self.end))) {
              $t_break.$throw(nil, $$10.$$is_lambda)
            }
          } else if ($truthy($rb_gt(current, self.end))) {
            $t_break.$throw(nil, $$10.$$is_lambda)
          };
          Opal.yield1($yield, current);
          return (i = $rb_plus(i, 1));}, {$$s: self})} catch($e) {
          if ($e === $t_break) return $e.$v;
          throw $e;
        } finally {$t_break.is_orphan = true;}})();
      } else {
        
        
        if (self.begin.$$is_string && self.end.$$is_string && n % 1 !== 0) {
          $Kernel.$raise($$$('TypeError'), "no implicit conversion to float from string")
        }
      ;
        $send(self, 'each_with_index', [], function $$11(value, idx){
          
          if (value == null) value = nil;
          if (idx == null) idx = nil;
          if ($eqeq(idx['$%'](n), 0)) {
            return Opal.yield1($yield, value);
          } else {
            return nil
          };});
      };
      return self;
    }, -1);
    
    $def(self, '$%', function $Range_$percent$12(n) {
      var self = this;

      if (($truthy(self.begin['$is_a?']($$('Numeric'))) && ($truthy(self.end['$is_a?']($$('Numeric')))))) {
        return $$$($$$('Enumerator'), 'ArithmeticSequence').$new(self, n, "%")
      } else {
        return self.$step(n)
      }
    });
    
    $def(self, '$bsearch', function $$bsearch() {
      var block = $$bsearch.$$p || nil, self = this;

      $$bsearch.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("bsearch")
      };
      if ($truthy(is_infinite(self) && (self.begin.$$is_number || self.end.$$is_number))) {
        $Kernel.$raise($$$('NotImplementedError'), "Can't #bsearch an infinite range")
      };
      if (!$truthy(self.begin.$$is_number && self.end.$$is_number)) {
        $Kernel.$raise($$$('TypeError'), "can't do binary search for " + $to_s(self.begin.$class()))
      };
      return $send(self.$to_a(), 'bsearch', [], block.$to_proc());
    });
    
    $def(self, '$to_s', function $$to_s() {
      var self = this, $ret_or_1 = nil;

      return $to_s(($truthy(($ret_or_1 = self.begin)) ? ($ret_or_1) : (""))) + $to_s(($truthy(self.excl) ? ("...") : (".."))) + $to_s(($truthy(($ret_or_1 = self.end)) ? ($ret_or_1) : ("")))
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, $ret_or_1 = nil;

      return $to_s(($truthy(($ret_or_1 = self.begin)) ? (self.begin.$inspect()) : ($ret_or_1))) + $to_s(($truthy(self.excl) ? ("...") : (".."))) + $to_s(($truthy(($ret_or_1 = self.end)) ? (self.end.$inspect()) : ($ret_or_1)))
    });
    
    $def(self, '$marshal_load', function $$marshal_load(args) {
      var self = this;

      
      self.begin = args['$[]']("begin");
      self.end = args['$[]']("end");
      return (self.excl = args['$[]']("excl"));
    });
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return [$$$('Range'), self.begin, self.end, self.excl].$hash()
    });
    $alias(self, "==", "eql?");
    return $alias(self, "member?", "include?");
  })('::', null, $nesting);
};

Opal.modules["corelib/proc"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $slice = Opal.slice, $each_ivar = Opal.each_ivar, $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $defs = Opal.defs, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a, $return_self = Opal.return_self, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $Opal = Opal.Opal, $to_s = Opal.to_s, $alias = Opal.alias, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,proc,call,to_proc,new,source_location,coerce_to!,dup');
  return (function($base, $super) {
    var self = $klass($base, $super, 'Proc');

    
    
    Opal.prop(self.$$prototype, '$$is_proc', true);
    Opal.prop(self.$$prototype, '$$is_lambda', false);
    $defs(self, '$new', function $Proc_new$1() {
      var block = $Proc_new$1.$$p || nil;

      $Proc_new$1.$$p = null;
      
      ;
      if (!$truthy(block)) {
        $Kernel.$raise($$$('ArgumentError'), "tried to create a Proc object without a block")
      };
      return block;
    });
    
    function $call_lambda(self, args) {
      if (self.$$ret) {
        try {
          return self.apply(null, args);
        } catch (err) {
          if (err === self.$$ret) {
            return err.$v;
          } else {
            throw err;
          }
        }
      } else {
        return self.apply(null, args);
      }
    }

    function $call_proc(self, args) {
      if (self.$$brk) {
        try {
          return Opal.yieldX(self, args);
        } catch (err) {
          if (err === self.$$brk) {
            return err.$v;
          } else {
            throw err;
          }
        }
      } else {
        return Opal.yieldX(self, args);
      }
    }
  ;
    
    $def(self, '$call', function $$call($a) {
      var block = $$call.$$p || nil, $post_args, args, self = this;

      $$call.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      
      if (block !== nil) self.$$p = block;
      if (self.$$is_lambda) return $call_lambda(self, args);
      return $call_proc(self, args);
    ;
    }, -1);
    
    $def(self, '$>>', function $Proc_$gt$gt$2(other) {
      var $yield = $Proc_$gt$gt$2.$$p || nil, self = this;

      $Proc_$gt$gt$2.$$p = null;
      return $send($Kernel, 'proc', [], function $$3($a){var block = $$3.$$p || nil, $post_args, args, self = $$3.$$s == null ? this : $$3.$$s, out = nil;

        $$3.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        out = $send(self, 'call', $to_a(args), block.$to_proc());
        return other.$call(out);}, {$$arity: -1, $$s: self})
    });
    
    $def(self, '$<<', function $Proc_$lt$lt$4(other) {
      var $yield = $Proc_$lt$lt$4.$$p || nil, self = this;

      $Proc_$lt$lt$4.$$p = null;
      return $send($Kernel, 'proc', [], function $$5($a){var block = $$5.$$p || nil, $post_args, args, self = $$5.$$s == null ? this : $$5.$$s, out = nil;

        $$5.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        out = $send(other, 'call', $to_a(args), block.$to_proc());
        return self.$call(out);}, {$$arity: -1, $$s: self})
    });
    
    $def(self, '$to_proc', $return_self);
    
    $def(self, '$lambda?', function $Proc_lambda$ques$6() {
      var self = this;

      return !!self.$$is_lambda;
    });
    
    $def(self, '$arity', function $$arity() {
      var self = this;

      
      if (self.$$is_curried) {
        return -1;
      } else if (self.$$arity != null) {
        return self.$$arity;
      } else {
        return self.length;
      }
    
    });
    
    $def(self, '$source_location', function $$source_location() {
      var self = this, $ret_or_1 = nil;

      
      if (self.$$is_curried) { return nil; };
      if ($truthy(($ret_or_1 = self.$$source_location))) {
        return $ret_or_1
      } else {
        return nil
      };
    });
    
    $def(self, '$binding', function $$binding() {
      var $a, self = this;

      
      if (self.$$is_curried) { $Kernel.$raise($$$('ArgumentError'), "Can't create Binding") };
      if ($truthy((($a = $$$('::', 'Binding', 'skip_raise')) ? 'constant' : nil))) {
        return $$$('Binding').$new(nil, [], self.$$s, self.$source_location())
      } else {
        return nil
      };
    });
    
    $def(self, '$parameters', function $$parameters($kwargs) {
      var lambda, self = this;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      lambda = $hash_get($kwargs, "lambda");;
      
      if (self.$$is_curried) {
        return [["rest"]];
      } else if (self.$$parameters) {
        if (lambda == null ? self.$$is_lambda : lambda) {
          return self.$$parameters;
        } else {
          var result = [], i, length;

          for (i = 0, length = self.$$parameters.length; i < length; i++) {
            var parameter = self.$$parameters[i];

            if (parameter[0] === 'req') {
              // required arguments always have name
              parameter = ['opt', parameter[1]];
            }

            result.push(parameter);
          }

          return result;
        }
      } else {
        return [];
      }
    ;
    }, -1);
    
    $def(self, '$curry', function $$curry(arity) {
      var self = this;

      
      ;
      
      if (arity === undefined) {
        arity = self.length;
      }
      else {
        arity = $Opal['$coerce_to!'](arity, $$$('Integer'), "to_int");
        if (self.$$is_lambda && arity !== self.length) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + $to_s(arity) + " for " + $to_s(self.length) + ")")
        }
      }

      function curried () {
        var args = $slice(arguments),
            length = args.length,
            result;

        if (length > arity && self.$$is_lambda && !self.$$is_curried) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + $to_s(length) + " for " + $to_s(arity) + ")")
        }

        if (length >= arity) {
          return self.$call.apply(self, args);
        }

        result = function () {
          return curried.apply(null,
            args.concat($slice(arguments)));
        }
        result.$$is_lambda = self.$$is_lambda;
        result.$$is_curried = true;

        return result;
      };

      curried.$$is_lambda = self.$$is_lambda;
      curried.$$is_curried = true;
      return curried;
    ;
    }, -1);
    
    $def(self, '$dup', function $$dup() {
      var self = this;

      
      var original_proc = self.$$original_proc || self,
          proc = function () {
            return original_proc.apply(this, arguments);
          };

      $each_ivar(self, function(prop) {
        proc[prop] = self[prop];
      });

      return proc;
    
    });
    $alias(self, "===", "call");
    $alias(self, "clone", "dup");
    $alias(self, "yield", "call");
    return $alias(self, "[]", "call");
  })('::', Function)
};

Opal.modules["corelib/method"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  var $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $slice = Opal.slice, $to_s = Opal.to_s, $alias = Opal.alias, $Kernel = Opal.Kernel, $send = Opal.send, $to_a = Opal.to_a, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_reader,arity,curry,>>,<<,new,class,join,source_location,call,raise,bind,to_proc');
  
  (function($base, $super) {
    var self = $klass($base, $super, 'Method');

    var $proto = self.$$prototype;

    $proto.method = $proto.receiver = $proto.owner = $proto.name = nil;
    
    self.$attr_reader("owner", "receiver", "name");
    
    $def(self, '$initialize', function $$initialize(receiver, owner, method, name) {
      var self = this;

      
      self.receiver = receiver;
      self.owner = owner;
      self.name = name;
      return (self.method = method);
    });
    
    $def(self, '$arity', function $$arity() {
      var self = this;

      return self.method.$arity()
    });
    
    $def(self, '$parameters', function $$parameters() {
      var self = this;

      return self.method.$$parameters
    });
    
    $def(self, '$source_location', function $$source_location() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$source_location))) {
        return $ret_or_1
      } else {
        return ["(eval)", 0]
      }
    });
    
    $def(self, '$comments', function $$comments() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$comments))) {
        return $ret_or_1
      } else {
        return []
      }
    });
    
    $def(self, '$call', function $$call($a) {
      var block = $$call.$$p || nil, $post_args, args, self = this;

      $$call.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      
      self.method.$$p = block;

      return self.method.apply(self.receiver, args);
    ;
    }, -1);
    
    $def(self, '$curry', function $$curry(arity) {
      var self = this;

      
      ;
      return self.method.$curry(arity);
    }, -1);
    
    $def(self, '$>>', function $Method_$gt$gt$1(other) {
      var self = this;

      return self.method['$>>'](other)
    });
    
    $def(self, '$<<', function $Method_$lt$lt$2(other) {
      var self = this;

      return self.method['$<<'](other)
    });
    
    $def(self, '$unbind', function $$unbind() {
      var self = this;

      return $$$('UnboundMethod').$new(self.receiver.$class(), self.owner, self.method, self.name)
    });
    
    $def(self, '$to_proc', function $$to_proc() {
      var self = this;

      
      var proc = self.$call.bind(self);
      proc.$$unbound = self.method;
      proc.$$is_lambda = true;
      proc.$$arity = self.method.$$arity == null ? self.method.length : self.method.$$arity;
      proc.$$parameters = self.method.$$parameters;
      return proc;
    
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<" + $to_s(self.$class()) + ": " + $to_s(self.receiver.$class()) + "#" + $to_s(self.name) + " (defined in " + $to_s(self.owner) + " in " + $to_s(self.$source_location().$join(":")) + ")>"
    });
    $alias(self, "[]", "call");
    return $alias(self, "===", "call");
  })('::', null);
  return (function($base, $super) {
    var self = $klass($base, $super, 'UnboundMethod');

    var $proto = self.$$prototype;

    $proto.method = $proto.owner = $proto.name = $proto.source = nil;
    
    self.$attr_reader("source", "owner", "name");
    
    $def(self, '$initialize', function $$initialize(source, owner, method, name) {
      var self = this;

      
      self.source = source;
      self.owner = owner;
      self.method = method;
      self.name = name;
      return self.$$method = method;;
    });
    
    $def(self, '$arity', function $$arity() {
      var self = this;

      return self.method.$arity()
    });
    
    $def(self, '$parameters', function $$parameters() {
      var self = this;

      return self.method.$$parameters
    });
    
    $def(self, '$source_location', function $$source_location() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$source_location))) {
        return $ret_or_1
      } else {
        return ["(eval)", 0]
      }
    });
    
    $def(self, '$comments', function $$comments() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$comments))) {
        return $ret_or_1
      } else {
        return []
      }
    });
    
    $def(self, '$bind', function $$bind(object) {
      var self = this;

      
      if (self.owner.$$is_module || Opal.is_a(object, self.owner)) {
        return $$$('Method').$new(object, self.owner, self.method, self.name);
      }
      else {
        $Kernel.$raise($$$('TypeError'), "can't bind singleton method to a different class (expected " + $to_s(object) + ".kind_of?(" + $to_s(self.owner) + " to be true)");
      }
    
    });
    
    $def(self, '$bind_call', function $$bind_call(object, $a) {
      var block = $$bind_call.$$p || nil, $post_args, args, self = this;

      $$bind_call.$$p = null;
      
      ;
      $post_args = $slice(arguments, 1);
      args = $post_args;
      return $send(self.$bind(object), 'call', $to_a(args), block.$to_proc());
    }, -2);
    return $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<" + $to_s(self.$class()) + ": " + $to_s(self.source) + "#" + $to_s(self.name) + " (defined in " + $to_s(self.owner) + " in " + $to_s(self.$source_location().$join(":")) + ")>"
    });
  })('::', null);
};

Opal.modules["opal/regexp_transpiler"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $module = Opal.module, $truthy = Opal.truthy, $lambda = Opal.lambda, $rb_plus = Opal.rb_plus, $rb_lt = Opal.rb_lt, $eqeq = Opal.eqeq, $rb_gt = Opal.rb_gt, $rb_le = Opal.rb_le, $rb_minus = Opal.rb_minus, $annotate_regexp = Opal.annotate_regexp, $neqeq = Opal.neqeq, $to_s = Opal.to_s, $def = Opal.def, $const_set = Opal.const_set, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('module_function,include?,remove_flag,add_flag,transform_regexp_by_re_and_hash,+,<,==,>,<=,-,=~,!=,call,warn,inspect');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'RegexpTranspiler');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      self.$module_function();
      
      $def(self, '$transform_regexp', function $$transform_regexp(original_regexp, flags) {
        var self = this, $ret_or_1 = nil, ruby_multiline = nil, regexp = nil, escaping = nil, str = nil, depth = nil, inside = nil, curr_inside = nil, new_regexp = nil, line_based_regexp = nil, string_based_regexp = nil, unicode_character_class = nil, quantifier = nil, apply_outside_transform = nil, length = nil, i = nil, char$ = nil, capture = nil, prev_chars = nil, tail = nil;

        
        flags = ($truthy(($ret_or_1 = flags)) ? ($ret_or_1) : (""));
        if ($truthy(self['$include?'](flags, "m"))) {
          
          ruby_multiline = true;
          flags = self.$remove_flag(flags, "m");
        };
        flags = self.$add_flag(flags, "u");
        regexp = self.$transform_regexp_by_re_and_hash(original_regexp, $$('ESCAPES_REGEXP'), $$$($$('Opal'), 'REGEXP_EQUIVALENTS'));
        escaping = false;
        str = "";
        depth = 0;
        inside = false;
        curr_inside = false;
        new_regexp = "";
        line_based_regexp = false;
        string_based_regexp = false;
        unicode_character_class = false;
        quantifier = false;
        apply_outside_transform = $lambda(function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

          
          if (!$truthy(curr_inside)) {
            str = self.$transform_regexp_by_re_and_hash(str, $$('OUTSIDE_ESCAPES_REGEXP'), $$$($$('Opal'), 'REGEXP_EQUIVALENTS_OUTSIDE'))
          };
          return (new_regexp = $rb_plus(new_regexp, str));}, {$$s: self});
        length = regexp.length;
        i = 0;
        while ($truthy($rb_lt(i, length))) {
        
          char$ = regexp[i];
          capture = true;
          if ($truthy(escaping)) {
            
            escaping = false;
            if (($eqeq(char$, "A") || ($eqeq(char$, "z")))) {
              string_based_regexp = true
            } else if (($eqeq(char$, "p") || ($eqeq(char$, "P")))) {
              unicode_character_class = 1
            };
          } else if ($eqeq(char$, "\\")) {
            escaping = true
          } else if ((($eqeq(depth, 0) && ($eqeq(char$, "."))) && ($truthy(ruby_multiline)))) {
            char$ = "[\\s\\S]"
          } else if (($eqeq(depth, 0) && (($eqeq(char$, "^") || ($eqeq(char$, "$")))))) {
            line_based_regexp = true
          } else if ($eqeq(char$, "[")) {
            
            depth = $rb_plus(depth, 1);
            if ($truthy($rb_gt(depth, 1))) {
              capture = false
            };
          } else if ($eqeq(char$, "]")) {
            
            if ($truthy($rb_gt(depth, 1))) {
              capture = false
            };
            if ($truthy($rb_le(depth, 0))) {
              
              str = $rb_plus("[", str);
              depth = 0;
            };
            depth = $rb_minus(depth, 1);
          } else if ($eqeq(char$, "{")) {
            if ($eqeq(unicode_character_class, 1)) {
              
              prev_chars = regexp.slice(i-2);
              if (($eqeq(prev_chars, "\\p") || ($eqeq(prev_chars, "\\P")))) {
                unicode_character_class = 2
              } else {
                
                unicode_character_class = false;
                char$ = "\\{";
              };
            } else if ($truthy($rb_gt(i, 0))) {
              
              tail = regexp.slice(i+1);
              if ($truthy(tail['$=~']($annotate_regexp(/^\d+(,|)\d*\}/u, "\\A\\d+(,|)\\d*}", "")))) {
                quantifier = true
              } else {
                char$ = "\\{"
              };
            } else {
              
              unicode_character_class = false;
              quantifier = false;
              char$ = "\\{";
            }
          } else if ($eqeq(char$, "}")) {
            if ($eqeq(unicode_character_class, 2)) {
              unicode_character_class = false
            } else if ($truthy(quantifier)) {
              quantifier = false
            } else {
              
              unicode_character_class = false;
              quantifier = false;
              char$ = "\\}";
            }
          };
          if ($truthy(capture)) {
            str = $rb_plus(str, char$)
          };
          curr_inside = inside;
          inside = $rb_gt(depth, 0);
          if ($neqeq(curr_inside, inside)) {
            
            apply_outside_transform.$call();
            str = "";
          };
          i = $rb_plus(i, 1);
        };
        apply_outside_transform.$call();
        if ($truthy(line_based_regexp)) {
          flags = self.$add_flag(flags, "m")
        };
        if (($truthy(line_based_regexp) && ($truthy(string_based_regexp)))) {
          self.$warn("warning: Both \\A or \\z and ^ or $ used in a regexp " + $to_s(original_regexp.$inspect()) + ". In Opal this will cause undefined behavior.")
        };
        return [new_regexp, flags];
      });
      
      
      $def(self, '$transform_regexp_by_re_and_hash', function $$transform_regexp_by_re_and_hash(regexp, transformer, hash) {
        
        
          return regexp.replace(transformer, function(i) {
            return hash.get(i) || i;
          });
        
      });
      
      $def(self, '$add_flag', function $$add_flag(flags, flag) {
        
        return flags.includes(flag) ? flags : flags + flag;
      });
      
      $def(self, '$remove_flag', function $$remove_flag(flags, flag) {
        
        return flags.replace(flag, '');
      });
      
      $def(self, '$simple_regexp?', function $RegexpTranspiler_simple_regexp$ques$2(regexp) {
        
        return /^(\\[dnrtAzZ\\]|\(\?[:!]|[\w\s(){}|?+*@^$-])*$/.test(regexp);
      });
      
      $def(self, '$include?', function $RegexpTranspiler_include$ques$3(str, needle) {
        
        return str.includes(needle);
      });
      $const_set($nesting[0], 'ESCAPES_REGEXP', /(\\.|\[:[a-z]*:\])/g);
      return $const_set($nesting[0], 'OUTSIDE_ESCAPES_REGEXP', /(\\.)/g);;
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["opal/regexp_anchors"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  var $module = Opal.module, $const_set = Opal.const_set, $hash_new = Opal.hash_new, $to_s = Opal.to_s, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('new');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set(self, 'REGEXP_START', "\\A");
    $const_set(self, 'REGEXP_END', "\\z");
    $const_set(self, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS', "\\u0001-\\u002F\\u003A-\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    $const_set(self, 'REGEXP_EQUIVALENTS', $hash_new("\\h", "[\\dA-Fa-f]", "\\e", "\\x1b", "\\_", "_", "\\~", "~", "\\#", "#", "\\'", "'", "\\\"", "\"", "\\ ", " ", "\\=", "=", "\\!", "!", "\\%", "%", "\\&", "&", "\\<", "<", "\\>", ">", "\\@", "@", "\\:", ":", "\\`", "`", "[:alnum:]", "\\p{Alphabetic}\\p{Number}", "[:alpha:]", "\\p{Alphabetic}", "[:blank:]", "\\p{Space_Separator}\\t", "[:cntrl:]", "\\p{Control}", "[:digit:]", "\\d", "[:graph:]", "\\p{Alphabetic}\\p{Number}\\p{Punctuation}\\p{Symbol}", "[:lower:]", "\\p{Lowercase_Letter}", "[:print:]", "\\p{Alphabetic}\\p{Number}\\p{Punctuation}\\p{Symbol}\\p{Space_Separator}", "[:punct:]", "\\p{Punctuation}", "[:space:]", "\\p{White_Space}", "[:upper:]", "\\p{Uppercase_Letter}", "[:xdigit:]", "\\dA-Fa-f"));
    $const_set(self, 'REGEXP_EQUIVALENTS_OUTSIDE', $hash_new("\\A", "^", "\\z", "$", "\\Z", "(?:\\n?$)", "\\-", "-", "\\R", "(?:\\r|\\n|\\r\\n|\\f|\\u0085|\\u2028|\\u2029)"));
    $const_set(self, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS', "\\u0001-\\u0020\\u0022-\\u002F\\u003A-\\u003E\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    $const_set(self, 'INLINE_IDENTIFIER_REGEXP', $$('Regexp').$new("[^" + $to_s($$$(self, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS')) + "]*[^" + $to_s($$$(self, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS')) + "]"));
    $const_set(self, 'FORBIDDEN_CONST_NAME_CHARS', "\\u0001-\\u0020\\u0021-\\u002F\\u003B-\\u003F\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    return $const_set(self, 'CONST_NAME_REGEXP', $$('Regexp').$new($to_s($$$(self, 'REGEXP_START')) + "(::)?[A-Z][^" + $to_s($$$(self, 'FORBIDDEN_CONST_NAME_CHARS')) + "]*" + $to_s($$$(self, 'REGEXP_END'))));
  })($nesting[0], $nesting)
};

Opal.modules["corelib/variables"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $gvars = Opal.gvars, $const_set = Opal.const_set, $Object = Opal.Object, nil = Opal.nil;

  Opal.add_stubs('new');
  
  $gvars['&'] = $gvars['~'] = $gvars['`'] = $gvars["'"] = nil;
  $gvars.LOADED_FEATURES = ($gvars["\""] = Opal.loaded_features);
  $gvars.LOAD_PATH = ($gvars[":"] = []);
  $gvars["/"] = "\n";
  $gvars[","] = nil;
  $const_set('::', 'ARGV', []);
  $const_set('::', 'ARGF', $Object.$new());
  $const_set('::', 'ENV', (new Map()));
  $gvars.VERBOSE = false;
  $gvars.DEBUG = false;
  return ($gvars.SAFE = 0);
};

Opal.modules["corelib/string/encoding"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  var $global_regexp = Opal.global_regexp, $klass = Opal.klass, $rb_plus = Opal.rb_plus, $truthy = Opal.truthy, $send = Opal.send, $def = Opal.def, $eqeq = Opal.eqeq, $return_ivar = Opal.return_ivar, $return_val = Opal.return_val, $to_s = Opal.to_s, $Kernel = Opal.Kernel, $hash_new = Opal.hash_new, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('+,[],clone,initialize,new,instance_eval,to_proc,each,const_set,tr,==,default_external,attr_accessor,attr_reader,raise,register,default_external=,default_internal=');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Encoding');

    var $nesting = [self].concat($parent_nesting), $proto = self.$$prototype;

    $proto.name = $proto.dummy = nil;
    
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$register', function $$register(name, options) {
        var block = $$register.$$p || nil, self = this, names = nil, $ret_or_1 = nil, ascii = nil, dummy = nil, encoding = nil, register = nil;

        $$register.$$p = null;
        
        ;
        if (options == null) options = (new Map());
        names = $rb_plus([name], ($truthy(($ret_or_1 = options['$[]']("aliases"))) ? ($ret_or_1) : ([])));
        ascii = ($truthy(($ret_or_1 = options['$[]']("ascii"))) && ($ret_or_1));
        dummy = ($truthy(($ret_or_1 = options['$[]']("dummy"))) && ($ret_or_1));
        if ($truthy(options['$[]']("inherits"))) {
          
          encoding = options['$[]']("inherits").$clone();
          encoding.$initialize(name, names, ascii, dummy);
        } else {
          encoding = self.$new(name, names, ascii, dummy)
        };
        if ((block !== nil)) {
          $send(encoding, 'instance_eval', [], block.$to_proc())
        };
        register = Opal.encodings;
        return $send(names, 'each', [], function $$1(encoding_name){var self = $$1.$$s == null ? this : $$1.$$s;

          
          if (encoding_name == null) encoding_name = nil;
          self.$const_set(encoding_name.$tr("-", "_"), encoding);
          return register[encoding_name] = encoding;}, {$$s: self});
      }, -2);
      
      $def(self, '$find', function $$find(name) {
        var self = this;

        
        if ($eqeq(name, "default_external")) {
          return self.$default_external()
        };
        return Opal.find_encoding(name);;
      });
      return self.$attr_accessor("default_external", "default_internal");
    })(Opal.get_singleton_class(self), $nesting);
    self.$attr_reader("name", "names");
    
    $def(self, '$initialize', function $$initialize(name, names, ascii, dummy) {
      var self = this;

      
      self.name = name;
      self.names = names;
      self.ascii = ascii;
      return (self.dummy = dummy);
    });
    
    $def(self, '$ascii_compatible?', $return_ivar("ascii"));
    
    $def(self, '$dummy?', $return_ivar("dummy"));
    
    $def(self, '$binary?', $return_val(false));
    
    $def(self, '$to_s', $return_ivar("name"));
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<Encoding:" + $to_s(self.name) + $to_s(($truthy(self.dummy) ? (" (dummy)") : nil)) + ">"
    });
    
    $def(self, '$bytesize', function $$bytesize(str, index) {
      
      return $Kernel.$raise($$$('NotImplementedError'))
    });
    
    $def(self, '$byteslice', function $$byteslice(str, index, length) {
      
      return $Kernel.$raise($$$('NotImplementedError'))
    });
    
    $def(self, '$each_byte', function $$each_byte(str) {
      
      return $Kernel.$raise($$$('NotImplementedError'))
    });
    
    $def(self, '$scrub', function $$scrub(str, replacement) {
      var block = $$scrub.$$p || nil;

      $$scrub.$$p = null;
      
      ;
      return $Kernel.$raise($$$('NotImplementedError'));
    });
    
    $def(self, '$valid_encoding?', function $Encoding_valid_encoding$ques$2(str) {
      
      return $Kernel.$raise($$$('NotImplementedError'))
    });
    $klass('::', $$$('StandardError'), 'EncodingError');
    $klass('::', $$$('EncodingError'), 'CompatibilityError');
    return ($klass($nesting[0], $$$('EncodingError'), 'UndefinedConversionError'), nil);
  })('::', null, $nesting);
  
  const SFCP = String.fromCodePoint;
  const SFCC = String.fromCharCode;

  function scrubbing_decoder(enc, label) {
    if (!enc.scrubbing_decoder) enc.scrubbing_decoder = new TextDecoder(label, { fatal: false });
    return enc.scrubbing_decoder;
  }

  function validating_decoder(enc, label) {
    if (!enc.validating_decoder) enc.validating_decoder = new TextDecoder(label, { fatal: true });
    return enc.validating_decoder;
  }
;
  $send($$$('Encoding'), 'register', ["UTF-8", $hash_new("aliases", ["CP65001"], "ascii", true)], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

    
    
    $def(self, '$bytesize', function $$bytesize(str, index) {
      
      
      let code_point, size = 0;
      for (const c of str) {
        code_point = c.codePointAt(0);
        if (code_point < 0x80) size++; // char is one byte long in UTF-8
        else if (code_point < 0x800) size += 2; // char is two bytes long
        // else if (code_point < 0xD800) size += 3; // char is three bytes long
        // else if (code_point < 0xE000) size += 3; // for lone surrogates the 0xBD 0xBF 0xEF, 3 bytes, get inserted
        else if (code_point < 0x10000) size += 3; // char is three bytes long
        else if (code_point <= 0x110000) size += 4; // char is four bytes long
        if (index-- <= 0) break;
      }
      return size;
    
    });
    
    $def(self, '$byteslice', function $$byteslice(str, index, length) {
      
      
      let result = "", code_point, idx, max;
      if (index < 0) {
        // negative index, walk from the end of the string,
        let i = str.length - 1,
            bad_cp = -1; // -1 = no, string ok, 0 or larger = the code point
        idx = -1;
        if (length < 0) max = length; // a negative index
        else if (length === 0) max = index;
        else if ((index + length) >= 0) max = -1; // from end of string
        else max = index + length - 1;
        for (; i >= 0; i--) {
          code_point = str.codePointAt(i);
          if (code_point >= 0xD800 && code_point <= 0xDFFF) {
            // low surrogate, get the full code_point next
            continue;
          }
          if (length >= 0 || length === -1 || (length < 0 && idx <= length)) {
            if (code_point < 0x80) {
              if (idx >= index && idx <= max) result = SFCP(code_point) + result;
              idx--;
              // always landing on character boundary, no need to check
            } else if (code_point < 0x800) {
              // 2 byte surrogates
              if (idx >= index && idx <= max) result = SFCP(code_point) + result;
              idx -= 2;
              // check for broken character boundary, raise if so
            // } else if (code_point < 0xD800) {
            //  // 3 byte surrogates
            //  if (idx >= index && idx <= max) result = SFCP(code_point) + result;
            //  idx -= 3;
            } else if (code_point < 0x10000) {
              // 3 byte surrogates
              if (idx >= index && idx <= max) result = SFCP(code_point) + result;
              idx -= 3;
            } else if (code_point < 0x110000) {
              // 4 byte surrogates
              if (idx >= index && idx <= max) result = SFCP(code_point) + result;
              idx -= 3;
            }
          }
          if (idx < index) break;
        }
        if (idx > index || result.length === 0) return nil;
      } else {
        // 0 or positive index, walk from beginning
        idx = 0;
        if (length < 0) max = Infinity; // to end of string
        else if (length === 0) max = index + 1;
        else max = index + length;
        for (const c of str) {
          code_point = c.codePointAt(0);
          if (code_point < 0x80) {
            if (idx >= index && idx <= max) result += SFCP(code_point);
            idx++;
          } else if (code_point < 0x800) {
            // 2 byte surrogates
            if (idx >= index && idx <= max) result += SFCP(code_point);
            idx += 2;
          } else if (code_point < 0xD800) {
            // 3 byte surrogates
            if (idx >= index && idx <= max) result += SFCP(code_point);
            idx += 3;
          } else if (code_point < 0xE000) {
            if (idx >= index && idx <= max) result += SFCP(0xEF); idx++;
            if (idx >= index && idx <= max) result += SFCP(0xBF); idx++;
            if (idx >= index && idx <= max) result += SFCP(0xBD); idx++;
          } else if (code_point < 0x10000) {
            // 3 byte surrogates
            if (idx >= index && idx <= max) result += SFCP(code_point);
            idx += 3;
          } else if (code_point < 0x110000) {
            // 4 byte surrogates
            if (idx >= index && idx <= max) result += SFCP(code_point);
            idx += 4;
          }
          if (idx >= max) break;
        }
        if (result.length === 0) {
          if (idx === index) result = "";
          else return nil;
        }
        if (length < 0) {
          // if length is a negative index from a range, we walked to the end,
          // so shorten the result accordingly
          // result has the bytes already spread out as chars so we can simply slice
          if ((idx + length) > 0) result = result.slice(0, result.length + length);
          else result = "";
        }
      }
      if (length === 0) result = "";
      return result;
    
    });
    
    $def(self, '$each_byte', function $$each_byte(str) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      let units = Infinity,
          code_point,
          length = str.length;
      for (const c of str) {
        code_point = c.codePointAt(0);
        if (code_point < 0x80) {
          Opal.yield1(block, code_point);
        } else if (code_point < 0x800) {
          Opal.yield1(block, code_point >> 0x6 | 0xC0);
          Opal.yield1(block, code_point & 0x3F | 0x80);
        } else if (code_point < 0xD800) {
          Opal.yield1(block, code_point >> 0xC | 0xE0);
          Opal.yield1(block, code_point >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, code_point & 0x3F | 0x80);
        } else if (code_point < 0xE000) {
          Opal.yield1(block, 0xEF);
          Opal.yield1(block, 0xBF);
          Opal.yield1(block, 0xBD);
        } else if (code_point < 0x10000) {
          Opal.yield1(block, code_point >> 0xC | 0xE0);
          Opal.yield1(block, code_point >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, code_point & 0x3F | 0x80);
        } else if (code_point < 0x110000) {
          Opal.yield1(block, code_point >> 0x12 | 0xF0);
          Opal.yield1(block, code_point >> 0xC & 0x3F | 0x80);
          Opal.yield1(block, code_point >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, code_point & 0x3F | 0x80);
        }
      }
    ;
    });
    
    $def(self, '$scrub', function $$scrub(str, replacement) {
      var block = $$scrub.$$p || nil, self = this;

      $$scrub.$$p = null;
      
      ;
      
      let result = scrubbing_decoder(self, 'utf-8').decode(new Uint8Array(str.$bytes()));
      if (block !== nil) {
        // dont know the bytes anymore ... ¯\_(ツ)_/¯
        result = result.replace(/�/g, (byte)=>{ return Opal.yield1(block, byte); });
      } else if (replacement && replacement !== nil) {
        // this may replace valid � that have existed in the string before,
        // but there currently is no way to specify a other replacement character for TextDecoder
        result = result.replace(/�/g, replacement);
      }
      return result.$force_encoding(self);
    ;
    });
    return $def(self, '$valid_encoding?', function $valid_encoding$ques$4(str) {
      var self = this;

      
      try { validating_decoder(self, 'utf-8').decode(new Uint8Array(str.$bytes())); }
      catch { return false; }
      return true;
    
    });}, {$$s: self});
  $send($$$('Encoding'), 'register', ["UTF-16LE", $hash_new("aliases", ["UTF-16"])], function $$5(){var self = $$5.$$s == null ? this : $$5.$$s;

    
    
    $def(self, '$bytesize', function $$bytesize(str, index) {
      
      
      if (index < str.length) return (index + 1) * 2;
      return str.length * 2;
    
    });
    
    $def(self, '$byteslice', function $$byteslice(str, index, length) {
      
      
      let result = "", char_code, idx, max, i;
      if (index < 0) {
        // negative index, walk from the end of the string,
        idx = -1;
        if (length < 0) max = length; // a negative index
        else if (length === 0) max = index;
        else if ((index + length) >= 0) max = -1; // from end of string
        else max = index + length - 1;
        for (i = str.length; i > 0; i--) {
          char_code = str.charCodeAt(i);
          if (length >= 0 || length === -1 || (length < 0 && idx <= length)) {
            if (idx >= index && idx <= max) result = SFCC(char_code) + result;
          }
          idx -= 2;
          if (idx < index) break;
        }
        if (idx > index || result.length === 0) return nil;
      } else {
        // 0 or positive index, walk from beginning
        idx = 0;
        if (length < 0) max = Infinity;
        else if (length === 0) max = index + 1;
        else max = index + length;
        for (i = 0, length = str.length; i < length; i++) {
          char_code = str.charCodeAt(i);
          if (idx >= index && idx <= max) result += SFCC(char_code);
          idx += 2;
          if (idx >= max) break;
        }
        if (result.length === 0) {
          if (idx === index) result = "";
          else return nil;
        }
        if (length < 0) {
          // if length is a negative index from a range, we walked to the end, so shorten the result
          if ((idx + length) > 0) result = result.slice(0, result.length + length);
          else result = "";
        }
      }
      if (length === 0) result = "";
      return result;
    
    });
    
    $def(self, '$each_byte', function $$each_byte(str) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      for (let i = 0, length = str.length; i < length; i++) {
        let char_code = str.charCodeAt(i);

        Opal.yield1(block, char_code & 0xff);
        Opal.yield1(block, char_code >> 8);
      }
    ;
    });
    
    $def(self, '$scrub', function $$scrub(str, replacement) {
      var block = $$scrub.$$p || nil, self = this;

      $$scrub.$$p = null;
      
      ;
      
      let result = scrubbing_decoder(self, 'utf-16').decode(new Uint8Array(str.$bytes()));
      if (block !== nil) {
        // dont know the bytes anymore ... ¯\_(ツ)_/¯
        result = result.replace(/�/g, (byte)=>{ return Opal.yield1(block, byte); });
      } else if (replacement && replacement !== nil) {
        // this may replace valid � that have existed in the string before,
        // but there currently is no way to specify a other replacement character for TextDecoder
        result = result.replace(/�/g, replacement);
      }
      return result.$force_encoding(self);
    ;
    });
    return $def(self, '$valid_encoding?', function $valid_encoding$ques$6(str) {
      var self = this;

      
      try { validating_decoder(self, 'utf-16').decode(new Uint8Array(str.$bytes())); }
      catch { return false; }
      return true;
    
    });}, {$$s: self});
  $send($$$('Encoding'), 'register', ["UTF-16BE", $hash_new("inherits", $$$($$$('Encoding'), 'UTF_16LE'))], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s;

    
    
    $def(self, '$each_byte', function $$each_byte(str) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      for (var i = 0, length = str.length; i < length; i++) {
        var char_code = str.charCodeAt(i);
        Opal.yield1(block, char_code >> 8);
        Opal.yield1(block, char_code & 0xff);
      }
    ;
    });
    
    $def(self, '$scrub', function $$scrub(str, replacement) {
      var block = $$scrub.$$p || nil, self = this;

      $$scrub.$$p = null;
      
      ;
      
      let result = scrubbing_decoder(self, 'utf-16be').decode(new Uint8Array(str.$bytes()));
      if (block !== nil) {
        // dont know the bytes anymore ... ¯\_(ツ)_/¯
        result = result.replace(/�/g, (byte)=>{ return Opal.yield1(block, byte); });
      } else if (replacement && replacement !== nil) {
        // this may replace valid � that have existed in the string before,
        // but there currently is no way to specify a other replacement character for TextDecoder
        result = result.replace(/�/g, replacement);
      }
      return result.$force_encoding(self);
    ;
    });
    return $def(self, '$valid_encoding?', function $valid_encoding$ques$8(str) {
      var self = this;

      
      try { validating_decoder(self, 'utf-16be').decode(new Uint8Array(str.$bytes())); }
      catch { return false; }
      return true;
    
    });}, {$$s: self});
  $send($$$('Encoding'), 'register', ["UTF-32LE"], function $$9(){var self = $$9.$$s == null ? this : $$9.$$s;

    
    
    $def(self, '$bytesize', function $$bytesize(str, index) {
      
      
      if (index < str.length) return (index + 1) * 4;
      return str.length * 4;
    
    });
    
    $def(self, '$byteslice', function $$byteslice(str, index, length) {
      
      
      let result = "", char_code, idx, max, i;
      if (index < 0) {
        // negative index, walk from the end of the string,
        idx = -1;
        if (length < 0) max = length; // a negative index
        else if (length === 0) max = index;
        else if ((index + length) >= 0) max = -1; // from end of string
        else max = index + length - 1;
        for (i = str.length; i > 0; i--) {
          char_code = str.charCodeAt(i);
          if (length > 0 || length === -1 || (length < 0 && idx <= length)) {
            if (idx >= index && idx <= max) result = SFCC(char_code) + result;
          }
          idx -= 4;
          if (idx < index) break;
        }
        if (idx > index || result.length === 0) return nil;
      } else {
        // 0 or positive index, walk from beginning
        idx = 0;
        if (length < 0) max = Infinity;
        else if (length === 0) max = index + 1;
        else max = index + length;
        for (let i = 0, length = str.length; i < length; i++) {
          char_code = str.charCodeAt(i);
          if (idx >= index && idx <= max) result += SFCC(char_code);
          idx += 4;
          if (idx >= max) break;
        }
        if (result.length === 0) {
          if (idx === index) result = "";
          else return nil;
        }
        if (length < 0) {
          // if length is a negative index from a range, we walked to the end, so shorten the result
          if ((idx + length) > 0) result = result.slice(0, result.length + length);
          else result = "";
        }
      }
      if (length === 0) result = "";
      return result;
    
    });
    
    $def(self, '$each_byte', function $$each_byte(str) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      for (var i = 0, length = str.length; i < length; i++) {
        var char_code = str.charCodeAt(i);

        Opal.yield1(block, char_code & 0xff);
        Opal.yield1(block, char_code >> 8);
        Opal.yield1(block, 0);
        Opal.yield1(block, 0);
      }
    ;
    });
    
    $def(self, '$scrub', function $$scrub(str, replacement) {
      var block = $$scrub.$$p || nil;

      $$scrub.$$p = null;
      
      ;
      return str;
    });
    return $def(self, '$valid_encoding?', $return_val(true));}, {$$s: self});
  $send($$$('Encoding'), 'register', ["UTF-32BE", $hash_new("inherits", $$$($$$('Encoding'), 'UTF_32LE'))], function $$10(){var self = $$10.$$s == null ? this : $$10.$$s;

    return $def(self, '$each_byte', function $$each_byte(str) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      for (var i = 0, length = str.length; i < length; i++) {
        var char_code = str.charCodeAt(i);
        Opal.yield1(block, 0);
        Opal.yield1(block, 0);
        Opal.yield1(block, char_code >> 8);
        Opal.yield1(block, char_code & 0xff);
      }
    ;
    })}, {$$s: self});
  $send($$$('Encoding'), 'register', ["ASCII-8BIT", $hash_new("aliases", ["BINARY"], "ascii", true)], function $$11(){var self = $$11.$$s == null ? this : $$11.$$s;

    
    
    $def(self, '$binary?', $return_val(true));
    
    $def(self, '$bytesize', function $$bytesize(str, index) {
      
      
      if (index < str.size) return index + 1;
      return str.length;
    
    });
    
    $def(self, '$byteslice', function $$byteslice(str, index, length) {
      
      
      let result = "", char_code, i;
      if (index < 0) index = str.length + index;
      if (index < 0) return nil;
      if (length < 0) length = (str.length + length) - index;
      if (length < 0) return nil;
      // must produce the same result as each_byte, so we cannot simply use slice()
      for (i = 0; i < length && (index + i) <= str.length; i++) {
        char_code = str.charCodeAt(index + i);
        result = SFCC(char_code & 0xff) + result;
      }
      if (result.length === 0) return nil;
      return result;
    
    });
    
    $def(self, '$each_byte', function $$each_byte(str) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      for (let i = 0, length = str.length; i < length; i++) {
        let char_code = str.charCodeAt(i);
        Opal.yield1(block, char_code & 0xff);
      }
    ;
    });
    
    $def(self, '$scrub', function $$scrub(str, replacement) {
      var block = $$scrub.$$p || nil, self = this;

      $$scrub.$$p = null;
      
      ;
      
      let result = scrubbing_decoder(self, 'ascii').decode(new Uint8Array(str.$bytes()));
      if (block !== nil) {
        // dont know all the bytes anymore ... ¯\_(ツ)_/¯
        result = result.replace(/[�\x80-\xff]/g, (byte)=>{ return Opal.yield1(block, byte); });
      } else if (replacement && replacement !== nil) {
        // this may replace valid � that have existed in the string before,
        // but there currently is no way to specify a other replacement character for TextDecoder
        result = result.replace(/[�\x80-\xff]/g, replacement);
      } else {
        result = result.replace(/[�\x80-\xff]/g, '?');
      }
      return result.$force_encoding(self);
    ;
    });
    return $def(self, '$valid_encoding?', function $valid_encoding$ques$12(str) {
      var self = this;

      
      try { validating_decoder(self, 'ascii').decode(new Uint8Array(str.$bytes())); }
      catch { return false; }
      return true;
    
    });}, {$$s: self});
  $$$('Encoding').$register("ISO-8859-1", $hash_new("aliases", ["ISO8859-1"], "ascii", true, "inherits", $$$($$$('Encoding'), 'ASCII_8BIT')));
  $$$('Encoding').$register("US-ASCII", $hash_new("aliases", ["ASCII"], "ascii", true, "inherits", $$$($$$('Encoding'), 'ASCII_8BIT')));
  $$$('Encoding').$register("EUC-JP", $hash_new("inherits", $$$($$$('Encoding'), 'UTF_16LE'), "dummy", true));
  $$$('Encoding').$register("IBM437", $hash_new("inherits", $$$($$$('Encoding'), 'UTF_16LE'), "dummy", true));
  $$$('Encoding').$register("IBM720", $hash_new("inherits", $$$($$$('Encoding'), 'UTF_16LE'), "dummy", true));
  $$$('Encoding').$register("ISO-2022-JP", $hash_new("inherits", $$$($$$('Encoding'), 'UTF_16LE'), "dummy", true));
  $$$('Encoding').$register("ISO-8859-15", $hash_new("inherits", $$$($$$('Encoding'), 'UTF_16LE'), "dummy", true));
  $$$('Encoding').$register("ISO-8859-5", $hash_new("inherits", $$$($$$('Encoding'), 'UTF_16LE'), "dummy", true));
  $$$('Encoding').$register("Shift_JIS", $hash_new("aliases", ["SHIFT_JIS"], "inherits", $$$($$$('Encoding'), 'UTF_16LE'), "dummy", true));
  $$$('Encoding').$register("Windows-1251", $hash_new("aliases", ["WINDOWS-1251"], "inherits", $$$($$$('Encoding'), 'UTF_16LE'), "dummy", true));
  $$$('Encoding')['$default_external=']($$$($$('Encoding'), 'UTF_8'));
  $$$('Encoding')['$default_internal=']($$$($$('Encoding'), 'UTF_8'));
  Opal.prop(String.prototype, 'encoding', $$$($$$('Encoding'), 'UTF_8'));
  return Opal.prop(String.prototype, 'internal_encoding', $$$($$$('Encoding'), 'UTF_8'));
};

Opal.modules["corelib/io"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  var $klass = Opal.klass, $const_set = Opal.const_set, $not = Opal.not, $annotate_regexp = Opal.annotate_regexp, $truthy = Opal.truthy, $def = Opal.def, $return_ivar = Opal.return_ivar, $return_val = Opal.return_val, $slice = Opal.slice, $Kernel = Opal.Kernel, $gvars = Opal.gvars, $send = Opal.send, $to_a = Opal.to_a, $rb_plus = Opal.rb_plus, $neqeq = Opal.neqeq, $range = Opal.range, $eqeq = Opal.eqeq, $to_ary = Opal.to_ary, $rb_gt = Opal.rb_gt, $assign_ivar_val = Opal.assign_ivar_val, $alias = Opal.alias, $a, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_reader,attr_accessor,!,match?,include?,size,write,String,flatten,puts,sysread_noraise,+,!=,[],ord,getc,readchar,raise,gets,==,to_str,length,split,sub,sysread,>,to_a,each_line,enum_for,getbyte,closed_write?,closed_read?,each,eof,new,write_proc=,read_proc=');
  
  (function($base, $super) {
    var self = $klass($base, $super, 'IO');

    var $proto = self.$$prototype;

    $proto.read_buffer = $proto.closed = nil;
    
    $const_set(self, 'SEEK_SET', 0);
    $const_set(self, 'SEEK_CUR', 1);
    $const_set(self, 'SEEK_END', 2);
    $const_set(self, 'SEEK_DATA', 3);
    $const_set(self, 'SEEK_HOLE', 4);
    $const_set(self, 'READABLE', 1);
    $const_set(self, 'WRITABLE', 4);
    self.$attr_reader("eof");
    self.$attr_accessor("read_proc", "sync", "tty", "write_proc");
    
    $def(self, '$initialize', function $$initialize(fd, flags) {
      var self = this;

      
      if (flags == null) flags = "r";
      self.fd = fd;
      self.flags = flags;
      self.eof = false;
      if (($truthy(flags['$include?']("r")) && ($not(flags['$match?']($annotate_regexp(/[wa+]/u, null, "")))))) {
        return (self.closed = "write")
      } else if (($truthy(flags['$match?']($annotate_regexp(/[wa]/u, null, ""))) && ($not(flags['$match?']($annotate_regexp(/[r+]/u, null, "")))))) {
        return (self.closed = "read")
      } else {
        return nil
      };
    }, -2);
    
    $def(self, '$fileno', $return_ivar("fd"));
    
    $def(self, '$tty?', function $IO_tty$ques$1() {
      var self = this;

      return self.tty == true;
    });
    
    $def(self, '$write', function $$write(string) {
      var self = this;

      
      self.write_proc(string);
      return string.$size();
    });
    
    $def(self, '$flush', $return_val(nil));
    
    $def(self, '$<<', function $IO_$lt$lt$2(string) {
      var self = this;

      
      self.$write(string);
      return self;
    });
    
    $def(self, '$print', function $$print($a) {
      var $post_args, args, self = this;
      if ($gvars[","] == null) $gvars[","] = nil;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      for (var i = 0, ii = args.length; i < ii; i++) {
        args[i] = $Kernel.$String(args[i])
      }
      self.$write(args.join($gvars[","]));
    ;
      return nil;
    }, -1);
    
    $def(self, '$puts', function $$puts($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      var line
      if (args.length === 0) {
        self.$write("\n");
        return nil;
      } else {
        for (var i = 0, ii = args.length; i < ii; i++) {
          if (args[i].$$is_array){
            var ary = (args[i]).$flatten()
            if (ary.length > 0) $send(self, 'puts', $to_a((ary)))
          } else {
            if (args[i].$$is_string) {
              line = args[i].valueOf();
            } else {
              line = $Kernel.$String(args[i]);
            }
            if (!line.endsWith("\n")) line += "\n"
            self.$write(line)
          }
        }
      }
    ;
      return nil;
    }, -1);
    
    $def(self, '$getc', function $$getc() {
      var self = this, $ret_or_1 = nil, parts = nil, ret = nil;

      
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      parts = "";
      do {
      
        self.read_buffer = $rb_plus(self.read_buffer, parts);
        if ($neqeq(self.read_buffer, "")) {
          
          ret = self.read_buffer['$[]'](0);
          self.read_buffer = self.read_buffer['$[]']($range(1, -1, false));
          return ret;
        };
      } while ($truthy((parts = self.$sysread_noraise(1))));;
      return nil;
    });
    
    $def(self, '$getbyte', function $$getbyte() {
      var $a, self = this;

      return ($a = self.$getc(), ($a === nil || $a == null) ? nil : $a.$ord())
    });
    
    $def(self, '$readbyte', function $$readbyte() {
      var self = this;

      return self.$readchar().$ord()
    });
    
    $def(self, '$readchar', function $$readchar() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.$getc()))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('EOFError'), "end of file reached")
      }
    });
    
    $def(self, '$readline', function $$readline($a) {
      var $post_args, args, self = this, $ret_or_1 = nil;

      
      $post_args = $slice(arguments);
      args = $post_args;
      if ($truthy(($ret_or_1 = $send(self, 'gets', $to_a(args))))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('EOFError'), "end of file reached")
      };
    }, -1);
    
    $def(self, '$gets', function $$gets(sep, limit, opts) {
      var $a, $b, self = this, orig_sep = nil, $ret_or_1 = nil, seplen = nil, data = nil, ret = nil, orig_buffer = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      if (sep == null) sep = false;
      if (limit == null) limit = nil;
      if (opts == null) opts = (new Map());
      if (($truthy(sep.$$is_number) && ($not(limit)))) {
        $a = [false, sep, limit], (sep = $a[0]), (limit = $a[1]), (opts = $a[2]), $a
      };
      if ((($truthy(sep.$$is_hash) && ($not(limit))) && ($eqeq(opts, (new Map()))))) {
        $a = [false, nil, sep], (sep = $a[0]), (limit = $a[1]), (opts = $a[2]), $a
      } else if (($truthy(limit.$$is_hash) && ($eqeq(opts, (new Map()))))) {
        $a = [sep, nil, limit], (sep = $a[0]), (limit = $a[1]), (opts = $a[2]), $a
      };
      orig_sep = sep;
      if ($eqeq(sep, false)) {
        sep = $gvars["/"]
      };
      if ($eqeq(sep, "")) {
        sep = $annotate_regexp(/\r?\n\r?\n/u, null, "")
      };
      sep = ($truthy(($ret_or_1 = sep)) ? ($ret_or_1) : (""));
      if (!$eqeq(orig_sep, "")) {
        sep = sep.$to_str()
      };
      seplen = ($eqeq(orig_sep, "") ? (2) : (sep.$length()));
      if ($eqeq(sep, " ")) {
        sep = $annotate_regexp(/ /u, null, "")
      };
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      data = "";
      ret = nil;
      do {
      
        self.read_buffer = $rb_plus(self.read_buffer, data);
        if (($neqeq(sep, "") && ($truthy(($truthy(sep.$$is_regexp) ? (self.read_buffer['$match?'](sep)) : (self.read_buffer['$include?'](sep))))))) {
          
          orig_buffer = self.read_buffer;
          $b = self.read_buffer.$split(sep, 2), $a = $to_ary($b), (ret = ($a[0] == null ? nil : $a[0])), (self.read_buffer = ($a[1] == null ? nil : $a[1])), $b;
          if ($neqeq(ret, orig_buffer)) {
            ret = $rb_plus(ret, orig_buffer['$[]'](ret.$length(), seplen))
          };
          break;
        };
      } while ($truthy((data = self.$sysread_noraise(($eqeq(sep, "") ? (65536) : (1))))));;
      if (!$truthy(ret)) {
        
        $a = [($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : ("")), ""], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
        if ($eqeq(ret, "")) {
          ret = nil
        };
      };
      if ($truthy(ret)) {
        
        if ($truthy(limit)) {
          
          ret = ret['$[]'](Opal.Range.$new(0,limit, true));
          self.read_buffer = $rb_plus(ret['$[]'](Opal.Range.$new(limit, -1, false)), self.read_buffer);
        };
        if ($truthy(opts['$[]']("chomp"))) {
          ret = ret.$sub($annotate_regexp(/\r?\n$/u, "\\r?\\n\\z", ""), "")
        };
        if ($eqeq(orig_sep, "")) {
          ret = ret.$sub($annotate_regexp(/^[\r\n]+/u, "\\A[\\r\\n]+", ""), "")
        };
      };
      if ($eqeq(orig_sep, false)) {
        $gvars._ = ret
      };
      return ret;
    }, -1);
    
    $def(self, '$sysread', function $$sysread(integer) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.read_proc(integer)))) {
        return $ret_or_1
      } else {
        
        self.eof = true;
        return $Kernel.$raise($$$('EOFError'), "end of file reached");
      }
    });
    
    $def(self, '$sysread_noraise', function $$sysread_noraise(integer) {
      var self = this;

      try {
        return self.$sysread(integer)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('EOFError')])) {
          try {
            return nil
          } finally { Opal.pop_exception($err); }
        } else { throw $err; }
      }
    });
    
    $def(self, '$readpartial', function $$readpartial(integer) {
      var $a, self = this, $ret_or_1 = nil, part = nil, ret = nil;

      
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      part = self.$sysread(integer);
      $a = [$rb_plus(self.read_buffer, ($truthy(($ret_or_1 = part)) ? ($ret_or_1) : (""))), ""], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
      if ($eqeq(ret, "")) {
        ret = nil
      };
      return ret;
    });
    
    $def(self, '$read', function $$read(integer) {
      var $a, self = this, $ret_or_1 = nil, parts = nil, ret = nil;

      
      if (integer == null) integer = nil;
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      parts = "";
      ret = nil;
      do {
      
        self.read_buffer = $rb_plus(self.read_buffer, parts);
        if (($truthy(integer) && ($truthy($rb_gt(self.read_buffer.$length(), integer))))) {
          
          $a = [self.read_buffer['$[]'](Opal.Range.$new(0,integer, true)), self.read_buffer['$[]'](Opal.Range.$new(integer, -1, false))], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
          return ret;
        };
      } while ($truthy((parts = self.$sysread_noraise(($truthy(($ret_or_1 = integer)) ? ($ret_or_1) : (65536))))));;
      $a = [self.read_buffer, ""], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
      return ret;
    }, -1);
    
    $def(self, '$readlines', function $$readlines(separator) {
      var self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      if (separator == null) separator = $gvars["/"];
      return self.$each_line(separator).$to_a();
    }, -1);
    
    $def(self, '$each', function $$each($a, $b) {
      var block = $$each.$$p || nil, $post_args, sep, args, self = this, s = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      $$each.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      
      if ($post_args.length > 0) sep = $post_args.shift();if (sep == null) sep = $gvars["/"];
      args = $post_args;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each", sep].concat($to_a(args)))
      };
      while ($truthy((s = $send(self, 'gets', [sep].concat($to_a(args)))))) {
      Opal.yield1(block, s)
      };
      return self;
    }, -1);
    
    $def(self, '$each_byte', function $$each_byte() {
      var block = $$each_byte.$$p || nil, self = this, s = nil;

      $$each_byte.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("each_byte")
      };
      while ($truthy((s = self.$getbyte()))) {
      Opal.yield1(block, s)
      };
      return self;
    });
    
    $def(self, '$each_char', function $$each_char() {
      var block = $$each_char.$$p || nil, self = this, s = nil;

      $$each_char.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("each_char")
      };
      while ($truthy((s = self.$getc()))) {
      Opal.yield1(block, s)
      };
      return self;
    });
    
    $def(self, '$close', $assign_ivar_val("closed", "both"));
    
    $def(self, '$close_read', function $$close_read() {
      var self = this;

      if ($eqeq(self.closed, "write")) {
        return (self.closed = "both")
      } else {
        return (self.closed = "read")
      }
    });
    
    $def(self, '$close_write', function $$close_write() {
      var self = this;

      if ($eqeq(self.closed, "read")) {
        return (self.closed = "both")
      } else {
        return (self.closed = "write")
      }
    });
    
    $def(self, '$closed?', function $IO_closed$ques$3() {
      var self = this;

      return self.closed['$==']("both")
    });
    
    $def(self, '$closed_read?', function $IO_closed_read$ques$4() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.closed['$==']("read")))) {
        return $ret_or_1
      } else {
        return self.closed['$==']("both")
      }
    });
    
    $def(self, '$closed_write?', function $IO_closed_write$ques$5() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.closed['$==']("write")))) {
        return $ret_or_1
      } else {
        return self.closed['$==']("both")
      }
    });
    
    $def(self, '$check_writable', function $$check_writable() {
      var self = this;

      if ($truthy(self['$closed_write?']())) {
        return $Kernel.$raise($$$('IOError'), "not opened for writing")
      } else {
        return nil
      }
    });
    
    $def(self, '$check_readable', function $$check_readable() {
      var self = this;

      if ($truthy(self['$closed_read?']())) {
        return $Kernel.$raise($$$('IOError'), "not opened for reading")
      } else {
        return nil
      }
    });
    $alias(self, "each_line", "each");
    return $alias(self, "eof?", "eof");
  })('::', null);
  $const_set('::', 'STDIN', ($gvars.stdin = $$$('IO').$new(0, "r")));
  $const_set('::', 'STDOUT', ($gvars.stdout = $$$('IO').$new(1, "w")));
  $const_set('::', 'STDERR', ($gvars.stderr = $$$('IO').$new(2, "w")));
  var console = Opal.global.console;
  $$$('STDOUT')['$write_proc='](typeof(process) === 'object' && typeof(process.stdout) === 'object' ? function(s){process.stdout.write(s)} : function(s){console.log(s)});
  $$$('STDERR')['$write_proc='](typeof(process) === 'object' && typeof(process.stderr) === 'object' ? function(s){process.stderr.write(s)} : function(s){console.warn(s)});
  return ($a = [function(s) { var p = prompt(); if (p !== null) return p + "\n"; return nil; }], $send($$$('STDIN'), 'read_proc=', $a), $a[$a.length - 1]);
};

Opal.modules["opal/mini"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  var $Object = Opal.Object, nil = Opal.nil;

  Opal.add_stubs('require');
  
  $Object.$require("opal/base");
  $Object.$require("corelib/nil");
  $Object.$require("corelib/boolean");
  $Object.$require("corelib/comparable");
  $Object.$require("corelib/regexp");
  $Object.$require("corelib/string");
  $Object.$require("corelib/string/mutable");
  $Object.$require("corelib/enumerable");
  $Object.$require("corelib/enumerator");
  $Object.$require("corelib/array");
  $Object.$require("corelib/hash");
  $Object.$require("corelib/number");
  $Object.$require("corelib/range");
  $Object.$require("corelib/proc");
  $Object.$require("corelib/method");
  $Object.$require("opal/regexp_transpiler");
  $Object.$require("opal/regexp_anchors");
  $Object.$require("corelib/variables");
  $Object.$require("corelib/string/encoding");
  return $Object.$require("corelib/io");
};

Opal.modules["corelib/kernel/format"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  var $coerce_to = Opal.coerce_to, $module = Opal.module, $slice = Opal.slice, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $Opal = Opal.Opal, $Kernel = Opal.Kernel, $to_s = Opal.to_s, $gvars = Opal.gvars, $def = Opal.def, $alias = Opal.alias, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('respond_to?,[],==,length,coerce_to?,nil?,to_a,raise,to_int,fetch,Integer,Float,to_ary,to_str,inspect,to_s,format');
  return (function($base) {
    var self = $module($base, 'Kernel');

    
    
    
    $def(self, '$format', function $$format(format_string, $a) {
      var $post_args, args, ary = nil;
      if ($gvars.DEBUG == null) $gvars.DEBUG = nil;

      
      $post_args = $slice(arguments, 1);
      args = $post_args;
      if (($eqeq(args.$length(), 1) && ($truthy(args['$[]'](0)['$respond_to?']("to_ary"))))) {
        
        ary = $Opal['$coerce_to?'](args['$[]'](0), $$$('Array'), "to_ary");
        if (!$truthy(ary['$nil?']())) {
          args = ary.$to_a()
        };
      };
      
      var result = '',
          //used for slicing:
          begin_slice = 0,
          end_slice,
          //used for iterating over the format string:
          i,
          len = format_string.length,
          //used for processing field values:
          arg,
          str,
          //used for processing %g and %G fields:
          exponent,
          //used for keeping track of width and precision:
          width,
          precision,
          //used for holding temporary values:
          tmp_num,
          //used for processing %{} and %<> fileds:
          hash_parameter_key,
          closing_brace_char,
          //used for processing %b, %B, %o, %x, and %X fields:
          base_number,
          base_prefix,
          base_neg_zero_regex,
          base_neg_zero_digit,
          //used for processing arguments:
          next_arg,
          seq_arg_num = 1,
          pos_arg_num = 0,
          //used for keeping track of flags:
          flags,
          FNONE  = 0,
          FSHARP = 1,
          FMINUS = 2,
          FPLUS  = 4,
          FZERO  = 8,
          FSPACE = 16,
          FWIDTH = 32,
          FPREC  = 64,
          FPREC0 = 128;

      function CHECK_FOR_FLAGS() {
        if (flags&FWIDTH) { $Kernel.$raise($$$('ArgumentError'), "flag after width") }
        if (flags&FPREC0) { $Kernel.$raise($$$('ArgumentError'), "flag after precision") }
      }

      function CHECK_FOR_WIDTH() {
        if (flags&FWIDTH) { $Kernel.$raise($$$('ArgumentError'), "width given twice") }
        if (flags&FPREC0) { $Kernel.$raise($$$('ArgumentError'), "width after precision") }
      }

      function GET_NTH_ARG(num) {
        if (num >= args.length) { $Kernel.$raise($$$('ArgumentError'), "too few arguments") }
        return args[num];
      }

      function GET_NEXT_ARG() {
        switch (pos_arg_num) {
        case -1: $Kernel.$raise($$$('ArgumentError'), "unnumbered(" + $to_s(seq_arg_num) + ") mixed with numbered") // raise
        case -2: $Kernel.$raise($$$('ArgumentError'), "unnumbered(" + $to_s(seq_arg_num) + ") mixed with named") // raise
        }
        pos_arg_num = seq_arg_num++;
        return GET_NTH_ARG(pos_arg_num - 1);
      }

      function GET_POS_ARG(num) {
        if (pos_arg_num > 0) {
          $Kernel.$raise($$$('ArgumentError'), "numbered(" + $to_s(num) + ") after unnumbered(" + $to_s(pos_arg_num) + ")")
        }
        if (pos_arg_num === -2) {
          $Kernel.$raise($$$('ArgumentError'), "numbered(" + $to_s(num) + ") after named")
        }
        if (num < 1) {
          $Kernel.$raise($$$('ArgumentError'), "invalid index - " + $to_s(num) + "$")
        }
        pos_arg_num = -1;
        return GET_NTH_ARG(num - 1);
      }

      function GET_ARG() {
        return (next_arg === undefined ? GET_NEXT_ARG() : next_arg);
      }

      function READ_NUM(label) {
        var num, str = '';
        for (;; i++) {
          if (i === len) {
            $Kernel.$raise($$$('ArgumentError'), "malformed format string - %*[0-9]")
          }
          if (format_string.charCodeAt(i) < 48 || format_string.charCodeAt(i) > 57) {
            i--;
            num = parseInt(str, 10) || 0;
            if (num > 2147483647) {
              $Kernel.$raise($$$('ArgumentError'), $to_s(label) + " too big")
            }
            return num;
          }
          str += format_string.charAt(i);
        }
      }

      function READ_NUM_AFTER_ASTER(label) {
        var arg, num = READ_NUM(label);
        if (format_string.charAt(i + 1) === '$') {
          i++;
          arg = GET_POS_ARG(num);
        } else {
          arg = GET_NEXT_ARG();
        }
        return (arg).$to_int();
      }

      for (i = format_string.indexOf('%'); i !== -1; i = format_string.indexOf('%', i)) {
        str = undefined;

        flags = FNONE;
        width = -1;
        precision = -1;
        next_arg = undefined;

        end_slice = i;

        i++;

        switch (format_string.charAt(i)) {
        case '%':
          begin_slice = i;
          // no-break
        case '':
        case '\n':
        case '\0':
          i++;
          continue;
        }

        format_sequence: for (; i < len; i++) {
          switch (format_string.charAt(i)) {

          case ' ':
            CHECK_FOR_FLAGS();
            flags |= FSPACE;
            continue format_sequence;

          case '#':
            CHECK_FOR_FLAGS();
            flags |= FSHARP;
            continue format_sequence;

          case '+':
            CHECK_FOR_FLAGS();
            flags |= FPLUS;
            continue format_sequence;

          case '-':
            CHECK_FOR_FLAGS();
            flags |= FMINUS;
            continue format_sequence;

          case '0':
            CHECK_FOR_FLAGS();
            flags |= FZERO;
            continue format_sequence;

          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            tmp_num = READ_NUM('width');
            if (format_string.charAt(i + 1) === '$') {
              if (i + 2 === len) {
                str = '%';
                i++;
                break format_sequence;
              }
              if (next_arg !== undefined) {
                $Kernel.$raise($$$('ArgumentError'), "value given twice - %" + $to_s(tmp_num) + "$")
              }
              next_arg = GET_POS_ARG(tmp_num);
              i++;
            } else {
              CHECK_FOR_WIDTH();
              flags |= FWIDTH;
              width = tmp_num;
            }
            continue format_sequence;

          case '<':
          case '\{':
            closing_brace_char = (format_string.charAt(i) === '<' ? '>' : '\}');
            hash_parameter_key = '';

            i++;

            for (;; i++) {
              if (i === len) {
                $Kernel.$raise($$$('ArgumentError'), "malformed name - unmatched parenthesis")
              }
              if (format_string.charAt(i) === closing_brace_char) {

                if (pos_arg_num > 0) {
                  $Kernel.$raise($$$('ArgumentError'), "named " + $to_s(hash_parameter_key) + " after unnumbered(" + $to_s(pos_arg_num) + ")")
                }
                if (pos_arg_num === -1) {
                  $Kernel.$raise($$$('ArgumentError'), "named " + $to_s(hash_parameter_key) + " after numbered")
                }
                pos_arg_num = -2;

                if (args[0] === undefined || !args[0].$$is_hash) {
                  $Kernel.$raise($$$('ArgumentError'), "one hash required")
                }

                next_arg = (args[0]).$fetch(hash_parameter_key);

                if (closing_brace_char === '>') {
                  continue format_sequence;
                } else {
                  str = next_arg.toString();
                  if (precision !== -1) { str = str.slice(0, precision); }
                  if (flags&FMINUS) {
                    while (str.length < width) { str = str + ' '; }
                  } else {
                    while (str.length < width) { str = ' ' + str; }
                  }
                  break format_sequence;
                }
              }
              hash_parameter_key += format_string.charAt(i);
            }
            // raise

          case '*':
            i++;
            CHECK_FOR_WIDTH();
            flags |= FWIDTH;
            width = READ_NUM_AFTER_ASTER('width');
            if (width < 0) {
              flags |= FMINUS;
              width = -width;
            }
            continue format_sequence;

          case '.':
            if (flags&FPREC0) {
              $Kernel.$raise($$$('ArgumentError'), "precision given twice")
            }
            flags |= FPREC|FPREC0;
            precision = 0;
            i++;
            if (format_string.charAt(i) === '*') {
              i++;
              precision = READ_NUM_AFTER_ASTER('precision');
              if (precision < 0) {
                flags &= ~FPREC;
              }
              continue format_sequence;
            }
            precision = READ_NUM('precision');
            continue format_sequence;

          case 'd':
          case 'i':
          case 'u':
            arg = $Kernel.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              str = (-arg).toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            break format_sequence;

          case 'b':
          case 'B':
          case 'o':
          case 'x':
          case 'X':
            switch (format_string.charAt(i)) {
            case 'b':
            case 'B':
              base_number = 2;
              base_prefix = '0b';
              base_neg_zero_regex = /^1+/;
              base_neg_zero_digit = '1';
              break;
            case 'o':
              base_number = 8;
              base_prefix = '0';
              base_neg_zero_regex = /^3?7+/;
              base_neg_zero_digit = '7';
              break;
            case 'x':
            case 'X':
              base_number = 16;
              base_prefix = '0x';
              base_neg_zero_regex = /^f+/;
              base_neg_zero_digit = 'f';
              break;
            }
            arg = $Kernel.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString(base_number);
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0) - ((flags&FSHARP && arg !== 0) ? base_prefix.length : 0)) { str = '0' + str; }
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (flags&FPLUS || flags&FSPACE) {
                str = (-arg).toString(base_number);
                while (str.length < precision) { str = '0' + str; }
                if (flags&FMINUS) {
                  if (flags&FSHARP) { str = base_prefix + str; }
                  str = '-' + str;
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 1 - (flags&FSHARP ? 2 : 0)) { str = '0' + str; }
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                  } else {
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              } else {
                str = (arg >>> 0).toString(base_number).replace(base_neg_zero_regex, base_neg_zero_digit);
                while (str.length < precision - 2) { str = base_neg_zero_digit + str; }
                if (flags&FMINUS) {
                  str = '..' + str;
                  if (flags&FSHARP) { str = base_prefix + str; }
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 2 - (flags&FSHARP ? base_prefix.length : 0)) { str = base_neg_zero_digit + str; }
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                  } else {
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase()) {
              str = str.toUpperCase();
            }
            break format_sequence;

          case 'f':
          case 'e':
          case 'E':
          case 'g':
          case 'G':
            arg = $Kernel.$Float(GET_ARG());
            if (arg >= 0 || isNaN(arg)) {
              if (arg === Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = arg.toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = arg.toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = arg.toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = arg.toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== Infinity && !isNaN(arg)) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (arg === -Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = (-arg).toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = (-arg).toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = (-arg).toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = (-arg).toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== -Infinity) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase() && arg !== Infinity && arg !== -Infinity && !isNaN(arg)) {
              str = str.toUpperCase();
            }
            str = str.replace(/([eE][-+]?)([0-9])$/, '$10$2');
            break format_sequence;

          case 'a':
          case 'A':
            // Not implemented because there are no specs for this field type.
            $Kernel.$raise($$$('NotImplementedError'), "`A` and `a` format field types are not implemented in Opal yet")
            // raise

          case 'c':
            arg = GET_ARG();
            if ((arg)['$respond_to?']("to_ary")) { arg = (arg).$to_ary()[0]; }
            if ((arg)['$respond_to?']("to_str")) {
              str = (arg).$to_str();
            } else {
              str = String.fromCharCode($coerce_to(arg, $$$('Integer'), 'to_int'));
            }
            if (str.length !== 1) {
              $Kernel.$raise($$$('ArgumentError'), "%c requires a character")
            }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 'p':
            str = (GET_ARG()).$inspect();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 's':
            str = (GET_ARG()).$to_s();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          default:
            $Kernel.$raise($$$('ArgumentError'), "malformed format string - %" + $to_s(format_string.charAt(i)))
          }
        }

        if (str === undefined) {
          $Kernel.$raise($$$('ArgumentError'), "malformed format string - %")
        }

        result += format_string.slice(begin_slice, end_slice) + str;
        begin_slice = i + 1;
      }

      if ($gvars.DEBUG && pos_arg_num >= 0 && seq_arg_num < args.length) {
        $Kernel.$raise($$$('ArgumentError'), "too many arguments for format string")
      }

      return result + format_string.slice(begin_slice);
    ;
    }, -2);
    return $alias(self, "sprintf", "format");
  })('::')
};

Opal.modules["corelib/math"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $type_error = Opal.type_error, $module = Opal.module, $const_set = Opal.const_set, $Class = Opal.Class, $slice = Opal.slice, $Kernel = Opal.Kernel, $to_s = Opal.to_s, $defs = Opal.defs, $truthy = Opal.truthy, $send = Opal.send, $def = Opal.def, $rb_minus = Opal.rb_minus, $eqeqeq = Opal.eqeqeq, $rb_divide = Opal.rb_divide, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('new,raise,Float,Integer,module_function,each,define_method,checked,float!,===,gamma,-,integer!,/,infinite?');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Math');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set(self, 'E', Math.E);
    $const_set(self, 'PI', Math.PI);
    $const_set(self, 'DomainError', $Class.$new($$$('StandardError')));
    $defs(self, '$checked', function $$checked(method, $a) {
      var $post_args, args;

      
      $post_args = $slice(arguments, 1);
      args = $post_args;
      
      if (isNaN(args[0]) || (args.length == 2 && isNaN(args[1]))) {
        return NaN;
      }

      var result = Math[method].apply(null, args);

      if (isNaN(result)) {
        $Kernel.$raise($$('DomainError'), "Numerical argument is out of domain - \"" + $to_s(method) + "\"");
      }

      return result;
    ;
    }, -2);
    $defs(self, '$float!', function $Math_float$excl$1(value) {
      
      try {
        return $Kernel.$Float(value)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('ArgumentError')])) {
          try {
            return $Kernel.$raise($type_error(value, $$$('Float')))
          } finally { Opal.pop_exception($err); }
        } else { throw $err; }
      }
    });
    $defs(self, '$integer!', function $Math_integer$excl$2(value) {
      
      try {
        return $Kernel.$Integer(value)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('ArgumentError')])) {
          try {
            return $Kernel.$raise($type_error(value, $$$('Integer')))
          } finally { Opal.pop_exception($err); }
        } else { throw $err; }
      }
    });
    self.$module_function();
    if (!$truthy((typeof(Math.erf) !== "undefined"))) {
      
      Opal.prop(Math, 'erf', function(x) {
        var A1 =  0.254829592,
            A2 = -0.284496736,
            A3 =  1.421413741,
            A4 = -1.453152027,
            A5 =  1.061405429,
            P  =  0.3275911;

        var sign = 1;

        if (x < 0) {
            sign = -1;
        }

        x = Math.abs(x);

        var t = 1.0 / (1.0 + P * x);
        var y = 1.0 - (((((A5 * t + A4) * t) + A3) * t + A2) * t + A1) * t * Math.exp(-x * x);

        return sign * y;
      });
    
    };
    if (!$truthy((typeof(Math.erfc) !== "undefined"))) {
      
      Opal.prop(Math, 'erfc', function(x) {
        var z = Math.abs(x),
            t = 1.0 / (0.5 * z + 1.0);

        var A1 = t * 0.17087277 + -0.82215223,
            A2 = t * A1 + 1.48851587,
            A3 = t * A2 + -1.13520398,
            A4 = t * A3 + 0.27886807,
            A5 = t * A4 + -0.18628806,
            A6 = t * A5 + 0.09678418,
            A7 = t * A6 + 0.37409196,
            A8 = t * A7 + 1.00002368,
            A9 = t * A8,
            A10 = -z * z - 1.26551223 + A9;

        var a = t * Math.exp(A10);

        if (x < 0.0) {
          return 2.0 - a;
        }
        else {
          return a;
        }
      });
    
    };
    $send(["acos", "acosh", "asin", "asinh", "atan", "atanh", "cbrt", "cos", "cosh", "erf", "erfc", "exp", "sin", "sinh", "sqrt", "tanh"], 'each', [], function $Math$3(method){var self = $Math$3.$$s == null ? this : $Math$3.$$s;

      
      if (method == null) method = nil;
      return $send(self, 'define_method', [method], function $$4(x){
        
        if (x == null) x = nil;
        return $$$('Math').$checked(method, $$$('Math')['$float!'](x));});}, {$$s: self});
    
    $def(self, '$atan2', function $$atan2(y, x) {
      
      return $$$('Math').$checked("atan2", $$$('Math')['$float!'](y), $$$('Math')['$float!'](x))
    });
    
    $def(self, '$hypot', function $$hypot(x, y) {
      
      return $$$('Math').$checked("hypot", $$$('Math')['$float!'](x), $$$('Math')['$float!'](y))
    });
    
    $def(self, '$frexp', function $$frexp(x) {
      
      
      x = $$('Math')['$float!'](x);
      
      if (isNaN(x)) {
        return [NaN, 0];
      }

      var ex   = Math.floor(Math.log(Math.abs(x)) / Math.log(2)) + 1,
          frac = x / Math.pow(2, ex);

      return [frac, ex];
    ;
    });
    
    $def(self, '$gamma', function $$gamma(n) {
      
      
      n = $$('Math')['$float!'](n);
      
      var i, t, x, value, result, twoN, threeN, fourN, fiveN;

      var G = 4.7421875;

      /* eslint no-loss-of-precision: "warn" */
      var P = [
         0.99999999999999709182,
         57.156235665862923517,
        -59.597960355475491248,
         14.136097974741747174,
        -0.49191381609762019978,
         0.33994649984811888699e-4,
         0.46523628927048575665e-4,
        -0.98374475304879564677e-4,
         0.15808870322491248884e-3,
        -0.21026444172410488319e-3,
         0.21743961811521264320e-3,
        -0.16431810653676389022e-3,
         0.84418223983852743293e-4,
        -0.26190838401581408670e-4,
         0.36899182659531622704e-5
      ];

      if (isNaN(n)) {
        return NaN;
      }

      if (n === 0 && 1 / n < 0) {
        return -Infinity;
      }

      if (n === -1 || n === -Infinity) {
        $Kernel.$raise($$('DomainError'), "Numerical argument is out of domain - \"gamma\"");
      }

      if ($$('Integer')['$==='](n)) {
        if (n <= 0) {
          return isFinite(n) ? Infinity : NaN;
        }

        if (n > 171) {
          return Infinity;
        }

        value  = n - 2;
        result = n - 1;

        while (value > 1) {
          result *= value;
          value--;
        }

        if (result == 0) {
          result = 1;
        }

        return result;
      }

      if (n < 0.5) {
        return Math.PI / (Math.sin(Math.PI * n) * $$$('Math').$gamma($rb_minus(1, n)));
      }

      if (n >= 171.35) {
        return Infinity;
      }

      if (n > 85.0) {
        twoN   = n * n;
        threeN = twoN * n;
        fourN  = threeN * n;
        fiveN  = fourN * n;

        return Math.sqrt(2 * Math.PI / n) * Math.pow((n / Math.E), n) *
          (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) -
          571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) +
          5246819 / (75246796800 * fiveN * n));
      }

      n -= 1;
      x  = P[0];

      for (i = 1; i < P.length; ++i) {
        x += P[i] / (n + i);
      }

      t = n + G + 0.5;

      return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
    ;
    });
    
    $def(self, '$ldexp', function $$ldexp(mantissa, exponent) {
      
      
      mantissa = $$('Math')['$float!'](mantissa);
      exponent = $$('Math')['$integer!'](exponent);
      
      if (isNaN(exponent)) {
        $Kernel.$raise($$$('RangeError'), "float NaN out of range of integer");
      }

      return mantissa * Math.pow(2, exponent);
    ;
    });
    
    $def(self, '$lgamma', function $$lgamma(n) {
      
      
      if (n == -1) {
        return [Infinity, 1];
      }
      else {
        return [Math.log(Math.abs($$$('Math').$gamma(n))), $$$('Math').$gamma(n) < 0 ? -1 : 1];
      }
    
    });
    
    $def(self, '$log', function $$log(x, base) {
      
      
      ;
      if ($eqeqeq($$$('String'), x)) {
        $Kernel.$raise($type_error(x, $$$('Float')))
      };
      if ($truthy(base == null)) {
        return $$$('Math').$checked("log", $$$('Math')['$float!'](x))
      } else {
        
        if ($eqeqeq($$$('String'), base)) {
          $Kernel.$raise($type_error(base, $$$('Float')))
        };
        return $rb_divide($$$('Math').$checked("log", $$$('Math')['$float!'](x)), $$$('Math').$checked("log", $$$('Math')['$float!'](base)));
      };
    }, -2);
    
    $def(self, '$log10', function $$log10(x) {
      
      
      if ($eqeqeq($$$('String'), x)) {
        $Kernel.$raise($type_error(x, $$$('Float')))
      };
      return $$$('Math').$checked("log10", $$$('Math')['$float!'](x));
    });
    
    $def(self, '$log2', function $$log2(x) {
      
      
      if ($eqeqeq($$$('String'), x)) {
        $Kernel.$raise($type_error(x, $$$('Float')))
      };
      return $$$('Math').$checked("log2", $$$('Math')['$float!'](x));
    });
    return $def(self, '$tan', function $$tan(x) {
      
      
      x = $$$('Math')['$float!'](x);
      if ($truthy(x['$infinite?']())) {
        return $$$($$$('Float'), 'NAN')
      };
      return $$$('Math').$checked("tan", $$$('Math')['$float!'](x));
    });
  })('::', $nesting)
};

Opal.modules["corelib/complex/base"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  var $module = Opal.module, $truthy = Opal.truthy, $def = Opal.def, $klass = Opal.klass, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('new,from_string');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$Complex', function $$Complex(real, imag) {
      
      
      if (imag == null) imag = nil;
      if ($truthy(imag)) {
        return $$('Complex').$new(real, imag)
      } else {
        return $$('Complex').$new(real, 0)
      };
    }, -2)
  })('::', $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$to_c', function $$to_c() {
      var self = this;

      return $$('Complex').$from_string(self)
    })
  })('::', null, $nesting);
};

Opal.modules["corelib/complex"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  var $klass = Opal.klass, $truthy = Opal.truthy, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $defs = Opal.defs, $rb_times = Opal.rb_times, $def = Opal.def, $to_s = Opal.to_s, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $rb_divide = Opal.rb_divide, $eqeq = Opal.eqeq, $to_ary = Opal.to_ary, $rb_gt = Opal.rb_gt, $neqeq = Opal.neqeq, $return_val = Opal.return_val, $const_set = Opal.const_set, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,real?,===,raise,new,*,cos,sin,attr_reader,freeze,class,==,real,imag,Complex,-@,+,__coerced__,-,nan?,/,conj,abs2,quo,polar,exp,log,>,!=,divmod,**,hypot,atan2,lcm,denominator,finite?,hash,infinite?,numerator,abs,arg,rationalize,to_f,to_i,to_r,inspect,zero?,positive?,Rational,rect,angle');
  
  self.$require("corelib/numeric");
  self.$require("corelib/complex/base");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Complex');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.real = $proto.imag = nil;
    
    $defs(self, '$rect', function $$rect(real, imag) {
      var self = this;

      
      if (imag == null) imag = 0;
      if (!((($eqeqeq($$$('Numeric'), real) && ($truthy(real['$real?']()))) && ($eqeqeq($$$('Numeric'), imag))) && ($truthy(imag['$real?']())))) {
        $Kernel.$raise($$$('TypeError'), "not a real")
      };
      return self.$new(real, imag);
    }, -2);
    $defs(self, '$polar', function $$polar(r, theta) {
      var self = this;

      
      if (theta == null) theta = 0;
      if (!((($eqeqeq($$$('Numeric'), r) && ($truthy(r['$real?']()))) && ($eqeqeq($$$('Numeric'), theta))) && ($truthy(theta['$real?']())))) {
        $Kernel.$raise($$$('TypeError'), "not a real")
      };
      return self.$new($rb_times(r, $$$('Math').$cos(theta)), $rb_times(r, $$$('Math').$sin(theta)));
    }, -2);
    self.$attr_reader("real", "imag");
    
    $def(self, '$initialize', function $$initialize(real, imag) {
      var self = this;

      
      if (imag == null) imag = 0;
      self.real = real;
      self.imag = imag;
      return self.$freeze();
    }, -2);
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return [other, self]
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return [$$$('Complex').$new(other, 0), self]
      } else {
        return $Kernel.$raise($$$('TypeError'), $to_s(other.$class()) + " can't be coerced into Complex")
      }
    });
    
    $def(self, '$==', function $Complex_$eq_eq$1(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Complex'), other)) {
        if ($truthy(($ret_or_1 = self.real['$=='](other.$real())))) {
          return self.imag['$=='](other.$imag())
        } else {
          return $ret_or_1
        }
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        if ($truthy(($ret_or_1 = self.real['$=='](other)))) {
          return self.imag['$=='](0)
        } else {
          return $ret_or_1
        }
      } else {
        return other['$=='](self)
      }
    });
    
    $def(self, '$-@', function $Complex_$minus$$2() {
      var self = this;

      return $Kernel.$Complex(self.real['$-@'](), self.imag['$-@']())
    });
    
    $def(self, '$+', function $Complex_$plus$3(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return $Kernel.$Complex($rb_plus(self.real, other.$real()), $rb_plus(self.imag, other.$imag()))
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex($rb_plus(self.real, other), self.imag)
      } else {
        return self.$__coerced__("+", other)
      }
    });
    
    $def(self, '$-', function $Complex_$minus$4(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return $Kernel.$Complex($rb_minus(self.real, other.$real()), $rb_minus(self.imag, other.$imag()))
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex($rb_minus(self.real, other), self.imag)
      } else {
        return self.$__coerced__("-", other)
      }
    });
    
    $def(self, '$*', function $Complex_$$5(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return $Kernel.$Complex($rb_minus($rb_times(self.real, other.$real()), $rb_times(self.imag, other.$imag())), $rb_plus($rb_times(self.real, other.$imag()), $rb_times(self.imag, other.$real())))
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex($rb_times(self.real, other), $rb_times(self.imag, other))
      } else {
        return self.$__coerced__("*", other)
      }
    });
    
    $def(self, '$/', function $Complex_$slash$6(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        if ((((($eqeqeq($$$('Number'), self.real) && ($truthy(self.real['$nan?']()))) || (($eqeqeq($$$('Number'), self.imag) && ($truthy(self.imag['$nan?']()))))) || (($eqeqeq($$$('Number'), other.$real()) && ($truthy(other.$real()['$nan?']()))))) || (($eqeqeq($$$('Number'), other.$imag()) && ($truthy(other.$imag()['$nan?']())))))) {
          return $$$('Complex').$new($$$($$$('Float'), 'NAN'), $$$($$$('Float'), 'NAN'))
        } else {
          return $rb_divide($rb_times(self, other.$conj()), other.$abs2())
        }
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex(self.real.$quo(other), self.imag.$quo(other))
      } else {
        return self.$__coerced__("/", other)
      }
    });
    
    $def(self, '$**', function $Complex_$$$7(other) {
      var $a, $b, self = this, r = nil, theta = nil, ore = nil, oim = nil, nr = nil, ntheta = nil, x = nil, z = nil, n = nil, div = nil, mod = nil;

      
      if ($eqeq(other, 0)) {
        return $$$('Complex').$new(1, 0)
      };
      if ($eqeqeq($$$('Complex'), other)) {
        
        $b = self.$polar(), $a = $to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        ore = other.$real();
        oim = other.$imag();
        nr = $$$('Math').$exp($rb_minus($rb_times(ore, $$$('Math').$log(r)), $rb_times(oim, theta)));
        ntheta = $rb_plus($rb_times(theta, ore), $rb_times(oim, $$$('Math').$log(r)));
        return $$$('Complex').$polar(nr, ntheta);
      } else if ($eqeqeq($$$('Integer'), other)) {
        if ($truthy($rb_gt(other, 0))) {
          
          x = self;
          z = x;
          n = $rb_minus(other, 1);
          while ($neqeq(n, 0)) {
          
            $b = n.$divmod(2), $a = $to_ary($b), (div = ($a[0] == null ? nil : $a[0])), (mod = ($a[1] == null ? nil : $a[1])), $b;
            while ($eqeq(mod, 0)) {
            
              x = $Kernel.$Complex($rb_minus($rb_times(x.$real(), x.$real()), $rb_times(x.$imag(), x.$imag())), $rb_times($rb_times(2, x.$real()), x.$imag()));
              n = div;
              $b = n.$divmod(2), $a = $to_ary($b), (div = ($a[0] == null ? nil : $a[0])), (mod = ($a[1] == null ? nil : $a[1])), $b;
            };
            z = $rb_times(z, x);
            n = $rb_minus(n, 1);
          };
          return z;
        } else {
          return $rb_divide($$$('Rational').$new(1, 1), self)['$**'](other['$-@']())
        }
      } else if (($eqeqeq($$$('Float'), other) || ($eqeqeq($$$('Rational'), other)))) {
        
        $b = self.$polar(), $a = $to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        return $$$('Complex').$polar(r['$**'](other), $rb_times(theta, other));
      } else {
        return self.$__coerced__("**", other)
      };
    });
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      return $$$('Math').$hypot(self.real, self.imag)
    });
    
    $def(self, '$abs2', function $$abs2() {
      var self = this;

      return $rb_plus($rb_times(self.real, self.real), $rb_times(self.imag, self.imag))
    });
    
    $def(self, '$angle', function $$angle() {
      var self = this;

      return $$$('Math').$atan2(self.imag, self.real)
    });
    
    $def(self, '$conj', function $$conj() {
      var self = this;

      return $Kernel.$Complex(self.real, self.imag['$-@']())
    });
    
    $def(self, '$denominator', function $$denominator() {
      var self = this;

      return self.real.$denominator().$lcm(self.imag.$denominator())
    });
    
    $def(self, '$eql?', function $Complex_eql$ques$8(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = $$('Complex')['$==='](other))) ? (self.real.$class()['$=='](self.imag.$class())) : ($ret_or_2))))) {
        return self['$=='](other)
      } else {
        return $ret_or_1
      }
    });
    
    $def(self, '$fdiv', function $$fdiv(other) {
      var self = this;

      
      if (!$eqeqeq($$$('Numeric'), other)) {
        $Kernel.$raise($$$('TypeError'), $to_s(other.$class()) + " can't be coerced into Complex")
      };
      return $rb_divide(self, other);
    });
    
    $def(self, '$finite?', function $Complex_finite$ques$9() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.real['$finite?']()))) {
        return self.imag['$finite?']()
      } else {
        return $ret_or_1
      }
    });
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return [$$$('Complex'), self.real, self.imag].$hash()
    });
    
    $def(self, '$infinite?', function $Complex_infinite$ques$10() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.real['$infinite?']()))) {
        return $ret_or_1
      } else {
        return self.imag['$infinite?']()
      }
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "(" + $to_s(self) + ")"
    });
    
    $def(self, '$numerator', function $$numerator() {
      var self = this, d = nil;

      
      d = self.$denominator();
      return $Kernel.$Complex($rb_times(self.real.$numerator(), $rb_divide(d, self.real.$denominator())), $rb_times(self.imag.$numerator(), $rb_divide(d, self.imag.$denominator())));
    });
    
    $def(self, '$polar', function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    });
    
    $def(self, '$rationalize', function $$rationalize(eps) {
      var self = this;

      
      ;
      
      if (arguments.length > 1) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + $to_s(arguments.length) + " for 0..1)");
      }
    ;
      if ($neqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + $to_s(self) + " into Rational")
      };
      return self.$real().$rationalize(eps);
    }, -1);
    
    $def(self, '$real?', $return_val(false));
    
    $def(self, '$rect', function $$rect() {
      var self = this;

      return [self.real, self.imag]
    });
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      
      if (!$eqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + $to_s(self) + " into Float")
      };
      return self.real.$to_f();
    });
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      
      if (!$eqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + $to_s(self) + " into Integer")
      };
      return self.real.$to_i();
    });
    
    $def(self, '$to_r', function $$to_r() {
      var self = this;

      
      if (!$eqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + $to_s(self) + " into Rational")
      };
      return self.real.$to_r();
    });
    
    $def(self, '$to_s', function $$to_s() {
      var self = this, result = nil;

      
      result = self.real.$inspect();
      result = $rb_plus(result, (((($eqeqeq($$$('Number'), self.imag) && ($truthy(self.imag['$nan?']()))) || ($truthy(self.imag['$positive?']()))) || ($truthy(self.imag['$zero?']()))) ? ("+") : ("-")));
      result = $rb_plus(result, self.imag.$abs().$inspect());
      if (($eqeqeq($$$('Number'), self.imag) && (($truthy(self.imag['$nan?']()) || ($truthy(self.imag['$infinite?']())))))) {
        result = $rb_plus(result, "*")
      };
      return $rb_plus(result, "i");
    });
    $const_set($nesting[0], 'I', self.$new(0, 1));
    $defs(self, '$from_string', function $$from_string(str) {
      
      
      var re = /[+-]?[\d_]+(\.[\d_]+)?(e\d+)?/,
          match = str.match(re),
          real, imag, denominator;

      function isFloat() {
        return re.test(str);
      }

      function cutFloat() {
        var match = str.match(re);
        var number = match[0];
        str = str.slice(number.length);
        return number.replace(/_/g, '');
      }

      // handles both floats and rationals
      function cutNumber() {
        if (isFloat()) {
          var numerator = parseFloat(cutFloat());

          if (str[0] === '/') {
            // rational real part
            str = str.slice(1);

            if (isFloat()) {
              var denominator = parseFloat(cutFloat());
              return $Kernel.$Rational(numerator, denominator);
            } else {
              // reverting '/'
              str = '/' + str;
              return numerator;
            }
          } else {
            // float real part, no denominator
            return numerator;
          }
        } else {
          return null;
        }
      }

      real = cutNumber();

      if (!real) {
        if (str[0] === 'i') {
          // i => Complex(0, 1)
          return $Kernel.$Complex(0, 1);
        }
        if (str[0] === '-' && str[1] === 'i') {
          // -i => Complex(0, -1)
          return $Kernel.$Complex(0, -1);
        }
        if (str[0] === '+' && str[1] === 'i') {
          // +i => Complex(0, 1)
          return $Kernel.$Complex(0, 1);
        }
        // anything => Complex(0, 0)
        return $Kernel.$Complex(0, 0);
      }

      imag = cutNumber();
      if (!imag) {
        if (str[0] === 'i') {
          // 3i => Complex(0, 3)
          return $Kernel.$Complex(0, real);
        } else {
          // 3 => Complex(3, 0)
          return $Kernel.$Complex(real, 0);
        }
      } else {
        // 3+2i => Complex(3, 2)
        return $Kernel.$Complex(real, imag);
      }
    
    });
    (function(self, $parent_nesting) {
      
      return $alias(self, "rectangular", "rect")
    })(Opal.get_singleton_class(self), $nesting);
    $alias(self, "arg", "angle");
    $alias(self, "conjugate", "conj");
    $alias(self, "divide", "/");
    $alias(self, "imaginary", "imag");
    $alias(self, "magnitude", "abs");
    $alias(self, "phase", "arg");
    $alias(self, "quo", "/");
    $alias(self, "rectangular", "rect");
    
    Opal.udef(self, '$' + "negative?");;
    
    Opal.udef(self, '$' + "positive?");;
    
    
    Opal.udef(self, '$' + "step");;
    return nil;;
  })('::', $$$('Numeric'), $nesting);
};

Opal.modules["corelib/rational/base"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  var $module = Opal.module, $def = Opal.def, $klass = Opal.klass, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('convert,from_string');
  
  (function($base) {
    var self = $module($base, 'Kernel');

    
    return $def(self, '$Rational', function $$Rational(numerator, denominator) {
      
      
      if (denominator == null) denominator = 1;
      return $$$('Rational').$convert(numerator, denominator);
    }, -2)
  })('::');
  return (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    return $def(self, '$to_r', function $$to_r() {
      var self = this;

      return $$$('Rational').$from_string(self)
    })
  })('::', null);
};

Opal.modules["corelib/rational"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  var $klass = Opal.klass, $eqeq = Opal.eqeq, $Kernel = Opal.Kernel, $truthy = Opal.truthy, $rb_lt = Opal.rb_lt, $rb_divide = Opal.rb_divide, $defs = Opal.defs, $eqeqeq = Opal.eqeqeq, $not = Opal.not, $Opal = Opal.Opal, $def = Opal.def, $return_ivar = Opal.return_ivar, $rb_minus = Opal.rb_minus, $rb_times = Opal.rb_times, $rb_plus = Opal.rb_plus, $rb_gt = Opal.rb_gt, $to_s = Opal.to_s, $rb_le = Opal.rb_le, $return_self = Opal.return_self, $alias = Opal.alias, self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,to_i,==,raise,<,-@,new,gcd,/,nil?,===,reduce,to_r,!,equal?,coerce_to!,freeze,to_f,numerator,denominator,<=>,-,*,__coerced__,+,Rational,>,**,abs,ceil,with_precision,floor,hash,<=,truncate,send');
  
  self.$require("corelib/numeric");
  self.$require("corelib/rational/base");
  return (function($base, $super) {
    var self = $klass($base, $super, 'Rational');

    var $proto = self.$$prototype;

    $proto.num = $proto.den = nil;
    
    $defs(self, '$reduce', function $$reduce(num, den) {
      var self = this, gcd = nil;

      
      num = num.$to_i();
      den = den.$to_i();
      if ($eqeq(den, 0)) {
        $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
      } else if ($truthy($rb_lt(den, 0))) {
        
        num = num['$-@']();
        den = den['$-@']();
      } else if ($eqeq(den, 1)) {
        return self.$new(num, den)
      };
      gcd = num.$gcd(den);
      return self.$new($rb_divide(num, gcd), $rb_divide(den, gcd));
    });
    $defs(self, '$convert', function $$convert(num, den) {
      var self = this;

      
      if (($truthy(num['$nil?']()) || ($truthy(den['$nil?']())))) {
        $Kernel.$raise($$$('TypeError'), "cannot convert nil into Rational")
      };
      if (($eqeqeq($$$('Integer'), num) && ($eqeqeq($$$('Integer'), den)))) {
        return self.$reduce(num, den)
      };
      if ((($eqeqeq($$$('Float'), num) || ($eqeqeq($$$('String'), num))) || ($eqeqeq($$$('Complex'), num)))) {
        num = num.$to_r()
      };
      if ((($eqeqeq($$$('Float'), den) || ($eqeqeq($$$('String'), den))) || ($eqeqeq($$$('Complex'), den)))) {
        den = den.$to_r()
      };
      if (($truthy(den['$equal?'](1)) && ($not($$$('Integer')['$==='](num))))) {
        return $Opal['$coerce_to!'](num, $$$('Rational'), "to_r")
      } else if (($eqeqeq($$$('Numeric'), num) && ($eqeqeq($$$('Numeric'), den)))) {
        return $rb_divide(num, den)
      } else {
        return self.$reduce(num, den)
      };
    });
    
    $def(self, '$initialize', function $$initialize(num, den) {
      var self = this;

      
      self.num = num;
      self.den = den;
      return self.$freeze();
    });
    
    $def(self, '$numerator', $return_ivar("num"));
    
    $def(self, '$denominator', $return_ivar("den"));
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        return [other, self]
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return [other.$to_r(), self]
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return [other, self.$to_f()]
      } else {
        return nil
      }
    });
    
    $def(self, '$==', function $Rational_$eq_eq$1(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        if ($truthy(($ret_or_2 = self.num['$=='](other.$numerator())))) {
          return self.den['$=='](other.$denominator())
        } else {
          return $ret_or_2
        }
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        if ($truthy(($ret_or_2 = self.num['$=='](other)))) {
          return self.den['$=='](1)
        } else {
          return $ret_or_2
        }
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return self.$to_f()['$=='](other)
      } else {
        return other['$=='](self)
      }
    });
    
    $def(self, '$<=>', function $Rational_$lt_eq_gt$2(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        return $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()))['$<=>'](0)
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $rb_minus(self.num, $rb_times(self.den, other))['$<=>'](0)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return self.$to_f()['$<=>'](other)
      } else {
        return self.$__coerced__("<=>", other)
      }
    });
    
    $def(self, '$+', function $Rational_$plus$3(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_plus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
        den = $rb_times(self.den, other.$denominator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $Kernel.$Rational($rb_plus(self.num, $rb_times(other, self.den)), self.den)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_plus(self.$to_f(), other)
      } else {
        return self.$__coerced__("+", other)
      }
    });
    
    $def(self, '$-', function $Rational_$minus$4(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
        den = $rb_times(self.den, other.$denominator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $Kernel.$Rational($rb_minus(self.num, $rb_times(other, self.den)), self.den)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_minus(self.$to_f(), other)
      } else {
        return self.$__coerced__("-", other)
      }
    });
    
    $def(self, '$*', function $Rational_$$5(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_times(self.num, other.$numerator());
        den = $rb_times(self.den, other.$denominator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $Kernel.$Rational($rb_times(self.num, other), self.den)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_times(self.$to_f(), other)
      } else {
        return self.$__coerced__("*", other)
      }
    });
    
    $def(self, '$/', function $Rational_$slash$6(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_times(self.num, other.$denominator());
        den = $rb_times(self.den, other.$numerator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        if ($eqeq(other, 0)) {
          return $rb_divide(self.$to_f(), 0.0)
        } else {
          return $Kernel.$Rational(self.num, $rb_times(self.den, other))
        }
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_divide(self.$to_f(), other)
      } else {
        return self.$__coerced__("/", other)
      }
    });
    
    $def(self, '$**', function $Rational_$$$7(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Integer'), ($ret_or_1 = other))) {
        if (($eqeq(self, 0) && ($truthy($rb_lt(other, 0))))) {
          return $$$($$$('Float'), 'INFINITY')
        } else if ($truthy($rb_gt(other, 0))) {
          return $Kernel.$Rational(self.num['$**'](other), self.den['$**'](other))
        } else if ($truthy($rb_lt(other, 0))) {
          return $Kernel.$Rational(self.den['$**'](other['$-@']()), self.num['$**'](other['$-@']()))
        } else {
          return $Kernel.$Rational(1, 1)
        }
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return self.$to_f()['$**'](other)
      } else if ($eqeqeq($$$('Rational'), $ret_or_1)) {
        if ($eqeq(other, 0)) {
          return $Kernel.$Rational(1, 1)
        } else if ($eqeq(other.$denominator(), 1)) {
          if ($truthy($rb_lt(other, 0))) {
            return $Kernel.$Rational(self.den['$**'](other.$numerator().$abs()), self.num['$**'](other.$numerator().$abs()))
          } else {
            return $Kernel.$Rational(self.num['$**'](other.$numerator()), self.den['$**'](other.$numerator()))
          }
        } else if (($eqeq(self, 0) && ($truthy($rb_lt(other, 0))))) {
          return $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
        } else {
          return self.$to_f()['$**'](other)
        }
      } else {
        return self.$__coerced__("**", other)
      }
    });
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      return $Kernel.$Rational(self.num.$abs(), self.den.$abs())
    });
    
    $def(self, '$ceil', function $$ceil(precision) {
      var self = this;

      
      if (precision == null) precision = 0;
      if ($eqeq(precision, 0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$ceil()
      } else {
        return self.$with_precision("ceil", precision)
      };
    }, -1);
    
    $def(self, '$floor', function $$floor(precision) {
      var self = this;

      
      if (precision == null) precision = 0;
      if ($eqeq(precision, 0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$floor()
      } else {
        return self.$with_precision("floor", precision)
      };
    }, -1);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return [$$$('Rational'), self.num, self.den].$hash()
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "(" + $to_s(self) + ")"
    });
    
    $def(self, '$rationalize', function $$rationalize(eps) {
      var self = this;

      
      ;
      
      if (arguments.length > 1) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + $to_s(arguments.length) + " for 0..1)");
      }

      if (eps == null) {
        return self;
      }

      var e = eps.$abs(),
          a = $rb_minus(self, e),
          b = $rb_plus(self, e);

      var p0 = 0,
          p1 = 1,
          q0 = 1,
          q1 = 0,
          p2, q2;

      var c, k, t;

      while (true) {
        c = (a).$ceil();

        if ($rb_le(c, b)) {
          break;
        }

        k  = c - 1;
        p2 = k * p1 + p0;
        q2 = k * q1 + q0;
        t  = $rb_divide(1, $rb_minus(b, k));
        b  = $rb_divide(1, $rb_minus(a, k));
        a  = t;

        p0 = p1;
        q0 = q1;
        p1 = p2;
        q1 = q2;
      }

      return $Kernel.$Rational(c * p1 + p0, c * q1 + q0);
    ;
    }, -1);
    
    $def(self, '$round', function $$round(precision) {
      var self = this, num = nil, den = nil, approx = nil;

      
      if (precision == null) precision = 0;
      if (!$eqeq(precision, 0)) {
        return self.$with_precision("round", precision)
      };
      if ($eqeq(self.num, 0)) {
        return 0
      };
      if ($eqeq(self.den, 1)) {
        return self.num
      };
      num = $rb_plus($rb_times(self.num.$abs(), 2), self.den);
      den = $rb_times(self.den, 2);
      approx = $rb_divide(num, den).$truncate();
      if ($truthy($rb_lt(self.num, 0))) {
        return approx['$-@']()
      } else {
        return approx
      };
    }, -1);
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      return $rb_divide(self.num, self.den)
    });
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      return self.$truncate()
    });
    
    $def(self, '$to_r', $return_self);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return $to_s(self.num) + "/" + $to_s(self.den)
    });
    
    $def(self, '$truncate', function $$truncate(precision) {
      var self = this;

      
      if (precision == null) precision = 0;
      if ($eqeq(precision, 0)) {
        if ($truthy($rb_lt(self.num, 0))) {
          return self.$ceil()
        } else {
          return self.$floor()
        }
      } else {
        return self.$with_precision("truncate", precision)
      };
    }, -1);
    
    $def(self, '$with_precision', function $$with_precision(method, precision) {
      var self = this, p = nil, s = nil;

      
      if (!$eqeqeq($$$('Integer'), precision)) {
        $Kernel.$raise($$$('TypeError'), "not an Integer")
      };
      p = (10)['$**'](precision);
      s = $rb_times(self, p);
      if ($truthy($rb_lt(precision, 1))) {
        return $rb_divide(s.$send(method), p).$to_i()
      } else {
        return $Kernel.$Rational(s.$send(method), p)
      };
    });
    $defs(self, '$from_string', function $$from_string(string) {
      
      
      var str = string.trimLeft(),
          re = /^[+-]?[\d_]+(\.[\d_]+)?/,
          match = str.match(re),
          numerator, denominator;

      function isFloat() {
        return re.test(str);
      }

      function cutFloat() {
        var match = str.match(re);
        var number = match[0];
        str = str.slice(number.length);
        return number.replace(/_/g, '');
      }

      if (isFloat()) {
        numerator = parseFloat(cutFloat());

        if (str[0] === '/') {
          // rational real part
          str = str.slice(1);

          if (isFloat()) {
            denominator = parseFloat(cutFloat());
            return $Kernel.$Rational(numerator, denominator);
          } else {
            return $Kernel.$Rational(numerator, 1);
          }
        } else {
          return $Kernel.$Rational(numerator, 1);
        }
      } else {
        return $Kernel.$Rational(0, 1);
      }
    
    });
    $alias(self, "divide", "/");
    return $alias(self, "quo", "/");
  })('::', $$$('Numeric'));
};

Opal.modules["corelib/time"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $slice = Opal.slice, $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $defs = Opal.defs, $to_s = Opal.to_s, $eqeqeq = Opal.eqeqeq, $def = Opal.def, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $send = Opal.send, $rb_plus = Opal.rb_plus, $rb_divide = Opal.rb_divide, $rb_minus = Opal.rb_minus, $range = Opal.range, $neqeq = Opal.neqeq, $rb_le = Opal.rb_le, $eqeq = Opal.eqeq, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,===,raise,coerce_to!,respond_to?,to_str,to_i,_parse_offset,new,<=>,to_f,nil?,>,<,strftime,each,define_method,year,month,day,+,round,/,-,copy_instance_variables,initialize_dup,is_a?,zero?,wday,hash,utc?,mon,yday,hour,min,sec,rjust,ljust,zone,to_s,[],cweek_cyear,jd,to_date,format,isdst,!=,<=,==,ceil,local,gm,asctime,getgm,gmt_offset,inspect,usec,gmtime,gmt?');
  
  self.$require("corelib/comparable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Time');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Comparable'));
    
    var days_of_week = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
        short_days   = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        short_months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        long_months  = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  ;
    $defs(self, '$at', function $$at(seconds, frac) {
      
      
      ;
      
      var result;

      if ($$$('Time')['$==='](seconds)) {
        if (frac !== undefined) {
          $Kernel.$raise($$$('TypeError'), "can't convert Time into an exact number")
        }
        result = new Date(seconds.getTime());
        result.timezone = seconds.timezone;
        return result;
      }

      if (!seconds.$$is_number) {
        seconds = $Opal['$coerce_to!'](seconds, $$$('Integer'), "to_int");
      }

      if (frac === undefined) {
        return new Date(seconds * 1000);
      }

      if (!frac.$$is_number) {
        frac = $Opal['$coerce_to!'](frac, $$$('Integer'), "to_int");
      }

      return new Date(seconds * 1000 + (frac / 1000));
    ;
    }, -2);
    
    function time_params(year, month, day, hour, min, sec) {
      if (year.$$is_string) {
        year = parseInt(year, 10);
      } else {
        year = $Opal['$coerce_to!'](year, $$$('Integer'), "to_int");
      }

      if (month === nil) {
        month = 1;
      } else if (!month.$$is_number) {
        if ((month)['$respond_to?']("to_str")) {
          month = (month).$to_str();
          switch (month.toLowerCase()) {
          case 'jan': month =  1; break;
          case 'feb': month =  2; break;
          case 'mar': month =  3; break;
          case 'apr': month =  4; break;
          case 'may': month =  5; break;
          case 'jun': month =  6; break;
          case 'jul': month =  7; break;
          case 'aug': month =  8; break;
          case 'sep': month =  9; break;
          case 'oct': month = 10; break;
          case 'nov': month = 11; break;
          case 'dec': month = 12; break;
          default: month = (month).$to_i();
          }
        } else {
          month = $Opal['$coerce_to!'](month, $$$('Integer'), "to_int");
        }
      }

      if (month < 1 || month > 12) {
        $Kernel.$raise($$$('ArgumentError'), "month out of range: " + $to_s(month))
      }
      month = month - 1;

      if (day === nil) {
        day = 1;
      } else if (day.$$is_string) {
        day = parseInt(day, 10);
      } else {
        day = $Opal['$coerce_to!'](day, $$$('Integer'), "to_int");
      }

      if (day < 1 || day > 31) {
        $Kernel.$raise($$$('ArgumentError'), "day out of range: " + $to_s(day))
      }

      if (hour === nil) {
        hour = 0;
      } else if (hour.$$is_string) {
        hour = parseInt(hour, 10);
      } else {
        hour = $Opal['$coerce_to!'](hour, $$$('Integer'), "to_int");
      }

      if (hour < 0 || hour > 24) {
        $Kernel.$raise($$$('ArgumentError'), "hour out of range: " + $to_s(hour))
      }

      if (min === nil) {
        min = 0;
      } else if (min.$$is_string) {
        min = parseInt(min, 10);
      } else {
        min = $Opal['$coerce_to!'](min, $$$('Integer'), "to_int");
      }

      if (min < 0 || min > 59) {
        $Kernel.$raise($$$('ArgumentError'), "min out of range: " + $to_s(min))
      }

      if (sec === nil) {
        sec = 0;
      } else if (!sec.$$is_number) {
        if (sec.$$is_string) {
          sec = parseInt(sec, 10);
        } else {
          sec = $Opal['$coerce_to!'](sec, $$$('Integer'), "to_int");
        }
      }

      if (sec < 0 || sec > 60) {
        $Kernel.$raise($$$('ArgumentError'), "sec out of range: " + $to_s(sec))
      }

      return [year, month, day, hour, min, sec];
    }
  ;
    $defs(self, '$new', function $Time_new$1(year, month, day, hour, min, sec, utc_offset) {
      var self = this;

      
      ;
      if (month == null) month = nil;
      if (day == null) day = nil;
      if (hour == null) hour = nil;
      if (min == null) min = nil;
      if (sec == null) sec = nil;
      if (utc_offset == null) utc_offset = nil;
      
      var args, result, timezone, utc_date;

      if (year === undefined) {
        return new Date();
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      if (utc_offset === nil) {
        result = new Date(year, month, day, hour, min, 0, sec * 1000);
        if (year < 100) {
          result.setFullYear(year);
        }
        return result;
      }

      timezone = self.$_parse_offset(utc_offset);
      utc_date = new Date(Date.UTC(year, month, day, hour, min, 0, sec * 1000));
      if (year < 100) {
        utc_date.setUTCFullYear(year);
      }

      result = new Date(utc_date.getTime() - timezone * 3600000);
      result.timezone = timezone;

      return result;
    ;
    }, -1);
    $defs(self, '$_parse_offset', function $$_parse_offset(utc_offset) {
      
      
      var timezone;
      if (utc_offset.$$is_string) {
        if (utc_offset == 'UTC') {
          timezone = 0;
        }
        else if(/^[+-]\d\d:[0-5]\d$/.test(utc_offset)) {
          var sign, hours, minutes;
          sign = utc_offset[0];
          hours = +(utc_offset[1] + utc_offset[2]);
          minutes = +(utc_offset[4] + utc_offset[5]);

          timezone = (sign == '-' ? -1 : 1) * (hours + minutes / 60);
        }
        else {
          // Unsupported: "A".."I","K".."Z"
          $Kernel.$raise($$$('ArgumentError'), "\"+HH:MM\", \"-HH:MM\", \"UTC\" expected for utc_offset: " + $to_s(utc_offset))
        }
      }
      else if (utc_offset.$$is_number) {
        timezone = utc_offset / 3600;
      }
      else {
        $Kernel.$raise($$$('ArgumentError'), "Opal doesn't support other types for a timezone argument than Integer and String")
      }
      return timezone;
    
    });
    $defs(self, '$local', function $$local(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      
      
      if (month == null) month = nil;
      if (day == null) day = nil;
      if (hour == null) hour = nil;
      if (min == null) min = nil;
      if (sec == null) sec = nil;
      if (millisecond == null) millisecond = nil;
      if (_dummy1 == null) _dummy1 = nil;
      if (_dummy2 == null) _dummy2 = nil;
      if (_dummy3 == null) _dummy3 = nil;
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(year, month, day, hour, min, 0, sec * 1000);
      if (year < 100) {
        result.setFullYear(year);
      }
      return result;
    ;
    }, -2);
    $defs(self, '$gm', function $$gm(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      
      
      if (month == null) month = nil;
      if (day == null) day = nil;
      if (hour == null) hour = nil;
      if (min == null) min = nil;
      if (sec == null) sec = nil;
      if (millisecond == null) millisecond = nil;
      if (_dummy1 == null) _dummy1 = nil;
      if (_dummy2 == null) _dummy2 = nil;
      if (_dummy3 == null) _dummy3 = nil;
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(Date.UTC(year, month, day, hour, min, 0, sec * 1000));
      if (year < 100) {
        result.setUTCFullYear(year);
      }
      result.timezone = 0;
      return result;
    ;
    }, -2);
    $defs(self, '$now', function $$now() {
      var self = this;

      return self.$new()
    });
    
    $def(self, '$+', function $Time_$plus$2(other) {
      var self = this;

      
      if ($eqeqeq($$$('Time'), other)) {
        $Kernel.$raise($$$('TypeError'), "time + time?")
      };
      
      if (!other.$$is_number) {
        other = $Opal['$coerce_to!'](other, $$$('Integer'), "to_int");
      }
      var result = new Date(self.getTime() + (other * 1000));
      result.timezone = self.timezone;
      return result;
    ;
    });
    
    $def(self, '$-', function $Time_$minus$3(other) {
      var self = this;

      
      if ($eqeqeq($$$('Time'), other)) {
        return (self.getTime() - other.getTime()) / 1000
      };
      
      if (!other.$$is_number) {
        other = $Opal['$coerce_to!'](other, $$$('Integer'), "to_int");
      }
      var result = new Date(self.getTime() - (other * 1000));
      result.timezone = self.timezone;
      return result;
    ;
    });
    
    $def(self, '$<=>', function $Time_$lt_eq_gt$4(other) {
      var self = this, r = nil;

      if ($eqeqeq($$$('Time'), other)) {
        return self.$to_f()['$<=>'](other.$to_f())
      } else {
        
        r = other['$<=>'](self);
        if ($truthy(r['$nil?']())) {
          return nil
        } else if ($truthy($rb_gt(r, 0))) {
          return -1
        } else if ($truthy($rb_lt(r, 0))) {
          return 1
        } else {
          return 0
        };
      }
    });
    
    $def(self, '$==', function $Time_$eq_eq$5(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = $$$('Time')['$==='](other)))) {
        return self.$to_f() === other.$to_f()
      } else {
        return $ret_or_1
      }
    });
    
    $def(self, '$asctime', function $$asctime() {
      var self = this;

      return self.$strftime("%a %b %e %H:%M:%S %Y")
    });
    $send([["year", "getFullYear", "getUTCFullYear"], ["mon", "getMonth", "getUTCMonth", 1], ["wday", "getDay", "getUTCDay"], ["day", "getDate", "getUTCDate"], ["hour", "getHours", "getUTCHours"], ["min", "getMinutes", "getUTCMinutes"], ["sec", "getSeconds", "getUTCSeconds"]], 'each', [], function $Time$6(method, getter, utcgetter, difference){var self = $Time$6.$$s == null ? this : $Time$6.$$s;

      
      if (method == null) method = nil;
      if (getter == null) getter = nil;
      if (utcgetter == null) utcgetter = nil;
      if (difference == null) difference = 0;
      return $send(self, 'define_method', [method], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s;

        
        return difference + ((self.timezone != null) ?
          (new Date(self.getTime() + self.timezone * 3600000))[utcgetter]() :
          self[getter]())
      }, {$$s: self});}, {$$arity: -4, $$s: self});
    
    $def(self, '$yday', function $$yday() {
      var self = this, start_of_year = nil, start_of_day = nil, one_day = nil;

      
      start_of_year = $$('Time').$new(self.$year()).$to_i();
      start_of_day = $$('Time').$new(self.$year(), self.$month(), self.$day()).$to_i();
      one_day = 86400;
      return $rb_plus($rb_divide($rb_minus(start_of_day, start_of_year), one_day).$round(), 1);
    });
    
    $def(self, '$isdst', function $$isdst() {
      var self = this;

      
      var jan = new Date(self.getFullYear(), 0, 1),
          jul = new Date(self.getFullYear(), 6, 1);
      return self.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
    
    });
    
    $def(self, '$dup', function $$dup() {
      var self = this, copy = nil;

      
      copy = new Date(self.getTime());
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    });
    
    $def(self, '$eql?', function $Time_eql$ques$8(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = other['$is_a?']($$$('Time'))))) {
        return self['$<=>'](other)['$zero?']()
      } else {
        return $ret_or_1
      }
    });
    $send([["sunday?", 0], ["monday?", 1], ["tuesday?", 2], ["wednesday?", 3], ["thursday?", 4], ["friday?", 5], ["saturday?", 6]], 'each', [], function $Time$9(method, weekday){var self = $Time$9.$$s == null ? this : $Time$9.$$s;

      
      if (method == null) method = nil;
      if (weekday == null) weekday = nil;
      return $send(self, 'define_method', [method], function $$10(){var self = $$10.$$s == null ? this : $$10.$$s;

        return self.$wday() === weekday}, {$$s: self});}, {$$s: self});
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return [$$$('Time'), self.getTime()].$hash()
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      if ($truthy(self['$utc?']())) {
        return self.$strftime("%Y-%m-%d %H:%M:%S UTC")
      } else {
        return self.$strftime("%Y-%m-%d %H:%M:%S %z")
      }
    });
    
    $def(self, '$succ', function $$succ() {
      var self = this;

      
      var result = new Date(self.getTime() + 1000);
      result.timezone = self.timezone;
      return result;
    
    });
    
    $def(self, '$usec', function $$usec() {
      var self = this;

      return self.getMilliseconds() * 1000;
    });
    
    $def(self, '$zone', function $$zone() {
      var self = this;

      
      if (self.timezone === 0) return "UTC";
      else if (self.timezone != null) return nil;

      var string = self.toString(),
          result;

      if (string.indexOf('(') == -1) {
        result = string.match(/[A-Z]{3,4}/)[0];
      }
      else {
        result = string.match(/\((.+)\)(?:\s|$)/)[1]
      }

      if (result == "GMT" && /(GMT\W*\d{4})/.test(string)) {
        return RegExp.$1;
      }
      else {
        return result;
      }
    
    });
    
    $def(self, '$getgm', function $$getgm() {
      var self = this;

      
      var result = new Date(self.getTime());
      result.timezone = 0;
      return result;
    
    });
    
    $def(self, '$gmtime', function $$gmtime() {
      var self = this;

      
      if (self.timezone !== 0) {
        $deny_frozen_access(self);
        self.timezone = 0;
      }
      return self;
    
    });
    
    $def(self, '$gmt?', function $Time_gmt$ques$11() {
      var self = this;

      return self.timezone === 0;
    });
    
    $def(self, '$gmt_offset', function $$gmt_offset() {
      var self = this;

      return (self.timezone != null) ? self.timezone * 60 : -self.getTimezoneOffset() * 60;
    });
    
    $def(self, '$strftime', function $$strftime(format) {
      var self = this;

      
      return format.replace(/%([\-_#^0]*:{0,2})(\d+)?([EO]*)(.)/g, function(full, flags, width, _, conv) {
        var result = "", jd, c, s,
            zero   = flags.indexOf('0') !== -1,
            pad    = flags.indexOf('-') === -1,
            blank  = flags.indexOf('_') !== -1,
            upcase = flags.indexOf('^') !== -1,
            invert = flags.indexOf('#') !== -1,
            colons = (flags.match(':') || []).length;

        width = parseInt(width, 10);

        if (zero && blank) {
          if (flags.indexOf('0') < flags.indexOf('_')) {
            zero = false;
          }
          else {
            blank = false;
          }
        }

        switch (conv) {
          case 'Y':
            result += self.$year();
            break;

          case 'C':
            zero    = !blank;
            result += Math.round(self.$year() / 100);
            break;

          case 'y':
            zero    = !blank;
            result += (self.$year() % 100);
            break;

          case 'm':
            zero    = !blank;
            result += self.$mon();
            break;

          case 'B':
            result += long_months[self.$mon() - 1];
            break;

          case 'b':
          case 'h':
            blank   = !zero;
            result += short_months[self.$mon() - 1];
            break;

          case 'd':
            zero    = !blank
            result += self.$day();
            break;

          case 'e':
            blank   = !zero
            result += self.$day();
            break;

          case 'j':
            zero    = !blank;
            width   = isNaN(width) ? 3 : width;
            result += self.$yday();
            break;

          case 'H':
            zero    = !blank;
            result += self.$hour();
            break;

          case 'k':
            blank   = !zero;
            result += self.$hour();
            break;

          case 'I':
            zero    = !blank;
            result += (self.$hour() % 12 || 12);
            break;

          case 'l':
            blank   = !zero;
            result += (self.$hour() % 12 || 12);
            break;

          case 'P':
            result += (self.$hour() >= 12 ? "pm" : "am");
            break;

          case 'p':
            result += (self.$hour() >= 12 ? "PM" : "AM");
            break;

          case 'M':
            zero    = !blank;
            result += self.$min();
            break;

          case 'S':
            zero    = !blank;
            result += self.$sec()
            break;

          case 'L':
            zero    = !blank;
            width   = isNaN(width) ? 3 : width;
            result += self.getMilliseconds();
            break;

          case 'N':
            width   = isNaN(width) ? 9 : width;
            result += (self.getMilliseconds().toString()).$rjust(3, "0");
            result  = (result).$ljust(width, "0");
            break;

          case 'z':
            var offset  = (self.timezone == null) ? self.getTimezoneOffset() : (-self.timezone * 60),
                hours   = Math.floor(Math.abs(offset) / 60),
                minutes = Math.abs(offset) % 60;

            result += offset < 0 ? "+" : "-";
            result += hours < 10 ? "0" : "";
            result += hours;

            if (colons > 0) {
              result += ":";
            }

            result += minutes < 10 ? "0" : "";
            result += minutes;

            if (colons > 1) {
              result += ":00";
            }

            break;

          case 'Z':
            result += self.$zone();
            break;

          case 'A':
            result += days_of_week[self.$wday()];
            break;

          case 'a':
            result += short_days[self.$wday()];
            break;

          case 'u':
            result += (self.$wday() + 1);
            break;

          case 'w':
            result += self.$wday();
            break;

          case 'V':
            result += self.$cweek_cyear()['$[]'](0).$to_s().$rjust(2, "0");
            break;

          case 'G':
            result += self.$cweek_cyear()['$[]'](1);
            break;

          case 'g':
            result += self.$cweek_cyear()['$[]'](1)['$[]']($range(-2, -1, false));
            break;

          case 's':
            result += self.$to_i();
            break;

          case 'n':
            result += "\n";
            break;

          case 't':
            result += "\t";
            break;

          case '%':
            result += "%";
            break;

          case 'c':
            result += self.$strftime("%a %b %e %T %Y");
            break;

          case 'D':
          case 'x':
            result += self.$strftime("%m/%d/%y");
            break;

          case 'F':
            result += self.$strftime("%Y-%m-%d");
            break;

          case 'v':
            result += self.$strftime("%e-%^b-%4Y");
            break;

          case 'r':
            result += self.$strftime("%I:%M:%S %p");
            break;

          case 'R':
            result += self.$strftime("%H:%M");
            break;

          case 'T':
          case 'X':
            result += self.$strftime("%H:%M:%S");
            break;

          // Non-standard: JIS X 0301 date format
          case 'J':
            jd = self.$to_date().$jd();
            if (jd < 2405160) {
              result += self.$strftime("%Y-%m-%d");
              break;
            }
            else if (jd < 2419614)
              c = 'M', s = 1867;
            else if (jd < 2424875)
              c = 'T', s = 1911;
            else if (jd < 2447535)
              c = 'S', s = 1925;
            else if (jd < 2458605)
              c = 'H', s = 1988;
            else
              c = 'R', s = 2018;

            result += self.$format("%c%02d", c, $rb_minus(self.$year(), s));
            result += self.$strftime("-%m-%d");
            break;

          default:
            return full;
        }

        if (upcase) {
          result = result.toUpperCase();
        }

        if (invert) {
          result = result.replace(/[A-Z]/, function(c) { c.toLowerCase() }).
                          replace(/[a-z]/, function(c) { c.toUpperCase() });
        }

        if (pad && (zero || blank)) {
          result = (result).$rjust(isNaN(width) ? 2 : width, blank ? " " : "0");
        }

        return result;
      });
    
    });
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      return [self.$sec(), self.$min(), self.$hour(), self.$day(), self.$month(), self.$year(), self.$wday(), self.$yday(), self.$isdst(), self.$zone()]
    });
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      return self.getTime() / 1000;
    });
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      return parseInt(self.getTime() / 1000, 10);
    });
    
    $def(self, '$cweek_cyear', function $$cweek_cyear() {
      var self = this, jan01 = nil, jan01_wday = nil, first_monday = nil, year = nil, offset = nil, week = nil, dec31 = nil, dec31_wday = nil;

      
      jan01 = $$$('Time').$new(self.$year(), 1, 1);
      jan01_wday = jan01.$wday();
      first_monday = 0;
      year = self.$year();
      if (($truthy($rb_le(jan01_wday, 4)) && ($neqeq(jan01_wday, 0)))) {
        offset = $rb_minus(jan01_wday, 1)
      } else {
        
        offset = $rb_minus($rb_minus(jan01_wday, 7), 1);
        if ($eqeq(offset, -8)) {
          offset = -1
        };
      };
      week = $rb_divide($rb_plus(self.$yday(), offset), 7.0).$ceil();
      if ($truthy($rb_le(week, 0))) {
        return $$$('Time').$new($rb_minus(self.$year(), 1), 12, 31).$cweek_cyear()
      } else if ($eqeq(week, 53)) {
        
        dec31 = $$$('Time').$new(self.$year(), 12, 31);
        dec31_wday = dec31.$wday();
        if (($truthy($rb_le(dec31_wday, 3)) && ($neqeq(dec31_wday, 0)))) {
          
          week = 1;
          year = $rb_plus(year, 1);
        };
      };
      return [week, year];
    });
    (function(self, $parent_nesting) {
      
      
      $alias(self, "mktime", "local");
      return $alias(self, "utc", "gm");
    })(Opal.get_singleton_class(self), $nesting);
    $alias(self, "ctime", "asctime");
    $alias(self, "dst?", "isdst");
    $alias(self, "getutc", "getgm");
    $alias(self, "gmtoff", "gmt_offset");
    $alias(self, "mday", "day");
    $alias(self, "month", "mon");
    $alias(self, "to_s", "inspect");
    $alias(self, "tv_sec", "to_i");
    $alias(self, "tv_usec", "usec");
    $alias(self, "utc", "gmtime");
    $alias(self, "utc?", "gmt?");
    return $alias(self, "utc_offset", "gmt_offset");
  })('::', Date, $nesting);
};

Opal.modules["corelib/struct"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  var $klass = Opal.klass, $slice = Opal.slice, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $truthy = Opal.truthy, $neqeq = Opal.neqeq, $eqeq = Opal.eqeq, $Opal = Opal.Opal, $send = Opal.send, $Class = Opal.Class, $to_a = Opal.to_a, $def = Opal.def, $defs = Opal.defs, $Kernel = Opal.Kernel, $to_s = Opal.to_s, $rb_gt = Opal.rb_gt, $rb_minus = Opal.rb_minus, $eqeqeq = Opal.eqeqeq, $rb_lt = Opal.rb_lt, $rb_ge = Opal.rb_ge, $rb_plus = Opal.rb_plus, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,!=,upcase,[],==,class,unshift,const_name!,map,coerce_to!,new,each,define_struct_attribute,allocate,initialize,alias_method,module_eval,to_proc,const_set,raise,<<,members,define_method,instance_eval,last,>,length,-,keys,any?,join,[]=,each_with_index,hash,to_a,===,<,-@,size,>=,include?,to_sym,instance_of?,__id__,eql?,enum_for,+,name,each_pair,inspect,to_h,each_with_object,flatten,respond_to?,dig');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Struct');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Enumerable'));
    $defs(self, '$new', function $Struct_new$1(const_name, $a, $b) {
      var block = $Struct_new$1.$$p || nil, $post_args, $kwargs, args, keyword_init, self = this, klass = nil;

      $Struct_new$1.$$p = null;
      
      ;
      $post_args = $slice(arguments, 1);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      args = $post_args;
      
      keyword_init = $hash_get($kwargs, "keyword_init");if (keyword_init == null) keyword_init = false;
      if ($truthy(const_name)) {
        if (($eqeq(const_name.$class(), $$$('String')) && ($neqeq(const_name['$[]'](0).$upcase(), const_name['$[]'](0))))) {
          
          args.$unshift(const_name);
          const_name = nil;
        } else {
          
          try {
            const_name = $Opal['$const_name!'](const_name)
          } catch ($err) {
            if (Opal.rescue($err, [$$$('TypeError'), $$$('NameError')])) {
              try {
                
                args.$unshift(const_name);
                const_name = nil;
              } finally { Opal.pop_exception($err); }
            } else { throw $err; }
          };
        }
      };
      $send(args, 'map', [], function $$2(arg){
        
        if (arg == null) arg = nil;
        return $Opal['$coerce_to!'](arg, $$$('String'), "to_str");});
      klass = $send($Class, 'new', [self], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

        
        $send(args, 'each', [], function $$4(arg){var self = $$4.$$s == null ? this : $$4.$$s;

          
          if (arg == null) arg = nil;
          return self.$define_struct_attribute(arg);}, {$$s: self});
        return (function(self, $parent_nesting) {
          
          
          
          $def(self, '$new', function $new$5($a) {
            var $post_args, args, self = this, instance = nil;

            
            $post_args = $slice(arguments);
            args = $post_args;
            instance = self.$allocate();
            instance.$$data = {};
            $send(instance, 'initialize', $to_a(args));
            return instance;
          }, -1);
          return self.$alias_method("[]", "new");
        })(Opal.get_singleton_class(self), $nesting);}, {$$s: self});
      if ($truthy(block)) {
        $send(klass, 'module_eval', [], block.$to_proc())
      };
      klass.$$keyword_init = keyword_init;
      if ($truthy(const_name)) {
        $$$('Struct').$const_set(const_name, klass)
      };
      return klass;
    }, -2);
    $defs(self, '$define_struct_attribute', function $$define_struct_attribute(name) {
      var self = this;

      
      if ($eqeq(self, $$$('Struct'))) {
        $Kernel.$raise($$$('ArgumentError'), "you cannot define attributes to the Struct class")
      };
      self.$members()['$<<'](name);
      $send(self, 'define_method', [name], function $$6(){var self = $$6.$$s == null ? this : $$6.$$s;

        return self.$$data[name];}, {$$s: self});
      return $send(self, 'define_method', [$to_s(name) + "="], function $$7(value){var self = $$7.$$s == null ? this : $$7.$$s;

        
        if (value == null) value = nil;
        return self.$$data[name] = value;;}, {$$s: self});
    });
    $defs(self, '$members', function $$members() {
      var self = this, $ret_or_1 = nil;
      if (self.members == null) self.members = nil;

      
      if ($eqeq(self, $$$('Struct'))) {
        $Kernel.$raise($$$('ArgumentError'), "the Struct class has no members")
      };
      return (self.members = ($truthy(($ret_or_1 = self.members)) ? ($ret_or_1) : ([])));
    });
    $defs(self, '$inherited', function $$inherited(klass) {
      var self = this, members = nil;
      if (self.members == null) self.members = nil;

      
      members = self.members;
      return $send(klass, 'instance_eval', [], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s;

        return (self.members = members)}, {$$s: self});
    });
    
    $def(self, '$initialize', function $$initialize($a) {
      var $post_args, args, self = this, kwargs = nil, $ret_or_1 = nil, extra = nil;

      
      $post_args = $slice(arguments);
      args = $post_args;
      if ($truthy(self.$class().$$keyword_init)) {
        
        kwargs = ($truthy(($ret_or_1 = args.$last())) ? ($ret_or_1) : ((new Map())));
        if (($truthy($rb_gt(args.$length(), 1)) || ($truthy((args.length === 1 && !kwargs.$$is_hash))))) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (given " + $to_s(args.$length()) + ", expected 0)")
        };
        extra = $rb_minus(kwargs.$keys(), self.$class().$members());
        if ($truthy(extra['$any?']())) {
          $Kernel.$raise($$$('ArgumentError'), "unknown keywords: " + $to_s(extra.$join(", ")))
        };
        return $send(self.$class().$members(), 'each', [], function $$9(name){var $b, self = $$9.$$s == null ? this : $$9.$$s;

          
          if (name == null) name = nil;
          return ($b = [name, kwargs['$[]'](name)], $send(self, '[]=', $b), $b[$b.length - 1]);}, {$$s: self});
      } else {
        
        if ($truthy($rb_gt(args.$length(), self.$class().$members().$length()))) {
          $Kernel.$raise($$$('ArgumentError'), "struct size differs")
        };
        return $send(self.$class().$members(), 'each_with_index', [], function $$10(name, index){var $b, self = $$10.$$s == null ? this : $$10.$$s;

          
          if (name == null) name = nil;
          if (index == null) index = nil;
          return ($b = [name, args['$[]'](index)], $send(self, '[]=', $b), $b[$b.length - 1]);}, {$$s: self});
      };
    }, -1);
    
    $def(self, '$initialize_copy', function $$initialize_copy(from) {
      var self = this;

      
      self.$$data = {}
      var keys = Object.keys(from.$$data), i, max, name;
      for (i = 0, max = keys.length; i < max; i++) {
        name = keys[i];
        self.$$data[name] = from.$$data[name];
      }
    
    });
    $defs(self, '$keyword_init?', function $Struct_keyword_init$ques$11() {
      var self = this;

      return self.$$keyword_init;
    });
    
    $def(self, '$members', function $$members() {
      var self = this;

      return self.$class().$members()
    });
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return [self.$class(), self.$to_a()].$hash()
    });
    
    $def(self, '$[]', function $Struct_$$$12(name) {
      var self = this;

      
      if ($eqeqeq($$$('Integer'), name)) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + $to_s(name) + " too small for struct(size:" + $to_s(self.$class().$members().$size()) + ")")
        };
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + $to_s(name) + " too large for struct(size:" + $to_s(self.$class().$members().$size()) + ")")
        };
        name = self.$class().$members()['$[]'](name);
      } else if ($eqeqeq($$$('String'), name)) {
        
        if(!self.$$data.hasOwnProperty(name)) {
          $Kernel.$raise($$$('NameError').$new("no member '" + $to_s(name) + "' in struct", name))
        }
      
      } else {
        $Kernel.$raise($$$('TypeError'), "no implicit conversion of " + $to_s(name.$class()) + " into Integer")
      };
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      return self.$$data[name];;
    });
    
    $def(self, '$[]=', function $Struct_$$$eq$13(name, value) {
      var self = this;

      
      if ($eqeqeq($$$('Integer'), name)) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + $to_s(name) + " too small for struct(size:" + $to_s(self.$class().$members().$size()) + ")")
        };
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + $to_s(name) + " too large for struct(size:" + $to_s(self.$class().$members().$size()) + ")")
        };
        name = self.$class().$members()['$[]'](name);
      } else if ($eqeqeq($$$('String'), name)) {
        if (!$truthy(self.$class().$members()['$include?'](name.$to_sym()))) {
          $Kernel.$raise($$$('NameError').$new("no member '" + $to_s(name) + "' in struct", name))
        }
      } else {
        $Kernel.$raise($$$('TypeError'), "no implicit conversion of " + $to_s(name.$class()) + " into Integer")
      };
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      return self.$$data[name] = value;;
    });
    
    $def(self, '$==', function $Struct_$eq_eq$14(other) {
      var self = this;

      
      if (!$truthy(other['$instance_of?'](self.$class()))) {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$$('Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    });
    
    $def(self, '$eql?', function $Struct_eql$ques$15(other) {
      var self = this;

      
      if (!$truthy(other['$instance_of?'](self.$class()))) {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$$('Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    });
    
    $def(self, '$each', function $$each() {
      var $yield = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["each"], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          return self.$size()}, {$$s: self})
      };
      $send(self.$class().$members(), 'each', [], function $$17(name){var self = $$17.$$s == null ? this : $$17.$$s;

        
        if (name == null) name = nil;
        return Opal.yield1($yield, self['$[]'](name));;}, {$$s: self});
      return self;
    });
    
    $def(self, '$each_pair', function $$each_pair() {
      var $yield = $$each_pair.$$p || nil, self = this;

      $$each_pair.$$p = null;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["each_pair"], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s;

          return self.$size()}, {$$s: self})
      };
      $send(self.$class().$members(), 'each', [], function $$19(name){var self = $$19.$$s == null ? this : $$19.$$s;

        
        if (name == null) name = nil;
        return Opal.yield1($yield, [name, self['$[]'](name)]);;}, {$$s: self});
      return self;
    });
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.$class().$members().$length()
    });
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      return $send(self.$class().$members(), 'map', [], function $$20(name){var self = $$20.$$s == null ? this : $$20.$$s;

        
        if (name == null) name = nil;
        return self['$[]'](name);}, {$$s: self})
    });
    var inspect_stack = [];
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, result = nil, pushed = nil;

      return (function() { try {
      
      result = "#<struct ";
      if ($truthy((inspect_stack)['$include?'](self.$__id__()))) {
        return $rb_plus(result, ":...>")
      } else {
        
        (inspect_stack)['$<<'](self.$__id__());
        pushed = true;
        if (($eqeqeq($$$('Struct'), self) && ($truthy(self.$class().$name())))) {
          result = $rb_plus(result, $to_s(self.$class()) + " ")
        };
        result = $rb_plus(result, $send(self.$each_pair(), 'map', [], function $$21(name, value){
          
          if (name == null) name = nil;
          if (value == null) value = nil;
          return $to_s(name) + "=" + $to_s($$('Opal').$inspect(value));}).$join(", "));
        result = $rb_plus(result, ">");
        return result;
      };
      } finally {
        ($truthy(pushed) ? (inspect_stack.pop()) : nil)
      }; })()
    });
    
    $def(self, '$to_h', function $$to_h($a) {
      var block = $$to_h.$$p || nil, $post_args, args, self = this;

      $$to_h.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      if ((block !== nil)) {
        return $send($send(self, 'map', [], block.$to_proc()), 'to_h', $to_a(args))
      };
      return $send(self.$class().$members(), 'each_with_object', [(new Map())], function $$22(name, h){var $b, self = $$22.$$s == null ? this : $$22.$$s;

        
        if (name == null) name = nil;
        if (h == null) h = nil;
        return ($b = [name, self['$[]'](name)], $send(h, '[]=', $b), $b[$b.length - 1]);}, {$$s: self});
    }, -1);
    
    $def(self, '$values_at', function $$values_at($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      args = $send(args, 'map', [], function $$23(arg){
        
        if (arg == null) arg = nil;
        return arg.$$is_range ? arg.$to_a() : arg;}).$flatten();
      
      var result = [];
      for (var i = 0, len = args.length; i < len; i++) {
        if (!args[i].$$is_number) {
          $Kernel.$raise($$$('TypeError'), "no implicit conversion of " + $to_s((args[i]).$class()) + " into Integer")
        }
        result.push(self['$[]'](args[i]));
      }
      return result;
    ;
    }, -1);
    
    $def(self, '$dig', function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      $post_args = $slice(arguments, 1);
      keys = $post_args;
      item = ($truthy(key.$$is_string && self.$$data.hasOwnProperty(key)) ? (self.$$data[key] || nil) : nil);
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if (!$truthy(item['$respond_to?']("dig"))) {
        $Kernel.$raise($$$('TypeError'), $to_s(item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', $to_a(keys));
    }, -2);
    $alias(self, "size", "length");
    $alias(self, "to_s", "inspect");
    return $alias(self, "values", "to_a");
  })('::', null, $nesting);
};

Opal.modules["corelib/set"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $freeze = Opal.freeze, $klass = Opal.klass, $slice = Opal.slice, $defs = Opal.defs, $truthy = Opal.truthy, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $send = Opal.send, $def = Opal.def, $to_s = Opal.to_s, $eqeq = Opal.eqeq, $rb_lt = Opal.rb_lt, $rb_le = Opal.rb_le, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,new,nil?,===,raise,each,add,merge,class,respond_to?,subtract,dup,join,to_a,equal?,instance_of?,==,instance_variable_get,size,is_a?,all?,include?,[]=,enum_for,[],<<,replace,compare_by_identity,name,compare_by_identity?,delete,select,frozen?,freeze,reject,delete_if,to_proc,keep_if,each_key,empty?,eql?,instance_eval,clear,<,<=,any?,!,intersect?,keys,|,proper_subset?,subset?,proper_superset?,superset?,-,select!,collect!');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Set');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $ret_or_1 = nil, $proto = self.$$prototype;

    $proto.hash = nil;
    
    self.$include($$$('Enumerable'));
    $defs(self, '$[]', function $Set_$$$1($a) {
      var $post_args, ary, self = this;

      
      $post_args = $slice(arguments);
      ary = $post_args;
      return self.$new(ary);
    }, -1);
    
    $def(self, '$initialize', function $$initialize(enum$) {
      var block = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      ;
      if (enum$ == null) enum$ = nil;
      self.hash = (new Map());
      if ($truthy(enum$['$nil?']())) {
        return nil
      };
      if (!$eqeqeq($$$('Enumerable'), enum$)) {
        $Kernel.$raise($$$('ArgumentError'), "value must be enumerable")
      };
      if ($truthy(block)) {
        return $send(enum$, 'each', [], function $$2(item){var self = $$2.$$s == null ? this : $$2.$$s;

          
          if (item == null) item = nil;
          return self.$add(Opal.yield1(block, item));}, {$$s: self})
      } else {
        return self.$merge(enum$)
      };
    }, -1);
    
    $def(self, '$dup', function $$dup() {
      var self = this, result = nil;

      
      result = self.$class().$new();
      return result.$merge(self);
    });
    
    $def(self, '$-', function $Set_$minus$3(enum$) {
      var self = this;

      
      if (!$truthy(enum$['$respond_to?']("each"))) {
        $Kernel.$raise($$$('ArgumentError'), "value must be enumerable")
      };
      return self.$dup().$subtract(enum$);
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<Set: {" + $to_s(self.$to_a().$join(",")) + "}>"
    });
    
    $def(self, '$==', function $Set_$eq_eq$4(other) {
      var self = this;

      if ($truthy(self['$equal?'](other))) {
        return true
      } else if ($truthy(other['$instance_of?'](self.$class()))) {
        return self.hash['$=='](other.$instance_variable_get("@hash"))
      } else if (($truthy(other['$is_a?']($$$('Set'))) && ($eqeq(self.$size(), other.$size())))) {
        return $send(other, 'all?', [], function $$5(o){var self = $$5.$$s == null ? this : $$5.$$s;
          if (self.hash == null) self.hash = nil;

          
          if (o == null) o = nil;
          return self.hash['$include?'](o);}, {$$s: self})
      } else {
        return false
      }
    });
    
    $def(self, '$add', function $$add(o) {
      var self = this;

      
      self.hash['$[]='](o, true);
      return self;
    });
    
    $def(self, '$classify', function $$classify() {
      var block = $$classify.$$p || nil, self = this, result = nil;

      $$classify.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("classify")
      };
      result = $send($$$('Hash'), 'new', [], function $$6(h, k){var $a, self = $$6.$$s == null ? this : $$6.$$s;

        
        if (h == null) h = nil;
        if (k == null) k = nil;
        return ($a = [k, self.$class().$new()], $send(h, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});
      $send(self, 'each', [], function $$7(item){
        
        if (item == null) item = nil;
        return result['$[]'](Opal.yield1(block, item)).$add(item);});
      return result;
    });
    
    $def(self, '$collect!', function $Set_collect$excl$8() {
      var block = $Set_collect$excl$8.$$p || nil, self = this, result = nil;

      $Set_collect$excl$8.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("collect!")
      };
      result = self.$class().$new();
      $send(self, 'each', [], function $$9(item){
        
        if (item == null) item = nil;
        return result['$<<'](Opal.yield1(block, item));});
      return self.$replace(result);
    });
    
    $def(self, '$compare_by_identity', function $$compare_by_identity() {
      var self = this;

      if ($truthy(self.hash['$respond_to?']("compare_by_identity"))) {
        
        self.hash.$compare_by_identity();
        return self;
      } else {
        return self.$raise($$('NotImplementedError'), $to_s(self.$class().$name()) + "#" + $to_s("compare_by_identity") + " is not implemented")
      }
    });
    
    $def(self, '$compare_by_identity?', function $Set_compare_by_identity$ques$10() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.hash['$respond_to?']("compare_by_identity?")))) {
        return self.hash['$compare_by_identity?']()
      } else {
        return $ret_or_1
      }
    });
    
    $def(self, '$delete', function $Set_delete$11(o) {
      var self = this;

      
      self.hash.$delete(o);
      return self;
    });
    
    $def(self, '$delete?', function $Set_delete$ques$12(o) {
      var self = this;

      if ($truthy(self['$include?'](o))) {
        
        self.$delete(o);
        return self;
      } else {
        return nil
      }
    });
    
    $def(self, '$delete_if', function $$delete_if() {
      var $yield = $$delete_if.$$p || nil, self = this;

      $$delete_if.$$p = null;
      
      if (!($yield !== nil)) {
        return self.$enum_for("delete_if")
      };
      $send($send(self, 'select', [], function $$13(o){
        
        if (o == null) o = nil;
        return Opal.yield1($yield, o);;}), 'each', [], function $$14(o){var self = $$14.$$s == null ? this : $$14.$$s;
        if (self.hash == null) self.hash = nil;

        
        if (o == null) o = nil;
        return self.hash.$delete(o);}, {$$s: self});
      return self;
    });
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      self.hash.$freeze();
      return $freeze(self);;
    });
    
    $def(self, '$keep_if', function $$keep_if() {
      var $yield = $$keep_if.$$p || nil, self = this;

      $$keep_if.$$p = null;
      
      if (!($yield !== nil)) {
        return self.$enum_for("keep_if")
      };
      $send($send(self, 'reject', [], function $$15(o){
        
        if (o == null) o = nil;
        return Opal.yield1($yield, o);;}), 'each', [], function $$16(o){var self = $$16.$$s == null ? this : $$16.$$s;
        if (self.hash == null) self.hash = nil;

        
        if (o == null) o = nil;
        return self.hash.$delete(o);}, {$$s: self});
      return self;
    });
    
    $def(self, '$reject!', function $Set_reject$excl$17() {
      var block = $Set_reject$excl$17.$$p || nil, self = this, before = nil;

      $Set_reject$excl$17.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("reject!")
      };
      before = self.$size();
      $send(self, 'delete_if', [], block.$to_proc());
      if ($eqeq(self.$size(), before)) {
        return nil
      } else {
        return self
      };
    });
    
    $def(self, '$select!', function $Set_select$excl$18() {
      var block = $Set_select$excl$18.$$p || nil, self = this, before = nil;

      $Set_select$excl$18.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("select!")
      };
      before = self.$size();
      $send(self, 'keep_if', [], block.$to_proc());
      if ($eqeq(self.$size(), before)) {
        return nil
      } else {
        return self
      };
    });
    
    $def(self, '$add?', function $Set_add$ques$19(o) {
      var self = this;

      if ($truthy(self['$include?'](o))) {
        return nil
      } else {
        return self.$add(o)
      }
    });
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("each")
      };
      $send(self.hash, 'each_key', [], block.$to_proc());
      return self;
    });
    
    $def(self, '$empty?', function $Set_empty$ques$20() {
      var self = this;

      return self.hash['$empty?']()
    });
    
    $def(self, '$eql?', function $Set_eql$ques$21(other) {
      var self = this;

      return self.hash['$eql?']($send(other, 'instance_eval', [], function $$22(){var self = $$22.$$s == null ? this : $$22.$$s;
        if (self.hash == null) self.hash = nil;

        return self.hash}, {$$s: self}))
    });
    
    $def(self, '$clear', function $$clear() {
      var self = this;

      
      self.hash.$clear();
      return self;
    });
    
    $def(self, '$include?', function $Set_include$ques$23(o) {
      var self = this;

      return self.hash['$include?'](o)
    });
    
    $def(self, '$merge', function $$merge(enum$) {
      var self = this;

      
      $send(enum$, 'each', [], function $$24(item){var self = $$24.$$s == null ? this : $$24.$$s;

        
        if (item == null) item = nil;
        return self.$add(item);}, {$$s: self});
      return self;
    });
    
    $def(self, '$replace', function $$replace(enum$) {
      var self = this;

      
      self.$clear();
      self.$merge(enum$);
      return self;
    });
    
    $def(self, '$size', function $$size() {
      var self = this;

      return self.hash.$size()
    });
    
    $def(self, '$subtract', function $$subtract(enum$) {
      var self = this;

      
      $send(enum$, 'each', [], function $$25(item){var self = $$25.$$s == null ? this : $$25.$$s;

        
        if (item == null) item = nil;
        return self.$delete(item);}, {$$s: self});
      return self;
    });
    
    $def(self, '$|', function $Set_$$26(enum$) {
      var self = this;

      
      if (!$truthy(enum$['$respond_to?']("each"))) {
        $Kernel.$raise($$$('ArgumentError'), "value must be enumerable")
      };
      return self.$dup().$merge(enum$);
    });
    
    function is_set(set) {
      ($truthy(($ret_or_1 = (set)['$is_a?']($$$('Set')))) ? ($ret_or_1) : ($Kernel.$raise($$$('ArgumentError'), "value must be a set")))
    }
  ;
    
    $def(self, '$superset?', function $Set_superset$ques$27(set) {
      var self = this;

      
      is_set(set);
      if ($truthy($rb_lt(self.$size(), set.$size()))) {
        return false
      };
      return $send(set, 'all?', [], function $$28(o){var self = $$28.$$s == null ? this : $$28.$$s;

        
        if (o == null) o = nil;
        return self['$include?'](o);}, {$$s: self});
    });
    
    $def(self, '$proper_superset?', function $Set_proper_superset$ques$29(set) {
      var self = this;

      
      is_set(set);
      if ($truthy($rb_le(self.$size(), set.$size()))) {
        return false
      };
      return $send(set, 'all?', [], function $$30(o){var self = $$30.$$s == null ? this : $$30.$$s;

        
        if (o == null) o = nil;
        return self['$include?'](o);}, {$$s: self});
    });
    
    $def(self, '$subset?', function $Set_subset$ques$31(set) {
      var self = this;

      
      is_set(set);
      if ($truthy($rb_lt(set.$size(), self.$size()))) {
        return false
      };
      return $send(self, 'all?', [], function $$32(o){
        
        if (o == null) o = nil;
        return set['$include?'](o);});
    });
    
    $def(self, '$proper_subset?', function $Set_proper_subset$ques$33(set) {
      var self = this;

      
      is_set(set);
      if ($truthy($rb_le(set.$size(), self.$size()))) {
        return false
      };
      return $send(self, 'all?', [], function $$34(o){
        
        if (o == null) o = nil;
        return set['$include?'](o);});
    });
    
    $def(self, '$intersect?', function $Set_intersect$ques$35(set) {
      var self = this;

      
      is_set(set);
      if ($truthy($rb_lt(self.$size(), set.$size()))) {
        return $send(self, 'any?', [], function $$36(o){
          
          if (o == null) o = nil;
          return set['$include?'](o);})
      } else {
        return $send(set, 'any?', [], function $$37(o){var self = $$37.$$s == null ? this : $$37.$$s;

          
          if (o == null) o = nil;
          return self['$include?'](o);}, {$$s: self})
      };
    });
    
    $def(self, '$disjoint?', function $Set_disjoint$ques$38(set) {
      var self = this;

      return self['$intersect?'](set)['$!']()
    });
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      return self.hash.$keys()
    });
    $alias(self, "+", "|");
    $alias(self, "<", "proper_subset?");
    $alias(self, "<<", "add");
    $alias(self, "<=", "subset?");
    $alias(self, ">", "proper_superset?");
    $alias(self, ">=", "superset?");
    $alias(self, "difference", "-");
    $alias(self, "filter!", "select!");
    $alias(self, "length", "size");
    $alias(self, "map!", "collect!");
    $alias(self, "member?", "include?");
    return $alias(self, "union", "|");
  })('::', null, $nesting)
};

Opal.modules["corelib/dir"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  var $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('[],pwd');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Dir');

    var $nesting = [self].concat($parent_nesting);

    return (function(self, $parent_nesting) {
      
      
      
      $def(self, '$chdir', function $$chdir(dir) {
        var $yield = $$chdir.$$p || nil, prev_cwd = nil;

        $$chdir.$$p = null;
        return (function() { try {
        
        prev_cwd = Opal.current_dir;
        Opal.current_dir = dir;
        return Opal.yieldX($yield, []);;
        } finally {
          Opal.current_dir = prev_cwd
        }; })()
      });
      
      $def(self, '$pwd', function $$pwd() {
        
        return Opal.current_dir || '.';
      });
      
      $def(self, '$home', function $$home() {
        var $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = $$$('ENV')['$[]']("HOME")))) {
          return $ret_or_1
        } else {
          return "."
        }
      });
      return $alias(self, "getwd", "pwd");
    })(Opal.get_singleton_class(self), $nesting)
  })('::', null, $nesting)
};

Opal.modules["corelib/file"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  var $truthy = Opal.truthy, $klass = Opal.klass, $const_set = Opal.const_set, $annotate_regexp = Opal.annotate_regexp, $Opal = Opal.Opal, $regexp = Opal.regexp, $rb_plus = Opal.rb_plus, $def = Opal.def, $Kernel = Opal.Kernel, $eqeq = Opal.eqeq, $rb_lt = Opal.rb_lt, $to_s = Opal.to_s, $rb_minus = Opal.rb_minus, $range = Opal.range, $send = Opal.send, $slice = Opal.slice, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('respond_to?,to_path,coerce_to!,pwd,split,sub,+,unshift,join,home,raise,start_with?,absolute_path,==,<,dirname,-,basename,empty?,rindex,[],length,nil?,gsub,find,=~,map,each_with_index,flatten,reject,to_proc,end_with?,expand_path,exist?');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'File');

    var $nesting = [self].concat($parent_nesting), windows_root_rx = nil;

    
    $const_set($nesting[0], 'Separator', $const_set($nesting[0], 'SEPARATOR', "/"));
    $const_set($nesting[0], 'ALT_SEPARATOR', nil);
    $const_set($nesting[0], 'PATH_SEPARATOR', ":");
    $const_set($nesting[0], 'FNM_SYSCASE', 0);
    windows_root_rx = $annotate_regexp(/^[a-zA-Z]:(?:\\|\/)/um, null, "");
    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$absolute_path', function $$absolute_path(path, basedir) {
        var sep = nil, sep_chars = nil, new_parts = nil, $ret_or_1 = nil, path_abs = nil, basedir_abs = nil, parts = nil, leading_sep = nil, abs = nil, new_path = nil;

        
        if (basedir == null) basedir = nil;
        sep = $$('SEPARATOR');
        sep_chars = $sep_chars();
        new_parts = [];
        path = ($truthy(path['$respond_to?']("to_path")) ? (path.$to_path()) : (path));
        path = $Opal['$coerce_to!'](path, $$$('String'), "to_str");
        basedir = ($truthy(($ret_or_1 = basedir)) ? ($ret_or_1) : ($$$('Dir').$pwd()));
        path_abs = path.substr(0, sep.length) === sep || windows_root_rx.test(path);
        basedir_abs = basedir.substr(0, sep.length) === sep || windows_root_rx.test(basedir);
        if ($truthy(path_abs)) {
          
          parts = path.$split($regexp(["[", sep_chars, "]"]));
          leading_sep = windows_root_rx.test(path) ? '' : path.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          abs = true;
        } else {
          
          parts = $rb_plus(basedir.$split($regexp(["[", sep_chars, "]"])), path.$split($regexp(["[", sep_chars, "]"])));
          leading_sep = windows_root_rx.test(basedir) ? '' : basedir.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          abs = basedir_abs;
        };
        
        var part;
        for (var i = 0, ii = parts.length; i < ii; i++) {
          part = parts[i];

          if (
            (part === nil) ||
            (part == ''  && ((new_parts.length === 0) || abs)) ||
            (part == '.' && ((new_parts.length === 0) || abs))
          ) {
            continue;
          }
          if (part == '..') {
            new_parts.pop();
          } else {
            new_parts.push(part);
          }
        }

        if (!abs && parts[0] != '.') {
          new_parts.$unshift(".")
        }
      ;
        new_path = new_parts.$join(sep);
        if ($truthy(abs)) {
          new_path = $rb_plus(leading_sep, new_path)
        };
        return new_path;
      }, -2);
      
      $def(self, '$expand_path', function $$expand_path(path, basedir) {
        var self = this, sep = nil, sep_chars = nil, home = nil, leading_sep = nil, home_path_regexp = nil;

        
        if (basedir == null) basedir = nil;
        sep = $$('SEPARATOR');
        sep_chars = $sep_chars();
        if ($truthy(path[0] === '~' || (basedir && basedir[0] === '~'))) {
          
          home = $$('Dir').$home();
          if (!$truthy(home)) {
            $Kernel.$raise($$$('ArgumentError'), "couldn't find HOME environment -- expanding `~'")
          };
          leading_sep = windows_root_rx.test(home) ? '' : home.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          if (!$truthy(home['$start_with?'](leading_sep))) {
            $Kernel.$raise($$$('ArgumentError'), "non-absolute home")
          };
          home = $rb_plus(home, sep);
          home_path_regexp = $regexp(["^\\~(?:", sep, "|$)"]);
          path = path.$sub(home_path_regexp, home);
          if ($truthy(basedir)) {
            basedir = basedir.$sub(home_path_regexp, home)
          };
        };
        return self.$absolute_path(path, basedir);
      }, -2);
      
      // Coerce a given path to a path string using #to_path and #to_str
      function $coerce_to_path(path) {
        if ($truthy((path)['$respond_to?']("to_path"))) {
          path = path.$to_path();
        }

        path = $Opal['$coerce_to!'](path, $$$('String'), "to_str");

        return path;
      }

      // Return a RegExp compatible char class
      function $sep_chars() {
        if ($$('ALT_SEPARATOR') === nil) {
          return Opal.escape_regexp($$('SEPARATOR'));
        } else {
          return Opal.escape_regexp($rb_plus($$('SEPARATOR'), $$('ALT_SEPARATOR')));
        }
      }
    ;
      
      $def(self, '$dirname', function $$dirname(path, level) {
        var self = this, sep_chars = nil;

        
        if (level == null) level = 1;
        if ($eqeq(level, 0)) {
          return path
        };
        if ($truthy($rb_lt(level, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "level can't be negative")
        };
        sep_chars = $sep_chars();
        path = $coerce_to_path(path);
        
        var absolute = path.match(new RegExp("^[" + $to_s(sep_chars) + "]")), out;

        path = path.replace(new RegExp("[" + $to_s(sep_chars) + "]+$"), ''); // remove trailing separators
        path = path.replace(new RegExp("[^" + $to_s(sep_chars) + "]+$"), ''); // remove trailing basename
        path = path.replace(new RegExp("[" + $to_s(sep_chars) + "]+$"), ''); // remove final trailing separators

        if (path === '') {
          out = absolute ? '/' : '.';
        }
        else {
          out = path;
        }

        if (level == 1) {
          return out;
        }
        else {
          return self.$dirname(out, $rb_minus(level, 1))
        }
      ;
      }, -2);
      
      $def(self, '$basename', function $$basename(name, suffix) {
        var sep_chars = nil;

        
        if (suffix == null) suffix = nil;
        sep_chars = $sep_chars();
        name = $coerce_to_path(name);
        
        if (name.length == 0) {
          return name;
        }

        if (suffix !== nil) {
          suffix = $Opal['$coerce_to!'](suffix, $$$('String'), "to_str")
        } else {
          suffix = null;
        }

        name = name.replace(new RegExp("(.)[" + $to_s(sep_chars) + "]*$"), '$1');
        name = name.replace(new RegExp("^(?:.*[" + $to_s(sep_chars) + "])?([^" + $to_s(sep_chars) + "]+)$"), '$1');

        if (suffix === ".*") {
          name = name.replace(/\.[^\.]+$/, '');
        } else if(suffix !== null) {
          suffix = Opal.escape_regexp(suffix);
          name = name.replace(new RegExp($to_s(suffix) + "$"), '');
        }

        return name;
      ;
      }, -2);
      
      $def(self, '$extname', function $$extname(path) {
        var self = this, filename = nil, last_dot_idx = nil;

        
        path = $coerce_to_path(path);
        filename = self.$basename(path);
        if ($truthy(filename['$empty?']())) {
          return ""
        };
        last_dot_idx = filename['$[]']($range(1, -1, false)).$rindex(".");
        if (($truthy(last_dot_idx['$nil?']()) || ($eqeq($rb_plus(last_dot_idx, 1), $rb_minus(filename.$length(), 1))))) {
          return ""
        } else {
          return filename['$[]'](Opal.Range.$new($rb_plus(last_dot_idx, 1), -1, false))
        };
      });
      
      $def(self, '$exist?', function $exist$ques$1(path) {
        
        return Opal.modules[path] != null
      });
      
      $def(self, '$directory?', function $directory$ques$2(path) {
        var files = nil;

        
        files = [];
        
        for (var key in Opal.modules) {
          files.push(key)
        }
      ;
        path = path.$gsub($regexp(["(^.", $$('SEPARATOR'), "+|", $$('SEPARATOR'), "+$)"]));
        return $send(files, 'find', [], function $$3(f){
          
          if (f == null) f = nil;
          return f['$=~']($regexp(["^", path]));});
      });
      
      $def(self, '$join', function $$join($a) {
        var $post_args, paths, result = nil;

        
        $post_args = $slice(arguments);
        paths = $post_args;
        if ($truthy(paths['$empty?']())) {
          return ""
        };
        result = "";
        paths = $send(paths.$flatten().$each_with_index(), 'map', [], function $$4(item, index){
          
          if (item == null) item = nil;
          if (index == null) index = nil;
          if (($eqeq(index, 0) && ($truthy(item['$empty?']())))) {
            return $$('SEPARATOR')
          } else if (($eqeq(paths.$length(), $rb_plus(index, 1)) && ($truthy(item['$empty?']())))) {
            return $$('SEPARATOR')
          } else {
            return item
          };});
        paths = $send(paths, 'reject', [], "empty?".$to_proc());
        $send(paths, 'each_with_index', [], function $$5(item, index){var next_item = nil;

          
          if (item == null) item = nil;
          if (index == null) index = nil;
          next_item = paths['$[]']($rb_plus(index, 1));
          if ($truthy(next_item['$nil?']())) {
            return (result = $to_s(result) + $to_s(item))
          } else {
            
            if (($truthy(item['$end_with?']($$('SEPARATOR'))) && ($truthy(next_item['$start_with?']($$('SEPARATOR')))))) {
              item = item.$sub($regexp([$$('SEPARATOR'), "+$"]), "")
            };
            return (result = (($truthy(item['$end_with?']($$('SEPARATOR'))) || ($truthy(next_item['$start_with?']($$('SEPARATOR'))))) ? ($to_s(result) + $to_s(item)) : ($to_s(result) + $to_s(item) + $to_s($$('SEPARATOR')))));
          };});
        return result;
      }, -1);
      
      $def(self, '$split', function $$split(path) {
        
        return path.$split($$('SEPARATOR'))
      });
      $alias(self, "realpath", "expand_path");
      return $alias(self, "exists?", "exist?");
    })(Opal.get_singleton_class(self), $nesting);
  })('::', $$$('IO'), $nesting)
};

Opal.modules["corelib/process/base"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  var $klass = Opal.klass, $slice = Opal.slice, $defs = Opal.defs, $return_val = Opal.return_val, nil = Opal.nil;

  
  (function($base, $super) {
    var self = $klass($base, $super, 'Signal');

    
    return $defs(self, '$trap', function $$trap($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1)
  })('::', null);
  return (function($base, $super) {
    var self = $klass($base, $super, 'GC');

    
    return $defs(self, '$start', $return_val(nil))
  })('::', null);
};

Opal.modules["corelib/process"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  var $module = Opal.module, $defs = Opal.defs, $truthy = Opal.truthy, $return_val = Opal.return_val, $Kernel = Opal.Kernel, $to_s = Opal.to_s, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('const_set,size,<<,__register_clock__,to_f,now,new,[],raise');
  return (function($base) {
    var self = $module($base, 'Process');

    var monotonic = nil;

    
    self.__clocks__ = [];
    $defs(self, '$__register_clock__', function $$__register_clock__(name, func) {
      var self = this;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      self.$const_set(name, self.__clocks__.$size());
      return self.__clocks__['$<<'](func);
    });
    self.$__register_clock__("CLOCK_REALTIME", function() { return Date.now() });
    monotonic = false;
    
    if (Opal.global.performance) {
      monotonic = function() {
        return performance.now()
      };
    }
    else if (Opal.global.process && process.hrtime) {
      // let now be the base to get smaller numbers
      var hrtime_base = process.hrtime();

      monotonic = function() {
        var hrtime = process.hrtime(hrtime_base);
        var us = (hrtime[1] / 1000) | 0; // cut below microsecs;
        return ((hrtime[0] * 1000) + (us / 1000));
      };
    }
  ;
    if ($truthy(monotonic)) {
      self.$__register_clock__("CLOCK_MONOTONIC", monotonic)
    };
    $defs(self, '$pid', $return_val(0));
    $defs(self, '$times', function $$times() {
      var t = nil;

      
      t = $$$('Time').$now().$to_f();
      return $$$($$$('Benchmark'), 'Tms').$new(t, t, t, t, t);
    });
    return $defs(self, '$clock_gettime', function $$clock_gettime(clock_id, unit) {
      var self = this, $ret_or_1 = nil, clock = nil;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      if (unit == null) unit = "float_second";
      if ($truthy(($ret_or_1 = (clock = self.__clocks__['$[]'](clock_id))))) {
        $ret_or_1
      } else {
        $Kernel.$raise($$$($$$('Errno'), 'EINVAL'), "clock_gettime(" + $to_s(clock_id) + ") " + $to_s(self.__clocks__['$[]'](clock_id)))
      };
      
      var ms = clock();
      switch (unit) {
        case 'float_second':      return  (ms / 1000);         // number of seconds as a float (default)
        case 'float_millisecond': return  (ms / 1);            // number of milliseconds as a float
        case 'float_microsecond': return  (ms * 1000);         // number of microseconds as a float
        case 'second':            return ((ms / 1000)    | 0); // number of seconds as an integer
        case 'millisecond':       return ((ms / 1)       | 0); // number of milliseconds as an integer
        case 'microsecond':       return ((ms * 1000)    | 0); // number of microseconds as an integer
        case 'nanosecond':        return ((ms * 1000000) | 0); // number of nanoseconds as an integer
        default: $Kernel.$raise($$$('ArgumentError'), "unexpected unit: " + $to_s(unit))
      }
    ;
    }, -2);
  })('::')
};

Opal.modules["corelib/random/formatter"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $klass = Opal.klass, $module = Opal.module, $def = Opal.def, $range = Opal.range, $send = Opal.send, $rb_divide = Opal.rb_divide, $Kernel = Opal.Kernel, $to_s = Opal.to_s, $Opal = Opal.Opal, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('_verify_count,bytes,encode,strict_encode64,random_bytes,urlsafe_encode64,split,hex,[]=,[],map,to_proc,join,times,<<,|,ord,/,abs,random_float,raise,coerce_to!,flatten,new,random_number,length,include,extend');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Random');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $parent_nesting) {
      var self = $module($base, 'Formatter');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$hex', function $$hex(count) {
        var self = this;

        
        if (count == null) count = nil;
        count = $$$('Random').$_verify_count(count);
        
        var bytes = self.$bytes(count);
        var out = "";
        for (var i = 0; i < count; i++) {
          out += bytes.charCodeAt(i).toString(16).padStart(2, '0');
        }
        return (out).$encode("US-ASCII");
      ;
      }, -1);
      
      $def(self, '$random_bytes', function $$random_bytes(count) {
        var self = this;

        
        if (count == null) count = nil;
        return self.$bytes(count);
      }, -1);
      
      $def(self, '$base64', function $$base64(count) {
        var self = this;

        
        if (count == null) count = nil;
        return $$$('Base64').$strict_encode64(self.$random_bytes(count)).$encode("US-ASCII");
      }, -1);
      
      $def(self, '$urlsafe_base64', function $$urlsafe_base64(count, padding) {
        var self = this;

        
        if (count == null) count = nil;
        if (padding == null) padding = false;
        return $$$('Base64').$urlsafe_encode64(self.$random_bytes(count), padding).$encode("US-ASCII");
      }, -1);
      
      $def(self, '$uuid', function $$uuid() {
        var self = this, str = nil;

        
        str = self.$hex(16).$split("");
        str['$[]='](12, "4");
        str['$[]='](16, (parseInt(str['$[]'](16), 16) & 3 | 8).toString(16));
        str = [str['$[]']($range(0, 8, true)), str['$[]']($range(8, 12, true)), str['$[]']($range(12, 16, true)), str['$[]']($range(16, 20, true)), str['$[]']($range(20, 32, true))];
        str = $send(str, 'map', [], "join".$to_proc());
        return str.$join("-");
      });
      
      $def(self, '$random_float', function $$random_float() {
        var self = this, bs = nil, num = nil;

        
        bs = self.$bytes(4);
        num = 0;
        $send((4), 'times', [], function $$1(i){
          
          if (i == null) i = nil;
          num = num['$<<'](8);
          return (num = num['$|'](bs['$[]'](i).$ord()));});
        return $rb_divide(num.$abs(), 2147483647);
      });
      
      $def(self, '$random_number', function $$random_number(limit) {
        var self = this;

        
        ;
        
        function randomFloat() {
          return self.$random_float();
        }

        function randomInt(max) {
          return Math.floor(randomFloat() * max);
        }

        function randomRange() {
          var min = limit.begin,
              max = limit.end;

          if (min === nil || max === nil) {
            return nil;
          }

          var length = max - min;

          if (length < 0) {
            return nil;
          }

          if (length === 0) {
            return min;
          }

          if (max % 1 === 0 && min % 1 === 0 && !limit.excl) {
            length++;
          }

          return randomInt(length) + min;
        }

        if (limit == null) {
          return randomFloat();
        } else if (limit.$$is_range) {
          return randomRange();
        } else if (limit.$$is_number) {
          if (limit <= 0) {
            $Kernel.$raise($$$('ArgumentError'), "invalid argument - " + $to_s(limit))
          }

          if (limit % 1 === 0) {
            // integer
            return randomInt(limit);
          } else {
            return randomFloat() * limit;
          }
        } else {
          limit = $Opal['$coerce_to!'](limit, $$$('Integer'), "to_int");

          if (limit <= 0) {
            $Kernel.$raise($$$('ArgumentError'), "invalid argument - " + $to_s(limit))
          }

          return randomInt(limit);
        }
      ;
      }, -1);
      return $def(self, '$alphanumeric', function $$alphanumeric(count) {
        var self = this, map = nil;

        
        if (count == null) count = nil;
        count = $$('Random').$_verify_count(count);
        map = $send([$range("0", "9", false), $range("a", "z", false), $range("A", "Z", false)], 'map', [], "to_a".$to_proc()).$flatten();
        return $send($$$('Array'), 'new', [count], function $$2(i){var self = $$2.$$s == null ? this : $$2.$$s;

          
          if (i == null) i = nil;
          return map['$[]'](self.$random_number(map.$length()));}, {$$s: self}).$join();
      }, -1);
    })(self, $nesting);
    self.$include($$$($$$('Random'), 'Formatter'));
    return self.$extend($$$($$$('Random'), 'Formatter'));
  })('::', null, $nesting)
};

Opal.modules["corelib/random/mersenne_twister"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $klass = Opal.klass, $const_set = Opal.const_set, $send = Opal.send, nil = Opal.nil, $$$ = Opal.$$$, mersenne_twister = nil;

  Opal.add_stubs('generator=');
  
  mersenne_twister = (function() {
  /* Period parameters */
  var N = 624;
  var M = 397;
  var MATRIX_A = 0x9908b0df;      /* constant vector a */
  var UMASK = 0x80000000;         /* most significant w-r bits */
  var LMASK = 0x7fffffff;         /* least significant r bits */
  var MIXBITS = function(u,v) { return ( ((u) & UMASK) | ((v) & LMASK) ); };
  var TWIST = function(u,v) { return (MIXBITS((u),(v)) >>> 1) ^ ((v & 0x1) ? MATRIX_A : 0x0); };

  function init(s) {
    var mt = {left: 0, next: N, state: new Array(N)};
    init_genrand(mt, s);
    return mt;
  }

  /* initializes mt[N] with a seed */
  function init_genrand(mt, s) {
    var j, i;
    mt.state[0] = s >>> 0;
    for (j=1; j<N; j++) {
      mt.state[j] = (1812433253 * ((mt.state[j-1] ^ (mt.state[j-1] >> 30) >>> 0)) + j);
      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
      /* In the previous versions, MSBs of the seed affect   */
      /* only MSBs of the array state[].                     */
      /* 2002/01/09 modified by Makoto Matsumoto             */
      mt.state[j] &= 0xffffffff;  /* for >32 bit machines */
    }
    mt.left = 1;
    mt.next = N;
  }

  /* generate N words at one time */
  function next_state(mt) {
    var p = 0, _p = mt.state;
    var j;

    mt.left = N;
    mt.next = 0;

    for (j=N-M+1; --j; p++)
      _p[p] = _p[p+(M)] ^ TWIST(_p[p+(0)], _p[p+(1)]);

    for (j=M; --j; p++)
      _p[p] = _p[p+(M-N)] ^ TWIST(_p[p+(0)], _p[p+(1)]);

    _p[p] = _p[p+(M-N)] ^ TWIST(_p[p+(0)], _p[0]);
  }

  /* generates a random number on [0,0xffffffff]-interval */
  function genrand_int32(mt) {
    /* mt must be initialized */
    var y;

    if (--mt.left <= 0) next_state(mt);
    y = mt.state[mt.next++];

    /* Tempering */
    y ^= (y >>> 11);
    y ^= (y << 7) & 0x9d2c5680;
    y ^= (y << 15) & 0xefc60000;
    y ^= (y >>> 18);

    return y >>> 0;
  }

  function int_pair_to_real_exclusive(a, b) {
    a >>>= 5;
    b >>>= 6;
    return(a*67108864.0+b)*(1.0/9007199254740992.0);
  }

  // generates a random number on [0,1) with 53-bit resolution
  function genrand_real(mt) {
    /* mt must be initialized */
    var a = genrand_int32(mt), b = genrand_int32(mt);
    return int_pair_to_real_exclusive(a, b);
  }

  return { genrand_real: genrand_real, init: init };
})();
  return (function($base, $super) {
    var self = $klass($base, $super, 'Random');

    var $a;

    
    var MAX_INT = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
    $const_set(self, 'MERSENNE_TWISTER_GENERATOR', {
    new_seed: function() { return Math.round(Math.random() * MAX_INT); },
    reseed: function(seed) { return mersenne_twister.init(seed); },
    rand: function(mt) { return mersenne_twister.genrand_real(mt); }
  });
    return ($a = [$$$(self, 'MERSENNE_TWISTER_GENERATOR')], $send(self, 'generator=', $a), $a[$a.length - 1]);
  })('::', null);
};

Opal.modules["corelib/random"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $truthy = Opal.truthy, $klass = Opal.klass, $Kernel = Opal.Kernel, $defs = Opal.defs, $Opal = Opal.Opal, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $send = Opal.send, self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,attr_reader,to_int,raise,new_seed,coerce_to!,reseed,rand,seed,bytes,===,==,state,_verify_count,encode,join,new,chr,random_number,random_float,const_defined?,const_set');
  
  self.$require("corelib/random/formatter");
  (function($base, $super) {
    var self = $klass($base, $super, 'Random');

    
    
    self.$attr_reader("seed", "state");
    $defs(self, '$_verify_count', function $$_verify_count(count) {
      
      
      if (!$truthy(count)) count = 16;
      if (typeof count !== "number") count = (count).$to_int();
      if (count < 0) $Kernel.$raise($$$('ArgumentError'), "negative string size (or size too big)");
      count = Math.floor(count);
      return count;
    
    });
    
    $def(self, '$initialize', function $$initialize(seed) {
      var self = this;

      
      if (seed == null) seed = $$$('Random').$new_seed();
      seed = $Opal['$coerce_to!'](seed, $$$('Integer'), "to_int");
      self.state = seed;
      return self.$reseed(seed);
    }, -1);
    
    $def(self, '$reseed', function $$reseed(seed) {
      var self = this;

      
      self.seed = seed;
      return self.$rng = Opal.$$rand.reseed(seed);;
    });
    $defs(self, '$new_seed', function $$new_seed() {
      
      return Opal.$$rand.new_seed();
    });
    $defs(self, '$rand', function $$rand(limit) {
      var self = this;

      
      ;
      return $$$(self, 'DEFAULT').$rand(limit);
    }, -1);
    $defs(self, '$srand', function $$srand(n) {
      var self = this, previous_seed = nil;

      
      if (n == null) n = $$$('Random').$new_seed();
      n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      previous_seed = $$$(self, 'DEFAULT').$seed();
      $$$(self, 'DEFAULT').$reseed(n);
      return previous_seed;
    }, -1);
    $defs(self, '$urandom', function $$urandom(size) {
      
      return $$$('SecureRandom').$bytes(size)
    });
    
    $def(self, '$==', function $Random_$eq_eq$1(other) {
      var self = this, $ret_or_1 = nil;

      
      if (!$eqeqeq($$$('Random'), other)) {
        return false
      };
      if ($truthy(($ret_or_1 = self.$seed()['$=='](other.$seed())))) {
        return self.$state()['$=='](other.$state())
      } else {
        return $ret_or_1
      };
    });
    
    $def(self, '$bytes', function $$bytes(length) {
      var self = this;

      
      length = $$$('Random').$_verify_count(length);
      return $send($$$('Array'), 'new', [length], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

        return self.$rand(255).$chr()}, {$$s: self}).$join().$encode("ASCII-8BIT");
    });
    $defs(self, '$bytes', function $$bytes(length) {
      var self = this;

      return $$$(self, 'DEFAULT').$bytes(length)
    });
    
    $def(self, '$rand', function $$rand(limit) {
      var self = this;

      
      ;
      return self.$random_number(limit);
    }, -1);
    
    $def(self, '$random_float', function $$random_float() {
      var self = this;

      
      self.state++;
      return Opal.$$rand.rand(self.$rng);
    
    });
    $defs(self, '$random_float', function $$random_float() {
      var self = this;

      return $$$(self, 'DEFAULT').$random_float()
    });
    return $defs(self, '$generator=', function $Random_generator$eq$3(generator) {
      var self = this;

      
      Opal.$$rand = generator;
      if ($truthy(self['$const_defined?']("DEFAULT"))) {
        return $$$(self, 'DEFAULT').$reseed()
      } else {
        return self.$const_set("DEFAULT", self.$new(self.$new_seed()))
      };
    });
  })('::', null);
  return self.$require("corelib/random/mersenne_twister");
};

Opal.modules["corelib/unsupported"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  "use strict";
  var $klass = Opal.klass, $send = Opal.send, $slice = Opal.slice, $Kernel = Opal.Kernel, $def = Opal.def, $return_val = Opal.return_val, $alias = Opal.alias, $module = Opal.module, $to_s = Opal.to_s, $defs = Opal.defs, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('each,define_method,raise,%,public,private_method_defined?,private_class_method,instance_method,instance_methods,method_defined?,private_methods');
  
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    
    var ERROR = "String#%s not supported. Mutable String methods are not supported in Opal.";
    return $send(["capitalize!", "chomp!", "chop!", "downcase!", "gsub!", "lstrip!", "next!", "reverse!", "slice!", "squeeze!", "strip!", "sub!", "succ!", "swapcase!", "tr!", "tr_s!", "upcase!", "prepend", "[]=", "clear", "encode!", "unicode_normalize!"], 'each', [], function $String$1(method_name){var self = $String$1.$$s == null ? this : $String$1.$$s;

      
      if (method_name == null) method_name = nil;
      return $send(self, 'define_method', [method_name], function $$2($a){var $post_args, $fwd_rest;

        
        $post_args = $slice(arguments);
        $fwd_rest = $post_args;
        return $Kernel.$raise($$$('NotImplementedError'), (ERROR)['$%'](method_name));}, -1);}, {$$s: self});
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Module');

    
    
    
    $def(self, '$public', function $Module_public$3($a) {
      var $post_args, methods, self = this;

      
      $post_args = $slice(arguments);
      methods = $post_args;
      
      if (methods.length === 0) {
        self.$$module_function = false;
        return nil;
      }
      return (methods.length === 1) ? methods[0] : methods;
    ;
    }, -1);
    
    $def(self, '$private_class_method', function $$private_class_method($a) {
      var $post_args, methods;

      
      $post_args = $slice(arguments);
      methods = $post_args;
      return (methods.length === 1) ? methods[0] : methods;;
    }, -1);
    
    $def(self, '$private_method_defined?', $return_val(false));
    
    $def(self, '$private_constant', function $$private_constant($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1);
    $alias(self, "nesting", "public");
    $alias(self, "private", "public");
    $alias(self, "protected", "public");
    $alias(self, "protected_method_defined?", "private_method_defined?");
    $alias(self, "public_class_method", "private_class_method");
    $alias(self, "public_instance_method", "instance_method");
    $alias(self, "public_instance_methods", "instance_methods");
    return $alias(self, "public_method_defined?", "method_defined?");
  })('::', null);
  (function($base) {
    var self = $module($base, 'Kernel');

    
    
    
    $def(self, '$private_methods', function $$private_methods($a) {
      var $post_args, methods;

      
      $post_args = $slice(arguments);
      methods = $post_args;
      return [];
    }, -1);
    $alias(self, "protected_methods", "private_methods");
    $alias(self, "private_instance_methods", "private_methods");
    return $alias(self, "protected_instance_methods", "private_methods");
  })('::');
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$eval', function $Kernel_eval$4($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return $Kernel.$raise($$$('NotImplementedError'), "To use Kernel#eval, you must first require 'opal-parser'. " + $to_s("See https://github.com/opal/opal/blob/" + $to_s($$('RUBY_ENGINE_VERSION')) + "/docs/opal_parser.md for details."));
    }, -1)
  })('::', $nesting);
  $defs(self, '$public', function $public$5($a) {
    var $post_args, methods;

    
    $post_args = $slice(arguments);
    methods = $post_args;
    return (methods.length === 1) ? methods[0] : methods;;
  }, -1);
  return $defs(self, '$private', function $private$6($a) {
    var $post_args, methods;

    
    $post_args = $slice(arguments);
    methods = $post_args;
    return (methods.length === 1) ? methods[0] : methods;;
  }, -1);
};

Opal.modules["corelib/binding"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  var $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $Kernel = Opal.Kernel, $to_s = Opal.to_s, $return_ivar = Opal.return_ivar, $eqeq = Opal.eqeq, $thrower = Opal.thrower, $module = Opal.module, $const_set = Opal.const_set, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('js_eval,call,raise,inspect,include?,==,receiver,eval,attr_reader,new');
  
  (function($base, $super) {
    var self = $klass($base, $super, 'Binding');

    var $proto = self.$$prototype;

    $proto.jseval = $proto.scope_variables = nil;
    
    
    $def(self, '$initialize', function $$initialize(jseval, scope_variables, receiver, source_location) {
      var $a, self = this;

      
      if (scope_variables == null) scope_variables = [];
      ;
      if (source_location == null) source_location = nil;
      $a = [jseval, scope_variables, receiver, source_location], (self.jseval = $a[0]), (self.scope_variables = $a[1]), (self.receiver = $a[2]), (self.source_location = $a[3]), $a;
      
      /* eslint no-constant-binary-expression: "warn" */
      /* eslint valid-typeof: "warn" */
    ;
      if ($truthy(typeof receiver !== undefined)) {
        return nil
      } else {
        return (receiver = self.$js_eval("self"))
      };
    }, -2);
    
    $def(self, '$js_eval', function $$js_eval($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      if ($truthy(self.jseval)) {
        return $send(self.jseval, 'call', $to_a(args))
      } else {
        return $Kernel.$raise("Evaluation on a Proc#binding is not supported")
      };
    }, -1);
    
    $def(self, '$local_variable_get', function $$local_variable_get(symbol) {
      var self = this;

      try {
        return self.$js_eval(symbol)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('Exception')])) {
          try {
            return $Kernel.$raise($$$('NameError'), "local variable `" + $to_s(symbol) + "' is not defined for " + $to_s(self.$inspect()))
          } finally { Opal.pop_exception($err); }
        } else { throw $err; }
      }
    });
    
    $def(self, '$local_variable_set', function $$local_variable_set(symbol, value) {
      var self = this;

      
      Opal.Binding.tmp_value = value;
      self.$js_eval($to_s(symbol) + " = Opal.Binding.tmp_value");
      delete Opal.Binding.tmp_value;
      return value;
    });
    
    $def(self, '$local_variables', $return_ivar("scope_variables"));
    
    $def(self, '$local_variable_defined?', function $Binding_local_variable_defined$ques$1(value) {
      var self = this;

      return self.scope_variables['$include?'](value)
    });
    
    $def(self, '$eval', function $Binding_eval$2(str, file, line) {try { 
      var self = this;

      
      if (file == null) file = nil;
      if (line == null) line = nil;
      if ($eqeq(str, "self")) {
        return self.$receiver()
      };
      return $Kernel.$eval(str, self, file, line);} catch($e) {
        if ($e === Opal.t_eval_return) return $e.$v;
        throw $e;
      }
    }, -2);
    return self.$attr_reader("receiver", "source_location");
  })('::', null);
  (function($base) {
    var self = $module($base, 'Kernel');

    
    return $def(self, '$binding', function $$binding() {
      
      return $Kernel.$raise("Opal doesn't support dynamic calls to binding")
    })
  })('::');
  return $const_set($nesting[0], 'TOPLEVEL_BINDING', $$$('Binding').$new(
    function(js) {
      return (new Function("self", "return " + js))(self);
    }
  , [], self, ["<main>", 0]));
};

Opal.modules["corelib/irb"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  var $module = Opal.module, $truthy = Opal.truthy, $to_s = Opal.to_s, $Kernel = Opal.Kernel, $defs = Opal.defs, $gvars = Opal.gvars, $lambda = Opal.lambda, $hash_new2 = Opal.hash_new2, $send = Opal.send, $rb_plus = Opal.rb_plus, $const_set = Opal.const_set, $klass = Opal.klass, $def = Opal.def, $Opal = Opal.Opal, $range = Opal.range, $eqeq = Opal.eqeq, $thrower = Opal.thrower, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include?,raise,attr_accessor,singleton_class,output=,browser?,each,dup,write_proc=,proc,+,output,join,last,split,end_with?,call,write_proc,tty=,read_proc,read_proc=,freeze,new,string,ensure_loaded,prepare_console,loop,print,gets,puts,start_with?,[],==,silence,message,empty?,warnings,warn,full_message,eval_and_print,irb');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'IRB');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $defs(self, '$ensure_loaded', function $$ensure_loaded(library) {
        var version = nil, url = nil;

        
        if ($truthy((Opal.loaded_features)['$include?'](library))) {
          return nil
        };
        version = ($truthy($$('RUBY_ENGINE_VERSION')['$include?']("dev")) ? ("master") : ($$('RUBY_ENGINE_VERSION')));
        url = "https://cdn.opalrb.com/opal/" + $to_s(version) + "/" + $to_s(library) + ".js";
        
        var libcode;

        if (typeof XMLHttpRequest !== 'undefined') { // Browser
          var r = new XMLHttpRequest();
          r.open("GET", url, false);
          r.send('');
          libcode = r.responseText;
        }
        else {
          $Kernel.$raise("You need to provision " + $to_s(library) + " yourself in this environment")
        }

        (new Function('Opal', libcode))(Opal);

        Opal.require(library);
      ;
        if ($truthy((Opal.loaded_features)['$include?'](library))) {
          return nil
        } else {
          return $Kernel.$raise("Could not load " + $to_s(library) + " for some reason")
        };
      });
      self.$singleton_class().$attr_accessor("output");
      $defs(self, '$prepare_console', function $$prepare_console() {
        var block = $$prepare_console.$$p || nil, $a, self = this, original = nil, original_read_proc = nil;
        if ($gvars.stdout == null) $gvars.stdout = nil;
        if ($gvars.stderr == null) $gvars.stderr = nil;
        if ($gvars.stdin == null) $gvars.stdin = nil;

        $$prepare_console.$$p = null;
        
        ;
        return (function() { try {
        
        self['$output=']("");
        original = $hash_new2($gvars.stdout, $lambda(function $$1(i){
          
          if (i == null) i = nil;
          return ($gvars.stdout = i);}), $gvars.stderr, $lambda(function $$2(i){
          
          if (i == null) i = nil;
          return ($gvars.stderr = i);}));
        if ($truthy(self['$browser?']())) {
          
          $send(original, 'each', [], function $$3(pipe, pipe_setter){var self = $$3.$$s == null ? this : $$3.$$s, new_pipe = nil;

            
            if (pipe == null) pipe = nil;
            if (pipe_setter == null) pipe_setter = nil;
            new_pipe = pipe.$dup();
            new_pipe['$write_proc=']($send(self, 'proc', [], function $$4(str){var self = $$4.$$s == null ? this : $$4.$$s;

              
              if (str == null) str = nil;
              self['$output=']($rb_plus(self.$output(), str));
              self['$output='](self.$output().$split("\n").$last(30).$join("\n"));
              if ($truthy(str['$end_with?']("\n"))) {
                self['$output=']($rb_plus(self.$output(), "\n"))
              };
              return pipe.$write_proc().$call(str);}, {$$s: self}));
            new_pipe['$tty='](false);
            return pipe_setter.$call(new_pipe);}, {$$s: self});
          original_read_proc = $gvars.stdin.$read_proc();
          $gvars.stdin['$read_proc='](function(s) { var p = prompt(self.$output()); if (p !== null) return p + "\n"; return nil; });
        };
        return Opal.yieldX(block, []);;
        } finally {
          ($send(original, 'each', [], function $$5(pipe, pipe_setter){
            
            if (pipe == null) pipe = nil;
            if (pipe_setter == null) pipe_setter = nil;
            return pipe_setter.$call(pipe);}), ($a = [original_read_proc], $send($gvars.stdin, 'read_proc=', $a), $a[$a.length - 1]), ($a = [""], $send(self, 'output=', $a), $a[$a.length - 1]))
        }; })();
      });
      $defs(self, '$browser?', function $IRB_browser$ques$6() {
        
        return typeof(document) !== 'undefined' && typeof(prompt) !== 'undefined';
      });
      $const_set($nesting[0], 'LINEBREAKS', ["unexpected token $end", "unterminated string meets end of file"].$freeze());
      return (function($base, $super) {
        var self = $klass($base, $super, 'Silencer');

        var $proto = self.$$prototype;

        $proto.collector = $proto.stderr = nil;
        
        
        $def(self, '$initialize', function $$initialize() {
          var self = this;
          if ($gvars.stderr == null) $gvars.stderr = nil;

          return (self.stderr = $gvars.stderr)
        });
        
        $def(self, '$silence', function $$silence() {
          var $yield = $$silence.$$p || nil, self = this;

          $$silence.$$p = null;
          return (function() { try {
          
          self.collector = $$$('StringIO').$new();
          $gvars.stderr = self.collector;
          return Opal.yieldX($yield, []);;
          } finally {
            ($gvars.stderr = self.stderr)
          }; })()
        });
        return $def(self, '$warnings', function $$warnings() {
          var self = this;

          return self.collector.$string()
        });
      })($nesting[0], null);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Binding');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$irb', function $$irb() {try { var $t_return = $thrower('return'); 
      var self = this, silencer = nil;

      
      $$$($Opal, 'IRB').$ensure_loaded("opal-replutils");
      silencer = $$$($$$($Opal, 'IRB'), 'Silencer').$new();
      return $send($$$($Opal, 'IRB'), 'prepare_console', [], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s;

        return (function(){try { var $t_break = $thrower('break'); return $send(self, 'loop', [], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s, line = nil, code = nil, mode = nil, js_code = nil, e = nil;

          
          self.$print(">> ");
          line = self.$gets();
          if (!$truthy(line)) {
            $t_break.$throw(nil, $$8.$$is_lambda)
          };
          code = "";
          if ($truthy($$$($Opal, 'IRB')['$browser?']())) {
            self.$puts(line)
          };
          if ($truthy(line['$start_with?']("ls "))) {
            
            code = line['$[]']($range(3, -1, false));
            mode = "ls";
          } else if ($eqeq(line, "ls\n")) {
            
            code = "self";
            mode = "ls";
          } else if ($truthy(line['$start_with?']("show "))) {
            
            code = line['$[]']($range(5, -1, false));
            mode = "show";
          } else {
            
            code = line;
            mode = "inspect";
          };
          js_code = nil;
          
          do { try {
            $send(silencer, 'silence', [], function $$9(){
              return (js_code = Opal.compile(code, {irb: true}))})
          } catch ($err) {
            if (Opal.rescue($err, [$$('SyntaxError')])) {(e = $err)
              try {
                if ($truthy($$$($$$($Opal, 'IRB'), 'LINEBREAKS')['$include?'](e.$message()))) {
                  
                  self.$print(".. ");
                  line = self.$gets();
                  if (!$truthy(line)) {
                    $t_return.$throw(nil, $$8.$$is_lambda)
                  };
                  if ($truthy($$$($Opal, 'IRB')['$browser?']())) {
                    self.$puts(line)
                  };
                  code = $rb_plus(code, line);
                  continue;
                } else if ($truthy(silencer.$warnings()['$empty?']())) {
                  self.$warn(e.$full_message())
                } else {
                  self.$warn(silencer.$warnings())
                }
              } finally { Opal.pop_exception($err); }
            } else { throw $err; }
          } break; } while(1);;
          if ($eqeq(mode, "show")) {
            
            self.$puts(js_code);
            $t_return.$throw(nil, $$8.$$is_lambda);
          };
          return self.$puts($$$('REPLUtils').$eval_and_print(js_code, mode, false, self));}, {$$s: self, $$ret: $t_return})} catch($e) {
          if ($e === $t_break) return $e.$v;
          throw $e;
        } finally {$t_break.is_orphan = true;}})()}, {$$s: self});} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      } finally {$t_return.is_orphan = true;}
    })
  })('::', null, $nesting);
  
  // Run in WebTools console with: Opal.irb(c => eval(c))
  Opal.irb = function(fun) {
    $$$('Binding').$new(fun).$irb()
  }

  Opal.load_parser = function() {
    Opal.Opal.IRB.$ensure_loaded('opal-parser');
  }

  if (typeof Opal.eval === 'undefined') {
    Opal.eval = function(str) {
      Opal.load_parser();
      return Opal.eval(str);
    }
  }

  if (typeof Opal.compile === 'undefined') {
    Opal.compile = function(str, options) {
      Opal.load_parser();
      return Opal.compile(str, options);
    }
  }
;
};

Opal.modules["opal"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  var $Object = Opal.Object, nil = Opal.nil;

  Opal.add_stubs('require,autoload');
  
  $Object.$require("opal/base");
  $Object.$require("opal/mini");
  $Object.$require("corelib/kernel/format");
  $Object.$require("corelib/string/encoding");
  $Object.$autoload("Math", "corelib/math");
  $Object.$require("corelib/complex/base");
  $Object.$autoload("Complex", "corelib/complex");
  $Object.$require("corelib/rational/base");
  $Object.$autoload("Rational", "corelib/rational");
  $Object.$require("corelib/time");
  $Object.$autoload("Struct", "corelib/struct");
  $Object.$autoload("Set", "corelib/set");
  $Object.$autoload("Dir", "corelib/dir");
  $Object.$autoload("File", "corelib/file");
  $Object.$require("corelib/process/base");
  $Object.$autoload("Process", "corelib/process");
  $Object.$autoload("Random", "corelib/random");
  $Object.$require("corelib/unsupported");
  $Object.$require("corelib/binding");
  return $Object.$require("corelib/irb");
};

Opal.queue(()=>{ Opal.load_normalized("opal") });

Opal.modules["opal"] = function(Opal) {/* Generated by Opal 2.0.0dev */
  var $Object = Opal.Object, nil = Opal.nil;

  Opal.add_stubs('require,autoload');
  
  $Object.$require("opal/base");
  $Object.$require("opal/mini");
  $Object.$require("corelib/kernel/format");
  $Object.$require("corelib/string/encoding");
  $Object.$autoload("Math", "corelib/math");
  $Object.$require("corelib/complex/base");
  $Object.$autoload("Complex", "corelib/complex");
  $Object.$require("corelib/rational/base");
  $Object.$autoload("Rational", "corelib/rational");
  $Object.$require("corelib/time");
  $Object.$autoload("Struct", "corelib/struct");
  $Object.$autoload("Set", "corelib/set");
  $Object.$autoload("Dir", "corelib/dir");
  $Object.$autoload("File", "corelib/file");
  $Object.$require("corelib/process/base");
  $Object.$autoload("Process", "corelib/process");
  $Object.$autoload("Random", "corelib/random");
  $Object.$require("corelib/unsupported");
  $Object.$require("corelib/binding");
  return $Object.$require("corelib/irb");
};

Opal.queue(function(Opal) {/* Generated by Opal 2.0.0dev */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, t = nil;

  Opal.add_stubs('require,puts,new,size,<<');
  
  self.$require("opal");
  self.$puts("ready");
  t = $$('String').$new("bla");
  self.$puts(t);
  self.$puts(t.$size());
  self.$puts(t.length);
  t['$<<']("haha");
  self.$puts(t);
  self.$puts(t.$size());
  return self.$puts(t.length);
});

Opal.queue(function(Opal) {/* Generated by Opal 2.0.0dev */
  var $Kernel = Opal.Kernel, nil = Opal.nil;

  Opal.add_stubs('exit');
  return $Kernel.$exit()
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzZWN0aW9ucyI6W3sib2Zmc2V0Ijp7ImxpbmUiOjAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3J1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKGdsb2JhbF9vYmplY3QpIHtcclxuICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgLy8gQG5vdGVcclxuICAvLyAgIEEgZmV3IGNvbnZlbnRpb25zIGZvciB0aGUgZG9jdW1lbnRhdGlvbiBvZiB0aGlzIGZpbGU6XHJcbiAgLy8gICAxLiBBbHdheXMgdXNlIFwiLy9cIiAoaW4gY29udHJhc3Qgd2l0aCBcIi8qKi9cIilcclxuICAvLyAgIDIuIFRoZSBzeW50YXggdXNlZCBpcyBZYXJkb2MgKHlhcmRvYy5vcmcpLCB3aGljaCBpcyBpbnRlbmRlZCBmb3IgUnVieSAoc2UgYmVsb3cpXHJcbiAgLy8gICAzLiBgQHBhcmFtYCBhbmQgYEByZXR1cm5gIHR5cGVzIHNob3VsZCBiZSBwcmVjZWRlZCBieSBgSlMuYCB3aGVuIHJlZmVycmluZyB0b1xyXG4gIC8vICAgICAgSmF2YVNjcmlwdCBjb25zdHJ1Y3RvcnMgKGUuZy4gYEpTLkZ1bmN0aW9uYCkgb3RoZXJ3aXNlIFJ1YnkgaXMgYXNzdW1lZC5cclxuICAvLyAgIDQuIGBuaWxgIGFuZCBgbnVsbGAgYmVpbmcgdW5hbWJpZ3VvdXMgcmVmZXIgdG8gdGhlIHJlc3BlY3RpdmVcclxuICAvLyAgICAgIG9iamVjdHMvdmFsdWVzIGluIFJ1YnkgYW5kIEphdmFTY3JpcHRcclxuICAvLyAgIDUuIFRoaXMgaXMgc3RpbGwgV0lQIDopIHNvIHBsZWFzZSBnaXZlIGZlZWRiYWNrIGFuZCBzdWdnZXN0aW9ucyBvbiBob3dcclxuICAvLyAgICAgIHRvIGltcHJvdmUgb3IgZm9yIGFsdGVybmF0aXZlIHNvbHV0aW9uc1xyXG4gIC8vXHJcbiAgLy8gICBUaGUgd2F5IHRoZSBjb2RlIGlzIGRpZ2VzdGVkIGJlZm9yZSBnb2luZyB0aHJvdWdoIFlhcmRvYyBpcyBhIHNlY3JldCBrZXB0XHJcbiAgLy8gICBpbiB0aGUgZG9jcyByZXBvIChodHRwczovL2dpdGh1Yi5jb20vb3BhbC9kb2NzL3RyZWUvbWFzdGVyKS5cclxuXHJcbiAgdmFyIGNvbnNvbGU7XHJcblxyXG4gIC8vIERldGVjdCB0aGUgZ2xvYmFsIG9iamVjdFxyXG4gIGlmICh0eXBlb2YoZ2xvYmFsVGhpcykgIT09ICd1bmRlZmluZWQnKSB7IGdsb2JhbF9vYmplY3QgPSBnbG9iYWxUaGlzOyB9XHJcbiAgZWxzZSBpZiAodHlwZW9mKGdsb2JhbCkgIT09ICd1bmRlZmluZWQnKSB7IGdsb2JhbF9vYmplY3QgPSBnbG9iYWw7IH1cclxuICBlbHNlIGlmICh0eXBlb2Yod2luZG93KSAhPT0gJ3VuZGVmaW5lZCcpIHsgZ2xvYmFsX29iamVjdCA9IHdpbmRvdzsgfVxyXG5cclxuICAvLyBTZXR1cCBhIGR1bW15IGNvbnNvbGUgb2JqZWN0IGlmIG1pc3NpbmdcclxuICBpZiAoZ2xvYmFsX29iamVjdC5jb25zb2xlID09IG51bGwpIHtcclxuICAgIGdsb2JhbF9vYmplY3QuY29uc29sZSA9IHt9O1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZihnbG9iYWxfb2JqZWN0LmNvbnNvbGUpID09PSAnb2JqZWN0Jykge1xyXG4gICAgY29uc29sZSA9IGdsb2JhbF9vYmplY3QuY29uc29sZTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc29sZSA9IHt9O1xyXG4gIH1cclxuXHJcbiAgaWYgKCEoJ2xvZycgaW4gY29uc29sZSkpIHsgY29uc29sZS5sb2cgPSBmdW5jdGlvbiAoKSB7fTsgfVxyXG4gIGlmICghKCd3YXJuJyBpbiBjb25zb2xlKSkgeyBjb25zb2xlLndhcm4gPSBjb25zb2xlLmxvZzsgfVxyXG5cclxuICBpZiAodHlwZW9mKGdsb2JhbF9vYmplY3QuT3BhbCkgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ09wYWwgYWxyZWFkeSBsb2FkZWQuIExvYWRpbmcgdHdpY2UgY2FuIGNhdXNlIHRyb3VibGVzLCBwbGVhc2UgZml4IHlvdXIgc2V0dXAuJyk7XHJcbiAgICByZXR1cm4gZ2xvYmFsX29iamVjdC5PcGFsO1xyXG4gIH1cclxuXHJcbiAgdmFyIG5pbDtcclxuXHJcbiAgLy8gVGhlIGFjdHVhbCBjbGFzcyBmb3IgQmFzaWNPYmplY3RcclxuICB2YXIgQmFzaWNPYmplY3Q7XHJcblxyXG4gIC8vIFRoZSBhY3R1YWwgT2JqZWN0IGNsYXNzLlxyXG4gIC8vIFRoZSBsZWFkaW5nIHVuZGVyc2NvcmUgaXMgdG8gYXZvaWQgY29uZnVzaW9uIHdpdGggd2luZG93Lk9iamVjdCgpXHJcbiAgdmFyIF9PYmplY3Q7XHJcblxyXG4gIC8vIFRoZSBhY3R1YWwgTW9kdWxlIGNsYXNzXHJcbiAgdmFyIE1vZHVsZTtcclxuXHJcbiAgLy8gVGhlIGFjdHVhbCBDbGFzcyBjbGFzc1xyXG4gIHZhciBDbGFzcztcclxuXHJcbiAgLy8gVGhlIE9wYWwuT3BhbCBjbGFzcyAoaGVscGVycyBldGMuKVxyXG4gIHZhciBfT3BhbDtcclxuXHJcbiAgLy8gVGhlIEtlcm5lbCBtb2R1bGVcclxuICB2YXIgS2VybmVsO1xyXG5cclxuICAvLyBUaGUgT3BhbCBvYmplY3QgdGhhdCBpcyBleHBvc2VkIGdsb2JhbGx5XHJcbiAgdmFyIE9wYWwgPSBnbG9iYWxfb2JqZWN0Lk9wYWwgPSB7fTtcclxuXHJcbiAgLy8gVGhpcyBpcyBhIHVzZWZ1bCByZWZlcmVuY2UgdG8gZ2xvYmFsIG9iamVjdCBpbnNpZGUgcnVieSBmaWxlc1xyXG4gIE9wYWwuZ2xvYmFsID0gZ2xvYmFsX29iamVjdDtcclxuXHJcbiAgLy8gQ29uZmlndXJlIHJ1bnRpbWUgYmVoYXZpb3Igd2l0aCByZWdhcmRzIHRvIHJlcXVpcmUgYW5kIHVuc3VwcG9ydGVkIGZlYXR1cmVzXHJcbiAgT3BhbC5jb25maWcgPSB7XHJcbiAgICBtaXNzaW5nX3JlcXVpcmVfc2V2ZXJpdHk6ICdlcnJvcicsICAgICAgICAvLyBlcnJvciwgd2FybmluZywgaWdub3JlXHJcbiAgICB1bnN1cHBvcnRlZF9mZWF0dXJlc19zZXZlcml0eTogJ3dhcm5pbmcnLCAvLyBlcnJvciwgd2FybmluZywgaWdub3JlXHJcbiAgICBleHBlcmltZW50YWxfZmVhdHVyZXNfc2V2ZXJpdHk6ICd3YXJuaW5nJywvLyB3YXJuaW5nLCBpZ25vcmVcclxuICAgIGVuYWJsZV9zdGFja190cmFjZTogdHJ1ZSAgICAgICAgICAgICAgICAgIC8vIHRydWUsIGZhbHNlXHJcbiAgfTtcclxuXHJcbiAgLy8gTWluaWZ5IGNvbW1vbiBmdW5jdGlvbiBjYWxsc1xyXG4gIHZhciAkY2FsbCAgICAgID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XHJcbiAgdmFyICRiaW5kICAgICAgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZDtcclxuICB2YXIgJGhhc19vd24gICA9IE9iamVjdC5oYXNPd24gfHwgJGNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcclxuICB2YXIgJHNldF9wcm90byA9IE9iamVjdC5zZXRQcm90b3R5cGVPZjtcclxuICB2YXIgJHNsaWNlICAgICA9ICRjYWxsLmJpbmQoQXJyYXkucHJvdG90eXBlLnNsaWNlKTtcclxuICB2YXIgJHNwbGljZSAgICA9ICRjYWxsLmJpbmQoQXJyYXkucHJvdG90eXBlLnNwbGljZSk7XHJcblxyXG4gIC8vIE5pbCBvYmplY3QgaWQgaXMgYWx3YXlzIDRcclxuICB2YXIgbmlsX2lkID0gNDtcclxuXHJcbiAgLy8gR2VuZXJhdGVzIGV2ZW4gc2VxdWVudGlhbCBudW1iZXJzIGdyZWF0ZXIgdGhhbiA0XHJcbiAgLy8gKG5pbF9pZCkgdG8gc2VydmUgYXMgdW5pcXVlIGlkcyBmb3IgcnVieSBvYmplY3RzXHJcbiAgdmFyIHVuaXF1ZV9pZCA9IG5pbF9pZDtcclxuXHJcbiAgLy8gUmV0dXJuIG5leHQgdW5pcXVlIGlkXHJcbiAgZnVuY3Rpb24gJHVpZCgpIHtcclxuICAgIHVuaXF1ZV9pZCArPSAyO1xyXG4gICAgcmV0dXJuIHVuaXF1ZV9pZDtcclxuICB9O1xyXG4gIE9wYWwudWlkID0gJHVpZDtcclxuXHJcbiAgLy8gUmV0cmlldmUgb3IgYXNzaWduIHRoZSBpZCBvZiBhbiBvYmplY3RcclxuICBPcGFsLmlkID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICBpZiAob2JqLiQkaXNfbnVtYmVyKSByZXR1cm4gKG9iaiAqIDIpKzE7XHJcbiAgICBpZiAob2JqLiQkaWQgPT0gbnVsbCkge1xyXG4gICAgICAkcHJvcChvYmosICckJGlkJywgJHVpZCgpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBvYmouJCRpZDtcclxuICB9O1xyXG5cclxuICAvLyBHbG9iYWxzIHRhYmxlXHJcbiAgdmFyICRndmFycyA9IE9wYWwuZ3ZhcnMgPSB7fTtcclxuXHJcbiAgLy8gRXhpdCBmdW5jdGlvbiwgdGhpcyBzaG91bGQgYmUgcmVwbGFjZWQgYnkgcGxhdGZvcm0gc3BlY2lmaWMgaW1wbGVtZW50YXRpb25cclxuICAvLyAoU2VlIG5vZGVqcyBhbmQgY2hyb21lIGZvciBleGFtcGxlcylcclxuICBPcGFsLmV4aXQgPSBmdW5jdGlvbihzdGF0dXMpIHsgaWYgKCRndmFycy5ERUJVRykgY29uc29sZS5sb2coJ0V4aXRlZCB3aXRoIHN0YXR1cyAnK3N0YXR1cyk7IH07XHJcblxyXG4gIC8vIGtlZXBzIHRyYWNrIG9mIGV4Y2VwdGlvbnMgZm9yICQhXHJcbiAgT3BhbC5leGNlcHRpb25zID0gW107XHJcblxyXG4gIC8vIEBwcml2YXRlXHJcbiAgLy8gUG9wcyBhbiBleGNlcHRpb24gZnJvbSB0aGUgc3RhY2sgYW5kIHVwZGF0ZXMgYCQhYC5cclxuICBPcGFsLnBvcF9leGNlcHRpb24gPSBmdW5jdGlvbihyZXNjdWVkX2V4Y2VwdGlvbikge1xyXG4gICAgdmFyIGV4Y2VwdGlvbiA9IE9wYWwuZXhjZXB0aW9ucy5wb3AoKTtcclxuICAgIGlmIChleGNlcHRpb24gPT09IHJlc2N1ZWRfZXhjZXB0aW9uKSB7XHJcbiAgICAgIC8vIEN1cnJlbnQgJCEgaXMgcmFpc2VkIGluIHRoZSByZXNjdWUgYmxvY2ssIHNvIHdlIGRvbid0IHVwZGF0ZSBpdFxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZXhjZXB0aW9uKSB7XHJcbiAgICAgICRndmFyc1tcIiFcIl0gPSBleGNlcHRpb247XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgJGd2YXJzW1wiIVwiXSA9IG5pbDtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBBIGhlbHBlciBmdW5jdGlvbiBmb3IgcmFpc2luZyB0aGluZ3MsIHRoYXQgZ3JhY2VmdWxseSBkZWdyYWRlcyBpZiBuZWNlc3NhcnlcclxuICAvLyBmdW5jdGlvbmFsaXR5IGlzIG5vdCB5ZXQgbG9hZGVkLlxyXG4gIGZ1bmN0aW9uICRyYWlzZShrbGFzcywgbWVzc2FnZSkge1xyXG4gICAgLy8gUmFpc2UgRXhjZXB0aW9uLCBzbyB3ZSBjYW4ga25vdyB0aGF0IHNvbWV0aGluZyB3cm9uZyBpcyBnb2luZyBvbi5cclxuICAgIGlmICgha2xhc3MpIGtsYXNzID0gT3BhbC5FeGNlcHRpb24gfHwgRXJyb3I7XHJcblxyXG4gICAgaWYgKEtlcm5lbCAmJiBLZXJuZWwuJHJhaXNlKSB7XHJcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xyXG4gICAgICAgIEtlcm5lbC4kcmFpc2Uoa2xhc3MuJG5ldy5hcHBseShrbGFzcywgJHNsaWNlKGFyZ3VtZW50cywgMSkpKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBLZXJuZWwuJHJhaXNlKGtsYXNzLCBtZXNzYWdlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIWtsYXNzLiRuZXcpIHtcclxuICAgICAgdGhyb3cgbmV3IGtsYXNzKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHRocm93IGtsYXNzLiRuZXcobWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBSZXVzZSB0aGUgc2FtZSBvYmplY3QgZm9yIHBlcmZvcm1hbmNlL21lbW9yeSBzYWtlXHJcbiAgdmFyIHByb3Bfb3B0aW9ucyA9IHtcclxuICAgIHZhbHVlOiB1bmRlZmluZWQsXHJcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlXHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gJHByb3Aob2JqZWN0LCBuYW1lLCBpbml0aWFsVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2Yob2JqZWN0KSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yOlxyXG4gICAgICAvLyAgIHMgPSBcInN0cmluZ1wiXHJcbiAgICAgIC8vICAgZGVmIHMubTsgZW5kXHJcbiAgICAgIC8vIFN0cmluZyBjbGFzcyBpcyB0aGUgb25seSBjbGFzcyB0aGF0OlxyXG4gICAgICAvLyArIGNvbXBpbGVzIHRvIEpTIHByaW1pdGl2ZVxyXG4gICAgICAvLyArIGFsbG93cyBtZXRob2QgZGVmaW5pdGlvbiBkaXJlY3RseSBvbiBpbnN0YW5jZXNcclxuICAgICAgLy8gbnVtYmVycywgdHJ1ZSwgZmFsc2UgYW5kIG51bGwgZG8gbm90IHN1cHBvcnQgaXQuXHJcbiAgICAgIG9iamVjdFtuYW1lXSA9IGluaXRpYWxWYWx1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHByb3Bfb3B0aW9ucy52YWx1ZSA9IGluaXRpYWxWYWx1ZTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwgcHJvcF9vcHRpb25zKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIE9wYWwucHJvcCA9ICRwcm9wO1xyXG5cclxuICAvLyBAZGVwcmVjYXRlZFxyXG4gIE9wYWwuZGVmaW5lUHJvcGVydHkgPSBPcGFsLnByb3A7XHJcblxyXG4gIE9wYWwuc2xpY2UgPSAkc2xpY2U7XHJcblxyXG4gIC8vIEhlbHBlcnNcclxuICAvLyAtLS0tLVxyXG5cclxuICB2YXIgJHRydXRoeSA9IE9wYWwudHJ1dGh5ID0gZnVuY3Rpb24odmFsKSB7XHJcbiAgICByZXR1cm4gZmFsc2UgIT09IHZhbCAmJiBuaWwgIT09IHZhbCAmJiB1bmRlZmluZWQgIT09IHZhbCAmJiBudWxsICE9PSB2YWwgJiYgKCEodmFsIGluc3RhbmNlb2YgQm9vbGVhbikgfHwgdHJ1ZSA9PT0gdmFsLnZhbHVlT2YoKSk7XHJcbiAgfTtcclxuXHJcbiAgT3BhbC5mYWxzeSA9IGZ1bmN0aW9uKHZhbCkge1xyXG4gICAgcmV0dXJuICEkdHJ1dGh5KHZhbCk7XHJcbiAgfTtcclxuXHJcbiAgT3BhbC50eXBlX2Vycm9yID0gZnVuY3Rpb24ob2JqZWN0LCB0eXBlLCBtZXRob2QsIGNvZXJjZWQpIHtcclxuICAgIG9iamVjdCA9IG9iamVjdC4kJGNsYXNzO1xyXG5cclxuICAgIGlmIChjb2VyY2VkICYmIG1ldGhvZCkge1xyXG4gICAgICBjb2VyY2VkID0gY29lcmNlZC4kJGNsYXNzO1xyXG4gICAgICAkcmFpc2UoT3BhbC5UeXBlRXJyb3IsXHJcbiAgICAgICAgXCJjYW4ndCBjb252ZXJ0IFwiICsgb2JqZWN0ICsgXCIgaW50byBcIiArIHR5cGUgK1xyXG4gICAgICAgIFwiIChcIiArIG9iamVjdCArIFwiI1wiICsgbWV0aG9kICsgXCIgZ2l2ZXMgXCIgKyBjb2VyY2VkICsgXCIpXCJcclxuICAgICAgKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgJHJhaXNlKE9wYWwuVHlwZUVycm9yLFxyXG4gICAgICAgIFwibm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiBcIiArIG9iamVjdCArIFwiIGludG8gXCIgKyB0eXBlXHJcbiAgICAgIClcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBPcGFsLmNvZXJjZV90byA9IGZ1bmN0aW9uKG9iamVjdCwgdHlwZSwgbWV0aG9kLCBhcmdzKSB7XHJcbiAgICB2YXIgYm9keTtcclxuXHJcbiAgICBpZiAobWV0aG9kID09PSAndG9faW50JyAmJiB0eXBlID09PSBPcGFsLkludGVnZXIgJiYgb2JqZWN0LiQkaXNfbnVtYmVyKVxyXG4gICAgICByZXR1cm4gb2JqZWN0IDwgMCA/IE1hdGguY2VpbChvYmplY3QpIDogTWF0aC5mbG9vcihvYmplY3QpO1xyXG5cclxuICAgIGlmIChtZXRob2QgPT09ICd0b19zdHInICYmIHR5cGUgPT09IE9wYWwuU3RyaW5nICYmIG9iamVjdC4kJGlzX3N0cmluZylcclxuICAgICAgcmV0dXJuIG9iamVjdDtcclxuXHJcbiAgICBpZiAoT3BhbC5pc19hKG9iamVjdCwgdHlwZSkpIHJldHVybiBvYmplY3Q7XHJcblxyXG4gICAgLy8gRmFzdCBwYXRoIGZvciB0aGUgbW9zdCBjb21tb24gc2l0dWF0aW9uXHJcbiAgICBpZiAob2JqZWN0WyckcmVzcG9uZF90bz8nXS4kJHByaXN0aW5lICYmIG9iamVjdC4kbWV0aG9kX21pc3NpbmcuJCRwcmlzdGluZSkge1xyXG4gICAgICBib2R5ID0gb2JqZWN0WyRqc2lkKG1ldGhvZCldO1xyXG4gICAgICBpZiAoYm9keSA9PSBudWxsIHx8IGJvZHkuJCRzdHViKSBPcGFsLnR5cGVfZXJyb3Iob2JqZWN0LCB0eXBlKTtcclxuICAgICAgcmV0dXJuIGJvZHkuYXBwbHkob2JqZWN0LCBhcmdzKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIW9iamVjdFsnJHJlc3BvbmRfdG8/J10obWV0aG9kKSkge1xyXG4gICAgICBPcGFsLnR5cGVfZXJyb3Iob2JqZWN0LCB0eXBlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYXJncyA9PSBudWxsKSBhcmdzID0gW107XHJcbiAgICByZXR1cm4gT3BhbC5zZW5kKG9iamVjdCwgbWV0aG9kLCBhcmdzKTtcclxuICB9XHJcblxyXG4gIE9wYWwucmVzcG9uZF90byA9IGZ1bmN0aW9uKG9iaiwganNpZCwgaW5jbHVkZV9hbGwpIHtcclxuICAgIGlmIChvYmogPT0gbnVsbCB8fCAhb2JqLiQkY2xhc3MpIHJldHVybiBmYWxzZTtcclxuICAgIGluY2x1ZGVfYWxsID0gISFpbmNsdWRlX2FsbDtcclxuICAgIHZhciBib2R5ID0gb2JqW2pzaWRdO1xyXG5cclxuICAgIGlmIChvYmpbJyRyZXNwb25kX3RvPyddLiQkcHJpc3RpbmUpIHtcclxuICAgICAgaWYgKHR5cGVvZihib2R5KSA9PT0gXCJmdW5jdGlvblwiICYmICFib2R5LiQkc3R1Yikge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghb2JqWyckcmVzcG9uZF90b19taXNzaW5nPyddLiQkcHJpc3RpbmUpIHtcclxuICAgICAgICByZXR1cm4gT3BhbC5zZW5kKG9iaiwgb2JqWyckcmVzcG9uZF90b19taXNzaW5nPyddLCBbanNpZC5zdWJzdHIoMSksIGluY2x1ZGVfYWxsXSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBPcGFsLnNlbmQob2JqLCBvYmpbJyRyZXNwb25kX3RvPyddLCBbanNpZC5zdWJzdHIoMSksIGluY2x1ZGVfYWxsXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBUcmFjZVBvaW50IHN1cHBvcnRcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvL1xyXG4gIC8vIFN1cHBvcnQgZm9yIGBUcmFjZVBvaW50LnRyYWNlKDpjbGFzcykgZG8gLi4uIGVuZGBcclxuICBPcGFsLnRyYWNlX2NsYXNzID0gZmFsc2U7XHJcbiAgT3BhbC50cmFjZXJzX2Zvcl9jbGFzcyA9IFtdO1xyXG5cclxuICBmdW5jdGlvbiBpbnZva2VfdHJhY2Vyc19mb3JfY2xhc3Moa2xhc3Nfb3JfbW9kdWxlKSB7XHJcbiAgICB2YXIgaSwgaWksIHRyYWNlcjtcclxuXHJcbiAgICBmb3IoaSA9IDAsIGlpID0gT3BhbC50cmFjZXJzX2Zvcl9jbGFzcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XHJcbiAgICAgIHRyYWNlciA9IE9wYWwudHJhY2Vyc19mb3JfY2xhc3NbaV07XHJcbiAgICAgIHRyYWNlci50cmFjZV9vYmplY3QgPSBrbGFzc19vcl9tb2R1bGU7XHJcbiAgICAgIHRyYWNlci5ibG9jay4kY2FsbCh0cmFjZXIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaGFuZGxlX2F1dG9sb2FkKGNyZWYsIG5hbWUpIHtcclxuICAgIGlmICghY3JlZi4kJGF1dG9sb2FkW25hbWVdLmxvYWRlZCkge1xyXG4gICAgICBjcmVmLiQkYXV0b2xvYWRbbmFtZV0ubG9hZGVkID0gdHJ1ZTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBPcGFsLktlcm5lbC4kcmVxdWlyZShjcmVmLiQkYXV0b2xvYWRbbmFtZV0ucGF0aCk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjcmVmLiQkYXV0b2xvYWRbbmFtZV0uZXhjZXB0aW9uID0gZTtcclxuICAgICAgICB0aHJvdyBlO1xyXG4gICAgICB9XHJcbiAgICAgIGNyZWYuJCRhdXRvbG9hZFtuYW1lXS5yZXF1aXJlZCA9IHRydWU7XHJcbiAgICAgIGlmIChjcmVmLiQkY29uc3RbbmFtZV0gIT0gbnVsbCkge1xyXG4gICAgICAgIGNyZWYuJCRhdXRvbG9hZFtuYW1lXS5zdWNjZXNzID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gY3JlZi4kJGNvbnN0W25hbWVdO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGNyZWYuJCRhdXRvbG9hZFtuYW1lXS5sb2FkZWQgJiYgIWNyZWYuJCRhdXRvbG9hZFtuYW1lXS5yZXF1aXJlZCkge1xyXG4gICAgICBpZiAoY3JlZi4kJGF1dG9sb2FkW25hbWVdLmV4Y2VwdGlvbikgeyB0aHJvdyBjcmVmLiQkYXV0b2xvYWRbbmFtZV0uZXhjZXB0aW9uOyB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDb25zdGFudHNcclxuICAvLyAtLS0tLS0tLS1cclxuICAvL1xyXG4gIC8vIEZvciBmdXR1cmUgcmVmZXJlbmNlOlxyXG4gIC8vIC0gVGhlIFJhaWxzIGF1dG9sb2FkaW5nIGd1aWRlIChodHRwOi8vZ3VpZGVzLnJ1YnlvbnJhaWxzLm9yZy92NS4wL2F1dG9sb2FkaW5nX2FuZF9yZWxvYWRpbmdfY29uc3RhbnRzLmh0bWwpXHJcbiAgLy8gLSBAQ29ucmFkSXJ3aW4ncyAyMDEyIHBvc3Qgb24g4oCcRXZlcnl0aGluZyB5b3UgZXZlciB3YW50ZWQgdG8ga25vdyBhYm91dCBjb25zdGFudCBsb29rdXAgaW4gUnVieeKAnSAoaHR0cDovL2NpcncuaW4vYmxvZy9jb25zdGFudC1sb29rdXAuaHRtbClcclxuICAvL1xyXG4gIC8vIExlZ2VuZCBvZiBNUkkgY29uY2VwdHMvbmFtZXM6XHJcbiAgLy8gLSBjb25zdGFudCByZWZlcmVuY2UgKGNyZWYpOiB0aGUgbW9kdWxlL2NsYXNzIHRoYXQgYWN0cyBhcyBhIG5hbWVzcGFjZVxyXG4gIC8vIC0gbmVzdGluZzogdGhlIG5hbWVzcGFjZXMgd3JhcHBpbmcgdGhlIGN1cnJlbnQgc2NvcGUsIGUuZy4gbmVzdGluZyBpbnNpZGVcclxuICAvLyAgICAgICAgICAgIGBtb2R1bGUgQTsgbW9kdWxlIEI6OkM7IGVuZDsgZW5kYCBpcyBgW0I6OkMsIEFdYFxyXG5cclxuICAvLyBHZXQgdGhlIGNvbnN0YW50IGluIHRoZSBzY29wZSBvZiB0aGUgY3VycmVudCBjcmVmXHJcbiAgZnVuY3Rpb24gY29uc3RfZ2V0X25hbWUoY3JlZiwgbmFtZSkge1xyXG4gICAgaWYgKGNyZWYpIHtcclxuICAgICAgaWYgKGNyZWYuJCRjb25zdFtuYW1lXSAhPSBudWxsKSB7IHJldHVybiBjcmVmLiQkY29uc3RbbmFtZV07IH1cclxuICAgICAgaWYgKGNyZWYuJCRhdXRvbG9hZCAmJiBjcmVmLiQkYXV0b2xvYWRbbmFtZV0pIHtcclxuICAgICAgICByZXR1cm4gaGFuZGxlX2F1dG9sb2FkKGNyZWYsIG5hbWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBXYWxrIHVwIHRoZSBuZXN0aW5nIGFycmF5IGxvb2tpbmcgZm9yIHRoZSBjb25zdGFudFxyXG4gIGZ1bmN0aW9uIGNvbnN0X2xvb2t1cF9uZXN0aW5nKG5lc3RpbmcsIG5hbWUpIHtcclxuICAgIHZhciBpLCBpaSwgY29uc3RhbnQ7XHJcblxyXG4gICAgaWYgKG5lc3RpbmcubGVuZ3RoID09PSAwKSByZXR1cm47XHJcblxyXG4gICAgLy8gSWYgdGhlIG5lc3RpbmcgaXMgbm90IGVtcHR5IHRoZSBjb25zdGFudCBpcyBsb29rZWQgdXAgaW4gaXRzIGVsZW1lbnRzXHJcbiAgICAvLyBhbmQgaW4gb3JkZXIuIFRoZSBhbmNlc3RvcnMgb2YgdGhvc2UgZWxlbWVudHMgYXJlIGlnbm9yZWQuXHJcbiAgICBmb3IgKGkgPSAwLCBpaSA9IG5lc3RpbmcubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xyXG4gICAgICBjb25zdGFudCA9IG5lc3RpbmdbaV0uJCRjb25zdFtuYW1lXTtcclxuICAgICAgaWYgKGNvbnN0YW50ICE9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gY29uc3RhbnQ7XHJcbiAgICAgIH0gZWxzZSBpZiAobmVzdGluZ1tpXS4kJGF1dG9sb2FkICYmIG5lc3RpbmdbaV0uJCRhdXRvbG9hZFtuYW1lXSkge1xyXG4gICAgICAgIHJldHVybiBoYW5kbGVfYXV0b2xvYWQobmVzdGluZ1tpXSwgbmFtZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFdhbGsgdXAgdGhlIGFuY2VzdG9ycyBjaGFpbiBsb29raW5nIGZvciB0aGUgY29uc3RhbnRcclxuICBmdW5jdGlvbiBjb25zdF9sb29rdXBfYW5jZXN0b3JzKGNyZWYsIG5hbWUpIHtcclxuICAgIHZhciBpLCBpaSwgYW5jZXN0b3JzO1xyXG5cclxuICAgIGlmIChjcmVmID09IG51bGwpIHJldHVybjtcclxuXHJcbiAgICBhbmNlc3RvcnMgPSAkYW5jZXN0b3JzKGNyZWYpO1xyXG5cclxuICAgIGZvciAoaSA9IDAsIGlpID0gYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcclxuICAgICAgaWYgKGFuY2VzdG9yc1tpXS4kJGNvbnN0ICYmICRoYXNfb3duKGFuY2VzdG9yc1tpXS4kJGNvbnN0LCBuYW1lKSkge1xyXG4gICAgICAgIHJldHVybiBhbmNlc3RvcnNbaV0uJCRjb25zdFtuYW1lXTtcclxuICAgICAgfSBlbHNlIGlmIChhbmNlc3RvcnNbaV0uJCRhdXRvbG9hZCAmJiBhbmNlc3RvcnNbaV0uJCRhdXRvbG9hZFtuYW1lXSkge1xyXG4gICAgICAgIHJldHVybiBoYW5kbGVfYXV0b2xvYWQoYW5jZXN0b3JzW2ldLCBuYW1lKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gV2FsayB1cCBPYmplY3QncyBhbmNlc3RvcnMgY2hhaW4gbG9va2luZyBmb3IgdGhlIGNvbnN0YW50LFxyXG4gIC8vIGJ1dCBvbmx5IGlmIGNyZWYgaXMgbWlzc2luZyBvciBhIG1vZHVsZS5cclxuICBmdW5jdGlvbiBjb25zdF9sb29rdXBfT2JqZWN0KGNyZWYsIG5hbWUpIHtcclxuICAgIGlmIChjcmVmID09IG51bGwgfHwgY3JlZi4kJGlzX21vZHVsZSkge1xyXG4gICAgICByZXR1cm4gY29uc3RfbG9va3VwX2FuY2VzdG9ycyhfT2JqZWN0LCBuYW1lKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENhbGwgY29uc3RfbWlzc2luZyBpZiBub3RoaW5nIGVsc2Ugd29ya2VkXHJcbiAgZnVuY3Rpb24gY29uc3RfbWlzc2luZyhjcmVmLCBuYW1lKSB7XHJcbiAgICByZXR1cm4gKGNyZWYgfHwgX09iamVjdCkuJGNvbnN0X21pc3NpbmcobmFtZSk7XHJcbiAgfVxyXG5cclxuICAvLyBMb29rIGZvciB0aGUgY29uc3RhbnQganVzdCBpbiB0aGUgY3VycmVudCBjcmVmIG9yIGNhbGwgYCNjb25zdF9taXNzaW5nYFxyXG4gIE9wYWwuY29uc3RfZ2V0X2xvY2FsID0gZnVuY3Rpb24oY3JlZiwgbmFtZSwgc2tpcF9taXNzaW5nKSB7XHJcbiAgICB2YXIgcmVzdWx0O1xyXG5cclxuICAgIGlmIChjcmVmID09IG51bGwpIHJldHVybjtcclxuXHJcbiAgICBpZiAoY3JlZiA9PT0gJzo6JykgY3JlZiA9IF9PYmplY3Q7XHJcblxyXG4gICAgaWYgKCFjcmVmLiQkaXNfbW9kdWxlICYmICFjcmVmLiQkaXNfY2xhc3MpIHtcclxuICAgICAgJHJhaXNlKE9wYWwuVHlwZUVycm9yLCBjcmVmLnRvU3RyaW5nKCkgKyBcIiBpcyBub3QgYSBjbGFzcy9tb2R1bGVcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcmVzdWx0ID0gY29uc3RfZ2V0X25hbWUoY3JlZiwgbmFtZSk7XHJcbiAgICByZXR1cm4gcmVzdWx0ICE9IG51bGwgfHwgc2tpcF9taXNzaW5nID8gcmVzdWx0IDogY29uc3RfbWlzc2luZyhjcmVmLCBuYW1lKTtcclxuICB9O1xyXG5cclxuICAvLyBMb29rIGZvciB0aGUgY29uc3RhbnQgcmVsYXRpdmUgdG8gYSBjcmVmIG9yIGNhbGwgYCNjb25zdF9taXNzaW5nYCAod2hlbiB0aGVcclxuICAvLyBjb25zdGFudCBpcyBwcmVmaXhlZCBieSBgOjpgKS5cclxuICBPcGFsLmNvbnN0X2dldF9xdWFsaWZpZWQgPSBmdW5jdGlvbihjcmVmLCBuYW1lLCBza2lwX21pc3NpbmcpIHtcclxuICAgIHZhciByZXN1bHQsIGNhY2hlLCBjYWNoZWQsIGN1cnJlbnRfdmVyc2lvbiA9IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbjtcclxuXHJcbiAgICBpZiAobmFtZSA9PSBudWxsKSB7XHJcbiAgICAgIC8vIEEgc2hvcnRwYXRoIGZvciBjYWxscyBsaWtlIDo6U3RyaW5nID0+ICQkJChcIlN0cmluZ1wiKVxyXG4gICAgICByZXN1bHQgPSBjb25zdF9nZXRfbmFtZShfT2JqZWN0LCBjcmVmKTtcclxuXHJcbiAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgcmV0dXJuIE9wYWwuY29uc3RfZ2V0X3F1YWxpZmllZChfT2JqZWN0LCBjcmVmLCBza2lwX21pc3NpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjcmVmID09IG51bGwpIHJldHVybjtcclxuXHJcbiAgICBpZiAoY3JlZiA9PT0gJzo6JykgY3JlZiA9IF9PYmplY3Q7XHJcblxyXG4gICAgaWYgKCFjcmVmLiQkaXNfbW9kdWxlICYmICFjcmVmLiQkaXNfY2xhc3MpIHtcclxuICAgICAgJHJhaXNlKE9wYWwuVHlwZUVycm9yLCBjcmVmLnRvU3RyaW5nKCkgKyBcIiBpcyBub3QgYSBjbGFzcy9tb2R1bGVcIik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKChjYWNoZSA9IGNyZWYuJCRjb25zdF9jYWNoZSkgPT0gbnVsbCkge1xyXG4gICAgICAkcHJvcChjcmVmLCAnJCRjb25zdF9jYWNoZScsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xyXG4gICAgICBjYWNoZSA9IGNyZWYuJCRjb25zdF9jYWNoZTtcclxuICAgIH1cclxuICAgIGNhY2hlZCA9IGNhY2hlW25hbWVdO1xyXG5cclxuICAgIGlmIChjYWNoZWQgPT0gbnVsbCB8fCBjYWNoZWRbMF0gIT09IGN1cnJlbnRfdmVyc2lvbikge1xyXG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2dldF9uYW1lKGNyZWYsIG5hbWUpKSAgICAgICAgICAgICAgIT0gbnVsbCkgfHxcclxuICAgICAgKChyZXN1bHQgPSBjb25zdF9sb29rdXBfYW5jZXN0b3JzKGNyZWYsIG5hbWUpKSAgICAgICE9IG51bGwpO1xyXG4gICAgICBjYWNoZVtuYW1lXSA9IFtjdXJyZW50X3ZlcnNpb24sIHJlc3VsdF07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXN1bHQgPSBjYWNoZWRbMV07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdCAhPSBudWxsIHx8IHNraXBfbWlzc2luZyA/IHJlc3VsdCA6IGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSB0aGUgdG9wIGxldmVsIGNvbnN0YW50IGNhY2hlIGdlbmVyYXRpb24gY291bnRlclxyXG4gIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbiA9IDE7XHJcblxyXG4gIC8vIExvb2sgZm9yIHRoZSBjb25zdGFudCBpbiB0aGUgb3BlbiB1c2luZyB0aGUgY3VycmVudCBuZXN0aW5nIGFuZCB0aGUgbmVhcmVzdFxyXG4gIC8vIGNyZWYgYW5jZXN0b3JzIG9yIGNhbGwgYCNjb25zdF9taXNzaW5nYCAod2hlbiB0aGUgY29uc3RhbnQgaGFzIG5vIDo6IHByZWZpeCkuXHJcbiAgT3BhbC5jb25zdF9nZXRfcmVsYXRpdmUgPSBmdW5jdGlvbihuZXN0aW5nLCBuYW1lLCBza2lwX21pc3NpbmcpIHtcclxuICAgIHZhciBjcmVmID0gbmVzdGluZ1swXSwgcmVzdWx0LCBjdXJyZW50X3ZlcnNpb24gPSBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24sIGNhY2hlLCBjYWNoZWQ7XHJcblxyXG4gICAgaWYgKChjYWNoZSA9IG5lc3RpbmcuJCRjb25zdF9jYWNoZSkgPT0gbnVsbCkge1xyXG4gICAgICAkcHJvcChuZXN0aW5nLCAnJCRjb25zdF9jYWNoZScsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xyXG4gICAgICBjYWNoZSA9IG5lc3RpbmcuJCRjb25zdF9jYWNoZTtcclxuICAgIH1cclxuICAgIGNhY2hlZCA9IGNhY2hlW25hbWVdO1xyXG5cclxuICAgIGlmIChjYWNoZWQgPT0gbnVsbCB8fCBjYWNoZWRbMF0gIT09IGN1cnJlbnRfdmVyc2lvbikge1xyXG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2dldF9uYW1lKGNyZWYsIG5hbWUpKSAgICAgICAgICAgICAgIT0gbnVsbCkgfHxcclxuICAgICAgKChyZXN1bHQgPSBjb25zdF9sb29rdXBfbmVzdGluZyhuZXN0aW5nLCBuYW1lKSkgICAgICE9IG51bGwpIHx8XHJcbiAgICAgICgocmVzdWx0ID0gY29uc3RfbG9va3VwX2FuY2VzdG9ycyhjcmVmLCBuYW1lKSkgICAgICAhPSBudWxsKSB8fFxyXG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2xvb2t1cF9PYmplY3QoY3JlZiwgbmFtZSkpICAgICAgICAgIT0gbnVsbCk7XHJcblxyXG4gICAgICBjYWNoZVtuYW1lXSA9IFtjdXJyZW50X3ZlcnNpb24sIHJlc3VsdF07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXN1bHQgPSBjYWNoZWRbMV07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdCAhPSBudWxsIHx8IHNraXBfbWlzc2luZyA/IHJlc3VsdCA6IGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmVnaXN0ZXIgdGhlIGNvbnN0YW50IG9uIGEgY3JlZiBhbmQgb3Bwb3J0dW5pc3RpY2FsbHkgc2V0IHRoZSBuYW1lIG9mXHJcbiAgLy8gdW5uYW1lZCBjbGFzc2VzL21vZHVsZXMuXHJcbiAgZnVuY3Rpb24gJGNvbnN0X3NldChjcmVmLCBuYW1lLCB2YWx1ZSkge1xyXG4gICAgdmFyIG5ld19jb25zdCA9IHRydWU7XHJcblxyXG4gICAgaWYgKGNyZWYgPT0gbnVsbCB8fCBjcmVmID09PSAnOjonKSBjcmVmID0gX09iamVjdDtcclxuXHJcbiAgICBpZiAodmFsdWUuJCRpc19hX21vZHVsZSkge1xyXG4gICAgICBpZiAodmFsdWUuJCRuYW1lID09IG51bGwgfHwgdmFsdWUuJCRuYW1lID09PSBuaWwpIHZhbHVlLiQkbmFtZSA9IG5hbWU7XHJcbiAgICAgIGlmICh2YWx1ZS4kJGJhc2VfbW9kdWxlID09IG51bGwpIHZhbHVlLiQkYmFzZV9tb2R1bGUgPSBjcmVmO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWYuJCRjb25zdCA9IChjcmVmLiQkY29uc3QgfHwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XHJcblxyXG4gICAgaWYgKG5hbWUgaW4gY3JlZi4kJGNvbnN0IHx8IChcIiQkYXV0b2xvYWRcIiBpbiBjcmVmICYmIG5hbWUgaW4gY3JlZi4kJGF1dG9sb2FkKSkge1xyXG4gICAgICBuZXdfY29uc3QgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBjcmVmLiQkY29uc3RbbmFtZV0gPSB2YWx1ZTtcclxuXHJcbiAgICAvLyBBZGQgYSBzaG9ydCBoZWxwZXIgdG8gbmF2aWdhdGUgY29uc3RhbnRzIG1hbnVhbGx5LlxyXG4gICAgLy8gQGV4YW1wbGVcclxuICAgIC8vICAgT3BhbC4kJC5SZWdleHAuJCQuSUdOT1JFQ0FTRVxyXG4gICAgY3JlZi4kJCA9IGNyZWYuJCRjb25zdDtcclxuXHJcbiAgICBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24rKztcclxuXHJcbiAgICAvLyBFeHBvc2UgdG9wIGxldmVsIGNvbnN0YW50cyBvbnRvIHRoZSBPcGFsIG9iamVjdFxyXG4gICAgaWYgKGNyZWYgPT09IF9PYmplY3QpIE9wYWxbbmFtZV0gPSB2YWx1ZTtcclxuXHJcbiAgICAvLyBOYW1lIG5ldyBjbGFzcyBkaXJlY3RseSBvbnRvIGN1cnJlbnQgc2NvcGUgKE9wYWwuRm9vLkJheiA9IGtsYXNzKVxyXG4gICAgJHByb3AoY3JlZiwgbmFtZSwgdmFsdWUpO1xyXG5cclxuICAgIGlmIChuZXdfY29uc3QgJiYgY3JlZi4kY29uc3RfYWRkZWQgJiYgIWNyZWYuJGNvbnN0X2FkZGVkLiQkcHJpc3RpbmUpIHtcclxuICAgICAgY3JlZi4kY29uc3RfYWRkZWQobmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH07XHJcblxyXG4gIE9wYWwuY29uc3Rfc2V0ID0gJGNvbnN0X3NldDtcclxuXHJcbiAgLy8gR2V0IGFsbCB0aGUgY29uc3RhbnRzIHJlYWNoYWJsZSBmcm9tIGEgZ2l2ZW4gY3JlZiwgYnkgZGVmYXVsdCB3aWxsIGluY2x1ZGVcclxuICAvLyBpbmhlcml0ZWQgY29uc3RhbnRzLlxyXG4gIE9wYWwuY29uc3RhbnRzID0gZnVuY3Rpb24oY3JlZiwgaW5oZXJpdCkge1xyXG4gICAgaWYgKGluaGVyaXQgPT0gbnVsbCkgaW5oZXJpdCA9IHRydWU7XHJcblxyXG4gICAgdmFyIG1vZHVsZSwgbW9kdWxlcyA9IFtjcmVmXSwgaSwgaWksIGNvbnN0YW50cyA9IHt9LCBjb25zdGFudDtcclxuXHJcbiAgICBpZiAoaW5oZXJpdCkgbW9kdWxlcyA9IG1vZHVsZXMuY29uY2F0KCRhbmNlc3RvcnMoY3JlZikpO1xyXG4gICAgaWYgKGluaGVyaXQgJiYgY3JlZi4kJGlzX21vZHVsZSkgbW9kdWxlcyA9IG1vZHVsZXMuY29uY2F0KFtPcGFsLk9iamVjdF0pLmNvbmNhdCgkYW5jZXN0b3JzKE9wYWwuT2JqZWN0KSk7XHJcblxyXG4gICAgZm9yIChpID0gMCwgaWkgPSBtb2R1bGVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcclxuICAgICAgbW9kdWxlID0gbW9kdWxlc1tpXTtcclxuXHJcbiAgICAgIC8vIERvIG5vdCBzaG93IE9iamVjdHMgY29uc3RhbnRzIHVubGVzcyB3ZSdyZSBxdWVyeWluZyBPYmplY3QgaXRzZWxmXHJcbiAgICAgIGlmIChjcmVmICE9PSBfT2JqZWN0ICYmIG1vZHVsZSA9PSBfT2JqZWN0KSBicmVhaztcclxuXHJcbiAgICAgIGZvciAoY29uc3RhbnQgaW4gbW9kdWxlLiQkY29uc3QpIHtcclxuICAgICAgICBjb25zdGFudHNbY29uc3RhbnRdID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobW9kdWxlLiQkYXV0b2xvYWQpIHtcclxuICAgICAgICBmb3IgKGNvbnN0YW50IGluIG1vZHVsZS4kJGF1dG9sb2FkKSB7XHJcbiAgICAgICAgICBjb25zdGFudHNbY29uc3RhbnRdID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoY29uc3RhbnRzKTtcclxuICB9O1xyXG5cclxuICAvLyBSZW1vdmUgYSBjb25zdGFudCBmcm9tIGEgY3JlZi5cclxuICBPcGFsLmNvbnN0X3JlbW92ZSA9IGZ1bmN0aW9uKGNyZWYsIG5hbWUpIHtcclxuICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xyXG5cclxuICAgIGlmIChjcmVmLiQkY29uc3RbbmFtZV0gIT0gbnVsbCkge1xyXG4gICAgICB2YXIgb2xkID0gY3JlZi4kJGNvbnN0W25hbWVdO1xyXG4gICAgICBkZWxldGUgY3JlZi4kJGNvbnN0W25hbWVdO1xyXG4gICAgICByZXR1cm4gb2xkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjcmVmLiQkYXV0b2xvYWQgJiYgY3JlZi4kJGF1dG9sb2FkW25hbWVdKSB7XHJcbiAgICAgIGRlbGV0ZSBjcmVmLiQkYXV0b2xvYWRbbmFtZV07XHJcbiAgICAgIHJldHVybiBuaWw7XHJcbiAgICB9XHJcblxyXG4gICAgJHJhaXNlKE9wYWwuTmFtZUVycm9yLCBcImNvbnN0YW50IFwiK2NyZWYrXCI6OlwiK2NyZWYuJG5hbWUoKStcIiBub3QgZGVmaW5lZFwiKTtcclxuICB9O1xyXG5cclxuICAvLyBHZW5lcmF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIGEgY3VycmllZCBjb25zdF9nZXRfcmVsYXRpdmUuXHJcbiAgT3BhbC5jb25zdF9nZXRfcmVsYXRpdmVfZmFjdG9yeSA9IGZ1bmN0aW9uKG5lc3RpbmcpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbihuYW1lLCBza2lwX21pc3NpbmcpIHtcclxuICAgICAgcmV0dXJuIE9wYWwuJCQobmVzdGluZywgbmFtZSwgc2tpcF9taXNzaW5nKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFNldHVwIHNvbWUgc2hvcnRjdXRzIHRvIHJlZHVjZSBjb21waWxlZCBzaXplXHJcbiAgT3BhbC4kJCA9IE9wYWwuY29uc3RfZ2V0X3JlbGF0aXZlO1xyXG4gIE9wYWwuJCQkID0gT3BhbC5jb25zdF9nZXRfcXVhbGlmaWVkO1xyXG4gIE9wYWwuJHIgPSBPcGFsLmNvbnN0X2dldF9yZWxhdGl2ZV9mYWN0b3J5O1xyXG5cclxuICBmdW5jdGlvbiBkZXNjZW5kc19mcm9tX2JyaWRnZWRfY2xhc3Moa2xhc3MpIHtcclxuICAgIGlmIChrbGFzcyA9PSBudWxsKSByZXR1cm4gZmFsc2U7XHJcbiAgICBpZiAoa2xhc3MuJCRicmlkZ2UpIHJldHVybiBrbGFzcztcclxuICAgIGlmIChrbGFzcy4kJHN1cGVyKSByZXR1cm4gZGVzY2VuZHNfZnJvbV9icmlkZ2VkX2NsYXNzKGtsYXNzLiQkc3VwZXIpO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gTW9kdWxlcyAmIENsYXNzZXNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyBBIGBjbGFzcyBGb287IGVuZGAgZXhwcmVzc2lvbiBpbiBydWJ5IGlzIGNvbXBpbGVkIHRvIGNhbGwgdGhpcyBydW50aW1lXHJcbiAgLy8gbWV0aG9kIHdoaWNoIGVpdGhlciByZXR1cm5zIGFuIGV4aXN0aW5nIGNsYXNzIG9mIHRoZSBnaXZlbiBuYW1lLCBvciBjcmVhdGVzXHJcbiAgLy8gYSBuZXcgY2xhc3MgaW4gdGhlIGdpdmVuIGBiYXNlYCBzY29wZS5cclxuICAvL1xyXG4gIC8vIElmIGEgY29uc3RhbnQgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBleGlzdHMsIHRoZW4gd2UgY2hlY2sgdG8gbWFrZSBzdXJlIHRoYXRcclxuICAvLyBpdCBpcyBhIGNsYXNzIGFuZCBhbHNvIHRoYXQgdGhlIHN1cGVyY2xhc3NlcyBtYXRjaC4gSWYgZWl0aGVyIG9mIHRoZXNlXHJcbiAgLy8gZmFpbCwgdGhlbiB3ZSByYWlzZSBhIGBUeXBlRXJyb3JgLiBOb3RlLCBgc3VwZXJjbGFzc2AgbWF5IGJlIG51bGwgaWYgb25lXHJcbiAgLy8gd2FzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIHJ1YnkgY29kZS5cclxuICAvL1xyXG4gIC8vIFdlIHBhc3MgYSBjb25zdHJ1Y3RvciB0byB0aGlzIG1ldGhvZCBvZiB0aGUgZm9ybSBgZnVuY3Rpb24gQ2xhc3NOYW1lKCkge31gXHJcbiAgLy8gc2ltcGx5IHNvIHRoYXQgY2xhc3NlcyBzaG93IHVwIHdpdGggbmljZWx5IGZvcm1hdHRlZCBuYW1lcyBpbnNpZGUgZGVidWdnZXJzXHJcbiAgLy8gaW4gdGhlIHdlYiBicm93c2VyIChvciBub2RlL3Nwcm9ja2V0cykuXHJcbiAgLy9cclxuICAvLyBUaGUgYHNjb3BlYCBpcyB0aGUgY3VycmVudCBgc2VsZmAgdmFsdWUgd2hlcmUgdGhlIGNsYXNzIGlzIGJlaW5nIGNyZWF0ZWRcclxuICAvLyBmcm9tLiBXZSB1c2UgdGhpcyB0byBnZXQgdGhlIHNjb3BlIGZvciB3aGVyZSB0aGUgY2xhc3Mgc2hvdWxkIGJlIGNyZWF0ZWQuXHJcbiAgLy8gSWYgYHNjb3BlYCBpcyBhbiBvYmplY3QgKG5vdCBhIGNsYXNzL21vZHVsZSksIHdlIHNpbXBsZSBnZXQgaXRzIGNsYXNzIGFuZFxyXG4gIC8vIHVzZSB0aGF0IGFzIHRoZSBzY29wZSBpbnN0ZWFkLlxyXG4gIC8vXHJcbiAgLy8gQHBhcmFtIHNjb3BlICAgICAgICBbT2JqZWN0XSB3aGVyZSB0aGUgY2xhc3MgaXMgYmVpbmcgY3JlYXRlZFxyXG4gIC8vIEBwYXJhbSBzdXBlcmNsYXNzICAgW0NsYXNzLG51bGxdIHN1cGVyY2xhc3Mgb2YgdGhlIG5ldyBjbGFzcyAobWF5IGJlIG51bGwpXHJcbiAgLy8gQHBhcmFtIHNpbmdsZXRvbiAgICBbQm9vbGVhbixudWxsXSBhIHRydWUgdmFsdWUgZGVub3RlcyB3ZSB3YW50IHRvIGFsbG9jYXRlXHJcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIHNpbmdsZXRvblxyXG4gIC8vXHJcbiAgLy8gQHJldHVybiBuZXcgW0NsYXNzXSAgb3IgZXhpc3RpbmcgcnVieSBjbGFzc1xyXG4gIC8vXHJcbiAgZnVuY3Rpb24gJGFsbG9jYXRlX2NsYXNzKG5hbWUsIHN1cGVyY2xhc3MsIHNpbmdsZXRvbikge1xyXG4gICAgdmFyIGtsYXNzLCBicmlkZ2VkX2Rlc2NlbmRhbnQ7XHJcblxyXG4gICAgaWYgKGJyaWRnZWRfZGVzY2VuZGFudCA9IGRlc2NlbmRzX2Zyb21fYnJpZGdlZF9jbGFzcyhzdXBlcmNsYXNzKSkge1xyXG4gICAgICAvLyBJbmhlcml0YW5jZSBmcm9tIGJyaWRnZWQgY2xhc3NlcyByZXF1aXJlc1xyXG4gICAgICAvLyBjYWxsaW5nIG9yaWdpbmFsIEpTIGNvbnN0cnVjdG9yc1xyXG4gICAgICBrbGFzcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBzZWxmID0gbmV3ICgkYmluZC5hcHBseShicmlkZ2VkX2Rlc2NlbmRhbnQuJCRjb25zdHJ1Y3RvciwgJHByZXBlbmQobnVsbCwgYXJndW1lbnRzKSkpKCk7XHJcblxyXG4gICAgICAgIC8vIGFuZCByZXBsYWNpbmcgYSBfX3Byb3RvX18gbWFudWFsbHlcclxuICAgICAgICAkc2V0X3Byb3RvKHNlbGYsIGtsYXNzLiQkcHJvdG90eXBlKTtcclxuICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAga2xhc3MgPSBmdW5jdGlvbigpe307XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5hbWUgJiYgbmFtZSAhPT0gbmlsKSB7XHJcbiAgICAgICRwcm9wKGtsYXNzLCAnZGlzcGxheU5hbWUnLCAnOjonK25hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgICRwcm9wKGtsYXNzLCAnJCRuYW1lJywgbmFtZSk7XHJcbiAgICAkcHJvcChrbGFzcywgJyQkY29uc3RydWN0b3InLCBrbGFzcyk7XHJcbiAgICAkcHJvcChrbGFzcywgJyQkcHJvdG90eXBlJywga2xhc3MucHJvdG90eXBlKTtcclxuICAgICRwcm9wKGtsYXNzLCAnJCRjb25zdCcsIHt9KTtcclxuICAgICRwcm9wKGtsYXNzLCAnJCRpc19jbGFzcycsIHRydWUpO1xyXG4gICAgJHByb3Aoa2xhc3MsICckJGlzX2FfbW9kdWxlJywgdHJ1ZSk7XHJcbiAgICAkcHJvcChrbGFzcywgJyQkc3VwZXInLCBzdXBlcmNsYXNzKTtcclxuICAgICRwcm9wKGtsYXNzLCAnJCRjdmFycycsIHt9KTtcclxuICAgICRwcm9wKGtsYXNzLCAnJCRvd25faW5jbHVkZWRfbW9kdWxlcycsIFtdKTtcclxuICAgICRwcm9wKGtsYXNzLCAnJCRvd25fcHJlcGVuZGVkX21vZHVsZXMnLCBbXSk7XHJcbiAgICAkcHJvcChrbGFzcywgJyQkYW5jZXN0b3JzJywgW10pO1xyXG4gICAgJHByb3Aoa2xhc3MsICckJGFuY2VzdG9yc19jYWNoZV92ZXJzaW9uJywgbnVsbCk7XHJcbiAgICAkcHJvcChrbGFzcywgJyQkc3ViY2xhc3NlcycsIFtdKTtcclxuICAgICRwcm9wKGtsYXNzLCAnJCRjbG9uZWRfZnJvbScsIFtdKTtcclxuXHJcbiAgICAkcHJvcChrbGFzcy4kJHByb3RvdHlwZSwgJyQkY2xhc3MnLCBrbGFzcyk7XHJcblxyXG4gICAgLy8gQnkgZGVmYXVsdCBpZiB0aGVyZSBhcmUgbm8gc2luZ2xldG9uIGNsYXNzIG1ldGhvZHNcclxuICAgIC8vIF9fcHJvdG9fXyBpcyBDbGFzcy5wcm90b3R5cGVcclxuICAgIC8vIExhdGVyIHNpbmdsZXRvbiBtZXRob2RzIGdlbmVyYXRlIGEgc2luZ2xldG9uX2NsYXNzXHJcbiAgICAvLyBhbmQgaW5qZWN0IGl0IGludG8gYW5jZXN0b3JzIGNoYWluXHJcbiAgICBpZiAoT3BhbC5DbGFzcykge1xyXG4gICAgICAkc2V0X3Byb3RvKGtsYXNzLCBPcGFsLkNsYXNzLnByb3RvdHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHN1cGVyY2xhc3MgIT0gbnVsbCkge1xyXG4gICAgICAkc2V0X3Byb3RvKGtsYXNzLiQkcHJvdG90eXBlLCBzdXBlcmNsYXNzLiQkcHJvdG90eXBlKTtcclxuXHJcbiAgICAgIGlmIChzaW5nbGV0b24gIT09IHRydWUpIHtcclxuICAgICAgICAvLyBMZXQncyBub3QgZm9yYmlkIEdDIGZyb20gY2xlYW5pbmcgdXAgb3VyXHJcbiAgICAgICAgLy8gc3ViY2xhc3Nlcy5cclxuICAgICAgICBpZiAodHlwZW9mIFdlYWtSZWYgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAvLyBGaXJzdCwgbGV0J3MgY2xlYW4gdXAgb3VyIGFycmF5IGZyb20gZW1wdHkgb2JqZWN0cy5cclxuICAgICAgICAgIHZhciBpLCBzdWJjbGFzcywgcmVidWlsdF9zdWJjbGFzc2VzID0gW107XHJcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3VwZXJjbGFzcy4kJHN1YmNsYXNzZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc3ViY2xhc3MgPSBzdXBlcmNsYXNzLiQkc3ViY2xhc3Nlc1tpXTtcclxuICAgICAgICAgICAgaWYgKHN1YmNsYXNzLmRlcmVmKCkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgIHJlYnVpbHRfc3ViY2xhc3Nlcy5wdXNoKHN1YmNsYXNzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gTm93LCBsZXQncyBhZGQgb3VyIGNsYXNzLlxyXG4gICAgICAgICAgcmVidWlsdF9zdWJjbGFzc2VzLnB1c2gobmV3IFdlYWtSZWYoa2xhc3MpKTtcclxuICAgICAgICAgIHN1cGVyY2xhc3MuJCRzdWJjbGFzc2VzID0gcmVidWlsdF9zdWJjbGFzc2VzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHN1cGVyY2xhc3MuJCRzdWJjbGFzc2VzLnB1c2goa2xhc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHN1cGVyY2xhc3MuJCRtZXRhKSB7XHJcbiAgICAgICAgLy8gSWYgc3VwZXJjbGFzcyBoYXMgbWV0YWNsYXNzIHRoZW4gd2UgaGF2ZSBleHBsaWNpdGVseSBpbmhlcml0IGl0LlxyXG4gICAgICAgIE9wYWwuYnVpbGRfY2xhc3Nfc2luZ2xldG9uX2NsYXNzKGtsYXNzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBrbGFzcztcclxuICB9O1xyXG4gIE9wYWwuYWxsb2NhdGVfY2xhc3MgPSAkYWxsb2NhdGVfY2xhc3M7XHJcblxyXG5cclxuICBmdW5jdGlvbiBmaW5kX2V4aXN0aW5nX2NsYXNzKHNjb3BlLCBuYW1lKSB7XHJcbiAgICAvLyBUcnkgdG8gZmluZCB0aGUgY2xhc3MgaW4gdGhlIGN1cnJlbnQgc2NvcGVcclxuICAgIHZhciBrbGFzcyA9IGNvbnN0X2dldF9uYW1lKHNjb3BlLCBuYW1lKTtcclxuXHJcbiAgICAvLyBJZiB0aGUgY2xhc3MgZXhpc3RzIGluIHRoZSBzY29wZSwgdGhlbiB3ZSBtdXN0IHVzZSB0aGF0XHJcbiAgICBpZiAoa2xhc3MpIHtcclxuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBleGlzdGluZyBjb25zdGFudCBpcyBhIGNsYXNzLCBvciByYWlzZSBlcnJvclxyXG4gICAgICBpZiAoIWtsYXNzLiQkaXNfY2xhc3MpIHtcclxuICAgICAgICAkcmFpc2UoT3BhbC5UeXBlRXJyb3IsIG5hbWUgKyBcIiBpcyBub3QgYSBjbGFzc1wiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGtsYXNzO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZW5zdXJlU3VwZXJjbGFzc01hdGNoKGtsYXNzLCBzdXBlcmNsYXNzKSB7XHJcbiAgICBpZiAoa2xhc3MuJCRzdXBlciAhPT0gc3VwZXJjbGFzcykge1xyXG4gICAgICAkcmFpc2UoT3BhbC5UeXBlRXJyb3IsIFwic3VwZXJjbGFzcyBtaXNtYXRjaCBmb3IgY2xhc3MgXCIgKyBrbGFzcy4kJG5hbWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgT3BhbC5rbGFzcyA9IGZ1bmN0aW9uKHNjb3BlLCBzdXBlcmNsYXNzLCBuYW1lKSB7XHJcbiAgICB2YXIgYnJpZGdlZDtcclxuXHJcbiAgICBpZiAoc2NvcGUgPT0gbnVsbCB8fCBzY29wZSA9PSAnOjonKSB7XHJcbiAgICAgIC8vIEdsb2JhbCBzY29wZVxyXG4gICAgICBzY29wZSA9IF9PYmplY3Q7XHJcbiAgICB9IGVsc2UgaWYgKCFzY29wZS4kJGlzX2NsYXNzICYmICFzY29wZS4kJGlzX21vZHVsZSkge1xyXG4gICAgICAvLyBTY29wZSBpcyBhbiBvYmplY3QsIHVzZSBpdHMgY2xhc3NcclxuICAgICAgc2NvcGUgPSBzY29wZS4kJGNsYXNzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHRoZSBzdXBlcmNsYXNzIGlzIG5vdCBhbiBPcGFsLWdlbmVyYXRlZCBjbGFzcyB0aGVuIHdlJ3JlIGJyaWRnaW5nIGEgbmF0aXZlIEpTIGNsYXNzXHJcbiAgICBpZiAoXHJcbiAgICAgIHN1cGVyY2xhc3MgIT0gbnVsbCAmJiAoIXN1cGVyY2xhc3MuaGFzT3duUHJvcGVydHkgfHwgKFxyXG4gICAgICAgIHN1cGVyY2xhc3MuaGFzT3duUHJvcGVydHkgJiYgIXN1cGVyY2xhc3MuaGFzT3duUHJvcGVydHkoJyQkaXNfY2xhc3MnKVxyXG4gICAgICApKVxyXG4gICAgKSB7XHJcbiAgICAgIGlmIChzdXBlcmNsYXNzLmNvbnN0cnVjdG9yICYmIHN1cGVyY2xhc3MuY29uc3RydWN0b3IubmFtZSA9PSBcIkZ1bmN0aW9uXCIpIHtcclxuICAgICAgICBicmlkZ2VkID0gc3VwZXJjbGFzcztcclxuICAgICAgICBzdXBlcmNsYXNzID0gX09iamVjdDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAkcmFpc2UoT3BhbC5UeXBlRXJyb3IsIFwic3VwZXJjbGFzcyBtdXN0IGJlIGEgQ2xhc3MgKFwiICsgKFxyXG4gICAgICAgICAgKHN1cGVyY2xhc3MuY29uc3RydWN0b3IgJiYgKHN1cGVyY2xhc3MuY29uc3RydWN0b3IubmFtZSB8fCBzdXBlcmNsYXNzLmNvbnN0cnVjdG9yLiQkbmFtZSkpIHx8XHJcbiAgICAgICAgICB0eXBlb2Yoc3VwZXJjbGFzcylcclxuICAgICAgICApICsgXCIgZ2l2ZW4pXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGtsYXNzID0gZmluZF9leGlzdGluZ19jbGFzcyhzY29wZSwgbmFtZSk7XHJcblxyXG4gICAgaWYgKGtsYXNzICE9IG51bGwpIHtcclxuICAgICAgaWYgKHN1cGVyY2xhc3MpIHtcclxuICAgICAgICAvLyBNYWtlIHN1cmUgZXhpc3RpbmcgY2xhc3MgaGFzIHNhbWUgc3VwZXJjbGFzc1xyXG4gICAgICAgIGVuc3VyZVN1cGVyY2xhc3NNYXRjaChrbGFzcywgc3VwZXJjbGFzcyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAvLyBDbGFzcyBkb2Vzbid0IGV4aXN0LCBjcmVhdGUgYSBuZXcgb25lIHdpdGggZ2l2ZW4gc3VwZXJjbGFzcy4uLlxyXG5cclxuICAgICAgLy8gTm90IHNwZWNpZnlpbmcgYSBzdXBlcmNsYXNzIG1lYW5zIHdlIGNhbiBhc3N1bWUgaXQgdG8gYmUgT2JqZWN0XHJcbiAgICAgIGlmIChzdXBlcmNsYXNzID09IG51bGwpIHtcclxuICAgICAgICBzdXBlcmNsYXNzID0gX09iamVjdDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ3JlYXRlIHRoZSBjbGFzcyBvYmplY3QgKGluc3RhbmNlIG9mIENsYXNzKVxyXG4gICAgICBrbGFzcyA9ICRhbGxvY2F0ZV9jbGFzcyhuYW1lLCBzdXBlcmNsYXNzKTtcclxuICAgICAgJGNvbnN0X3NldChzY29wZSwgbmFtZSwga2xhc3MpO1xyXG5cclxuICAgICAgLy8gQ2FsbCAuaW5oZXJpdGVkKCkgaG9vayB3aXRoIG5ldyBjbGFzcyBvbiB0aGUgc3VwZXJjbGFzc1xyXG4gICAgICBpZiAoc3VwZXJjbGFzcy4kaW5oZXJpdGVkKSB7XHJcbiAgICAgICAgc3VwZXJjbGFzcy4kaW5oZXJpdGVkKGtsYXNzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGJyaWRnZWQpIHtcclxuICAgICAgICBPcGFsLmJyaWRnZShicmlkZ2VkLCBrbGFzcyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoT3BhbC50cmFjZV9jbGFzcykgeyBpbnZva2VfdHJhY2Vyc19mb3JfY2xhc3Moa2xhc3MpOyB9XHJcblxyXG4gICAgcmV0dXJuIGtsYXNzO1xyXG4gIH07XHJcblxyXG4gIC8vIERlZmluZSBuZXcgbW9kdWxlIChvciByZXR1cm4gZXhpc3RpbmcgbW9kdWxlKS4gVGhlIGdpdmVuIGBzY29wZWAgaXMgYmFzaWNhbGx5XHJcbiAgLy8gdGhlIGN1cnJlbnQgYHNlbGZgIHZhbHVlIHRoZSBgbW9kdWxlYCBzdGF0ZW1lbnQgd2FzIGRlZmluZWQgaW4uIElmIHRoaXMgaXNcclxuICAvLyBhIHJ1YnkgbW9kdWxlIG9yIGNsYXNzLCB0aGVuIGl0IGlzIHVzZWQsIG90aGVyd2lzZSBpZiB0aGUgc2NvcGUgaXMgYSBydWJ5XHJcbiAgLy8gb2JqZWN0IHRoZW4gdGhhdCBvYmplY3RzIHJlYWwgcnVieSBjbGFzcyBpcyB1c2VkIChlLmcuIGlmIHRoZSBzY29wZSBpcyB0aGVcclxuICAvLyBtYWluIG9iamVjdCwgdGhlbiB0aGUgdG9wIGxldmVsIGBPYmplY3RgIGNsYXNzIGlzIHVzZWQgYXMgdGhlIHNjb3BlKS5cclxuICAvL1xyXG4gIC8vIElmIGEgbW9kdWxlIG9mIHRoZSBnaXZlbiBuYW1lIGlzIGFscmVhZHkgZGVmaW5lZCBpbiB0aGUgc2NvcGUsIHRoZW4gdGhhdFxyXG4gIC8vIGluc3RhbmNlIGlzIGp1c3QgcmV0dXJuZWQuXHJcbiAgLy9cclxuICAvLyBJZiB0aGVyZSBpcyBhIGNsYXNzIG9mIHRoZSBnaXZlbiBuYW1lIGluIHRoZSBzY29wZSwgdGhlbiBhbiBlcnJvciBpc1xyXG4gIC8vIGdlbmVyYXRlZCBpbnN0ZWFkIChjYW5ub3QgaGF2ZSBhIGNsYXNzIGFuZCBtb2R1bGUgb2Ygc2FtZSBuYW1lIGluIHNhbWUgc2NvcGUpLlxyXG4gIC8vXHJcbiAgLy8gT3RoZXJ3aXNlLCBhIG5ldyBtb2R1bGUgaXMgY3JlYXRlZCBpbiB0aGUgc2NvcGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZSwgYW5kIHRoYXRcclxuICAvLyBuZXcgaW5zdGFuY2UgaXMgcmV0dXJuZWQgYmFjayAodG8gYmUgcmVmZXJlbmNlZCBhdCBydW50aW1lKS5cclxuICAvL1xyXG4gIC8vIEBwYXJhbSAgc2NvcGUgW01vZHVsZSwgQ2xhc3NdIGNsYXNzIG9yIG1vZHVsZSB0aGlzIGRlZmluaXRpb24gaXMgaW5zaWRlXHJcbiAgLy8gQHBhcmFtICBpZCAgIFtTdHJpbmddIHRoZSBuYW1lIG9mIHRoZSBuZXcgKG9yIGV4aXN0aW5nKSBtb2R1bGVcclxuICAvL1xyXG4gIC8vIEByZXR1cm4gW01vZHVsZV1cclxuICBmdW5jdGlvbiAkYWxsb2NhdGVfbW9kdWxlKG5hbWUpIHtcclxuICAgIHZhciBjb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCl7fTtcclxuICAgIHZhciBtb2R1bGUgPSBjb25zdHJ1Y3RvcjtcclxuXHJcbiAgICBpZiAobmFtZSlcclxuICAgICAgJHByb3AoY29uc3RydWN0b3IsICdkaXNwbGF5TmFtZScsIG5hbWUrJy5jb25zdHJ1Y3RvcicpO1xyXG5cclxuICAgICRwcm9wKG1vZHVsZSwgJyQkbmFtZScsIG5hbWUpO1xyXG4gICAgJHByb3AobW9kdWxlLCAnJCRwcm90b3R5cGUnLCBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xyXG4gICAgJHByb3AobW9kdWxlLCAnJCRjb25zdCcsIHt9KTtcclxuICAgICRwcm9wKG1vZHVsZSwgJyQkaXNfbW9kdWxlJywgdHJ1ZSk7XHJcbiAgICAkcHJvcChtb2R1bGUsICckJGlzX2FfbW9kdWxlJywgdHJ1ZSk7XHJcbiAgICAkcHJvcChtb2R1bGUsICckJGN2YXJzJywge30pO1xyXG4gICAgJHByb3AobW9kdWxlLCAnJCRpY2xhc3NlcycsIFtdKTtcclxuICAgICRwcm9wKG1vZHVsZSwgJyQkb3duX2luY2x1ZGVkX21vZHVsZXMnLCBbXSk7XHJcbiAgICAkcHJvcChtb2R1bGUsICckJG93bl9wcmVwZW5kZWRfbW9kdWxlcycsIFtdKTtcclxuICAgICRwcm9wKG1vZHVsZSwgJyQkYW5jZXN0b3JzJywgW21vZHVsZV0pO1xyXG4gICAgJHByb3AobW9kdWxlLCAnJCRhbmNlc3RvcnNfY2FjaGVfdmVyc2lvbicsIG51bGwpO1xyXG4gICAgJHByb3AobW9kdWxlLCAnJCRjbG9uZWRfZnJvbScsIFtdKTtcclxuXHJcbiAgICAkc2V0X3Byb3RvKG1vZHVsZSwgT3BhbC5Nb2R1bGUucHJvdG90eXBlKTtcclxuXHJcbiAgICByZXR1cm4gbW9kdWxlO1xyXG4gIH07XHJcbiAgT3BhbC5hbGxvY2F0ZV9tb2R1bGUgPSAkYWxsb2NhdGVfbW9kdWxlO1xyXG5cclxuICBmdW5jdGlvbiBmaW5kX2V4aXN0aW5nX21vZHVsZShzY29wZSwgbmFtZSkge1xyXG4gICAgdmFyIG1vZHVsZSA9IGNvbnN0X2dldF9uYW1lKHNjb3BlLCBuYW1lKTtcclxuICAgIGlmIChtb2R1bGUgPT0gbnVsbCAmJiBzY29wZSA9PT0gX09iamVjdCkgbW9kdWxlID0gY29uc3RfbG9va3VwX2FuY2VzdG9ycyhfT2JqZWN0LCBuYW1lKTtcclxuXHJcbiAgICBpZiAobW9kdWxlKSB7XHJcbiAgICAgIGlmICghbW9kdWxlLiQkaXNfbW9kdWxlICYmIG1vZHVsZSAhPT0gX09iamVjdCkge1xyXG4gICAgICAgICRyYWlzZShPcGFsLlR5cGVFcnJvciwgbmFtZSArIFwiIGlzIG5vdCBhIG1vZHVsZVwiKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtb2R1bGU7XHJcbiAgfVxyXG5cclxuICBPcGFsLm1vZHVsZSA9IGZ1bmN0aW9uKHNjb3BlLCBuYW1lKSB7XHJcbiAgICB2YXIgbW9kdWxlO1xyXG5cclxuICAgIGlmIChzY29wZSA9PSBudWxsIHx8IHNjb3BlID09ICc6OicpIHtcclxuICAgICAgLy8gR2xvYmFsIHNjb3BlXHJcbiAgICAgIHNjb3BlID0gX09iamVjdDtcclxuICAgIH0gZWxzZSBpZiAoIXNjb3BlLiQkaXNfY2xhc3MgJiYgIXNjb3BlLiQkaXNfbW9kdWxlKSB7XHJcbiAgICAgIC8vIFNjb3BlIGlzIGFuIG9iamVjdCwgdXNlIGl0cyBjbGFzc1xyXG4gICAgICBzY29wZSA9IHNjb3BlLiQkY2xhc3M7XHJcbiAgICB9XHJcblxyXG4gICAgbW9kdWxlID0gZmluZF9leGlzdGluZ19tb2R1bGUoc2NvcGUsIG5hbWUpO1xyXG5cclxuICAgIGlmIChtb2R1bGUgPT0gbnVsbCkge1xyXG4gICAgICAvLyBNb2R1bGUgZG9lc250IGV4aXN0LCBjcmVhdGUgYSBuZXcgb25lLi4uXHJcbiAgICAgIG1vZHVsZSA9ICRhbGxvY2F0ZV9tb2R1bGUobmFtZSk7XHJcbiAgICAgICRjb25zdF9zZXQoc2NvcGUsIG5hbWUsIG1vZHVsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKE9wYWwudHJhY2VfY2xhc3MpIHsgaW52b2tlX3RyYWNlcnNfZm9yX2NsYXNzKG1vZHVsZSk7IH1cclxuXHJcbiAgICByZXR1cm4gbW9kdWxlO1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybiB0aGUgc2luZ2xldG9uIGNsYXNzIGZvciB0aGUgcGFzc2VkIG9iamVjdC5cclxuICAvL1xyXG4gIC8vIElmIHRoZSBnaXZlbiBvYmplY3QgYWxyZWR5IGhhcyBhIHNpbmdsZXRvbiBjbGFzcywgdGhlbiBpdCB3aWxsIGJlIHN0b3JlZCBvblxyXG4gIC8vIHRoZSBvYmplY3QgYXMgdGhlIGAkJG1ldGFgIHByb3BlcnR5LiBJZiB0aGlzIGV4aXN0cywgdGhlbiBpdCBpcyBzaW1wbHlcclxuICAvLyByZXR1cm5lZCBiYWNrLlxyXG4gIC8vXHJcbiAgLy8gT3RoZXJ3aXNlLCBhIG5ldyBzaW5nbGV0b24gb2JqZWN0IGZvciB0aGUgY2xhc3Mgb3Igb2JqZWN0IGlzIGNyZWF0ZWQsIHNldCBvblxyXG4gIC8vIHRoZSBvYmplY3QgYXQgYCQkbWV0YWAgZm9yIGZ1dHVyZSB1c2UsIGFuZCB0aGVuIHJldHVybmVkLlxyXG4gIC8vXHJcbiAgLy8gQHBhcmFtIG9iamVjdCBbT2JqZWN0XSB0aGUgcnVieSBvYmplY3RcclxuICAvLyBAcmV0dXJuIFtDbGFzc10gdGhlIHNpbmdsZXRvbiBjbGFzcyBmb3Igb2JqZWN0XHJcbiAgT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzID0gZnVuY3Rpb24ob2JqZWN0KSB7XHJcbiAgICBpZiAob2JqZWN0LiQkaXNfbnVtYmVyKSB7XHJcbiAgICAgICRyYWlzZShPcGFsLlR5cGVFcnJvciwgXCJjYW4ndCBkZWZpbmUgc2luZ2xldG9uXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKG9iamVjdC4kJG1ldGEpIHtcclxuICAgICAgcmV0dXJuIG9iamVjdC4kJG1ldGE7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eSgnJCRpc19jbGFzcycpKSB7XHJcbiAgICAgIHJldHVybiBPcGFsLmJ1aWxkX2NsYXNzX3NpbmdsZXRvbl9jbGFzcyhvYmplY3QpO1xyXG4gICAgfSBlbHNlIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoJyQkaXNfbW9kdWxlJykpIHtcclxuICAgICAgcmV0dXJuIE9wYWwuYnVpbGRfbW9kdWxlX3NpbmdsZXRvbl9jbGFzcyhvYmplY3QpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIE9wYWwuYnVpbGRfb2JqZWN0X3NpbmdsZXRvbl9jbGFzcyhvYmplY3QpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIGhlbHBlciB0byBzZXQgJCRtZXRhIG9uIGtsYXNzLCBtb2R1bGUgb3IgaW5zdGFuY2VcclxuICBmdW5jdGlvbiBzZXRfbWV0YShvYmosIG1ldGEpIHtcclxuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoJyQkbWV0YScpKSB7XHJcbiAgICAgIG9iai4kJG1ldGEgPSBtZXRhO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgJHByb3Aob2JqLCAnJCRtZXRhJywgbWV0YSk7XHJcbiAgICB9XHJcbiAgICBpZiAob2JqLiQkZnJvemVuKSB7XHJcbiAgICAgIC8vIElmIGEgb2JqZWN0IGlzIGZyb3plbiAoc2VhbGVkKSwgZnJlZXplICQkbWV0YSB0b28uXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gaW5qZWN0ICQkbWV0YS4kJHByb3RvdHlwZSBpbiB0aGUgcHJvdG90eXBlIGNoYWluLFxyXG4gICAgICAvLyBhcyAkJG1ldGEgY2Fubm90IGJlIG1vZGlmaWVkIGFueXdheS5cclxuICAgICAgb2JqLiQkbWV0YS4kZnJlZXplKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAkc2V0X3Byb3RvKG9iaiwgbWV0YS4kJHByb3RvdHlwZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gQnVpbGQgdGhlIHNpbmdsZXRvbiBjbGFzcyBmb3IgYW4gZXhpc3RpbmcgY2xhc3MuIENsYXNzIG9iamVjdCBhcmUgYnVpbHRcclxuICAvLyB3aXRoIHRoZWlyIHNpbmdsZXRvbiBjbGFzcyBhbHJlYWR5IGluIHRoZSBwcm90b3R5cGUgY2hhaW4gYW5kIGluaGVyaXRpbmdcclxuICAvLyBmcm9tIHRoZWlyIHN1cGVyY2xhc3Mgb2JqZWN0ICh1cCB0byBgQ2xhc3NgIGl0c2VsZikuXHJcbiAgLy9cclxuICAvLyBOT1RFOiBBY3R1YWxseSBpbiBNUkkgYSBjbGFzcycgc2luZ2xldG9uIGNsYXNzIGluaGVyaXRzIGZyb20gaXRzXHJcbiAgLy8gc3VwZXJjbGFzcycgc2luZ2xldG9uIGNsYXNzIHdoaWNoIGluIHR1cm4gaW5oZXJpdHMgZnJvbSBDbGFzcy5cclxuICAvL1xyXG4gIC8vIEBwYXJhbSBrbGFzcyBbQ2xhc3NdXHJcbiAgLy8gQHJldHVybiBbQ2xhc3NdXHJcbiAgT3BhbC5idWlsZF9jbGFzc19zaW5nbGV0b25fY2xhc3MgPSBmdW5jdGlvbihrbGFzcykge1xyXG4gICAgaWYgKGtsYXNzLiQkbWV0YSkge1xyXG4gICAgICByZXR1cm4ga2xhc3MuJCRtZXRhO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZSBzaW5nbGV0b25fY2xhc3Mgc3VwZXJjbGFzcyBpcyB0aGUgc2luZ2xldG9uX2NsYXNzIG9mIGl0cyBzdXBlcmNsYXNzO1xyXG4gICAgLy8gYnV0IEJhc2ljT2JqZWN0IGhhcyBubyBzdXBlcmNsYXNzIChpdHMgYCQkc3VwZXJgIGlzIG51bGwpLCB0aHVzIHdlXHJcbiAgICAvLyBmYWxsYmFjayBvbiBgQ2xhc3NgLlxyXG4gICAgdmFyIHN1cGVyY2xhc3MgPSBrbGFzcyA9PT0gQmFzaWNPYmplY3QgPyBDbGFzcyA6IE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhrbGFzcy4kJHN1cGVyKTtcclxuXHJcbiAgICB2YXIgbWV0YSA9ICRhbGxvY2F0ZV9jbGFzcyhudWxsLCBzdXBlcmNsYXNzLCB0cnVlKTtcclxuXHJcbiAgICAkcHJvcChtZXRhLCAnJCRpc19zaW5nbGV0b24nLCB0cnVlKTtcclxuICAgICRwcm9wKG1ldGEsICckJHNpbmdsZXRvbl9vZicsIGtsYXNzKTtcclxuICAgIHNldF9tZXRhKGtsYXNzLCBtZXRhKTtcclxuICAgIC8vIFJlc3RvcmluZyBDbGFzc05hbWUuY2xhc3NcclxuICAgICRwcm9wKGtsYXNzLCAnJCRjbGFzcycsIE9wYWwuQ2xhc3MpO1xyXG5cclxuICAgIHJldHVybiBtZXRhO1xyXG4gIH07XHJcblxyXG4gIE9wYWwuYnVpbGRfbW9kdWxlX3NpbmdsZXRvbl9jbGFzcyA9IGZ1bmN0aW9uKG1vZCkge1xyXG4gICAgaWYgKG1vZC4kJG1ldGEpIHtcclxuICAgICAgcmV0dXJuIG1vZC4kJG1ldGE7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG1ldGEgPSAkYWxsb2NhdGVfY2xhc3MobnVsbCwgT3BhbC5Nb2R1bGUsIHRydWUpO1xyXG5cclxuICAgICRwcm9wKG1ldGEsICckJGlzX3NpbmdsZXRvbicsIHRydWUpO1xyXG4gICAgJHByb3AobWV0YSwgJyQkc2luZ2xldG9uX29mJywgbW9kKTtcclxuICAgIHNldF9tZXRhKG1vZCwgbWV0YSk7XHJcbiAgICAvLyBSZXN0b3JpbmcgTW9kdWxlTmFtZS5jbGFzc1xyXG4gICAgJHByb3AobW9kLCAnJCRjbGFzcycsIE9wYWwuTW9kdWxlKTtcclxuXHJcbiAgICByZXR1cm4gbWV0YTtcclxuICB9O1xyXG5cclxuICAvLyBCdWlsZCB0aGUgc2luZ2xldG9uIGNsYXNzIGZvciBhIFJ1YnkgKG5vbiBjbGFzcykgT2JqZWN0LlxyXG4gIC8vXHJcbiAgLy8gQHBhcmFtIG9iamVjdCBbT2JqZWN0XVxyXG4gIC8vIEByZXR1cm4gW0NsYXNzXVxyXG4gIE9wYWwuYnVpbGRfb2JqZWN0X3NpbmdsZXRvbl9jbGFzcyA9IGZ1bmN0aW9uKG9iamVjdCkge1xyXG4gICAgdmFyIHN1cGVyY2xhc3MgPSBvYmplY3QuJCRjbGFzcyxcclxuICAgICAgICBrbGFzcyA9ICRhbGxvY2F0ZV9jbGFzcyhuaWwsIHN1cGVyY2xhc3MsIHRydWUpO1xyXG5cclxuICAgICRwcm9wKGtsYXNzLCAnJCRpc19zaW5nbGV0b24nLCB0cnVlKTtcclxuICAgICRwcm9wKGtsYXNzLCAnJCRzaW5nbGV0b25fb2YnLCBvYmplY3QpO1xyXG5cclxuICAgIGRlbGV0ZSBrbGFzcy4kJHByb3RvdHlwZS4kJGNsYXNzO1xyXG5cclxuICAgIHNldF9tZXRhKG9iamVjdCwga2xhc3MpO1xyXG5cclxuICAgIHJldHVybiBrbGFzcztcclxuICB9O1xyXG5cclxuICBPcGFsLmlzX21ldGhvZCA9IGZ1bmN0aW9uKHByb3ApIHtcclxuICAgIHJldHVybiAocHJvcFswXSA9PT0gJyQnICYmIHByb3BbMV0gIT09ICckJyk7XHJcbiAgfTtcclxuXHJcbiAgT3BhbC5pbnN0YW5jZV9tZXRob2RzID0gZnVuY3Rpb24obW9kKSB7XHJcbiAgICB2YXIgcHJvY2Vzc2VkID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgcmVzdWx0cyA9IFtdLCBhbmNlc3RvcnMgPSAkYW5jZXN0b3JzKG1vZCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIHZhciBhbmNlc3RvciA9IGFuY2VzdG9yc1tpXSxcclxuICAgICAgICAgIHByb3RvID0gYW5jZXN0b3IuJCRwcm90b3R5cGU7XHJcblxyXG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xyXG4gICAgICAgIHByb3RvID0gcHJvdG8uJCRkZWZpbmVfbWV0aG9kc19vbjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xyXG5cclxuICAgICAgZm9yICh2YXIgaiA9IDAsIGxsID0gcHJvcHMubGVuZ3RoOyBqIDwgbGw7IGorKykge1xyXG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbal07XHJcblxyXG4gICAgICAgIGlmIChwcm9jZXNzZWRbcHJvcF0pIHtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoT3BhbC5pc19tZXRob2QocHJvcCkpIHtcclxuICAgICAgICAgIHZhciBtZXRob2QgPSBwcm90b1twcm9wXTtcclxuXHJcbiAgICAgICAgICBpZiAoIW1ldGhvZC4kJHN0dWIpIHtcclxuICAgICAgICAgICAgdmFyIG1ldGhvZF9uYW1lID0gcHJvcC5zbGljZSgxKTtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG1ldGhvZF9uYW1lKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvY2Vzc2VkW3Byb3BdID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHRzO1xyXG4gIH07XHJcblxyXG4gIE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMgPSBmdW5jdGlvbihtb2QpIHtcclxuICAgIHZhciByZXN1bHRzID0gW10sXHJcbiAgICAgICAgcHJvdG8gPSBtb2QuJCRwcm90b3R5cGU7XHJcblxyXG4gICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcclxuICAgICAgcHJvdG8gPSBwcm90by4kJGRlZmluZV9tZXRob2RzX29uO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gcHJvcHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcclxuXHJcbiAgICAgIGlmIChPcGFsLmlzX21ldGhvZChwcm9wKSkge1xyXG4gICAgICAgIHZhciBtZXRob2QgPSBwcm90b1twcm9wXTtcclxuXHJcbiAgICAgICAgaWYgKCFtZXRob2QuJCRzdHViKSB7XHJcbiAgICAgICAgICB2YXIgbWV0aG9kX25hbWUgPSBwcm9wLnNsaWNlKDEpO1xyXG4gICAgICAgICAgcmVzdWx0cy5wdXNoKG1ldGhvZF9uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxuICB9O1xyXG5cclxuICBPcGFsLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHJldHVybiBPcGFsLmluc3RhbmNlX21ldGhvZHMob2JqLiQkbWV0YSB8fCBvYmouJCRjbGFzcyk7XHJcbiAgfTtcclxuXHJcbiAgT3BhbC5vd25fbWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgcmV0dXJuIG9iai4kJG1ldGEgPyBPcGFsLm93bl9pbnN0YW5jZV9tZXRob2RzKG9iai4kJG1ldGEpIDogW107XHJcbiAgfTtcclxuXHJcbiAgT3BhbC5yZWNlaXZlcl9tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICB2YXIgbW9kID0gT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKG9iaik7XHJcbiAgICB2YXIgc2luZ2xldG9uX21ldGhvZHMgPSBPcGFsLm93bl9pbnN0YW5jZV9tZXRob2RzKG1vZCk7XHJcbiAgICB2YXIgaW5zdGFuY2VfbWV0aG9kcyA9IE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMobW9kLiQkc3VwZXIpO1xyXG4gICAgcmV0dXJuIHNpbmdsZXRvbl9tZXRob2RzLmNvbmNhdChpbnN0YW5jZV9tZXRob2RzKTtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCBwYWlycyBvZiBuYW1lcy92YWx1ZXNcclxuICAvLyBmb3IgYWxsIGNsYXNzIHZhcmlhYmxlcyBkZWZpbmVkIGluIHByb3ZpZGVkICttb2R1bGUrXHJcbiAgLy8gYW5kIGl0cyBhbmNlc3RvcnMuXHJcbiAgLy9cclxuICAvLyBAcGFyYW0gbW9kdWxlIFtNb2R1bGVdXHJcbiAgLy8gQHJldHVybiBbT2JqZWN0XVxyXG4gIE9wYWwuY2xhc3NfdmFyaWFibGVzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcbiAgICB2YXIgYW5jZXN0b3JzID0gJGFuY2VzdG9ycyhtb2R1bGUpLFxyXG4gICAgICAgIGksIGxlbmd0aCA9IGFuY2VzdG9ycy5sZW5ndGgsXHJcbiAgICAgICAgcmVzdWx0ID0ge307XHJcblxyXG4gICAgZm9yIChpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgdmFyIGFuY2VzdG9yID0gYW5jZXN0b3JzW2ldO1xyXG5cclxuICAgICAgZm9yICh2YXIgY3ZhciBpbiBhbmNlc3Rvci4kJGN2YXJzKSB7XHJcbiAgICAgICAgcmVzdWx0W2N2YXJdID0gYW5jZXN0b3IuJCRjdmFyc1tjdmFyXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfTtcclxuXHJcbiAgLy8gU2V0cyBjbGFzcyB2YXJpYWJsZSB3aXRoIHNwZWNpZmllZCArbmFtZSsgdG8gK3ZhbHVlK1xyXG4gIC8vIGluIHByb3ZpZGVkICttb2R1bGUrXHJcbiAgLy9cclxuICAvLyBAcGFyYW0gbW9kdWxlIFtNb2R1bGVdXHJcbiAgLy8gQHBhcmFtIG5hbWUgW1N0cmluZ11cclxuICAvLyBAcGFyYW0gdmFsdWUgW09iamVjdF1cclxuICBPcGFsLmNsYXNzX3ZhcmlhYmxlX3NldCA9IGZ1bmN0aW9uKG1vZHVsZSwgbmFtZSwgdmFsdWUpIHtcclxuICAgIHZhciBhbmNlc3RvcnMgPSAkYW5jZXN0b3JzKG1vZHVsZSksXHJcbiAgICAgICAgaSwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDtcclxuXHJcbiAgICBmb3IgKGkgPSBsZW5ndGggLSAyOyBpID49IDA7IGktLSkge1xyXG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV07XHJcblxyXG4gICAgICBpZiAoJGhhc19vd24oYW5jZXN0b3IuJCRjdmFycywgbmFtZSkpIHtcclxuICAgICAgICBhbmNlc3Rvci4kJGN2YXJzW25hbWVdID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbW9kdWxlLiQkY3ZhcnNbbmFtZV0gPSB2YWx1ZTtcclxuXHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfTtcclxuXHJcbiAgLy8gR2V0cyBjbGFzcyB2YXJpYWJsZSB3aXRoIHNwZWNpZmllZCArbmFtZSsgZnJvbSBwcm92aWRlZCArbW9kdWxlK1xyXG4gIC8vXHJcbiAgLy8gQHBhcmFtIG1vZHVsZSBbTW9kdWxlXVxyXG4gIC8vIEBwYXJhbSBuYW1lIFtTdHJpbmddXHJcbiAgT3BhbC5jbGFzc192YXJpYWJsZV9nZXQgPSBmdW5jdGlvbihtb2R1bGUsIG5hbWUsIHRvbGVyYW50KSB7XHJcbiAgICBpZiAoJGhhc19vd24obW9kdWxlLiQkY3ZhcnMsIG5hbWUpKVxyXG4gICAgICByZXR1cm4gbW9kdWxlLiQkY3ZhcnNbbmFtZV07XHJcblxyXG4gICAgdmFyIGFuY2VzdG9ycyA9ICRhbmNlc3RvcnMobW9kdWxlKSxcclxuICAgICAgaSwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGFuY2VzdG9yID0gYW5jZXN0b3JzW2ldO1xyXG5cclxuICAgICAgaWYgKCRoYXNfb3duKGFuY2VzdG9yLiQkY3ZhcnMsIG5hbWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9yLiQkY3ZhcnNbbmFtZV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRvbGVyYW50KVxyXG4gICAgICAkcmFpc2UoT3BhbC5OYW1lRXJyb3IsICd1bmluaXRpYWxpemVkIGNsYXNzIHZhcmlhYmxlICcrbmFtZSsnIGluICcrbW9kdWxlLiRuYW1lKCkpO1xyXG5cclxuICAgIHJldHVybiBuaWw7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpc1Jvb3QocHJvdG8pIHtcclxuICAgIHJldHVybiBwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRpY2xhc3MnKSAmJiBwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRyb290Jyk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBvd25faW5jbHVkZWRfbW9kdWxlcyhtb2R1bGUpIHtcclxuICAgIHZhciByZXN1bHQgPSBbXSwgbW9kLCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGUuJCRwcm90b3R5cGUpO1xyXG5cclxuICAgIHdoaWxlIChwcm90bykge1xyXG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkY2xhc3MnKSkge1xyXG4gICAgICAgIC8vIHN1cGVyY2xhc3NcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBtb2QgPSBwcm90b1RvTW9kdWxlKHByb3RvKTtcclxuICAgICAgaWYgKG1vZCkge1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKG1vZCk7XHJcbiAgICAgIH1cclxuICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBvd25fcHJlcGVuZGVkX21vZHVsZXMobW9kdWxlKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gW10sIG1vZCwgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobW9kdWxlLiQkcHJvdG90eXBlKTtcclxuXHJcbiAgICBpZiAobW9kdWxlLiQkcHJvdG90eXBlLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcclxuICAgICAgd2hpbGUgKHByb3RvKSB7XHJcbiAgICAgICAgaWYgKHByb3RvID09PSBtb2R1bGUuJCRwcm90b3R5cGUuJCRkZWZpbmVfbWV0aG9kc19vbikge1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtb2QgPSBwcm90b1RvTW9kdWxlKHByb3RvKTtcclxuICAgICAgICBpZiAobW9kKSB7XHJcbiAgICAgICAgICByZXN1bHQucHVzaChtb2QpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG5cclxuICAvLyBUaGUgYWN0dWFsIGluY2x1c2lvbiBvZiBhIG1vZHVsZSBpbnRvIGEgY2xhc3MuXHJcbiAgLy9cclxuICAvLyAjIyBDbGFzcyBgJCRwYXJlbnRgIGFuZCBgaWNsYXNzYFxyXG4gIC8vXHJcbiAgLy8gVG8gaGFuZGxlIGBzdXBlcmAgY2FsbHMsIGV2ZXJ5IGNsYXNzIGhhcyBhIGAkJHBhcmVudGAuIFRoaXMgcGFyZW50IGlzXHJcbiAgLy8gdXNlZCB0byByZXNvbHZlIHRoZSBuZXh0IGNsYXNzIGZvciBhIHN1cGVyIGNhbGwuIEEgbm9ybWFsIGNsYXNzIHdvdWxkXHJcbiAgLy8gaGF2ZSB0aGlzIHBvaW50IHRvIGl0cyBzdXBlcmNsYXNzLiBIb3dldmVyLCBpZiBhIGNsYXNzIGluY2x1ZGVzIGEgbW9kdWxlXHJcbiAgLy8gdGhlbiB0aGlzIHdvdWxkIG5lZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgdGhlIG1vZHVsZS4gVGhlIG1vZHVsZSB3b3VsZFxyXG4gIC8vIGFsc28gaGF2ZSB0byB0aGVuIHBvaW50IGl0cyBgJCRwYXJlbnRgIHRvIHRoZSBhY3R1YWwgc3VwZXJjbGFzcy4gV2VcclxuICAvLyBjYW5ub3QgbW9kaWZ5IG1vZHVsZXMgbGlrZSB0aGlzLCBiZWNhdXNlIGl0IG1pZ2h0IGJlIGluY2x1ZGVkIGluIG1vcmVcclxuICAvLyB0aGVuIG9uZSBjbGFzcy4gVG8gZml4IHRoaXMsIHdlIGFjdHVhbGx5IGluc2VydCBhbiBgaWNsYXNzYCBhcyB0aGUgY2xhc3MnXHJcbiAgLy8gYCQkcGFyZW50YCB3aGljaCBjYW4gdGhlbiBwb2ludCB0byB0aGUgc3VwZXJjbGFzcy4gVGhlIGBpY2xhc3NgIGFjdHMgYXNcclxuICAvLyBhIHByb3h5IHRvIHRoZSBhY3R1YWwgbW9kdWxlLCBzbyB0aGUgYHN1cGVyYCBjaGFpbiBjYW4gdGhlbiBzZWFyY2ggaXQgZm9yXHJcbiAgLy8gdGhlIHJlcXVpcmVkIG1ldGhvZC5cclxuICAvL1xyXG4gIC8vIEBwYXJhbSBtb2R1bGUgW01vZHVsZV0gdGhlIG1vZHVsZSB0byBpbmNsdWRlXHJcbiAgLy8gQHBhcmFtIGluY2x1ZGVyIFtNb2R1bGVdIHRoZSB0YXJnZXQgY2xhc3MgdG8gaW5jbHVkZSBtb2R1bGUgaW50b1xyXG4gIC8vIEByZXR1cm4gW251bGxdXHJcbiAgT3BhbC5hcHBlbmRfZmVhdHVyZXMgPSBmdW5jdGlvbihtb2R1bGUsIGluY2x1ZGVyKSB7XHJcbiAgICB2YXIgbW9kdWxlX2FuY2VzdG9ycyA9ICRhbmNlc3RvcnMobW9kdWxlKTtcclxuICAgIHZhciBpY2xhc3NlcyA9IFtdO1xyXG5cclxuICAgIGlmIChtb2R1bGVfYW5jZXN0b3JzLmluZGV4T2YoaW5jbHVkZXIpICE9PSAtMSkge1xyXG4gICAgICAkcmFpc2UoT3BhbC5Bcmd1bWVudEVycm9yLCAnY3ljbGljIGluY2x1ZGUgZGV0ZWN0ZWQnKTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbW9kdWxlX2FuY2VzdG9ycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgYW5jZXN0b3IgPSBtb2R1bGVfYW5jZXN0b3JzW2ldLCBpY2xhc3MgPSBjcmVhdGVfaWNsYXNzKGFuY2VzdG9yKTtcclxuICAgICAgJHByb3AoaWNsYXNzLCAnJCRpbmNsdWRlZCcsIHRydWUpO1xyXG4gICAgICBpY2xhc3Nlcy5wdXNoKGljbGFzcyk7XHJcbiAgICB9XHJcbiAgICB2YXIgaW5jbHVkZXJfYW5jZXN0b3JzID0gJGFuY2VzdG9ycyhpbmNsdWRlciksXHJcbiAgICAgICAgY2hhaW4gPSBjaGFpbl9pY2xhc3NlcyhpY2xhc3NlcyksXHJcbiAgICAgICAgc3RhcnRfY2hhaW5fYWZ0ZXIsXHJcbiAgICAgICAgZW5kX2NoYWluX29uO1xyXG5cclxuICAgIGlmIChpbmNsdWRlcl9hbmNlc3RvcnMuaW5kZXhPZihtb2R1bGUpID09PSAtMSkge1xyXG4gICAgICAvLyBmaXJzdCB0aW1lIGluY2x1ZGVcclxuXHJcbiAgICAgIC8vIGluY2x1ZGVyIC0+IGNoYWluLmZpcnN0IC0+IC4uLmNoYWluLi4uIC0+IGNoYWluLmxhc3QgLT4gaW5jbHVkZXIucGFyZW50XHJcbiAgICAgIHN0YXJ0X2NoYWluX2FmdGVyID0gaW5jbHVkZXIuJCRwcm90b3R5cGU7XHJcbiAgICAgIGVuZF9jaGFpbl9vbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpbmNsdWRlci4kJHByb3RvdHlwZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBUaGUgbW9kdWxlIGhhcyBiZWVuIGFscmVhZHkgaW5jbHVkZWQsXHJcbiAgICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gcHV0IGl0IGludG8gdGhlIGFuY2VzdG9ycyBjaGFpbiBhZ2FpbixcclxuICAgICAgLy8gYnV0IHRoaXMgbW9kdWxlIG1heSBoYXZlIG5ldyBpbmNsdWRlZCBtb2R1bGVzLlxyXG4gICAgICAvLyBJZiBpdCdzIHRydWUgd2UgbmVlZCB0byBjb3B5IHRoZW0uXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFRoZSBzaW1wbGVzdCB3YXkgaXMgdG8gcmVwbGFjZSBhbmNlc3RvcnMgY2hhaW4gZnJvbVxyXG4gICAgICAvLyAgICAgICAgICBwYXJlbnRcclxuICAgICAgLy8gICAgICAgICAgICB8XHJcbiAgICAgIC8vICAgYG1vZHVsZWAgaWNsYXNzIChoYXMgYSAkJHJvb3QgZmxhZylcclxuICAgICAgLy8gICAgICAgICAgICB8XHJcbiAgICAgIC8vICAgLi4ucHJldmlvcyBjaGFpbiBvZiBtb2R1bGUuaW5jbHVkZWRfbW9kdWxlcyAuLi5cclxuICAgICAgLy8gICAgICAgICAgICB8XHJcbiAgICAgIC8vICBcIm5leHQgYW5jZXN0b3JcIiAoaGFzIGEgJCRyb290IGZsYWcgb3IgaXMgYSByZWFsIGNsYXNzKVxyXG4gICAgICAvL1xyXG4gICAgICAvLyB0b1xyXG4gICAgICAvLyAgICAgICAgICBwYXJlbnRcclxuICAgICAgLy8gICAgICAgICAgICB8XHJcbiAgICAgIC8vICAgIGBtb2R1bGVgIGljbGFzcyAoaGFzIGEgJCRyb290IGZsYWcpXHJcbiAgICAgIC8vICAgICAgICAgICAgfFxyXG4gICAgICAvLyAgIC4uLnJlZ2VuZXJhdGVkIGNoYWluIG9mIG1vZHVsZS5pbmNsdWRlZF9tb2R1bGVzXHJcbiAgICAgIC8vICAgICAgICAgICAgfFxyXG4gICAgICAvLyAgIFwibmV4dCBhbmNlc3RvclwiIChoYXMgYSAkJHJvb3QgZmxhZyBvciBpcyBhIHJlYWwgY2xhc3MpXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIGJlY2F1c2UgdGhlcmUgYXJlIG5vIGludGVybWVkaWF0ZSBjbGFzc2VzIGJldHdlZW4gYHBhcmVudGAgYW5kIGBuZXh0IGFuY2VzdG9yYC5cclxuICAgICAgLy8gSXQgZG9lc24ndCBicmVhayBhbnkgcHJvdG90eXBlcyBvZiBvdGhlciBvYmplY3RzIGFzIHdlIGRvbid0IGNoYW5nZSBjbGFzcyByZWZlcmVuY2VzLlxyXG5cclxuICAgICAgdmFyIHBhcmVudCA9IGluY2x1ZGVyLiQkcHJvdG90eXBlLCBtb2R1bGVfaWNsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHBhcmVudCk7XHJcblxyXG4gICAgICB3aGlsZSAobW9kdWxlX2ljbGFzcyAhPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKG1vZHVsZV9pY2xhc3MuJCRtb2R1bGUgPT09IG1vZHVsZSAmJiBpc1Jvb3QobW9kdWxlX2ljbGFzcykpIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGFyZW50ID0gbW9kdWxlX2ljbGFzcztcclxuICAgICAgICBtb2R1bGVfaWNsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZHVsZV9pY2xhc3MpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobW9kdWxlX2ljbGFzcykge1xyXG4gICAgICAgIC8vIG1vZHVsZSBoYXMgYmVlbiBkaXJlY3RseSBpbmNsdWRlZFxyXG4gICAgICAgIHZhciBuZXh0X2FuY2VzdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZHVsZV9pY2xhc3MpO1xyXG5cclxuICAgICAgICAvLyBza2lwIG5vbi1yb290IGljbGFzc2VzICh0aGF0IHdlcmUgcmVjdXJzaXZlbHkgaW5jbHVkZWQpXHJcbiAgICAgICAgd2hpbGUgKG5leHRfYW5jZXN0b3IuaGFzT3duUHJvcGVydHkoJyQkaWNsYXNzJykgJiYgIWlzUm9vdChuZXh0X2FuY2VzdG9yKSkge1xyXG4gICAgICAgICAgbmV4dF9hbmNlc3RvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXh0X2FuY2VzdG9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXJ0X2NoYWluX2FmdGVyID0gcGFyZW50O1xyXG4gICAgICAgIGVuZF9jaGFpbl9vbiA9IG5leHRfYW5jZXN0b3I7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gbW9kdWxlIGhhcyBub3QgYmVlbiBkaXJlY3RseSBpbmNsdWRlZCBidXQgd2FzIGluIGFuY2VzdG9yIGNoYWluIGJlY2F1c2UgaXQgd2FzIGluY2x1ZGVkIGJ5IGFub3RoZXIgbW9kdWxlXHJcbiAgICAgICAgLy8gaW5jbHVkZSBpdCBkaXJlY3RseVxyXG4gICAgICAgIHN0YXJ0X2NoYWluX2FmdGVyID0gaW5jbHVkZXIuJCRwcm90b3R5cGU7XHJcbiAgICAgICAgZW5kX2NoYWluX29uID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGluY2x1ZGVyLiQkcHJvdG90eXBlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgICRzZXRfcHJvdG8oc3RhcnRfY2hhaW5fYWZ0ZXIsIGNoYWluLmZpcnN0KTtcclxuICAgICRzZXRfcHJvdG8oY2hhaW4ubGFzdCwgZW5kX2NoYWluX29uKTtcclxuXHJcbiAgICAvLyByZWNhbGN1bGF0ZSBvd25faW5jbHVkZWRfbW9kdWxlcyBjYWNoZVxyXG4gICAgaW5jbHVkZXIuJCRvd25faW5jbHVkZWRfbW9kdWxlcyA9IG93bl9pbmNsdWRlZF9tb2R1bGVzKGluY2x1ZGVyKTtcclxuXHJcbiAgICBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24rKztcclxuICB9O1xyXG5cclxuICBPcGFsLnByZXBlbmRfZmVhdHVyZXMgPSBmdW5jdGlvbihtb2R1bGUsIHByZXBlbmRlcikge1xyXG4gICAgLy8gSGVyZSB3ZSBjaGFuZ2UgdGhlIGFuY2VzdG9ycyBjaGFpbiBmcm9tXHJcbiAgICAvL1xyXG4gICAgLy8gICBwcmVwZW5kZXJcclxuICAgIC8vICAgICAgfFxyXG4gICAgLy8gICAgcGFyZW50XHJcbiAgICAvL1xyXG4gICAgLy8gdG86XHJcbiAgICAvL1xyXG4gICAgLy8gZHVtbXkocHJlcGVuZGVyKVxyXG4gICAgLy8gICAgICB8XHJcbiAgICAvLyAgaWNsYXNzKG1vZHVsZSlcclxuICAgIC8vICAgICAgfFxyXG4gICAgLy8gaWNsYXNzKHByZXBlbmRlcilcclxuICAgIC8vICAgICAgfFxyXG4gICAgLy8gICAgcGFyZW50XHJcbiAgICB2YXIgbW9kdWxlX2FuY2VzdG9ycyA9ICRhbmNlc3RvcnMobW9kdWxlKTtcclxuICAgIHZhciBpY2xhc3NlcyA9IFtdO1xyXG5cclxuICAgIGlmIChtb2R1bGVfYW5jZXN0b3JzLmluZGV4T2YocHJlcGVuZGVyKSAhPT0gLTEpIHtcclxuICAgICAgJHJhaXNlKE9wYWwuQXJndW1lbnRFcnJvciwgJ2N5Y2xpYyBwcmVwZW5kIGRldGVjdGVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG1vZHVsZV9hbmNlc3RvcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGFuY2VzdG9yID0gbW9kdWxlX2FuY2VzdG9yc1tpXSwgaWNsYXNzID0gY3JlYXRlX2ljbGFzcyhhbmNlc3Rvcik7XHJcbiAgICAgICRwcm9wKGljbGFzcywgJyQkcHJlcGVuZGVkJywgdHJ1ZSk7XHJcbiAgICAgIGljbGFzc2VzLnB1c2goaWNsYXNzKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY2hhaW4gPSBjaGFpbl9pY2xhc3NlcyhpY2xhc3NlcyksXHJcbiAgICAgICAgZHVtbXlfcHJlcGVuZGVyID0gcHJlcGVuZGVyLiQkcHJvdG90eXBlLFxyXG4gICAgICAgIHByZXZpb3VzX3BhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihkdW1teV9wcmVwZW5kZXIpLFxyXG4gICAgICAgIHByZXBlbmRlcl9pY2xhc3MsXHJcbiAgICAgICAgc3RhcnRfY2hhaW5fYWZ0ZXIsXHJcbiAgICAgICAgZW5kX2NoYWluX29uO1xyXG5cclxuICAgIGlmIChkdW1teV9wcmVwZW5kZXIuaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xyXG4gICAgICAvLyBUaGUgbW9kdWxlIGFscmVhZHkgaGFzIHNvbWUgcHJlcGVuZGVkIG1vZHVsZXNcclxuICAgICAgLy8gd2hpY2ggbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIHRvIG1ha2UgaXQgXCJkdW1teVwiXHJcbiAgICAgIHByZXBlbmRlcl9pY2xhc3MgPSBkdW1teV9wcmVwZW5kZXIuJCRkZWZpbmVfbWV0aG9kc19vbjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIE1ha2luZyB0aGUgbW9kdWxlIFwiZHVtbXlcIlxyXG4gICAgICBwcmVwZW5kZXJfaWNsYXNzID0gY3JlYXRlX2R1bW15X2ljbGFzcyhwcmVwZW5kZXIpO1xyXG4gICAgICBmbHVzaF9tZXRob2RzX2luKHByZXBlbmRlcik7XHJcbiAgICAgICRwcm9wKGR1bW15X3ByZXBlbmRlciwgJyQkZHVtbXknLCB0cnVlKTtcclxuICAgICAgJHByb3AoZHVtbXlfcHJlcGVuZGVyLCAnJCRkZWZpbmVfbWV0aG9kc19vbicsIHByZXBlbmRlcl9pY2xhc3MpO1xyXG5cclxuICAgICAgLy8gQ29udmVydGluZ1xyXG4gICAgICAvLyAgIGR1bW15KHByZXBlbmRlcikgLT4gcHJldmlvdXNfcGFyZW50XHJcbiAgICAgIC8vIHRvXHJcbiAgICAgIC8vICAgZHVtbXkocHJlcGVuZGVyKSAtPiBpY2xhc3MocHJlcGVuZGVyKSAtPiBwcmV2aW91c19wYXJlbnRcclxuICAgICAgJHNldF9wcm90byhkdW1teV9wcmVwZW5kZXIsIHByZXBlbmRlcl9pY2xhc3MpO1xyXG4gICAgICAkc2V0X3Byb3RvKHByZXBlbmRlcl9pY2xhc3MsIHByZXZpb3VzX3BhcmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHByZXBlbmRlcl9hbmNlc3RvcnMgPSAkYW5jZXN0b3JzKHByZXBlbmRlcik7XHJcblxyXG4gICAgaWYgKHByZXBlbmRlcl9hbmNlc3RvcnMuaW5kZXhPZihtb2R1bGUpID09PSAtMSkge1xyXG4gICAgICAvLyBmaXJzdCB0aW1lIHByZXBlbmRcclxuXHJcbiAgICAgIHN0YXJ0X2NoYWluX2FmdGVyID0gZHVtbXlfcHJlcGVuZGVyO1xyXG5cclxuICAgICAgLy8gbmV4dCAkJHJvb3Qgb3IgcHJlcGVuZGVyX2ljbGFzcyBvciBub24tJCRpY2xhc3NcclxuICAgICAgZW5kX2NoYWluX29uID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGR1bW15X3ByZXBlbmRlcik7XHJcbiAgICAgIHdoaWxlIChlbmRfY2hhaW5fb24gIT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIGVuZF9jaGFpbl9vbi5oYXNPd25Qcm9wZXJ0eSgnJCRyb290JykgfHxcclxuICAgICAgICAgIGVuZF9jaGFpbl9vbiA9PT0gcHJlcGVuZGVyX2ljbGFzcyB8fFxyXG4gICAgICAgICAgIWVuZF9jaGFpbl9vbi5oYXNPd25Qcm9wZXJ0eSgnJCRpY2xhc3MnKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlbmRfY2hhaW5fb24gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZW5kX2NoYWluX29uKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgJHJhaXNlKE9wYWwuUnVudGltZUVycm9yLCBcIlByZXBlbmRpbmcgYSBtb2R1bGUgbXVsdGlwbGUgdGltZXMgaXMgbm90IHN1cHBvcnRlZFwiKTtcclxuICAgIH1cclxuXHJcbiAgICAkc2V0X3Byb3RvKHN0YXJ0X2NoYWluX2FmdGVyLCBjaGFpbi5maXJzdCk7XHJcbiAgICAkc2V0X3Byb3RvKGNoYWluLmxhc3QsIGVuZF9jaGFpbl9vbik7XHJcblxyXG4gICAgLy8gcmVjYWxjdWxhdGUgb3duX3ByZXBlbmRlZF9tb2R1bGVzIGNhY2hlXHJcbiAgICBwcmVwZW5kZXIuJCRvd25fcHJlcGVuZGVkX21vZHVsZXMgPSBvd25fcHJlcGVuZGVkX21vZHVsZXMocHJlcGVuZGVyKTtcclxuXHJcbiAgICBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24rKztcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBmbHVzaF9tZXRob2RzX2luKG1vZHVsZSkge1xyXG4gICAgdmFyIHByb3RvID0gbW9kdWxlLiQkcHJvdG90eXBlLFxyXG4gICAgICAgIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcclxuICAgICAgaWYgKE9wYWwuaXNfbWV0aG9kKHByb3ApKSB7XHJcbiAgICAgICAgZGVsZXRlIHByb3RvW3Byb3BdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjcmVhdGVfaWNsYXNzKG1vZHVsZSkge1xyXG4gICAgdmFyIGljbGFzcyA9IGNyZWF0ZV9kdW1teV9pY2xhc3MobW9kdWxlKTtcclxuXHJcbiAgICBpZiAobW9kdWxlLiQkaXNfbW9kdWxlKSB7XHJcbiAgICAgIG1vZHVsZS4kJGljbGFzc2VzLnB1c2goaWNsYXNzKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaWNsYXNzO1xyXG4gIH1cclxuXHJcbiAgLy8gRHVtbXkgaWNsYXNzIGRvZXNuJ3QgcmVjZWl2ZSB1cGRhdGVzIHdoZW4gdGhlIG1vZHVsZSBnZXRzIGEgbmV3IG1ldGhvZC5cclxuICBmdW5jdGlvbiBjcmVhdGVfZHVtbXlfaWNsYXNzKG1vZHVsZSkge1xyXG4gICAgdmFyIGljbGFzcyA9IHt9LFxyXG4gICAgICAgIHByb3RvID0gbW9kdWxlLiQkcHJvdG90eXBlO1xyXG5cclxuICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XHJcbiAgICAgIHByb3RvID0gcHJvdG8uJCRkZWZpbmVfbWV0aG9kc19vbjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90byksXHJcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLCBpO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xyXG4gICAgICAkcHJvcChpY2xhc3MsIHByb3AsIHByb3RvW3Byb3BdKTtcclxuICAgIH1cclxuXHJcbiAgICAkcHJvcChpY2xhc3MsICckJGljbGFzcycsIHRydWUpO1xyXG4gICAgJHByb3AoaWNsYXNzLCAnJCRtb2R1bGUnLCBtb2R1bGUpO1xyXG5cclxuICAgIHJldHVybiBpY2xhc3M7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjaGFpbl9pY2xhc3NlcyhpY2xhc3Nlcykge1xyXG4gICAgdmFyIGxlbmd0aCA9IGljbGFzc2VzLmxlbmd0aCwgZmlyc3QgPSBpY2xhc3Nlc1swXTtcclxuXHJcbiAgICAkcHJvcChmaXJzdCwgJyQkcm9vdCcsIHRydWUpO1xyXG5cclxuICAgIGlmIChsZW5ndGggPT09IDEpIHtcclxuICAgICAgcmV0dXJuIHsgZmlyc3Q6IGZpcnN0LCBsYXN0OiBmaXJzdCB9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwcmV2aW91cyA9IGZpcnN0O1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGN1cnJlbnQgPSBpY2xhc3Nlc1tpXTtcclxuICAgICAgJHNldF9wcm90byhwcmV2aW91cywgY3VycmVudCk7XHJcbiAgICAgIHByZXZpb3VzID0gY3VycmVudDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcmV0dXJuIHsgZmlyc3Q6IGljbGFzc2VzWzBdLCBsYXN0OiBpY2xhc3Nlc1tsZW5ndGggLSAxXSB9O1xyXG4gIH1cclxuXHJcbiAgLy8gRm9yIHBlcmZvcm1hbmNlLCBzb21lIGNvcmUgUnVieSBjbGFzc2VzIGFyZSB0b2xsLWZyZWUgYnJpZGdlZCB0byB0aGVpclxyXG4gIC8vIG5hdGl2ZSBKYXZhU2NyaXB0IGNvdW50ZXJwYXJ0cyAoZS5nLiBhIFJ1YnkgQXJyYXkgaXMgYSBKYXZhU2NyaXB0IEFycmF5KS5cclxuICAvL1xyXG4gIC8vIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc2V0dXAgYSBuYXRpdmUgY29uc3RydWN0b3IgKGUuZy4gQXJyYXkpLCB0byBoYXZlXHJcbiAgLy8gaXRzIHByb3RvdHlwZSBhY3QgbGlrZSBhIG5vcm1hbCBSdWJ5IGNsYXNzLiBGaXJzdGx5LCBhIG5ldyBSdWJ5IGNsYXNzIGlzXHJcbiAgLy8gY3JlYXRlZCB1c2luZyB0aGUgbmF0aXZlIGNvbnN0cnVjdG9yIHNvIHRoYXQgaXRzIHByb3RvdHlwZSBpcyBzZXQgYXMgdGhlXHJcbiAgLy8gdGFyZ2V0IGZvciB0aGUgbmV3IGNsYXNzLiBOb3RlOiBhbGwgYnJpZGdlZCBjbGFzc2VzIGFyZSBzZXQgdG8gaW5oZXJpdFxyXG4gIC8vIGZyb20gT2JqZWN0LlxyXG4gIC8vXHJcbiAgLy8gRXhhbXBsZTpcclxuICAvL1xyXG4gIC8vICAgIE9wYWwuYnJpZGdlKHNlbGYsIEZ1bmN0aW9uKTtcclxuICAvL1xyXG4gIC8vIEBwYXJhbSBrbGFzcyAgICAgICBbQ2xhc3NdIHRoZSBSdWJ5IGNsYXNzIHRvIGJyaWRnZVxyXG4gIC8vIEBwYXJhbSBjb25zdHJ1Y3RvciBbSlMuRnVuY3Rpb25dIG5hdGl2ZSBKYXZhU2NyaXB0IGNvbnN0cnVjdG9yIHRvIHVzZVxyXG4gIC8vIEByZXR1cm4gW0NsYXNzXSByZXR1cm5zIHRoZSBwYXNzZWQgUnVieSBjbGFzc1xyXG4gIC8vXHJcbiAgT3BhbC5icmlkZ2UgPSBmdW5jdGlvbihuYXRpdmVfa2xhc3MsIGtsYXNzKSB7XHJcbiAgICBpZiAobmF0aXZlX2tsYXNzLmhhc093blByb3BlcnR5KCckJGJyaWRnZScpKSB7XHJcbiAgICAgICRyYWlzZShPcGFsLkFyZ3VtZW50RXJyb3IsIFwiYWxyZWFkeSBicmlkZ2VkXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbnN0cnVjdG9yIGlzIGEgSlMgZnVuY3Rpb24gd2l0aCBhIHByb3RvdHlwZSBjaGFpbiBsaWtlOlxyXG4gICAgLy8gLSBjb25zdHJ1Y3RvclxyXG4gICAgLy8gICAtIHN1cGVyXHJcbiAgICAvL1xyXG4gICAgLy8gV2hhdCB3ZSBuZWVkIHRvIGRvIGlzIHRvIGluamVjdCBvdXIgY2xhc3MgKHdpdGggaXRzIHByb3RvdHlwZSBjaGFpbilcclxuICAgIC8vIGJldHdlZW4gY29uc3RydWN0b3IgYW5kIHN1cGVyLiBGb3IgZXhhbXBsZSwgYWZ0ZXIgaW5qZWN0aW5nIDo6T2JqZWN0XHJcbiAgICAvLyBpbnRvIEpTIFN0cmluZyB3ZSBnZXQ6XHJcbiAgICAvL1xyXG4gICAgLy8gLSBjb25zdHJ1Y3RvciAod2luZG93LlN0cmluZylcclxuICAgIC8vICAgLSBPcGFsLk9iamVjdFxyXG4gICAgLy8gICAgIC0gT3BhbC5LZXJuZWxcclxuICAgIC8vICAgICAgIC0gT3BhbC5CYXNpY09iamVjdFxyXG4gICAgLy8gICAgICAgICAtIHN1cGVyICh3aW5kb3cuT2JqZWN0KVxyXG4gICAgLy8gICAgICAgICAgIC0gbnVsbFxyXG4gICAgLy9cclxuICAgICRwcm9wKG5hdGl2ZV9rbGFzcywgJyQkYnJpZGdlJywga2xhc3MpO1xyXG4gICAgJHNldF9wcm90byhuYXRpdmVfa2xhc3MucHJvdG90eXBlLCAoa2xhc3MuJCRzdXBlciB8fCBPcGFsLk9iamVjdCkuJCRwcm90b3R5cGUpO1xyXG4gICAgJHByb3Aoa2xhc3MsICckJHByb3RvdHlwZScsIG5hdGl2ZV9rbGFzcy5wcm90b3R5cGUpO1xyXG5cclxuICAgICRwcm9wKGtsYXNzLiQkcHJvdG90eXBlLCAnJCRjbGFzcycsIGtsYXNzKTtcclxuICAgICRwcm9wKGtsYXNzLCAnJCRjb25zdHJ1Y3RvcicsIG5hdGl2ZV9rbGFzcyk7XHJcbiAgICAkcHJvcChrbGFzcywgJyQkYnJpZGdlJywgdHJ1ZSk7XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gcHJvdG9Ub01vZHVsZShwcm90bykge1xyXG4gICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfSBlbHNlIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRpY2xhc3MnKSkge1xyXG4gICAgICByZXR1cm4gcHJvdG8uJCRtb2R1bGU7XHJcbiAgICB9IGVsc2UgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGNsYXNzJykpIHtcclxuICAgICAgcmV0dXJuIHByb3RvLiQkY2xhc3M7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBvd25fYW5jZXN0b3JzKG1vZHVsZSkge1xyXG4gICAgcmV0dXJuIG1vZHVsZS4kJG93bl9wcmVwZW5kZWRfbW9kdWxlcy5jb25jYXQoW21vZHVsZV0pLmNvbmNhdChtb2R1bGUuJCRvd25faW5jbHVkZWRfbW9kdWxlcyk7XHJcbiAgfVxyXG5cclxuICAvLyBUaGUgQXJyYXkgb2YgYW5jZXN0b3JzIGZvciBhIGdpdmVuIG1vZHVsZS9jbGFzc1xyXG4gIGZ1bmN0aW9uICRhbmNlc3RvcnMobW9kdWxlKSB7XHJcbiAgICBpZiAoIW1vZHVsZSkgeyByZXR1cm4gW107IH1cclxuXHJcbiAgICBpZiAobW9kdWxlLiQkYW5jZXN0b3JzX2NhY2hlX3ZlcnNpb24gPT09IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbikge1xyXG4gICAgICByZXR1cm4gbW9kdWxlLiQkYW5jZXN0b3JzO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciByZXN1bHQgPSBbXSwgaSwgbW9kcywgbGVuZ3RoO1xyXG5cclxuICAgIGZvciAoaSA9IDAsIG1vZHMgPSBvd25fYW5jZXN0b3JzKG1vZHVsZSksIGxlbmd0aCA9IG1vZHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgcmVzdWx0LnB1c2gobW9kc1tpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1vZHVsZS4kJHN1cGVyKSB7XHJcbiAgICAgIGZvciAoaSA9IDAsIG1vZHMgPSAkYW5jZXN0b3JzKG1vZHVsZS4kJHN1cGVyKSwgbGVuZ3RoID0gbW9kcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKG1vZHNbaV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbW9kdWxlLiQkYW5jZXN0b3JzX2NhY2hlX3ZlcnNpb24gPSBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb247XHJcbiAgICBtb2R1bGUuJCRhbmNlc3RvcnMgPSByZXN1bHQ7XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9O1xyXG4gIE9wYWwuYW5jZXN0b3JzID0gJGFuY2VzdG9ycztcclxuXHJcbiAgT3BhbC5pbmNsdWRlZF9tb2R1bGVzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gW10sIG1vZCA9IG51bGwsIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZHVsZS4kJHByb3RvdHlwZSk7XHJcblxyXG4gICAgZm9yICg7IHByb3RvICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSkge1xyXG4gICAgICBtb2QgPSBwcm90b1RvTW9kdWxlKHByb3RvKTtcclxuICAgICAgaWYgKG1vZCAmJiBtb2QuJCRpc19tb2R1bGUgJiYgcHJvdG8uJCRpY2xhc3MgJiYgcHJvdG8uJCRpbmNsdWRlZCkge1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKG1vZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcblxyXG5cclxuICAvLyBNZXRob2QgTWlzc2luZ1xyXG4gIC8vIC0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIE1ldGhvZHMgc3R1YnMgYXJlIHVzZWQgdG8gZmFjaWxpdGF0ZSBtZXRob2RfbWlzc2luZyBpbiBvcGFsLiBBIHN0dWIgaXMgYVxyXG4gIC8vIHBsYWNlaG9sZGVyIGZ1bmN0aW9uIHdoaWNoIGp1c3QgY2FsbHMgYG1ldGhvZF9taXNzaW5nYCBvbiB0aGUgcmVjZWl2ZXIuXHJcbiAgLy8gSWYgbm8gbWV0aG9kIHdpdGggdGhlIGdpdmVuIG5hbWUgaXMgYWN0dWFsbHkgZGVmaW5lZCBvbiBhbiBvYmplY3QsIHRoZW4gaXRcclxuICAvLyBpcyBvYnZpb3VzIHRvIHNheSB0aGF0IHRoZSBzdHViIHdpbGwgYmUgY2FsbGVkIGluc3RlYWQsIGFuZCB0aGVuIGluIHR1cm5cclxuICAvLyBtZXRob2RfbWlzc2luZyB3aWxsIGJlIGNhbGxlZC5cclxuICAvL1xyXG4gIC8vIFdoZW4gYSBmaWxlIGluIHJ1YnkgZ2V0cyBjb21waWxlZCB0byBqYXZhc2NyaXB0LCBpdCBpbmNsdWRlcyBhIGNhbGwgdG9cclxuICAvLyB0aGlzIGZ1bmN0aW9uIHdoaWNoIGFkZHMgc3R1YnMgZm9yIGV2ZXJ5IG1ldGhvZCBuYW1lIGluIHRoZSBjb21waWxlZCBmaWxlLlxyXG4gIC8vIEl0IHNob3VsZCB0aGVuIGJlIHNhZmUgdG8gYXNzdW1lIHRoYXQgbWV0aG9kX21pc3Npbmcgd2lsbCB3b3JrIGZvciBhbnlcclxuICAvLyBtZXRob2QgY2FsbCBkZXRlY3RlZC5cclxuICAvL1xyXG4gIC8vIE1ldGhvZCBzdHVicyBhcmUgYWRkZWQgdG8gdGhlIEJhc2ljT2JqZWN0IHByb3RvdHlwZSwgd2hpY2ggZXZlcnkgb3RoZXJcclxuICAvLyBydWJ5IG9iamVjdCBpbmhlcml0cywgc28gYWxsIG9iamVjdHMgc2hvdWxkIGhhbmRsZSBtZXRob2QgbWlzc2luZy4gQSBzdHViXHJcbiAgLy8gaXMgb25seSBhZGRlZCBpZiB0aGUgZ2l2ZW4gcHJvcGVydHkgbmFtZSAobWV0aG9kIG5hbWUpIGlzIG5vdCBhbHJlYWR5XHJcbiAgLy8gZGVmaW5lZC5cclxuICAvL1xyXG4gIC8vIE5vdGU6IGFsbCBydWJ5IG1ldGhvZHMgaGF2ZSBhIGAkYCBwcmVmaXggaW4gamF2YXNjcmlwdCwgc28gYWxsIHN0dWJzIHdpbGxcclxuICAvLyBoYXZlIHRoaXMgcHJlZml4IGFzIHdlbGwgKHRvIG1ha2UgdGhpcyBtZXRob2QgbW9yZSBwZXJmb3JtYW50KS5cclxuICAvL1xyXG4gIC8vICAgIE9wYWwuYWRkX3N0dWJzKFwiZm9vLGJhcixiYXo9XCIpO1xyXG4gIC8vXHJcbiAgLy8gQWxsIHN0dWIgZnVuY3Rpb25zIHdpbGwgaGF2ZSBhIHByaXZhdGUgYCQkc3R1YmAgcHJvcGVydHkgc2V0IHRvIHRydWUgc29cclxuICAvLyB0aGF0IG90aGVyIGludGVybmFsIG1ldGhvZHMgY2FuIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBqdXN0IGEgc3R1YiBvciBub3QuXHJcbiAgLy8gYEtlcm5lbCNyZXNwb25kX3RvP2AgdXNlcyB0aGlzIHByb3BlcnR5IHRvIGRldGVjdCBhIG1ldGhvZHMgcHJlc2VuY2UuXHJcbiAgLy9cclxuICAvLyBAcGFyYW0gc3R1YnMgW0FycmF5XSBhbiBhcnJheSBvZiBtZXRob2Qgc3R1YnMgdG8gYWRkXHJcbiAgLy8gQHJldHVybiBbdW5kZWZpbmVkXVxyXG4gIE9wYWwuYWRkX3N0dWJzID0gZnVuY3Rpb24oc3R1YnMpIHtcclxuICAgIHZhciBwcm90byA9IE9wYWwuQmFzaWNPYmplY3QuJCRwcm90b3R5cGU7XHJcbiAgICB2YXIgc3R1YiwgZXhpc3RpbmdfbWV0aG9kO1xyXG4gICAgc3R1YnMgPSBzdHVicy5zcGxpdCgnLCcpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHVicy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICBzdHViID0gJGpzaWQoc3R1YnNbaV0pLCBleGlzdGluZ19tZXRob2QgPSBwcm90b1tzdHViXTtcclxuXHJcbiAgICAgIGlmIChleGlzdGluZ19tZXRob2QgPT0gbnVsbCB8fCBleGlzdGluZ19tZXRob2QuJCRzdHViKSB7XHJcbiAgICAgICAgT3BhbC5hZGRfc3R1Yl9mb3IocHJvdG8sIHN0dWIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gQWRkIGEgbWV0aG9kX21pc3Npbmcgc3R1YiBmdW5jdGlvbiB0byB0aGUgZ2l2ZW4gcHJvdG90eXBlIGZvciB0aGVcclxuICAvLyBnaXZlbiBuYW1lLlxyXG4gIC8vXHJcbiAgLy8gQHBhcmFtIHByb3RvdHlwZSBbUHJvdG90eXBlXSB0aGUgdGFyZ2V0IHByb3RvdHlwZVxyXG4gIC8vIEBwYXJhbSBzdHViIFtTdHJpbmddIHN0dWIgbmFtZSB0byBhZGQgKGUuZy4gXCIkZm9vXCIpXHJcbiAgLy8gQHJldHVybiBbdW5kZWZpbmVkXVxyXG4gIE9wYWwuYWRkX3N0dWJfZm9yID0gZnVuY3Rpb24ocHJvdG90eXBlLCBzdHViKSB7XHJcbiAgICAvLyBPcGFsLnN0dWJfZm9yKHN0dWIpIGlzIHRoZSBtZXRob2RfbWlzc2luZ19zdHViXHJcbiAgICAkcHJvcChwcm90b3R5cGUsIHN0dWIsIE9wYWwuc3R1Yl9mb3Ioc3R1YikpO1xyXG4gIH07XHJcblxyXG4gIC8vIEdlbmVyYXRlIHRoZSBtZXRob2RfbWlzc2luZyBzdHViIGZvciBhIGdpdmVuIG1ldGhvZCBuYW1lLlxyXG4gIC8vXHJcbiAgLy8gQHBhcmFtIG1ldGhvZF9uYW1lIFtTdHJpbmddIFRoZSBqcy1uYW1lIG9mIHRoZSBtZXRob2QgdG8gc3R1YiAoZS5nLiBcIiRmb29cIilcclxuICAvLyBAcmV0dXJuIFt1bmRlZmluZWRdXHJcbiAgT3BhbC5zdHViX2ZvciA9IGZ1bmN0aW9uKG1ldGhvZF9uYW1lKSB7XHJcbiAgICBmdW5jdGlvbiBtZXRob2RfbWlzc2luZ19zdHViKCkge1xyXG4gICAgICAvLyBDb3B5IGFueSBnaXZlbiBibG9jayBvbnRvIHRoZSBtZXRob2RfbWlzc2luZyBkaXNwYXRjaGVyXHJcbiAgICAgIHRoaXMuJG1ldGhvZF9taXNzaW5nLiQkcCA9IG1ldGhvZF9taXNzaW5nX3N0dWIuJCRwO1xyXG5cclxuICAgICAgLy8gU2V0IGJsb2NrIHByb3BlcnR5IHRvIG51bGwgcmVhZHkgZm9yIHRoZSBuZXh0IGNhbGwgKHN0b3AgZmFsc2UtcG9zaXRpdmVzKVxyXG4gICAgICBtZXRob2RfbWlzc2luZ19zdHViLiQkcCA9IG51bGw7XHJcblxyXG4gICAgICAvLyBjYWxsIG1ldGhvZCBtaXNzaW5nIHdpdGggY29ycmVjdCBhcmdzIChyZW1vdmUgJyQnIHByZWZpeCBvbiBtZXRob2QgbmFtZSlcclxuICAgICAgcmV0dXJuIHRoaXMuJG1ldGhvZF9taXNzaW5nLmFwcGx5KHRoaXMsICRwcmVwZW5kKG1ldGhvZF9uYW1lLnNsaWNlKDEpLCBhcmd1bWVudHMpKTtcclxuICAgIH07XHJcblxyXG4gICAgbWV0aG9kX21pc3Npbmdfc3R1Yi4kJHN0dWIgPSB0cnVlO1xyXG5cclxuICAgIHJldHVybiBtZXRob2RfbWlzc2luZ19zdHViO1xyXG4gIH07XHJcblxyXG5cclxuICAvLyBNZXRob2RzXHJcbiAgLy8gLS0tLS0tLVxyXG5cclxuICAvLyBBcml0eSBjb3VudCBlcnJvciBkaXNwYXRjaGVyIGZvciBtZXRob2RzXHJcbiAgLy9cclxuICAvLyBAcGFyYW0gYWN0dWFsIFtGaXhudW1dIG51bWJlciBvZiBhcmd1bWVudHMgZ2l2ZW4gdG8gbWV0aG9kXHJcbiAgLy8gQHBhcmFtIGV4cGVjdGVkIFtGaXhudW1dIGV4cGVjdGVkIG51bWJlciBvZiBhcmd1bWVudHNcclxuICAvLyBAcGFyYW0gb2JqZWN0IFtPYmplY3RdIG93bmVyIG9mIHRoZSBtZXRob2QgK21ldGgrXHJcbiAgLy8gQHBhcmFtIG1ldGggW1N0cmluZ10gbWV0aG9kIG5hbWUgdGhhdCBnb3Qgd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50c1xyXG4gIC8vIEByYWlzZSBbQXJndW1lbnRFcnJvcl1cclxuICBPcGFsLmFjID0gZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCwgb2JqZWN0LCBtZXRoKSB7XHJcbiAgICB2YXIgaW5zcGVjdCA9ICcnO1xyXG4gICAgaWYgKG9iamVjdC4kJGlzX2FfbW9kdWxlKSB7XHJcbiAgICAgIGluc3BlY3QgKz0gb2JqZWN0LiQkbmFtZSArICcuJztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBpbnNwZWN0ICs9IG9iamVjdC4kJGNsYXNzLiQkbmFtZSArICcjJztcclxuICAgIH1cclxuICAgIGluc3BlY3QgKz0gbWV0aDtcclxuXHJcbiAgICAkcmFpc2UoT3BhbC5Bcmd1bWVudEVycm9yLCAnWycgKyBpbnNwZWN0ICsgJ10gd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoZ2l2ZW4gJyArIGFjdHVhbCArICcsIGV4cGVjdGVkICcgKyBleHBlY3RlZCArICcpJyk7XHJcbiAgfTtcclxuXHJcbiAgLy8gQXJpdHkgY291bnQgZXJyb3IgZGlzcGF0Y2hlciBmb3IgYmxvY2tzXHJcbiAgLy9cclxuICAvLyBAcGFyYW0gYWN0dWFsIFtGaXhudW1dIG51bWJlciBvZiBhcmd1bWVudHMgZ2l2ZW4gdG8gYmxvY2tcclxuICAvLyBAcGFyYW0gZXhwZWN0ZWQgW0ZpeG51bV0gZXhwZWN0ZWQgbnVtYmVyIG9mIGFyZ3VtZW50c1xyXG4gIC8vIEBwYXJhbSBjb250ZXh0IFtPYmplY3RdIGNvbnRleHQgb2YgdGhlIGJsb2NrIGRlZmluaXRpb25cclxuICAvLyBAcmFpc2UgW0FyZ3VtZW50RXJyb3JdXHJcbiAgT3BhbC5ibG9ja19hYyA9IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQsIGNvbnRleHQpIHtcclxuICAgIHZhciBpbnNwZWN0ID0gXCJgYmxvY2sgaW4gXCIgKyBjb250ZXh0ICsgXCInXCI7XHJcblxyXG4gICAgJHJhaXNlKE9wYWwuQXJndW1lbnRFcnJvciwgaW5zcGVjdCArICc6IHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKGdpdmVuICcgKyBhY3R1YWwgKyAnLCBleHBlY3RlZCAnICsgZXhwZWN0ZWQgKyAnKScpO1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGdldF9hbmNlc3RvcnMob2JqKSB7XHJcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KCckJG1ldGEnKSAmJiBvYmouJCRtZXRhICE9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiAkYW5jZXN0b3JzKG9iai4kJG1ldGEpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuICRhbmNlc3RvcnMob2JqLiQkY2xhc3MpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIFN1cGVyIGRpc3BhdGNoZXJcclxuICBPcGFsLmZpbmRfc3VwZXIgPSBmdW5jdGlvbihvYmosIG1pZCwgY3VycmVudF9mdW5jLCBkZWZjaGVjaywgYWxsb3dfc3R1YnMpIHtcclxuICAgIHZhciBqc2lkID0gJGpzaWQobWlkKSwgYW5jZXN0b3JzLCBhbmNlc3Rvciwgc3VwZXJfbWV0aG9kLCBtZXRob2Rfb3duZXIsIGN1cnJlbnRfaW5kZXggPSAtMSwgaTtcclxuXHJcbiAgICBhbmNlc3RvcnMgPSBnZXRfYW5jZXN0b3JzKG9iaik7XHJcbiAgICBtZXRob2Rfb3duZXIgPSBjdXJyZW50X2Z1bmMuJCRvd25lcjtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3JzW2ldO1xyXG4gICAgICBpZiAoYW5jZXN0b3IgPT09IG1ldGhvZF9vd25lciB8fCBhbmNlc3Rvci4kJGNsb25lZF9mcm9tLmluZGV4T2YobWV0aG9kX293bmVyKSAhPT0gLTEpIHtcclxuICAgICAgICBjdXJyZW50X2luZGV4ID0gaTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvciAoaSA9IGN1cnJlbnRfaW5kZXggKyAxOyBpIDwgYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3JzW2ldO1xyXG4gICAgICB2YXIgcHJvdG8gPSBhbmNlc3Rvci4kJHByb3RvdHlwZTtcclxuXHJcbiAgICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XHJcbiAgICAgICAgcHJvdG8gPSBwcm90by4kJGRlZmluZV9tZXRob2RzX29uO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoanNpZCkpIHtcclxuICAgICAgICBzdXBlcl9tZXRob2QgPSBwcm90b1tqc2lkXTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghZGVmY2hlY2sgJiYgc3VwZXJfbWV0aG9kICYmIHN1cGVyX21ldGhvZC4kJHN0dWIgJiYgb2JqLiRtZXRob2RfbWlzc2luZy4kJHByaXN0aW5lKSB7XHJcbiAgICAgIC8vIG1ldGhvZF9taXNzaW5nIGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgZGVmaW5lZFxyXG4gICAgICAkcmFpc2UoT3BhbC5Ob01ldGhvZEVycm9yLCAnc3VwZXI6IG5vIHN1cGVyY2xhc3MgbWV0aG9kIGAnK21pZCtcIicgZm9yIFwiK29iaiwgbWlkKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKHN1cGVyX21ldGhvZC4kJHN0dWIgJiYgIWFsbG93X3N0dWJzKSA/IG51bGwgOiBzdXBlcl9tZXRob2Q7XHJcbiAgfTtcclxuXHJcbiAgLy8gSXRlciBkaXNwYXRjaGVyIGZvciBzdXBlciBpbiBhIGJsb2NrXHJcbiAgT3BhbC5maW5kX2Jsb2NrX3N1cGVyID0gZnVuY3Rpb24ob2JqLCBqc2lkLCBjdXJyZW50X2Z1bmMsIGRlZmNoZWNrLCBpbXBsaWNpdCkge1xyXG4gICAgdmFyIGNhbGxfanNpZCA9IGpzaWQ7XHJcblxyXG4gICAgaWYgKCFjdXJyZW50X2Z1bmMpIHtcclxuICAgICAgJHJhaXNlKE9wYWwuUnVudGltZUVycm9yLCBcInN1cGVyIGNhbGxlZCBvdXRzaWRlIG9mIG1ldGhvZFwiKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaW1wbGljaXQgJiYgY3VycmVudF9mdW5jLiQkZGVmaW5lX21ldGgpIHtcclxuICAgICAgJHJhaXNlKE9wYWwuUnVudGltZUVycm9yLFxyXG4gICAgICAgIFwiaW1wbGljaXQgYXJndW1lbnQgcGFzc2luZyBvZiBzdXBlciBmcm9tIG1ldGhvZCBkZWZpbmVkIGJ5IGRlZmluZV9tZXRob2QoKSBpcyBub3Qgc3VwcG9ydGVkLiBcIiArXHJcbiAgICAgICAgXCJTcGVjaWZ5IGFsbCBhcmd1bWVudHMgZXhwbGljaXRseVwiXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGN1cnJlbnRfZnVuYy4kJGRlZikge1xyXG4gICAgICBjYWxsX2pzaWQgPSBjdXJyZW50X2Z1bmMuJCRqc2lkO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBPcGFsLmZpbmRfc3VwZXIob2JqLCBjYWxsX2pzaWQsIGN1cnJlbnRfZnVuYywgZGVmY2hlY2spO1xyXG4gIH07XHJcblxyXG4gIC8vIEBkZXByZWNhdGVkXHJcbiAgT3BhbC5maW5kX3N1cGVyX2Rpc3BhdGNoZXIgPSBPcGFsLmZpbmRfc3VwZXI7XHJcblxyXG4gIC8vIEBkZXByZWNhdGVkXHJcbiAgT3BhbC5maW5kX2l0ZXJfc3VwZXJfZGlzcGF0Y2hlciA9IE9wYWwuZmluZF9ibG9ja19zdXBlcjtcclxuXHJcbiAgZnVuY3Rpb24gY2FsbF9sYW1iZGEoYmxvY2ssIGFyZywgcmV0KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBibG9jayhhcmcpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBpZiAoZSA9PT0gcmV0KSB7XHJcbiAgICAgICAgcmV0dXJuIHJldC4kdjtcclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gaGFuZGxlcyB5aWVsZCBjYWxscyBmb3IgMSB5aWVsZGVkIGFyZ1xyXG4gIE9wYWwueWllbGQxID0gZnVuY3Rpb24oYmxvY2ssIGFyZykge1xyXG4gICAgaWYgKHR5cGVvZihibG9jaykgIT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAkcmFpc2UoT3BhbC5Mb2NhbEp1bXBFcnJvciwgXCJubyBibG9jayBnaXZlblwiKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaGFzX21saHMgPSBibG9jay4kJGhhc190b3BfbGV2ZWxfbWxoc19hcmcsXHJcbiAgICAgICAgaGFzX3RyYWlsaW5nX2NvbW1hID0gYmxvY2suJCRoYXNfdHJhaWxpbmdfY29tbWFfaW5fYXJncyxcclxuICAgICAgICBpc19yZXR1cm5pbmdfbGFtYmRhID0gYmxvY2suJCRpc19sYW1iZGEgJiYgYmxvY2suJCRyZXQ7XHJcblxyXG4gICAgaWYgKGJsb2NrLmxlbmd0aCA+IDEgfHwgKChoYXNfbWxocyB8fCBoYXNfdHJhaWxpbmdfY29tbWEpICYmIGJsb2NrLmxlbmd0aCA9PT0gMSkpIHtcclxuICAgICAgYXJnID0gT3BhbC50b19hcnkoYXJnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoKGJsb2NrLmxlbmd0aCA+IDEgfHwgKGhhc190cmFpbGluZ19jb21tYSAmJiBibG9jay5sZW5ndGggPT09IDEpKSAmJiBhcmcuJCRpc19hcnJheSkge1xyXG4gICAgICBpZiAoaXNfcmV0dXJuaW5nX2xhbWJkYSkge1xyXG4gICAgICAgIHJldHVybiBjYWxsX2xhbWJkYShibG9jay5hcHBseS5iaW5kKGJsb2NrLCBudWxsKSwgYXJnLCBibG9jay4kJHJldCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGJsb2NrLmFwcGx5KG51bGwsIGFyZyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgaWYgKGlzX3JldHVybmluZ19sYW1iZGEpIHtcclxuICAgICAgICByZXR1cm4gY2FsbF9sYW1iZGEoYmxvY2ssIGFyZywgYmxvY2suJCRyZXQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBibG9jayhhcmcpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIGhhbmRsZXMgeWllbGQgZm9yID4gMSB5aWVsZGVkIGFyZ1xyXG4gIE9wYWwueWllbGRYID0gZnVuY3Rpb24oYmxvY2ssIGFyZ3MpIHtcclxuICAgIGlmICh0eXBlb2YoYmxvY2spICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgJHJhaXNlKE9wYWwuTG9jYWxKdW1wRXJyb3IsIFwibm8gYmxvY2sgZ2l2ZW5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGJsb2NrLmxlbmd0aCA+IDEgJiYgYXJncy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgaWYgKGFyZ3NbMF0uJCRpc19hcnJheSkge1xyXG4gICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGJsb2NrLiQkaXNfbGFtYmRhICYmIGJsb2NrLiQkcmV0KSB7XHJcbiAgICAgIHJldHVybiBjYWxsX2xhbWJkYShibG9jay5hcHBseS5iaW5kKGJsb2NrLCBudWxsKSwgYXJncywgYmxvY2suJCRyZXQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJsb2NrLmFwcGx5KG51bGwsIGFyZ3MpO1xyXG4gIH07XHJcblxyXG4gIC8vIEZpbmRzIHRoZSBjb3JyZXNwb25kaW5nIGV4Y2VwdGlvbiBtYXRjaCBpbiBjYW5kaWRhdGVzLiAgRWFjaCBjYW5kaWRhdGUgY2FuXHJcbiAgLy8gYmUgYSB2YWx1ZSwgb3IgYW4gYXJyYXkgb2YgdmFsdWVzLiAgUmV0dXJucyBudWxsIGlmIG5vdCBmb3VuZC5cclxuICBPcGFsLnJlc2N1ZSA9IGZ1bmN0aW9uKGV4Y2VwdGlvbiwgY2FuZGlkYXRlcykge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYW5kaWRhdGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBjYW5kaWRhdGUgPSBjYW5kaWRhdGVzW2ldO1xyXG5cclxuICAgICAgaWYgKGNhbmRpZGF0ZS4kJGlzX2FycmF5KSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IE9wYWwucmVzY3VlKGV4Y2VwdGlvbiwgY2FuZGlkYXRlKTtcclxuXHJcbiAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoKE9wYWwuT3BhbC5SYXcgJiYgY2FuZGlkYXRlID09PSBPcGFsLk9wYWwuUmF3LkVycm9yKSB8fCBjYW5kaWRhdGVbJyQ9PT0nXShleGNlcHRpb24pKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH07XHJcblxyXG4gIE9wYWwuaXNfYSA9IGZ1bmN0aW9uKG9iamVjdCwga2xhc3MpIHtcclxuICAgIGlmIChrbGFzcyAhPSBudWxsICYmIG9iamVjdC4kJG1ldGEgPT09IGtsYXNzIHx8IG9iamVjdC4kJGNsYXNzID09PSBrbGFzcykge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob2JqZWN0LiQkaXNfbnVtYmVyICYmIGtsYXNzLiQkaXNfbnVtYmVyX2NsYXNzKSB7XHJcbiAgICAgIHJldHVybiAoa2xhc3MuJCRpc19pbnRlZ2VyX2NsYXNzKSA/IChvYmplY3QgJSAxKSA9PT0gMCA6IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGFuY2VzdG9ycyA9ICRhbmNlc3RvcnMob2JqZWN0LiQkaXNfY2xhc3MgPyBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqZWN0KSA6IChvYmplY3QuJCRtZXRhIHx8IG9iamVjdC4kJGNsYXNzKSk7XHJcblxyXG4gICAgcmV0dXJuIGFuY2VzdG9ycy5pbmRleE9mKGtsYXNzKSAhPT0gLTE7XHJcbiAgfTtcclxuXHJcbiAgLy8gSGVscGVycyBmb3IgZXh0cmFjdGluZyBrd3NwbGF0c1xyXG4gIC8vIFVzZWQgZm9yOiB7ICoqaCB9XHJcbiAgT3BhbC50b19oYXNoID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZS4kJGlzX2hhc2gpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmFsdWVbJyRyZXNwb25kX3RvPyddKCd0b19oYXNoJywgdHJ1ZSkpIHtcclxuICAgICAgdmFyIGhhc2ggPSB2YWx1ZS4kdG9faGFzaCgpO1xyXG4gICAgICBpZiAoaGFzaC4kJGlzX2hhc2gpIHtcclxuICAgICAgICByZXR1cm4gaGFzaDtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAkcmFpc2UoT3BhbC5UeXBlRXJyb3IsIFwiQ2FuJ3QgY29udmVydCBcIiArIHZhbHVlLiQkY2xhc3MgK1xyXG4gICAgICAgICAgXCIgdG8gSGFzaCAoXCIgKyB2YWx1ZS4kJGNsYXNzICsgXCIjdG9faGFzaCBnaXZlcyBcIiArIGhhc2guJCRjbGFzcyArIFwiKVwiKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICRyYWlzZShPcGFsLlR5cGVFcnJvciwgXCJubyBpbXBsaWNpdCBjb252ZXJzaW9uIG9mIFwiICsgdmFsdWUuJCRjbGFzcyArIFwiIGludG8gSGFzaFwiKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBIZWxwZXJzIGZvciBpbXBsZW1lbnRpbmcgbXVsdGlwbGUgYXNzaWdubWVudFxyXG4gIC8vIE91ciBjb2RlIGZvciBleHRyYWN0aW5nIHRoZSB2YWx1ZXMgYW5kIGFzc2lnbmluZyB0aGVtIG9ubHkgd29ya3MgaWYgdGhlXHJcbiAgLy8gcmV0dXJuIHZhbHVlIGlzIGEgSlMgYXJyYXkuXHJcbiAgLy8gU28gaWYgd2UgZ2V0IGFuIEFycmF5IHN1YmNsYXNzLCBleHRyYWN0IHRoZSB3cmFwcGVkIEpTIGFycmF5IGZyb20gaXRcclxuXHJcbiAgLy8gVXNlZCBmb3I6IGEsIGIgPSBzb21ldGhpbmcgKG5vIHNwbGF0KVxyXG4gIE9wYWwudG9fYXJ5ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZS4kJGlzX2FycmF5KSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlWyckcmVzcG9uZF90bz8nXSgndG9fYXJ5JywgdHJ1ZSkpIHtcclxuICAgICAgdmFyIGFyeSA9IHZhbHVlLiR0b19hcnkoKTtcclxuICAgICAgaWYgKGFyeSA9PT0gbmlsKSB7XHJcbiAgICAgICAgcmV0dXJuIFt2YWx1ZV07XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoYXJ5LiQkaXNfYXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gYXJ5O1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICRyYWlzZShPcGFsLlR5cGVFcnJvciwgXCJDYW4ndCBjb252ZXJ0IFwiICsgdmFsdWUuJCRjbGFzcyArXHJcbiAgICAgICAgICBcIiB0byBBcnJheSAoXCIgKyB2YWx1ZS4kJGNsYXNzICsgXCIjdG9fYXJ5IGdpdmVzIFwiICsgYXJ5LiQkY2xhc3MgKyBcIilcIik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICByZXR1cm4gW3ZhbHVlXTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBVc2VkIGZvcjogYSwgYiA9ICpzb21ldGhpbmcgKHdpdGggc3BsYXQpXHJcbiAgT3BhbC50b19hID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZS4kJGlzX2FycmF5KSB7XHJcbiAgICAgIC8vIEEgc3BsYXR0ZWQgYXJyYXkgbXVzdCBiZSBjb3BpZWRcclxuICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZVsnJHJlc3BvbmRfdG8/J10oJ3RvX2EnLCB0cnVlKSkge1xyXG4gICAgICB2YXIgYXJ5ID0gdmFsdWUuJHRvX2EoKTtcclxuICAgICAgaWYgKGFyeSA9PT0gbmlsKSB7XHJcbiAgICAgICAgcmV0dXJuIFt2YWx1ZV07XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoYXJ5LiQkaXNfYXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gYXJ5O1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICRyYWlzZShPcGFsLlR5cGVFcnJvciwgXCJDYW4ndCBjb252ZXJ0IFwiICsgdmFsdWUuJCRjbGFzcyArXHJcbiAgICAgICAgICBcIiB0byBBcnJheSAoXCIgKyB2YWx1ZS4kJGNsYXNzICsgXCIjdG9fYSBnaXZlcyBcIiArIGFyeS4kJGNsYXNzICsgXCIpXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgcmV0dXJuIFt2YWx1ZV07XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gVXNlZCBmb3IgZXh0cmFjdGluZyBrZXl3b3JkIGFyZ3VtZW50cyBmcm9tIGFyZ3VtZW50cyBwYXNzZWQgdG9cclxuICAvLyBKUyBmdW5jdGlvbi5cclxuICAvL1xyXG4gIC8vIEBwYXJhbSBwYXJhbWV0ZXJzIFtBcnJheV1cclxuICAvLyBAcmV0dXJuIFtIYXNoXSBvciB1bmRlZmluZWRcclxuICAvL1xyXG4gIE9wYWwuZXh0cmFjdF9rd2FyZ3MgPSBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XHJcbiAgICB2YXIga3dhcmdzID0gcGFyYW1ldGVyc1twYXJhbWV0ZXJzLmxlbmd0aCAtIDFdO1xyXG4gICAgaWYgKGt3YXJncyAhPSBudWxsICYmIE9wYWwucmVzcG9uZF90byhrd2FyZ3MsICckdG9faGFzaCcsIHRydWUpKSB7XHJcbiAgICAgICRzcGxpY2UocGFyYW1ldGVycywgcGFyYW1ldGVycy5sZW5ndGggLSAxKTtcclxuICAgICAgcmV0dXJuIGt3YXJncztcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBVc2VkIHRvIGdldCBhIGxpc3Qgb2YgcmVzdCBrZXl3b3JkIGFyZ3VtZW50cy4gTWV0aG9kIHRha2VzIHRoZSBnaXZlblxyXG4gIC8vIGtleXdvcmQgYXJncywgaS5lLiB0aGUgaGFzaCBsaXRlcmFsIHBhc3NlZCB0byB0aGUgbWV0aG9kIGNvbnRhaW5pbmcgYWxsXHJcbiAgLy8ga2V5d29yZCBhcmd1bWVudHMgcGFzc2VkIHRvIG1ldGhvZCwgYXMgd2VsbCBhcyB0aGUgdXNlZCBhcmdzIHdoaWNoIGFyZVxyXG4gIC8vIHRoZSBuYW1lcyBvZiByZXF1aXJlZCBhbmQgb3B0aW9uYWwgYXJndW1lbnRzIGRlZmluZWQuIFRoaXMgbWV0aG9kIHRoZW5cclxuICAvLyBqdXN0IHJldHVybnMgYWxsIGtleS92YWx1ZSBwYWlycyB3aGljaCBoYXZlIG5vdCBiZWVuIHVzZWQsIGluIGEgbmV3XHJcbiAgLy8gaGFzaCBsaXRlcmFsLlxyXG4gIC8vXHJcbiAgLy8gQHBhcmFtIGdpdmVuX2FyZ3MgW0hhc2hdIGFsbCBrd2FyZ3MgZ2l2ZW4gdG8gbWV0aG9kXHJcbiAgLy8gQHBhcmFtIHVzZWRfYXJncyBbT2JqZWN0PFN0cmluZzogdHJ1ZT5dIGFsbCBrZXlzIHVzZWQgYXMgbmFtZWQga3dhcmdzXHJcbiAgLy8gQHJldHVybiBbSGFzaF1cclxuICAvL1xyXG4gIE9wYWwua3dyZXN0YXJncyA9IGZ1bmN0aW9uKGdpdmVuX2FyZ3MsIHVzZWRfYXJncykge1xyXG4gICAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICBPcGFsLmhhc2hfZWFjaChnaXZlbl9hcmdzLCBmYWxzZSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICBpZiAoIXVzZWRfYXJnc1trZXldKSB7XHJcbiAgICAgICAgT3BhbC5oYXNoX3B1dChtYXAsIGtleSwgdmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBbZmFsc2UsIGZhbHNlXTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBtYXA7XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gYXBwbHlfYmxvY2tvcHRzKGJsb2NrLCBibG9ja29wdHMpIHtcclxuICAgIGlmICh0eXBlb2YoYmxvY2tvcHRzKSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgYmxvY2suJCRhcml0eSA9IGJsb2Nrb3B0cztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZihibG9ja29wdHMpID09PSAnb2JqZWN0Jykge1xyXG4gICAgICBPYmplY3QuYXNzaWduKGJsb2NrLCBibG9ja29wdHMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gT3B0aW1pemF0aW9uIGZvciBhIGNvc3RseSBvcGVyYXRpb24gb2YgcHJlcGVuZGluZyAnJCcgdG8gbWV0aG9kIG5hbWVzXHJcbiAgdmFyIGpzaWRfY2FjaGUgPSBuZXcgTWFwKCk7XHJcbiAgZnVuY3Rpb24gJGpzaWQobmFtZSkge1xyXG4gICAgdmFyIGpzaWQgPSBqc2lkX2NhY2hlLmdldChuYW1lKTtcclxuICAgIGlmICghanNpZCkge1xyXG4gICAgICBqc2lkID0gJyQnICsgbmFtZTtcclxuICAgICAganNpZF9jYWNoZS5zZXQobmFtZSwganNpZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ganNpZDtcclxuICB9XHJcbiAgT3BhbC5qc2lkID0gJGpzaWQ7XHJcblxyXG4gIGZ1bmN0aW9uICRwcmVwZW5kKGZpcnN0LCBzZWNvbmQpIHtcclxuICAgIGlmICghc2Vjb25kLiQkaXNfYXJyYXkpIHNlY29uZCA9ICRzbGljZShzZWNvbmQpO1xyXG4gICAgcmV0dXJuIFtmaXJzdF0uY29uY2F0KHNlY29uZCk7XHJcbiAgfVxyXG5cclxuICAvLyBDYWxscyBwYXNzZWQgbWV0aG9kIG9uIGEgcnVieSBvYmplY3Qgd2l0aCBhcmd1bWVudHMgYW5kIGJsb2NrOlxyXG4gIC8vXHJcbiAgLy8gQ2FuIHRha2UgYSBtZXRob2Qgb3IgYSBtZXRob2QgbmFtZS5cclxuICAvL1xyXG4gIC8vIDEuIFdoZW4gbWV0aG9kIG5hbWUgZ2V0cyBwYXNzZWQgaXQgaW52b2tlcyBpdCBieSBpdHMgbmFtZVxyXG4gIC8vICAgIGFuZCBjYWxscyAnbWV0aG9kX21pc3NpbmcnIHdoZW4gb2JqZWN0IGRvZXNuJ3QgaGF2ZSB0aGlzIG1ldGhvZC5cclxuICAvLyAgICBVc2VkIGludGVybmFsbHkgYnkgT3BhbCB0byBpbnZva2UgbWV0aG9kIHRoYXQgdGFrZXMgYSBibG9jayBvciBhIHNwbGF0LlxyXG4gIC8vIDIuIFdoZW4gbWV0aG9kIChpLmUuIG1ldGhvZCBib2R5KSBnZXRzIHBhc3NlZCwgaXQgZG9lc24ndCB0cmlnZ2VyICdtZXRob2RfbWlzc2luZydcclxuICAvLyAgICBiZWNhdXNlIGl0IGRvZXNuJ3Qga25vdyB0aGUgbmFtZSBvZiB0aGUgYWN0dWFsIG1ldGhvZC5cclxuICAvLyAgICBVc2VkIGludGVybmFsbHkgYnkgT3BhbCB0byBpbnZva2UgJ3N1cGVyJy5cclxuICAvL1xyXG4gIC8vIEBleGFtcGxlXHJcbiAgLy8gICB2YXIgbXlfYXJyYXkgPSBbMSwgMiwgMywgNF1cclxuICAvLyAgIE9wYWwuc2VuZChteV9hcnJheSwgJ2xlbmd0aCcpICAgICAgICAgICAgICAgICAgICAjID0+IDRcclxuICAvLyAgIE9wYWwuc2VuZChteV9hcnJheSwgbXlfYXJyYXkuJGxlbmd0aCkgICAgICAgICAgICAjID0+IDRcclxuICAvL1xyXG4gIC8vICAgT3BhbC5zZW5kKG15X2FycmF5LCAncmV2ZXJzZSEnKSAgICAgICAgICAgICAgICAgICMgPT4gWzQsIDMsIDIsIDFdXHJcbiAgLy8gICBPcGFsLnNlbmQobXlfYXJyYXksIG15X2FycmF5WyckcmV2ZXJzZSEnXScpICAgICAgIyA9PiBbNCwgMywgMiwgMV1cclxuICAvL1xyXG4gIC8vIEBwYXJhbSByZWN2IFtPYmplY3RdIHJ1Ynkgb2JqZWN0XHJcbiAgLy8gQHBhcmFtIG1ldGhvZCBbRnVuY3Rpb24sIFN0cmluZ10gbWV0aG9kIGJvZHkgb3IgbmFtZSBvZiB0aGUgbWV0aG9kXHJcbiAgLy8gQHBhcmFtIGFyZ3MgW0FycmF5XSBhcmd1bWVudHMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgbWV0aG9kIGNhbGxcclxuICAvLyBAcGFyYW0gYmxvY2sgW0Z1bmN0aW9uXSBydWJ5IGJsb2NrXHJcbiAgLy8gQHBhcmFtIGJsb2Nrb3B0cyBbT2JqZWN0LCBOdW1iZXJdIG9wdGlvbmFsIHByb3BlcnRpZXMgdG8gc2V0IG9uIHRoZSBibG9ja1xyXG4gIC8vIEByZXR1cm4gW09iamVjdF0gcmV0dXJuaW5nIHZhbHVlIG9mIHRoZSBtZXRob2QgY2FsbFxyXG4gIE9wYWwuc2VuZCA9IGZ1bmN0aW9uKHJlY3YsIG1ldGhvZCwgYXJncywgYmxvY2ssIGJsb2Nrb3B0cykge1xyXG4gICAgdmFyIGJvZHk7XHJcblxyXG4gICAgaWYgKHR5cGVvZihtZXRob2QpID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGJvZHkgPSBtZXRob2Q7XHJcbiAgICAgIG1ldGhvZCA9IG51bGw7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZihtZXRob2QpID09PSAnc3RyaW5nJykge1xyXG4gICAgICBib2R5ID0gcmVjdlskanNpZChtZXRob2QpXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICRyYWlzZShPcGFsLk5hbWVFcnJvciwgXCJQYXNzZWQgbWV0aG9kIHNob3VsZCBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBPcGFsLnNlbmQyKHJlY3YsIGJvZHksIG1ldGhvZCwgYXJncywgYmxvY2ssIGJsb2Nrb3B0cyk7XHJcbiAgfTtcclxuXHJcbiAgT3BhbC5zZW5kMiA9IGZ1bmN0aW9uKHJlY3YsIGJvZHksIG1ldGhvZCwgYXJncywgYmxvY2ssIGJsb2Nrb3B0cykge1xyXG4gICAgaWYgKGJvZHkgPT0gbnVsbCAmJiBtZXRob2QgIT0gbnVsbCAmJiByZWN2LiRtZXRob2RfbWlzc2luZykge1xyXG4gICAgICBib2R5ID0gcmVjdi4kbWV0aG9kX21pc3Npbmc7XHJcbiAgICAgIGFyZ3MgPSAkcHJlcGVuZChtZXRob2QsIGFyZ3MpO1xyXG4gICAgfVxyXG5cclxuICAgIGFwcGx5X2Jsb2Nrb3B0cyhibG9jaywgYmxvY2tvcHRzKTtcclxuXHJcbiAgICBpZiAodHlwZW9mIGJsb2NrID09PSAnZnVuY3Rpb24nKSBib2R5LiQkcCA9IGJsb2NrO1xyXG4gICAgcmV0dXJuIGJvZHkuYXBwbHkocmVjdiwgYXJncyk7XHJcbiAgfTtcclxuXHJcbiAgT3BhbC5yZWZpbmVkX3NlbmQgPSBmdW5jdGlvbihyZWZpbmVtZW50X2dyb3VwcywgcmVjdiwgbWV0aG9kLCBhcmdzLCBibG9jaywgYmxvY2tvcHRzKSB7XHJcbiAgICB2YXIgaSwgaiwgaywgYW5jZXN0b3JzLCBhbmNlc3RvciwgcmVmaW5lbWVudHMsIHJlZmluZW1lbnQsIHJlZmluZV9tb2R1bGVzLCByZWZpbmVfbW9kdWxlLCBib2R5O1xyXG5cclxuICAgIGFuY2VzdG9ycyA9IGdldF9hbmNlc3RvcnMocmVjdik7XHJcblxyXG4gICAgLy8gRm9yIGFsbCBhbmNlc3RvcnMgdGhhdCB0aGVyZSBhcmUsIHN0YXJ0aW5nIGZyb20gdGhlIGNsb3Nlc3QgdG8gdGhlIGZ1cnRoZXN0Li4uXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGFuY2VzdG9yID0gT3BhbC5pZChhbmNlc3RvcnNbaV0pO1xyXG5cclxuICAgICAgLy8gRm9yIGFsbCByZWZpbmVtZW50IGdyb3VwcyB0aGVyZSBhcmUsIHN0YXJ0aW5nIGZyb20gdGhlIGNsb3Nlc3Qgc2NvcGUgdG8gdGhlIGZ1cnRoZXN0Li4uXHJcbiAgICAgIGZvciAoaiA9IDA7IGogPCByZWZpbmVtZW50X2dyb3Vwcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIHJlZmluZW1lbnRzID0gcmVmaW5lbWVudF9ncm91cHNbal07XHJcblxyXG4gICAgICAgIC8vIEZvciBhbGwgcmVmaW5lbWVudHMgdGhlcmUgYXJlLCBzdGFydGluZyBmcm9tIHRoZSBsYXN0IGB1c2luZ2AgY2FsbCB0byB0aGUgZnVydGhlc3QuLi5cclxuICAgICAgICBmb3IgKGsgPSByZWZpbmVtZW50cy5sZW5ndGggLSAxOyBrID49IDA7IGstLSkge1xyXG4gICAgICAgICAgcmVmaW5lbWVudCA9IHJlZmluZW1lbnRzW2tdO1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiByZWZpbmVtZW50LiQkcmVmaW5lX21vZHVsZXMgPT09ICd1bmRlZmluZWQnKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAvLyBBIHNpbmdsZSBtb2R1bGUgYmVpbmcgZ2l2ZW4gYXMgYW4gYXJndW1lbnQgb2YgdGhlIGB1c2luZ2AgY2FsbCBjb250YWlucyBtdWx0aXBsZVxyXG4gICAgICAgICAgLy8gcmVmaW5lbWVudCBtb2R1bGVzXHJcbiAgICAgICAgICByZWZpbmVfbW9kdWxlcyA9IHJlZmluZW1lbnQuJCRyZWZpbmVfbW9kdWxlcztcclxuXHJcbiAgICAgICAgICAvLyBEb2VzIHRoaXMgbW9kdWxlIHJlZmluZSBhIGdpdmVuIGNhbGwgZm9yIGEgZ2l2ZW4gYW5jZXN0b3IgbW9kdWxlP1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiByZWZpbmVfbW9kdWxlc1thbmNlc3Rvcl0gPT09ICd1bmRlZmluZWQnKSBjb250aW51ZTtcclxuICAgICAgICAgIHJlZmluZV9tb2R1bGUgPSByZWZpbmVfbW9kdWxlc1thbmNlc3Rvcl07XHJcblxyXG4gICAgICAgICAgLy8gRG9lcyB0aGlzIG1vZHVsZSBkZWZpbmUgYSBtZXRob2Qgd2Ugd2FudCB0byBjYWxsP1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiByZWZpbmVfbW9kdWxlLiQkcHJvdG90eXBlWyRqc2lkKG1ldGhvZCldICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBib2R5ID0gcmVmaW5lX21vZHVsZS4kJHByb3RvdHlwZVskanNpZChtZXRob2QpXTtcclxuICAgICAgICAgICAgcmV0dXJuIE9wYWwuc2VuZDIocmVjdiwgYm9keSwgbWV0aG9kLCBhcmdzLCBibG9jaywgYmxvY2tvcHRzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gT3BhbC5zZW5kKHJlY3YsIG1ldGhvZCwgYXJncywgYmxvY2ssIGJsb2Nrb3B0cyk7XHJcbiAgfTtcclxuXHJcbiAgT3BhbC5sYW1iZGEgPSBmdW5jdGlvbihibG9jaywgYmxvY2tvcHRzKSB7XHJcbiAgICBibG9jay4kJGlzX2xhbWJkYSA9IHRydWU7XHJcblxyXG4gICAgYXBwbHlfYmxvY2tvcHRzKGJsb2NrLCBibG9ja29wdHMpO1xyXG5cclxuICAgIHJldHVybiBibG9jaztcclxuICB9O1xyXG5cclxuICAvLyBVc2VkIHRvIGRlZmluZSBtZXRob2RzIG9uIGFuIG9iamVjdC4gVGhpcyBpcyBhIGhlbHBlciBtZXRob2QsIHVzZWQgYnkgdGhlXHJcbiAgLy8gY29tcGlsZWQgc291cmNlIHRvIGRlZmluZSBtZXRob2RzIG9uIHNwZWNpYWwgY2FzZSBvYmplY3RzIHdoZW4gdGhlIGNvbXBpbGVyXHJcbiAgLy8gY2FuIG5vdCBkZXRlcm1pbmUgdGhlIGRlc3RpbmF0aW9uIG9iamVjdCwgb3IgdGhlIG9iamVjdCBpcyBhIE1vZHVsZVxyXG4gIC8vIGluc3RhbmNlLiBUaGlzIGNhbiBnZXQgY2FsbGVkIGJ5IGBNb2R1bGUjZGVmaW5lX21ldGhvZGAgYXMgd2VsbC5cclxuICAvL1xyXG4gIC8vICMjIE1vZHVsZXNcclxuICAvL1xyXG4gIC8vIEFueSBtZXRob2QgZGVmaW5lZCBvbiBhIG1vZHVsZSB3aWxsIGNvbWUgdGhyb3VnaCB0aGlzIHJ1bnRpbWUgaGVscGVyLlxyXG4gIC8vIFRoZSBtZXRob2QgaXMgYWRkZWQgdG8gdGhlIG1vZHVsZSBib2R5LCBhbmQgdGhlIG93bmVyIG9mIHRoZSBtZXRob2QgaXNcclxuICAvLyBzZXQgdG8gYmUgdGhlIG1vZHVsZSBpdHNlbGYuIFRoaXMgaXMgdXNlZCBsYXRlciB3aGVuIGNob29zaW5nIHdoaWNoXHJcbiAgLy8gbWV0aG9kIHNob3VsZCBzaG93IG9uIGEgY2xhc3MgaWYgbW9yZSB0aGFuIDEgaW5jbHVkZWQgbW9kdWxlcyBkZWZpbmVcclxuICAvLyB0aGUgc2FtZSBtZXRob2QuIEZpbmFsbHksIGlmIHRoZSBtb2R1bGUgaXMgaW4gYG1vZHVsZV9mdW5jdGlvbmAgbW9kZSxcclxuICAvLyB0aGVuIHRoZSBtZXRob2QgaXMgYWxzbyBkZWZpbmVkIG9udG8gdGhlIG1vZHVsZSBpdHNlbGYuXHJcbiAgLy9cclxuICAvLyAjIyBDbGFzc2VzXHJcbiAgLy9cclxuICAvLyBUaGlzIGhlbHBlciB3aWxsIG9ubHkgYmUgY2FsbGVkIGZvciBjbGFzc2VzIHdoZW4gYSBtZXRob2QgaXMgYmVpbmdcclxuICAvLyBkZWZpbmVkIGluZGlyZWN0bHk7IGVpdGhlciB0aHJvdWdoIGBNb2R1bGUjZGVmaW5lX21ldGhvZGAsIG9yIGJ5IGFcclxuICAvLyBsaXRlcmFsIGBkZWZgIG1ldGhvZCBpbnNpZGUgYW4gYGluc3RhbmNlX2V2YWxgIG9yIGBjbGFzc19ldmFsYCBib2R5LiBJblxyXG4gIC8vIGVpdGhlciBjYXNlLCB0aGUgbWV0aG9kIGlzIHNpbXBseSBhZGRlZCB0byB0aGUgY2xhc3MnIHByb3RvdHlwZS4gQSBzcGVjaWFsXHJcbiAgLy8gZXhjZXB0aW9uIGV4aXN0cyBmb3IgYEJhc2ljT2JqZWN0YCBhbmQgYE9iamVjdGAuIFRoZXNlIHR3byBjbGFzc2VzIGFyZVxyXG4gIC8vIHNwZWNpYWwgYmVjYXVzZSB0aGV5IGFyZSB1c2VkIGluIHRvbGwtZnJlZSBicmlkZ2VkIGNsYXNzZXMuIEluIGVhY2ggb2ZcclxuICAvLyB0aGVzZSB0d28gY2FzZXMsIGV4dHJhIHdvcmsgaXMgcmVxdWlyZWQgdG8gZGVmaW5lIHRoZSBtZXRob2RzIG9uIHRvbGwtZnJlZVxyXG4gIC8vIGJyaWRnZWQgY2xhc3MnIHByb3RvdHlwZXMgYXMgd2VsbC5cclxuICAvL1xyXG4gIC8vICMjIE9iamVjdHNcclxuICAvL1xyXG4gIC8vIElmIGEgc2ltcGxlIHJ1Ynkgb2JqZWN0IGlzIHRoZSBvYmplY3QsIHRoZW4gdGhlIG1ldGhvZCBpcyBzaW1wbHkganVzdFxyXG4gIC8vIGRlZmluZWQgb24gdGhlIG9iamVjdCBhcyBhIHNpbmdsZXRvbiBtZXRob2QuIFRoaXMgd291bGQgYmUgdGhlIGNhc2Ugd2hlblxyXG4gIC8vIGEgbWV0aG9kIGlzIGRlZmluZWQgaW5zaWRlIGFuIGBpbnN0YW5jZV9ldmFsYCBibG9jay5cclxuICAvL1xyXG4gIC8vIEBwYXJhbSBvYmogIFtPYmplY3QsIENsYXNzXSB0aGUgYWN0dWFsIG9iaiB0byBkZWZpbmUgbWV0aG9kIGZvclxyXG4gIC8vIEBwYXJhbSBqc2lkIFtTdHJpbmddIHRoZSBKYXZhU2NyaXB0IGZyaWVuZGx5IG1ldGhvZCBuYW1lIChlLmcuICckZm9vJylcclxuICAvLyBAcGFyYW0gYm9keSBbSlMuRnVuY3Rpb25dIHRoZSBsaXRlcmFsIEphdmFTY3JpcHQgZnVuY3Rpb24gdXNlZCBhcyBtZXRob2RcclxuICAvLyBAcGFyYW0gYmxvY2tvcHRzIFtPYmplY3QsIE51bWJlcl0gb3B0aW9uYWwgcHJvcGVydGllcyB0byBzZXQgb24gdGhlIGJvZHlcclxuICAvLyBAcmV0dXJuIFtudWxsXVxyXG4gIC8vXHJcbiAgT3BhbC5kZWYgPSBmdW5jdGlvbihvYmosIGpzaWQsIGJvZHksIGJsb2Nrb3B0cykge1xyXG4gICAgYXBwbHlfYmxvY2tvcHRzKGJvZHksIGJsb2Nrb3B0cyk7XHJcblxyXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIG1ldGhvZCBkZWZpbml0aW9uIGluIHRoZVxyXG4gICAgLy8gdG9wLWxldmVsIG5hbWVzcGFjZVxyXG4gICAgaWYgKG9iaiA9PT0gT3BhbC50b3ApIHtcclxuICAgICAgcmV0dXJuIE9wYWwuZGVmbihPcGFsLk9iamVjdCwganNpZCwgYm9keSk7XHJcbiAgICB9XHJcbiAgICAvLyBpZiBpbnN0YW5jZV9ldmFsIGlzIGludm9rZWQgb24gYSBtb2R1bGUvY2xhc3MsIGl0IHNldHMgaW5zdF9ldmFsX21vZFxyXG4gICAgZWxzZSBpZiAoIW9iai4kJGV2YWwgJiYgb2JqLiQkaXNfYV9tb2R1bGUpIHtcclxuICAgICAgcmV0dXJuIE9wYWwuZGVmbihvYmosIGpzaWQsIGJvZHkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHJldHVybiBPcGFsLmRlZnMob2JqLCBqc2lkLCBib2R5KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBEZWZpbmUgbWV0aG9kIG9uIGEgbW9kdWxlIG9yIGNsYXNzIChzZWUgT3BhbC5kZWYpLlxyXG4gIE9wYWwuZGVmbiA9IGZ1bmN0aW9uKG1vZHVsZSwganNpZCwgYm9keSkge1xyXG4gICAgJGRlbnlfZnJvemVuX2FjY2Vzcyhtb2R1bGUpO1xyXG5cclxuICAgIGJvZHkuZGlzcGxheU5hbWUgPSBqc2lkO1xyXG4gICAgYm9keS4kJG93bmVyID0gbW9kdWxlO1xyXG5cclxuICAgIHZhciBuYW1lID0ganNpZC5zdWJzdHIoMSk7XHJcblxyXG4gICAgdmFyIHByb3RvID0gbW9kdWxlLiQkcHJvdG90eXBlO1xyXG4gICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcclxuICAgICAgcHJvdG8gPSBwcm90by4kJGRlZmluZV9tZXRob2RzX29uO1xyXG4gICAgfVxyXG4gICAgJHByb3AocHJvdG8sIGpzaWQsIGJvZHkpO1xyXG5cclxuICAgIGlmIChtb2R1bGUuJCRpc19tb2R1bGUpIHtcclxuICAgICAgaWYgKG1vZHVsZS4kJG1vZHVsZV9mdW5jdGlvbikge1xyXG4gICAgICAgIE9wYWwuZGVmcyhtb2R1bGUsIGpzaWQsIGJvZHkpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpY2xhc3NlcyA9IG1vZHVsZS4kJGljbGFzc2VzLCBsZW5ndGggPSBpY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBpY2xhc3MgPSBpY2xhc3Nlc1tpXTtcclxuICAgICAgICAkcHJvcChpY2xhc3MsIGpzaWQsIGJvZHkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHNpbmdsZXRvbl9vZiA9IG1vZHVsZS4kJHNpbmdsZXRvbl9vZjtcclxuICAgIGlmIChtb2R1bGUuJG1ldGhvZF9hZGRlZCAmJiAhbW9kdWxlLiRtZXRob2RfYWRkZWQuJCRzdHViICYmICFzaW5nbGV0b25fb2YpIHtcclxuICAgICAgbW9kdWxlLiRtZXRob2RfYWRkZWQobmFtZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzaW5nbGV0b25fb2YgJiYgc2luZ2xldG9uX29mLiRzaW5nbGV0b25fbWV0aG9kX2FkZGVkICYmICFzaW5nbGV0b25fb2YuJHNpbmdsZXRvbl9tZXRob2RfYWRkZWQuJCRzdHViKSB7XHJcbiAgICAgIHNpbmdsZXRvbl9vZi4kc2luZ2xldG9uX21ldGhvZF9hZGRlZChuYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmFtZTtcclxuICB9O1xyXG5cclxuICAvLyBEZWZpbmUgYSBzaW5nbGV0b24gbWV0aG9kIG9uIHRoZSBnaXZlbiBvYmplY3QgKHNlZSBPcGFsLmRlZikuXHJcbiAgT3BhbC5kZWZzID0gZnVuY3Rpb24ob2JqLCBqc2lkLCBib2R5LCBibG9ja29wdHMpIHtcclxuICAgIGFwcGx5X2Jsb2Nrb3B0cyhib2R5LCBibG9ja29wdHMpO1xyXG5cclxuICAgIGlmIChvYmouJCRpc19zdHJpbmcgfHwgb2JqLiQkaXNfbnVtYmVyKSB7XHJcbiAgICAgICRyYWlzZShPcGFsLlR5cGVFcnJvciwgXCJjYW4ndCBkZWZpbmUgc2luZ2xldG9uXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE9wYWwuZGVmbihPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqKSwganNpZCwgYm9keSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gU2luY2UgSmF2YVNjcmlwdCBoYXMgbm8gY29uY2VwdCBvZiBtb2R1bGVzLCB3ZSBjcmVhdGUgcHJveHkgY2xhc3Nlc1xyXG4gIC8vIGNhbGxlZCBgaWNsYXNzZXNgIHRoYXQgc3RvcmUgY29waWVzIG9mIG1ldGhvZHMgbG9hZGVkLiBXZSBuZWVkIHRvXHJcbiAgLy8gdXBkYXRlIHRoZW0gaWYgd2UgcmVtb3ZlIGEgbWV0aG9kLlxyXG4gIGZ1bmN0aW9uIHJlbW92ZV9tZXRob2RfZnJvbV9pY2xhc3NlcyhvYmosIGpzaWQpIHtcclxuICAgIGlmIChvYmouJCRpc19tb2R1bGUpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGljbGFzc2VzID0gb2JqLiQkaWNsYXNzZXMsIGxlbmd0aCA9IGljbGFzc2VzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGljbGFzcyA9IGljbGFzc2VzW2ldO1xyXG4gICAgICAgIGRlbGV0ZSBpY2xhc3NbanNpZF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENhbGxlZCBmcm9tICNyZW1vdmVfbWV0aG9kLlxyXG4gIE9wYWwucmRlZiA9IGZ1bmN0aW9uKG9iaiwganNpZCkge1xyXG4gICAgaWYgKCEkaGFzX293bihvYmouJCRwcm90b3R5cGUsIGpzaWQpKSB7XHJcbiAgICAgICRyYWlzZShPcGFsLk5hbWVFcnJvciwgXCJtZXRob2QgJ1wiICsganNpZC5zdWJzdHIoMSkgKyBcIicgbm90IGRlZmluZWQgaW4gXCIgKyBvYmouJG5hbWUoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVsZXRlIG9iai4kJHByb3RvdHlwZVtqc2lkXTtcclxuXHJcbiAgICByZW1vdmVfbWV0aG9kX2Zyb21faWNsYXNzZXMob2JqLCBqc2lkKTtcclxuXHJcbiAgICBpZiAob2JqLiQkaXNfc2luZ2xldG9uKSB7XHJcbiAgICAgIGlmIChvYmouJCRwcm90b3R5cGUuJHNpbmdsZXRvbl9tZXRob2RfcmVtb3ZlZCAmJiAhb2JqLiQkcHJvdG90eXBlLiRzaW5nbGV0b25fbWV0aG9kX3JlbW92ZWQuJCRzdHViKSB7XHJcbiAgICAgICAgb2JqLiQkcHJvdG90eXBlLiRzaW5nbGV0b25fbWV0aG9kX3JlbW92ZWQoanNpZC5zdWJzdHIoMSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgaWYgKG9iai4kbWV0aG9kX3JlbW92ZWQgJiYgIW9iai4kbWV0aG9kX3JlbW92ZWQuJCRzdHViKSB7XHJcbiAgICAgICAgb2JqLiRtZXRob2RfcmVtb3ZlZChqc2lkLnN1YnN0cigxKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBDYWxsZWQgZnJvbSAjdW5kZWZfbWV0aG9kLlxyXG4gIE9wYWwudWRlZiA9IGZ1bmN0aW9uKG9iaiwganNpZCkge1xyXG4gICAgaWYgKCFvYmouJCRwcm90b3R5cGVbanNpZF0gfHwgb2JqLiQkcHJvdG90eXBlW2pzaWRdLiQkc3R1Yikge1xyXG4gICAgICAkcmFpc2UoT3BhbC5OYW1lRXJyb3IsIFwibWV0aG9kICdcIiArIGpzaWQuc3Vic3RyKDEpICsgXCInIG5vdCBkZWZpbmVkIGluIFwiICsgb2JqLiRuYW1lKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIE9wYWwuYWRkX3N0dWJfZm9yKG9iai4kJHByb3RvdHlwZSwganNpZCk7XHJcblxyXG4gICAgcmVtb3ZlX21ldGhvZF9mcm9tX2ljbGFzc2VzKG9iaiwganNpZCk7XHJcblxyXG4gICAgaWYgKG9iai4kJGlzX3NpbmdsZXRvbikge1xyXG4gICAgICBpZiAob2JqLiQkcHJvdG90eXBlLiRzaW5nbGV0b25fbWV0aG9kX3VuZGVmaW5lZCAmJiAhb2JqLiQkcHJvdG90eXBlLiRzaW5nbGV0b25fbWV0aG9kX3VuZGVmaW5lZC4kJHN0dWIpIHtcclxuICAgICAgICBvYmouJCRwcm90b3R5cGUuJHNpbmdsZXRvbl9tZXRob2RfdW5kZWZpbmVkKGpzaWQuc3Vic3RyKDEpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIGlmIChvYmouJG1ldGhvZF91bmRlZmluZWQgJiYgIW9iai4kbWV0aG9kX3VuZGVmaW5lZC4kJHN0dWIpIHtcclxuICAgICAgICBvYmouJG1ldGhvZF91bmRlZmluZWQoanNpZC5zdWJzdHIoMSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gaXNfbWV0aG9kX2JvZHkoYm9keSkge1xyXG4gICAgcmV0dXJuICh0eXBlb2YoYm9keSkgPT09IFwiZnVuY3Rpb25cIiAmJiAhYm9keS4kJHN0dWIpO1xyXG4gIH1cclxuXHJcbiAgT3BhbC5hbGlhcyA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgb2xkKSB7XHJcbiAgICB2YXIgaWQgICAgID0gJGpzaWQobmFtZSksXHJcbiAgICAgICAgb2xkX2lkID0gJGpzaWQob2xkKSxcclxuICAgICAgICBib2R5LFxyXG4gICAgICAgIGFsaWFzO1xyXG5cclxuICAgIC8vIEFsaWFzaW5nIG9uIG1haW4gbWVhbnMgYWxpYXNpbmcgb24gT2JqZWN0Li4uXHJcbiAgICBpZiAodHlwZW9mIG9iai4kJHByb3RvdHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgb2JqID0gT3BhbC5PYmplY3Q7XHJcbiAgICB9XHJcblxyXG4gICAgYm9keSA9IG9iai4kJHByb3RvdHlwZVtvbGRfaWRdO1xyXG5cclxuICAgIC8vIFdoZW4gcnVubmluZyBpbnNpZGUgI2luc3RhbmNlX2V2YWwgdGhlIGFsaWFzIHJlZmVycyB0byBjbGFzcyBtZXRob2RzLlxyXG4gICAgaWYgKG9iai4kJGV2YWwpIHtcclxuICAgICAgcmV0dXJuIE9wYWwuYWxpYXMoT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKG9iaiksIG5hbWUsIG9sZCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFpc19tZXRob2RfYm9keShib2R5KSkge1xyXG4gICAgICB2YXIgYW5jZXN0b3IgPSBvYmouJCRzdXBlcjtcclxuXHJcbiAgICAgIHdoaWxlICh0eXBlb2YoYm9keSkgIT09IFwiZnVuY3Rpb25cIiAmJiBhbmNlc3Rvcikge1xyXG4gICAgICAgIGJvZHkgICAgID0gYW5jZXN0b3Jbb2xkX2lkXTtcclxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLiQkc3VwZXI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghaXNfbWV0aG9kX2JvZHkoYm9keSkgJiYgb2JqLiQkaXNfbW9kdWxlKSB7XHJcbiAgICAgICAgLy8gdHJ5IHRvIGxvb2sgaW50byBPYmplY3RcclxuICAgICAgICBib2R5ID0gT3BhbC5PYmplY3QuJCRwcm90b3R5cGVbb2xkX2lkXVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWlzX21ldGhvZF9ib2R5KGJvZHkpKSB7XHJcbiAgICAgICAgJHJhaXNlKE9wYWwuTmFtZUVycm9yLCBcInVuZGVmaW5lZCBtZXRob2QgYFwiICsgb2xkICsgXCInIGZvciBjbGFzcyBgXCIgKyBvYmouJG5hbWUoKSArIFwiJ1wiKVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgdGhlIGJvZHkgaXMgaXRzZWxmIGFuIGFsaWFzIHVzZSB0aGUgb3JpZ2luYWwgYm9keVxyXG4gICAgLy8gdG8ga2VlcCB0aGUgbWF4IGRlcHRoIGF0IDEuXHJcbiAgICBpZiAoYm9keS4kJGFsaWFzX29mKSBib2R5ID0gYm9keS4kJGFsaWFzX29mO1xyXG5cclxuICAgIC8vIFdlIG5lZWQgYSB3cmFwcGVyIGJlY2F1c2Ugb3RoZXJ3aXNlIHByb3BlcnRpZXNcclxuICAgIC8vIHdvdWxkIGJlIG92ZXJ3cml0dGVuIG9uIHRoZSBvcmlnaW5hbCBib2R5LlxyXG4gICAgYWxpYXMgPSBPcGFsLndyYXBfbWV0aG9kX2JvZHkoYm9keSk7XHJcblxyXG4gICAgLy8gVHJ5IHRvIG1ha2UgdGhlIGJyb3dzZXIgcGljayB0aGUgcmlnaHQgbmFtZVxyXG4gICAgYWxpYXMuZGlzcGxheU5hbWUgID0gbmFtZTtcclxuICAgIGFsaWFzLiQkYWxpYXNfb2YgICA9IGJvZHk7XHJcbiAgICBhbGlhcy4kJGFsaWFzX25hbWUgPSBuYW1lO1xyXG5cclxuICAgIE9wYWwuZGVmbihvYmosIGlkLCBhbGlhcyk7XHJcblxyXG4gICAgcmV0dXJuIG9iajtcclxuICB9O1xyXG5cclxuICBPcGFsLndyYXBfbWV0aG9kX2JvZHkgPSBmdW5jdGlvbihib2R5KSB7XHJcbiAgICB2YXIgd3JhcHBlZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgYmxvY2sgPSB3cmFwcGVkLiQkcDtcclxuXHJcbiAgICAgIHdyYXBwZWQuJCRwID0gbnVsbDtcclxuXHJcbiAgICAgIHJldHVybiBPcGFsLnNlbmQodGhpcywgYm9keSwgYXJndW1lbnRzLCBibG9jayk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEFzc2lnbiB0aGUgJ2xlbmd0aCcgdmFsdWUgd2l0aCBkZWZpbmVQcm9wZXJ0eSBiZWNhdXNlXHJcbiAgICAvLyBpbiBzdHJpY3QgbW9kZSB0aGUgcHJvcGVydHkgaXMgbm90IHdyaXRhYmxlLlxyXG4gICAgLy8gSXQgZG9lc24ndCB3b3JrIGluIG9sZGVyIGJyb3dzZXJzIChsaWtlIENocm9tZSAzOCksIHdoZXJlXHJcbiAgICAvLyBhbiBleGNlcHRpb24gaXMgdGhyb3duIGJyZWFraW5nIE9wYWwgYWx0b2dldGhlci5cclxuICAgIHRyeSB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3cmFwcGVkLCAnbGVuZ3RoJywgeyB2YWx1ZTogYm9keS5sZW5ndGggfSk7XHJcbiAgICB9IGNhdGNoIHt9XHJcblxyXG4gICAgd3JhcHBlZC4kJGFyaXR5ICAgICAgICAgICA9IGJvZHkuJCRhcml0eSA9PSBudWxsID8gYm9keS5sZW5ndGggOiBib2R5LiQkYXJpdHk7XHJcbiAgICB3cmFwcGVkLiQkcGFyYW1ldGVycyAgICAgID0gYm9keS4kJHBhcmFtZXRlcnM7XHJcbiAgICB3cmFwcGVkLiQkc291cmNlX2xvY2F0aW9uID0gYm9keS4kJHNvdXJjZV9sb2NhdGlvbjtcclxuXHJcbiAgICByZXR1cm4gd3JhcHBlZDtcclxuICB9O1xyXG5cclxuICBPcGFsLmFsaWFzX2d2YXIgPSBmdW5jdGlvbihuZXdfbmFtZSwgb2xkX25hbWUpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgkZ3ZhcnMsIG5ld19uYW1lLCB7XHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gJGd2YXJzW29sZF9uYW1lXTtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbihuZXdfdmFsdWUpIHtcclxuICAgICAgICAkZ3ZhcnNbb2xkX25hbWVdID0gbmV3X3ZhbHVlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBuaWw7XHJcbiAgfVxyXG5cclxuICBPcGFsLmFsaWFzX25hdGl2ZSA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgbmF0aXZlX25hbWUpIHtcclxuICAgIHZhciBpZCAgID0gJGpzaWQobmFtZSksXHJcbiAgICAgICAgYm9keSA9IG9iai4kJHByb3RvdHlwZVtuYXRpdmVfbmFtZV07XHJcblxyXG4gICAgaWYgKHR5cGVvZihib2R5KSAhPT0gXCJmdW5jdGlvblwiIHx8IGJvZHkuJCRzdHViKSB7XHJcbiAgICAgICRyYWlzZShPcGFsLk5hbWVFcnJvciwgXCJ1bmRlZmluZWQgbmF0aXZlIG1ldGhvZCBgXCIgKyBuYXRpdmVfbmFtZSArIFwiJyBmb3IgY2xhc3MgYFwiICsgb2JqLiRuYW1lKCkgKyBcIidcIilcclxuICAgIH1cclxuXHJcbiAgICBPcGFsLmRlZm4ob2JqLCBpZCwgYm9keSk7XHJcblxyXG4gICAgcmV0dXJuIG9iajtcclxuICB9O1xyXG5cclxuXHJcbiAgLy8gSGFzaGVzXHJcbiAgLy8gLS0tLS0tXHJcblxyXG5cclxuICAvLyBFeHBlcmltZW50cyBoYXZlIHNob3duLCB0aGF0IHVzaW5nIG5ldyBNYXAoW1sxLDJdXSkgaW5saW5lIGlzIHJhdGhlciBzbG93XHJcbiAgLy8gY29tcGFyZWQgdG8gdXNpbmcgbmV3IE1hcCgpIGluIGNvbWJpbmF0aW9uIHdpdGggLnNldCgxLDIpLCBiZWNhdXNlIHRoZSBmb3JtZXJcclxuICAvLyBjcmVhdGVzIGEgbmV3IEFycmF5IGZvciBlYWNoIHBhaXIgYW5kIHRoZW4gZGlzY2FyZHMgaXQuIFVzaW5nIC5zZXQgdGhvdWdoXHJcbiAgLy8gd291bGQgaW5jcmVhc2UgdGhlIHNpemUgb2YgdGhlIGdlbmVyYXRlZCBjb2RlLiBTbyBsZXRzIHVzZSBhIGNvbXByb21pc2UgYW5kXHJcbiAgLy8gdXNlIGEgaGVscGVyIGZ1bmN0aW9uLCB3aGljaCBhbGxvd3MgdGhlIGNvbXBpbGVyIHRvIGdlbmVyYXRlIGNvbXBhY3QgY29kZVxyXG4gIC8vIGFuZCBhdCB0aGUgc2FtZSB0aW1lIHByb3ZpZGVzIHRoZSBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudCBvZiB1c2luZyAuc2V0XHJcbiAgLy8gd2l0aCBhIG92ZXJhbGwgc21hbGxlciBvdmVyaGVhZCB0aGFuIGNyZWF0aW5nIGFycmF5cyBmb3IgZWFjaCBwYWlyLlxyXG4gIC8vIEZvciBwcmltaXRpdmUga2V5czpcclxuICBPcGFsLmhhc2hfbmV3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgbGV0IGggPSBuZXcgTWFwKCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICBoLnNldChhcmd1bWVudHNbaV0sIGFyZ3VtZW50c1tpICsgMV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGg7XHJcbiAgfVxyXG5cclxuICAvLyBUaGUgc2FtZSBhcyBhYm92ZSwgZXhjZXB0IGZvciBjb21wbGV4IGtleXM6XHJcbiAgT3BhbC5oYXNoX25ldzIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBsZXQgaCA9IG5ldyBNYXAoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgIE9wYWwuaGFzaF9wdXQoaCwgYXJndW1lbnRzW2ldLCBhcmd1bWVudHNbaSArIDFdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBoO1xyXG4gIH1cclxuXHJcbiAgT3BhbC5oYXNoX2luaXQgPSBmdW5jdGlvbiAoX2hhc2gpIHtcclxuICAgIGNvbnNvbGUud2FybihcIkRFUFJFQ0FUSU9OOiBPcGFsLmhhc2hfaW5pdCBpcyBkZXByZWNhdGVkIGFuZCBpcyBub3cgYSBuby1vcC5cIik7XHJcbiAgfVxyXG5cclxuICBPcGFsLmhhc2hfY2xvbmUgPSBmdW5jdGlvbihmcm9tX2hhc2gsIHRvX2hhc2gpIHtcclxuICAgIHRvX2hhc2guJCRub25lID0gZnJvbV9oYXNoLiQkbm9uZTtcclxuICAgIHRvX2hhc2guJCRwcm9jID0gZnJvbV9oYXNoLiQkcHJvYztcclxuXHJcbiAgICByZXR1cm4gT3BhbC5oYXNoX2VhY2goZnJvbV9oYXNoLCB0b19oYXNoLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICAgIE9wYWwuaGFzaF9wdXQodG9faGFzaCwga2V5LCB2YWx1ZSk7XHJcbiAgICAgIHJldHVybiBbZmFsc2UsIHRvX2hhc2hdO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgT3BhbC5oYXNoX3B1dCA9IGZ1bmN0aW9uKGhhc2gsIGtleSwgdmFsdWUpIHtcclxuICAgIHZhciB0eXBlID0gdHlwZW9mIGtleTtcclxuICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwic3ltYm9sXCIgfHwgdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIiB8fCB0eXBlID09PSBcImJpZ2ludFwiKSB7XHJcbiAgICAgIGhhc2guc2V0KGtleSwgdmFsdWUpXHJcbiAgICB9IGVsc2UgaWYgKGtleS4kJGlzX3N0cmluZykge1xyXG4gICAgICBoYXNoLnNldChrZXkudmFsdWVPZigpLCB2YWx1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoIWhhc2guJCRrZXlzKVxyXG4gICAgICAgIGhhc2guJCRrZXlzID0gbmV3IE1hcCgpO1xyXG5cclxuICAgICAgdmFyIGtleV9oYXNoID0ga2V5LiQkaXNfc3RyaW5nID8ga2V5LnZhbHVlT2YoKSA6IChoYXNoLiQkYnlfaWRlbnRpdHkgPyBPcGFsLmlkKGtleSkgOiBrZXkuJGhhc2goKSksXHJcbiAgICAgICAgICBrZXlzID0gaGFzaC4kJGtleXM7XHJcblxyXG4gICAgICBpZiAoIWtleXMuaGFzKGtleV9oYXNoKSkge1xyXG4gICAgICAgIGtleXMuc2V0KGtleV9oYXNoLCBba2V5XSk7XHJcbiAgICAgICAgaGFzaC5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgb2JqZWN0cyA9IGtleXMuZ2V0KGtleV9oYXNoKSxcclxuICAgICAgICAgIG9iamVjdDtcclxuXHJcbiAgICAgIGZvciAodmFyIGk9MDsgaTxvYmplY3RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0c1tpXTtcclxuICAgICAgICBpZiAoa2V5ID09PSBvYmplY3QgfHwga2V5WyckZXFsPyddKG9iamVjdCkpIHtcclxuICAgICAgICAgIGhhc2guc2V0KG9iamVjdCwgdmFsdWUpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgb2JqZWN0cy5wdXNoKGtleSk7XHJcbiAgICAgIGhhc2guc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIE9wYWwuaGFzaF9nZXQgPSBmdW5jdGlvbihoYXNoLCBrZXkpIHtcclxuICAgIHZhciB0eXBlID0gdHlwZW9mIGtleTtcclxuICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwic3ltYm9sXCIgfHwgdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIiB8fCB0eXBlID09PSBcImJpZ2ludFwiKSB7XHJcbiAgICAgIHJldHVybiBoYXNoLmdldChrZXkpXHJcbiAgICB9IGVsc2UgaWYgKGhhc2guJCRrZXlzKSB7XHJcbiAgICAgIHZhciBrZXlfaGFzaCA9IGtleS4kJGlzX3N0cmluZyA/IGtleS52YWx1ZU9mKCkgOiAoaGFzaC4kJGJ5X2lkZW50aXR5ID8gT3BhbC5pZChrZXkpIDoga2V5LiRoYXNoKCkpLFxyXG4gICAgICAgICAgb2JqZWN0cyA9IGhhc2guJCRrZXlzLmdldChrZXlfaGFzaCksXHJcbiAgICAgICAgICBvYmplY3Q7XHJcblxyXG4gICAgICBpZiAob2JqZWN0cyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPG9iamVjdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIG9iamVjdCA9IG9iamVjdHNbaV07XHJcbiAgICAgICAgICBpZiAoa2V5ID09PSBvYmplY3QgfHwga2V5WyckZXFsPyddKG9iamVjdCkpXHJcbiAgICAgICAgICAgIHJldHVybiBoYXNoLmdldChvYmplY3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gaGFzaC5nZXQoa2V5X2hhc2gpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGtleS4kJGlzX3N0cmluZykge1xyXG4gICAgICByZXR1cm4gaGFzaC5nZXQoa2V5LnZhbHVlT2YoKSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gJGhhc2hfZGVsZXRlX3N0YWdlMihoYXNoLCBrZXkpIHtcclxuICAgIHZhciB2YWx1ZSA9IGhhc2guZ2V0KGtleSk7XHJcbiAgICBoYXNoLmRlbGV0ZShrZXkpO1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgT3BhbC5oYXNoX2RlbGV0ZSA9IGZ1bmN0aW9uKGhhc2gsIGtleSkge1xyXG4gICAgdmFyIHR5cGUgPSB0eXBlb2Yga2V5XHJcbiAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcInN5bWJvbFwiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgfHwgdHlwZSA9PT0gXCJiaWdpbnRcIikge1xyXG4gICAgICByZXR1cm4gJGhhc2hfZGVsZXRlX3N0YWdlMihoYXNoLCBrZXkpO1xyXG4gICAgfSBlbHNlIGlmIChoYXNoLiQka2V5cykge1xyXG4gICAgICB2YXIga2V5X2hhc2ggPSBrZXkuJCRpc19zdHJpbmcgPyBrZXkudmFsdWVPZigpIDogKGhhc2guJCRieV9pZGVudGl0eSA/IE9wYWwuaWQoa2V5KSA6IGtleS4kaGFzaCgpKSxcclxuICAgICAgICAgIG9iamVjdHMgPSBoYXNoLiQka2V5cy5nZXQoa2V5X2hhc2gpLFxyXG4gICAgICAgICAgb2JqZWN0O1xyXG5cclxuICAgICAgaWYgKG9iamVjdHMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxvYmplY3RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBvYmplY3QgPSBvYmplY3RzW2ldO1xyXG4gICAgICAgICAgaWYgKGtleSA9PT0gb2JqZWN0IHx8IGtleVsnJGVxbD8nXShvYmplY3QpKSB7XHJcbiAgICAgICAgICAgIG9iamVjdHMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0cy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgICAgaGFzaC4kJGtleXMuZGVsZXRlKGtleV9oYXNoKTtcclxuICAgICAgICAgICAgcmV0dXJuICRoYXNoX2RlbGV0ZV9zdGFnZTIoaGFzaCwgb2JqZWN0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuICRoYXNoX2RlbGV0ZV9zdGFnZTIoaGFzaCwga2V5X2hhc2gpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGtleS4kJGlzX3N0cmluZykge1xyXG4gICAgICByZXR1cm4gJGhhc2hfZGVsZXRlX3N0YWdlMihoYXNoLCBrZXkudmFsdWVPZigpKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBPcGFsLmhhc2hfcmVoYXNoID0gZnVuY3Rpb24oaGFzaCkge1xyXG4gICAgdmFyIGtleXMgPSBoYXNoLiQka2V5cztcclxuXHJcbiAgICBpZiAoa2V5cylcclxuICAgICAga2V5cy5jbGVhcigpO1xyXG5cclxuICAgIE9wYWwuaGFzaF9lYWNoKGhhc2gsIGZhbHNlLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGtleTtcclxuICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZSA9PT0gXCJzeW1ib2xcIiB8fCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGUgPT09IFwiYmlnaW50XCIpXHJcbiAgICAgICAgcmV0dXJuIFtmYWxzZSwgZmFsc2VdOyAvLyBub3RoaW5nIHRvIHJlaGFzaFxyXG5cclxuICAgICAgdmFyIGtleV9oYXNoID0ga2V5LiQkaXNfc3RyaW5nID8ga2V5LnZhbHVlT2YoKSA6IChoYXNoLiQkYnlfaWRlbnRpdHkgPyBPcGFsLmlkKGtleSkgOiBrZXkuJGhhc2goKSk7XHJcblxyXG4gICAgICBpZiAoIWtleXMpXHJcbiAgICAgICAgaGFzaC4kJGtleXMgPSBrZXlzID0gbmV3IE1hcCgpO1xyXG5cclxuICAgICAgaWYgKCFrZXlzLmhhcyhrZXlfaGFzaCkpIHtcclxuICAgICAgICBrZXlzLnNldChrZXlfaGFzaCwgW2tleV0pO1xyXG4gICAgICAgIHJldHVybiBbZmFsc2UsIGZhbHNlXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIG9iamVjdHMgPSBrZXlzLmdldChrZXlfaGFzaCksXHJcbiAgICAgICAgICBvYmplY3RzX2NvcHkgPSAob2JqZWN0cy5sZW5ndGggPT09IDEpID8gb2JqZWN0cyA6ICRzbGljZShvYmplY3RzKSxcclxuICAgICAgICAgIG9iamVjdDtcclxuXHJcbiAgICAgIGZvciAodmFyIGk9MDsgaTxvYmplY3RzX2NvcHkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBvYmplY3QgPSBvYmplY3RzX2NvcHlbaV07XHJcbiAgICAgICAgaWYgKGtleSA9PT0gb2JqZWN0IHx8IGtleVsnJGVxbD8nXShvYmplY3QpKSB7XHJcbiAgICAgICAgICAvLyBnb3QgYSBkdXBsaWNhdGUsIHJlbW92ZSBpdFxyXG4gICAgICAgICAgb2JqZWN0cy5zcGxpY2Uob2JqZWN0cy5pbmRleE9mKG9iamVjdCksIDEpO1xyXG4gICAgICAgICAgaGFzaC5kZWxldGUob2JqZWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG9iamVjdHMucHVzaChrZXkpO1xyXG5cclxuICAgICAgcmV0dXJuIFtmYWxzZSwgZmFsc2VdXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gaGFzaDtcclxuICB9O1xyXG5cclxuICBPcGFsLmhhc2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYXJndW1lbnRzX2xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXHJcbiAgICAgIGFyZ3MsXHJcbiAgICAgIGhhc2gsXHJcbiAgICAgIGksXHJcbiAgICAgIGxlbmd0aCxcclxuICAgICAga2V5LFxyXG4gICAgICB2YWx1ZTtcclxuXHJcbiAgICBpZiAoYXJndW1lbnRzX2xlbmd0aCA9PT0gMSAmJiBhcmd1bWVudHNbMF0uJCRpc19oYXNoKSB7XHJcbiAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XHJcbiAgICB9XHJcblxyXG4gICAgaGFzaCA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICBpZiAoYXJndW1lbnRzX2xlbmd0aCA9PT0gMSkge1xyXG4gICAgICBhcmdzID0gYXJndW1lbnRzWzBdO1xyXG5cclxuICAgICAgaWYgKGFyZ3VtZW50c1swXS4kJGlzX2FycmF5KSB7XHJcbiAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgaWYgKGFyZ3NbaV0ubGVuZ3RoICE9PSAyKSB7XHJcbiAgICAgICAgICAgICRyYWlzZShPcGFsLkFyZ3VtZW50RXJyb3IsICd2YWx1ZSBub3Qgb2YgbGVuZ3RoIDI6ICcgKyBhcmdzW2ldLiRpbnNwZWN0KCkpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGtleSA9IGFyZ3NbaV1bMF07XHJcbiAgICAgICAgICB2YWx1ZSA9IGFyZ3NbaV1bMV07XHJcblxyXG4gICAgICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBoYXNoO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHNbMF07XHJcbiAgICAgICAgZm9yIChrZXkgaW4gYXJncykge1xyXG4gICAgICAgICAgaWYgKCRoYXNfb3duKGFyZ3MsIGtleSkpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBhcmdzW2tleV07XHJcblxyXG4gICAgICAgICAgICBPcGFsLmhhc2hfcHV0KGhhc2gsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGhhc2g7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoYXJndW1lbnRzX2xlbmd0aCAlIDIgIT09IDApIHtcclxuICAgICAgJHJhaXNlKE9wYWwuQXJndW1lbnRFcnJvciwgJ29kZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBIYXNoJyk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50c19sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICBrZXkgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgIHZhbHVlID0gYXJndW1lbnRzW2kgKyAxXTtcclxuXHJcbiAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGhhc2g7XHJcbiAgfTtcclxuXHJcbiAgLy8gQSBmYXN0ZXIgSGFzaCBjcmVhdG9yIGZvciBoYXNoZXMgdGhhdCBqdXN0IHVzZSBzeW1ib2xzIGFuZFxyXG4gIC8vIHN0cmluZ3MgYXMga2V5cy4gVGhlIG1hcCBhbmQga2V5cyBhcnJheSBjYW4gYmUgY29uc3RydWN0ZWQgYXRcclxuICAvLyBjb21waWxlIHRpbWUsIHNvIHRoZXkgYXJlIGp1c3QgYWRkZWQgaGVyZSBieSB0aGUgY29uc3RydWN0b3JcclxuICAvLyBmdW5jdGlvbi5cclxuICAvL1xyXG4gIE9wYWwuaGFzaDIgPSBmdW5jdGlvbihrZXlzLCBzbWFwKSB7XHJcbiAgICBjb25zb2xlLndhcm4oXCJERVBSRUNBVElPTjogYE9wYWwuaGFzaDJgIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBPcGFsIDIuMC4gVXNlICRoYXNoX25ldyBmb3IgcHJpbWl0aXZlIGtleXMgb3IgJGhhc2hfbmV3MiBmb3IgY29tcGxleCBrZXlzIGluc3RlYWQuXCIpO1xyXG5cclxuICAgIHZhciBoYXNoID0gbmV3IE1hcCgpO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIG1heCA9IGtleXMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcclxuICAgICAgaGFzaC5zZXQoa2V5c1tpXSwgc21hcFtrZXlzW2ldXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFzaDtcclxuICB9O1xyXG5cclxuICBPcGFsLmhhc2hfZWFjaCA9IGZ1bmN0aW9uIChoYXNoLCBkcmVzLCBmdW4pIHtcclxuICAgIC8vIGRyZXMgPSBkZWZhdWx0IHJlc3VsdCwgcmV0dXJuZWQgaWYgaGFzaCBpcyBlbXB0eVxyXG4gICAgLy8gZnVuIGlzIGNhbGxlZCBhcyBmdW4oa2V5LCB2YWx1ZSkgYW5kIG11c3QgcmV0dXJuIGEgYXJyYXkgd2l0aCBbYnJlYWssIHJlc3VsdF1cclxuICAgIC8vIGlmIGJyZWFrIGlzIHRydWUsIGl0ZXJhdGlvbiBzdG9wcyBhbmQgcmVzdWx0IGlzIHJldHVybmVkXHJcbiAgICAvLyBpZiBicmVhayBpcyBmYWxzZSwgaXRlcmF0aW9uIGNvbnRpbnVlcyBhbmQgZXZlbnR1YWxseSB0aGUgbGFzdCByZXN1bHQgaXMgcmV0dXJuZWRcclxuICAgIHZhciByZXM7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgZW50cnksIGVudHJpZXMgPSBBcnJheS5mcm9tKGhhc2guZW50cmllcygpKSwgbCA9IGVudHJpZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIGVudHJ5ID0gZW50cmllc1tpXTtcclxuICAgICAgcmVzID0gZnVuKGVudHJ5WzBdLCBlbnRyeVsxXSk7XHJcbiAgICAgIGlmIChyZXNbMF0pIHJldHVybiByZXNbMV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzID8gcmVzWzFdIDogZHJlcztcclxuICB9O1xyXG5cclxuICAvLyBDcmVhdGUgYSBuZXcgcmFuZ2UgaW5zdGFuY2Ugd2l0aCBmaXJzdCBhbmQgbGFzdCB2YWx1ZXMsIGFuZCB3aGV0aGVyIHRoZVxyXG4gIC8vIHJhbmdlIGV4Y2x1ZGVzIHRoZSBsYXN0IHZhbHVlLlxyXG4gIC8vXHJcbiAgT3BhbC5yYW5nZSA9IGZ1bmN0aW9uKGZpcnN0LCBsYXN0LCBleGMpIHtcclxuICAgIHZhciByYW5nZSAgICAgICAgID0gbmV3IE9wYWwuUmFuZ2UoKTtcclxuICAgICAgICByYW5nZS5iZWdpbiAgID0gZmlyc3Q7XHJcbiAgICAgICAgcmFuZ2UuZW5kICAgICA9IGxhc3Q7XHJcbiAgICAgICAgcmFuZ2UuZXhjbCAgICA9IGV4YztcclxuXHJcbiAgICByZXR1cm4gcmFuZ2U7XHJcbiAgfTtcclxuXHJcbiAgdmFyIHJlc2VydmVkX2l2YXJfbmFtZXMgPSBbXHJcbiAgICAvLyBwcm9wZXJ0aWVzXHJcbiAgICBcImNvbnN0cnVjdG9yXCIsIFwiZGlzcGxheU5hbWVcIiwgXCJfX2NvdW50X19cIiwgXCJfX25vU3VjaE1ldGhvZF9fXCIsXHJcbiAgICBcIl9fcGFyZW50X19cIiwgXCJfX3Byb3RvX19cIixcclxuICAgIC8vIG1ldGhvZHNcclxuICAgIFwiaGFzT3duUHJvcGVydHlcIiwgXCJ2YWx1ZU9mXCJcclxuICBdO1xyXG5cclxuICAvLyBHZXQgdGhlIGl2YXIgbmFtZSBmb3IgYSBnaXZlbiBuYW1lLlxyXG4gIC8vIE1vc3RseSBhZGRzIGEgdHJhaWxpbmcgJCB0byByZXNlcnZlZCBuYW1lcy5cclxuICAvL1xyXG4gIE9wYWwuaXZhciA9IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgIGlmIChyZXNlcnZlZF9pdmFyX25hbWVzLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XHJcbiAgICAgIG5hbWUgKz0gXCIkXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5hbWU7XHJcbiAgfTtcclxuXHJcbiAgLy8gU3VwcG9ydCBmb3IgI2ZyZWV6ZVxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gaGVscGVyIHRoYXQgY2FuIGJlIHVzZWQgZnJvbSBtZXRob2RzXHJcbiAgZnVuY3Rpb24gJGRlbnlfZnJvemVuX2FjY2VzcyhvYmopIHtcclxuICAgIGlmIChvYmouJCRmcm96ZW4pIHtcclxuICAgICAgJHJhaXNlKE9wYWwuRnJvemVuRXJyb3IsIFwiY2FuJ3QgbW9kaWZ5IGZyb3plbiBcIiArIChvYmouJGNsYXNzKCkpICsgXCI6IFwiICsgKG9iaiksIG5ldyBNYXAoW1tcInJlY2VpdmVyXCIsIG9ial1dKSk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBPcGFsLmRlbnlfZnJvemVuX2FjY2VzcyA9ICRkZW55X2Zyb3plbl9hY2Nlc3M7XHJcblxyXG4gIC8vIGNvbW1vbiAjZnJlZXplIHJ1bnRpbWUgc3VwcG9ydFxyXG4gIE9wYWwuZnJlZXplID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAkcHJvcChvYmosIFwiJCRmcm96ZW5cIiwgdHJ1ZSk7XHJcblxyXG4gICAgLy8gc2V0ICQkaWRcclxuICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KCckJGlkJykpIHsgJHByb3Aob2JqLCAnJCRpZCcsICR1aWQoKSk7IH1cclxuXHJcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KCckJG1ldGEnKSkge1xyXG4gICAgICAvLyBmcmVlemUgJCRtZXRhIGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gc2V0XHJcbiAgICAgIG9iai4kJG1ldGEuJGZyZWV6ZSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gZW5zdXJlICQkbWV0YSBjYW4gYmUgc2V0IGxhemlseSwgJCRtZXRhIGlzIGZyb3plbiB3aGVuIHNldCBpbiBydW50aW1lLmpzXHJcbiAgICAgICRwcm9wKG9iaiwgJyQkbWV0YScsIG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICQkY29tcGFyYWJsZSBpcyB1c2VkIGludGVybmFsbHkgYW5kIHNldCBtdWx0aXBsZSB0aW1lc1xyXG4gICAgLy8gZGVmaW5pbmcgaXQgYmVmb3JlIHNlYWxpbmcgZW5zdXJlcyBpdCBjYW4gYmUgbW9kaWZpZWQgbGF0ZXIgb25cclxuICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KCckJGNvbXBhcmFibGUnKSkgeyAkcHJvcChvYmosICckJGNvbXBhcmFibGUnLCBudWxsKTsgfVxyXG5cclxuICAgIC8vIHNlYWwgdGhlIE9iamVjdFxyXG4gICAgT2JqZWN0LnNlYWwob2JqKTtcclxuXHJcbiAgICByZXR1cm4gb2JqO1xyXG4gIH07XHJcblxyXG4gIC8vIEl0ZXJhdGUgb3ZlciBldmVyeSBpbnN0YW5jZSB2YXJpYWJsZSBhbmQgY2FsbCBmdW5jIGZvciBlYWNoIG9uZVxyXG4gIC8vIGdpdmluZyBuYW1lIG9mIHRoZSBpdmFyIGFuZCBvcHRpb25hbGx5IHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxyXG4gIGZ1bmN0aW9uICRlYWNoX2l2YXIob2JqLCBmdW5jKSB7XHJcbiAgICB2YXIgb3duX3Byb3BzID0gT2JqZWN0LmtleXMob2JqKSwgb3duX3Byb3BzX2xlbmd0aCA9IG93bl9wcm9wcy5sZW5ndGgsIGksIHByb3A7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IG93bl9wcm9wc19sZW5ndGg7IGkrKykge1xyXG4gICAgICBwcm9wID0gb3duX3Byb3BzW2ldO1xyXG5cclxuICAgICAgaWYgKHByb3BbMF0gPT09ICckJykgY29udGludWU7XHJcblxyXG4gICAgICBmdW5jKHByb3ApO1xyXG4gICAgfVxyXG4gIH1cclxuICBPcGFsLmVhY2hfaXZhciA9ICRlYWNoX2l2YXI7XHJcblxyXG4gIC8vIGZyZXplIHByb3BzLCBtYWtlIHNldHRlcnMgb2YgaW5zdGFuY2UgdmFyaWFibGVzIHRocm93IEZyb3plbkVycm9yXHJcbiAgT3BhbC5mcmVlemVfcHJvcHMgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICB2YXIgb3duX3Byb3BzID0gT2JqZWN0LmtleXMob2JqKSwgb3duX3Byb3BzX2xlbmd0aCA9IG93bl9wcm9wcy5sZW5ndGgsIGksIHByb3AsIGRlc2MsXHJcbiAgICAgIGRwX3RlbXBsYXRlID0ge1xyXG4gICAgICAgIGdldDogbnVsbCxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfdmFsKSB7ICRkZW55X2Zyb3plbl9hY2Nlc3Mob2JqKTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXHJcbiAgICAgIH07XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IG93bl9wcm9wc19sZW5ndGg7IGkrKykge1xyXG4gICAgICBwcm9wID0gb3duX3Byb3BzW2ldO1xyXG5cclxuICAgICAgaWYgKHByb3BbMF0gPT09ICckJykgY29udGludWU7XHJcblxyXG4gICAgICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHByb3ApO1xyXG5cclxuICAgICAgaWYgKGRlc2MgJiYgZGVzYy53cml0YWJsZSkge1xyXG4gICAgICAgIGRwX3RlbXBsYXRlLmdldCA9ICRyZXR1cm5fdmFsKGRlc2MudmFsdWUpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIGRwX3RlbXBsYXRlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIFJlZ2V4cHNcclxuICAvLyAtLS0tLS0tXHJcblxyXG4gIC8vIEVzY2FwZSBSZWdleHAgc3BlY2lhbCBjaGFycyBsZXR0aW5nIHRoZSByZXN1bHRpbmcgc3RyaW5nIGJlIHVzZWQgdG8gYnVpbGRcclxuICAvLyBhIG5ldyBSZWdleHAuXHJcbiAgLy9cclxuICBPcGFsLmVzY2FwZV9yZWdleHAgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgIHJldHVybiBPcGFsLmVzY2FwZV9tZXRhY2hhcmFjdGVycyhzdHIucmVwbGFjZSgvKFstW1xcXVxcL3t9KCkqKz8uXiRcXFxcfCBdKS9nLCAnXFxcXCQxJykpXHJcbiAgfTtcclxuXHJcbiAgT3BhbC5lc2NhcGVfbWV0YWNoYXJhY3RlcnMgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvW1xcbl0vZywgJ1xcXFxuJylcclxuICAgICAgICAgICAgICAucmVwbGFjZSgvW1xccl0vZywgJ1xcXFxyJylcclxuICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcZl0vZywgJ1xcXFxmJylcclxuICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcdF0vZywgJ1xcXFx0Jyk7XHJcbiAgfVxyXG5cclxuICAvLyBDcmVhdGUgYSBnbG9iYWwgUmVnZXhwIGZyb20gYSBSZWdFeHAgb2JqZWN0IGFuZCBjYWNoZSB0aGUgcmVzdWx0XHJcbiAgLy8gb24gdGhlIG9iamVjdCBpdHNlbGYgKCQkZyBhdHRyaWJ1dGUpLlxyXG4gIC8vXHJcbiAgT3BhbC5nbG9iYWxfcmVnZXhwID0gZnVuY3Rpb24ocGF0dGVybikge1xyXG4gICAgaWYgKHBhdHRlcm4uZ2xvYmFsKSB7XHJcbiAgICAgIHJldHVybiBwYXR0ZXJuOyAvLyBSZWdFeHAgYWxyZWFkeSBoYXMgdGhlIGdsb2JhbCBmbGFnXHJcbiAgICB9XHJcbiAgICBpZiAocGF0dGVybi4kJGcgPT0gbnVsbCkge1xyXG4gICAgICBwYXR0ZXJuLiQkZyA9IG5ldyBSZWdFeHAocGF0dGVybi5zb3VyY2UsICdnJyArIHBhdHRlcm4uZmxhZ3MpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcGF0dGVybi4kJGcubGFzdEluZGV4ID0gbnVsbDsgLy8gcmVzZXQgbGFzdEluZGV4IHByb3BlcnR5XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF0dGVybi4kJGc7XHJcbiAgfTtcclxuXHJcbiAgLy8gVHJhbnNmb3JtIGEgcmVndWxhciBleHByZXNzaW9uIGZyb20gUnVieSBzeW50YXggdG8gSlMgc3ludGF4LlxyXG4gIE9wYWwudHJhbnNmb3JtX3JlZ2V4cCA9IGZ1bmN0aW9uKHJlZ2V4cCwgZmxhZ3MpIHtcclxuICAgIHJldHVybiBPcGFsLk9wYWwuUmVnZXhwVHJhbnNwaWxlci4kdHJhbnNmb3JtX3JlZ2V4cChyZWdleHAsIGZsYWdzKTtcclxuICB9O1xyXG5cclxuICAvLyBDb21iaW5lIG11bHRpcGxlIHJlZ2V4cCBwYXJ0cyB0b2dldGhlclxyXG4gIE9wYWwucmVnZXhwID0gZnVuY3Rpb24ocGFydHMsIGZsYWdzKSB7XHJcbiAgICB2YXIgcGFydDtcclxuXHJcbiAgICBpZiAoZmxhZ3MgPT0gbnVsbCkgZmxhZ3MgPSAnJztcclxuXHJcbiAgICB2YXIgaWdub3JlQ2FzZSA9IGZsYWdzLmluY2x1ZGVzKCdpJyk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGFydHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xyXG4gICAgICBwYXJ0ID0gcGFydHNbaV07XHJcbiAgICAgIGlmIChwYXJ0IGluc3RhbmNlb2YgUmVnRXhwKSB7XHJcbiAgICAgICAgaWYgKHBhcnQuaWdub3JlQ2FzZSAhPT0gaWdub3JlQ2FzZSlcclxuICAgICAgICAgIE9wYWwuS2VybmVsLiR3YXJuKFxyXG4gICAgICAgICAgICBcImlnbm9yZSBjYXNlIGRvZXNuJ3QgbWF0Y2ggZm9yIFwiICsgcGFydC5zb3VyY2UuJGluc3BlY3QoKSxcclxuICAgICAgICAgICAgbmV3IE1hcChbWyd1cGxldmVsJywgIDFdXSlcclxuICAgICAgICAgIClcclxuXHJcbiAgICAgICAgcGFydCA9IHBhcnQuJCRzb3VyY2UgIT0gbnVsbCA/IHBhcnQuJCRzb3VyY2UgOiBwYXJ0LnNvdXJjZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocGFydCA9PSAnJykgcGFydCA9ICcoPzopJztcclxuICAgICAgcGFydHNbaV0gPSBwYXJ0O1xyXG4gICAgfVxyXG5cclxuICAgIHBhcnRzID0gcGFydHMuam9pbignJyk7XHJcbiAgICBwYXJ0cyA9IE9wYWwuZXNjYXBlX21ldGFjaGFyYWN0ZXJzKHBhcnRzKTtcclxuXHJcbiAgICB2YXIgb3V0cHV0ID0gT3BhbC50cmFuc2Zvcm1fcmVnZXhwKHBhcnRzLCBmbGFncyk7XHJcblxyXG4gICAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAob3V0cHV0WzBdLCBvdXRwdXRbMV0pO1xyXG4gICAgaWYgKHBhcnRzICE9IG91dHB1dFswXSkgcmVnZXhwLiQkc291cmNlID0gcGFydHNcclxuICAgIGlmIChmbGFncyAhPSBvdXRwdXRbMV0pIHJlZ2V4cC4kJG9wdGlvbnMgPSBmbGFncztcclxuICAgIHJldHVybiByZWdleHA7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmVnZXhwIGhhcyBiZWVuIHRyYW5zZm9ybWVkLCBzbyBsZXQncyBhbm5vdGF0ZSB0aGUgb3JpZ2luYWwgcmVnZXhwXHJcbiAgT3BhbC5hbm5vdGF0ZV9yZWdleHAgPSBmdW5jdGlvbihyZWdleHAsIHNvdXJjZSwgb3B0aW9ucykge1xyXG4gICAgcmVnZXhwLiQkc291cmNlID0gc291cmNlO1xyXG4gICAgcmVnZXhwLiQkb3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICByZXR1cm4gcmVnZXhwO1xyXG4gIH1cclxuXHJcbiAgLy8gQW5ub3RhdGVkIGVtcHR5IHJlZ2V4cFxyXG4gIE9wYWwuZW1wdHlfcmVnZXhwID0gZnVuY3Rpb24oZmxhZ3MpIHtcclxuICAgIHJldHVybiBPcGFsLmFubm90YXRlX3JlZ2V4cChuZXcgUmVnRXhwKC8oPzopLywgZmxhZ3MpLCAnJyk7XHJcbiAgfVxyXG5cclxuICAvLyBSZXF1aXJlIHN5c3RlbVxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIE9wYWwubW9kdWxlcyAgICAgICAgID0ge307XHJcbiAgT3BhbC5sb2FkZWRfZmVhdHVyZXMgPSBbJ2NvcmVsaWIvcnVudGltZSddO1xyXG4gIE9wYWwuY3VycmVudF9kaXIgICAgID0gJy4nO1xyXG4gIE9wYWwucmVxdWlyZV90YWJsZSAgID0geydjb3JlbGliL3J1bnRpbWUnOiB0cnVlfTtcclxuXHJcbiAgT3BhbC5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XHJcbiAgICB2YXIgcGFydHMsIHBhcnQsIG5ld19wYXJ0cyA9IFtdLCBTRVBBUkFUT1IgPSAnLyc7XHJcblxyXG4gICAgaWYgKE9wYWwuY3VycmVudF9kaXIgIT09ICcuJykge1xyXG4gICAgICBwYXRoID0gT3BhbC5jdXJyZW50X2Rpci5yZXBsYWNlKC9cXC8qJC8sICcvJykgKyBwYXRoO1xyXG4gICAgfVxyXG5cclxuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL15cXC5cXC8vLCAnJyk7XHJcbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC4ocmJ8b3BhbHxqcykkLywgJycpO1xyXG4gICAgcGFydHMgPSBwYXRoLnNwbGl0KFNFUEFSQVRPUik7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGFydHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xyXG4gICAgICBwYXJ0ID0gcGFydHNbaV07XHJcbiAgICAgIGlmIChwYXJ0ID09PSAnJykgY29udGludWU7XHJcbiAgICAgIChwYXJ0ID09PSAnLi4nKSA/IG5ld19wYXJ0cy5wb3AoKSA6IG5ld19wYXJ0cy5wdXNoKHBhcnQpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ld19wYXJ0cy5qb2luKFNFUEFSQVRPUik7XHJcbiAgfTtcclxuXHJcbiAgT3BhbC5sb2FkZWQgPSBmdW5jdGlvbihwYXRocykge1xyXG4gICAgdmFyIGksIGwsIHBhdGg7XHJcblxyXG4gICAgZm9yIChpID0gMCwgbCA9IHBhdGhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICBwYXRoID0gT3BhbC5ub3JtYWxpemUocGF0aHNbaV0pO1xyXG5cclxuICAgICAgaWYgKE9wYWwucmVxdWlyZV90YWJsZVtwYXRoXSkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBPcGFsLmxvYWRlZF9mZWF0dXJlcy5wdXNoKHBhdGgpO1xyXG4gICAgICBPcGFsLnJlcXVpcmVfdGFibGVbcGF0aF0gPSB0cnVlO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIE9wYWwubG9hZF9ub3JtYWxpemVkID0gZnVuY3Rpb24ocGF0aCkge1xyXG4gICAgT3BhbC5sb2FkZWQoW3BhdGhdKTtcclxuXHJcbiAgICB2YXIgbW9kdWxlID0gT3BhbC5tb2R1bGVzW3BhdGhdO1xyXG5cclxuICAgIGlmIChtb2R1bGUpIHtcclxuICAgICAgdmFyIHJldHZhbCA9IG1vZHVsZShPcGFsKTtcclxuICAgICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiByZXR2YWwgaW5zdGFuY2VvZiBQcm9taXNlKSB7XHJcbiAgICAgICAgLy8gQSBzcGVjaWFsIGNhc2Ugb2YgcmVxdWlyZSBoYXZpbmcgYW4gYXN5bmMgdG9wOlxyXG4gICAgICAgIC8vIFdlIHdpbGwgbmVlZCB0byBhd2FpdCBpdC5cclxuICAgICAgICByZXR1cm4gcmV0dmFsLnRoZW4oJHJldHVybl92YWwodHJ1ZSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgdmFyIHNldmVyaXR5ID0gT3BhbC5jb25maWcubWlzc2luZ19yZXF1aXJlX3NldmVyaXR5O1xyXG4gICAgICB2YXIgbWVzc2FnZSAgPSAnY2Fubm90IGxvYWQgc3VjaCBmaWxlIC0tICcgKyBwYXRoO1xyXG5cclxuICAgICAgaWYgKHNldmVyaXR5ID09PSBcImVycm9yXCIpIHtcclxuICAgICAgICAkcmFpc2UoT3BhbC5Mb2FkRXJyb3IsIG1lc3NhZ2UpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKHNldmVyaXR5ID09PSBcIndhcm5pbmdcIikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogTG9hZEVycm9yOiAnICsgbWVzc2FnZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9O1xyXG5cclxuICBPcGFsLmxvYWQgPSBmdW5jdGlvbihwYXRoKSB7XHJcbiAgICBwYXRoID0gT3BhbC5ub3JtYWxpemUocGF0aCk7XHJcblxyXG4gICAgcmV0dXJuIE9wYWwubG9hZF9ub3JtYWxpemVkKHBhdGgpO1xyXG4gIH07XHJcblxyXG4gIE9wYWwucmVxdWlyZSA9IGZ1bmN0aW9uKHBhdGgpIHtcclxuICAgIHBhdGggPSBPcGFsLm5vcm1hbGl6ZShwYXRoKTtcclxuXHJcbiAgICBpZiAoT3BhbC5yZXF1aXJlX3RhYmxlW3BhdGhdKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gT3BhbC5sb2FkX25vcm1hbGl6ZWQocGF0aCk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8vIFN0cmluZ3NcclxuICAvLyAtLS0tLS0tXHJcblxyXG4gIC8vIEByZXR1cm5zIGEgZnVuY3Rpb24gcHJveHkgZm9yIGFsbCBzb3J0cyBvZiBTdHJpbmcgZnVuY3Rpb25zXHJcbiAgZnVuY3Rpb24gc3RyaW5nX2Z1bl9wcm94eSh0YXJnZXRfc3RyLCB0YXJnZXRfZnVuLCBzdHJfcHJveHkpIHtcclxuICAgIHJldHVybiBuZXcgUHJveHkodGFyZ2V0X2Z1biwge1xyXG4gICAgICBhcHBseSh0cmd0LCBfdGhpc0FyZywgYXJncykge1xyXG4gICAgICAgIGxldCByZXMgPSB0cmd0LmFwcGx5KHRhcmdldF9zdHIsIGFyZ3MpO1xyXG4gICAgICAgIGlmIChyZXMgPT09IHRhcmdldF9zdHIgfHwgcmVzID09PSBzdHJfcHJveHkpIHJldHVybiBzdHJfcHJveHk7XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mKHJlcykgPT09ICdzdHJpbmcnKSByZXR1cm4gJHN0cihyZXMpO1xyXG4gICAgICAgIGVsc2UgaWYgKHJlcyAhPSBudWxsICYmIHR5cGVvZihyZXMpID09PSAnb2JqZWN0JyAmJiByZXMuJCRpc19zdHJpbmcpIHJldHVybiAkc3RyKHJlcy50b1N0cmluZygpKTtcclxuICAgICAgICBlbHNlIHJldHVybiByZXM7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gQHJldHVybnMgYSBmdW5jdGlvbiBwcm94eSB0aGF0IHJldHVybnMgdGhlIHJlc3VsdCAncmF3JywgdXNlZmV1bCBmb3IgU3RyaW5nLnRvU3RyaW5nXHJcbiAgZnVuY3Rpb24gc3RyaW5nX3Jhd19mdW5fcHJveHkodGFyZ2V0X3N0ciwgdGFyZ2V0X2Z1bikge1xyXG4gICAgcmV0dXJuIG5ldyBQcm94eSh0YXJnZXRfZnVuLCB7XHJcbiAgICAgIGFwcGx5KHRyZ3QsIF90aGlzQXJnLCBhcmdzKSB7IHJldHVybiB0cmd0LmFwcGx5KHRhcmdldF9zdHIsIGFyZ3MpOyB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHN0cl9wcm9wX2lzX2Z1bihzdHIsIHByb3ApIHtcclxuICAgIHJldHVybiAodHlwZW9mIHN0cltwcm9wXSA9PT0gJ2Z1bmN0aW9uJyAmJiBzdHJbcHJvcF0uY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uKTtcclxuICB9XHJcblxyXG4gIGxldCBzdHJpbmdfcHJveHlfaGFuZGxlciA9IHtcclxuICAgIGdldDogZnVuY3Rpb24odGFyZ2V0X3N0ciwgcHJvcCwgc3RyX3Byb3h5KSB7XHJcbiAgICAgIGlmICh0YXJnZXRfc3RyLiQkc3RyaW5nKSB7XHJcbiAgICAgICAgLy8gY2F1Z2h0IGEgbXV0YXRlZCBTdHJpbmdcclxuICAgICAgICBpZiAocHJvcCA9PT0gU3ltYm9sLnRvUHJpbWl0aXZlIHx8IHByb3AgPT09ICd0b1N0cmluZycgfHwgcHJvcCA9PT0gJ3ZhbHVlT2YnKSB7XHJcbiAgICAgICAgICAvLyBzcGVjaWFsIGNhc2VzLCBkbyBub3QgYm94IHRoZSByZXN1bHRcclxuICAgICAgICAgIHJldHVybiBzdHJpbmdfcmF3X2Z1bl9wcm94eSh0YXJnZXRfc3RyLiQkc3RyaW5nLCB0YXJnZXRfc3RyLiQkc3RyaW5nWyd0b1N0cmluZyddKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHByb3BbMF0gPT09ICckJyAmJiBwcm9wWzFdICE9PSAnJCcgJiYgc3RyX3Byb3BfaXNfZnVuKHRhcmdldF9zdHIsIHByb3ApKSB7XHJcbiAgICAgICAgICAvLyBhIFJ1YnkgbWV0aG9kLCBhcHBseSB0byBvdXRlciBTdHJpbmcgb2JqZWN0XHJcbiAgICAgICAgICByZXR1cm4gc3RyaW5nX2Z1bl9wcm94eSh0YXJnZXRfc3RyLCB0YXJnZXRfc3RyW3Byb3BdLCBzdHJfcHJveHkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc3RyX3Byb3BfaXNfZnVuKHRhcmdldF9zdHIsIHByb3ApKSB7XHJcbiAgICAgICAgICAvLyBhIEpTIFN0cmluZyBmdW5jdGlvbiwgYXBwbHkgaXQgdG8gbXV0YXRlZCBTdHJpbmcgcHJpbWl0aXZlXHJcbiAgICAgICAgICByZXR1cm4gc3RyaW5nX2Z1bl9wcm94eSh0YXJnZXRfc3RyLiQkc3RyaW5nLCB0YXJnZXRfc3RyLiQkc3RyaW5nW3Byb3BdLCBzdHJfcHJveHkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gJ2xlbmd0aCcpIHtcclxuICAgICAgICAgIC8vIHJldHVybiB0aGUgbXV0YXRlZCBTdHJpbmcgcHJpbWl0aXZlcyBsZW5ndGhcclxuICAgICAgICAgIHJldHVybiB0YXJnZXRfc3RyLiQkc3RyaW5nLmxlbmd0aDtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihwcm9wKSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgIC8vIGEgaW5kZXggYWNjZXNzLCBhcHBseSB0byBtdXRhdGVkIFN0cmluZ1xyXG4gICAgICAgICAgcmV0dXJuIHRhcmdldF9zdHIuJCRzdHJpbmdbcHJvcF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIG90aGVyd2lzZSByZXR1cm4gcHJvcGVydHkgb2Ygb3V0ZXIgU3RyaW5nIG9iamVjdCwgZS5nLiBlbmNvZGluZ1xyXG4gICAgICAgICAgcmV0dXJuIHRhcmdldF9zdHJbcHJvcF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGNhdWdodCBhIG5vcm1hbCBTdHJpbmdcclxuICAgICAgICBpZiAocHJvcCA9PT0gU3ltYm9sLnRvUHJpbWl0aXZlIHx8IHByb3AgPT09ICd0b1N0cmluZycgfHwgcHJvcCA9PT0gJ3ZhbHVlT2YnKSB7XHJcbiAgICAgICAgICAvLyBzcGVjaWFsIGNhc2VzLCBkbyBub3QgYm94IHRoZSByZXN1bHRcclxuICAgICAgICAgIHJldHVybiBzdHJpbmdfcmF3X2Z1bl9wcm94eSh0YXJnZXRfc3RyLCB0YXJnZXRfc3RyWyd0b1N0cmluZyddKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHN0cl9wcm9wX2lzX2Z1bih0YXJnZXRfc3RyLCBwcm9wKSkge1xyXG4gICAgICAgICAgLy8gYXBwbHkgYW55IG1ldGhvZCBkaXJlY3RseVxyXG4gICAgICAgICAgcmV0dXJuIHN0cmluZ19mdW5fcHJveHkodGFyZ2V0X3N0ciwgdGFyZ2V0X3N0cltwcm9wXSwgc3RyX3Byb3h5KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gYXBwbHkgYW55IHByb3AgZGlyZWN0bHlcclxuICAgICAgICAgIHJldHVybiB0YXJnZXRfc3RyW3Byb3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQHJldHVybnMgYSBuZXcgU3RyaW5nIG9iamVjdCwgcHJveGllZCBhbmQgbXV0YWJsZS5cclxuICBmdW5jdGlvbiAkc3RyKHN0cmluZykge1xyXG4gICAgcmV0dXJuIG5ldyBQcm94eShuZXcgU3RyaW5nKHN0cmluZyksIHN0cmluZ19wcm94eV9oYW5kbGVyKTtcclxuICB9XHJcblxyXG4gIE9wYWwuc3RyID0gJHN0cjtcclxuXHJcbiAgLy8gQHJldHVybnMgYSBuZXcgU3RyaW5nIG9iamVjdCB3aXRoIGVuY29kaW5nIHNldCwgcHJveGllZCBhbmQgbXV0YWJsZS5cclxuICBPcGFsLnN0cl93aXRoX2VuYyA9IGZ1bmN0aW9uKHN0ciwgZW5jb2RpbmcpIHtcclxuICAgIHN0ciA9IE9wYWwuc2V0X2VuY29kaW5nKCRzdHIoc3RyKSwgZW5jb2RpbmcpO1xyXG4gICAgc3RyLmludGVybmFsX2VuY29kaW5nID0gc3RyLmVuY29kaW5nO1xyXG4gICAgcmV0dXJuIHN0cjtcclxuICB9XHJcblxyXG4gIE9wYWwuZW5jb2RpbmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuXHJcbiAgLy8gU2V0cyB0aGUgZW5jb2Rpbmcgb24gYSBzdHJpbmcsIHdpbGwgdHJlYXQgc3RyaW5nIGxpdGVyYWxzIGFzIGZyb3plbiBzdHJpbmdzXHJcbiAgLy8gcmFpc2luZyBhIEZyb3plbkVycm9yLlxyXG4gIC8vXHJcbiAgLy8gQHBhcmFtIHN0ciBbU3RyaW5nXSB0aGUgc3RyaW5nIG9uIHdoaWNoIHRoZSBlbmNvZGluZyBzaG91bGQgYmUgc2V0XHJcbiAgLy8gQHBhcmFtIG5hbWUgW1N0cmluZ10gdGhlIGNhbm9uaWNhbCBuYW1lIG9mIHRoZSBlbmNvZGluZ1xyXG4gIC8vIEBwYXJhbSB0eXBlIFtTdHJpbmddIHBvc3NpYmxlIHZhbHVlcyBhcmUgZWl0aGVyIGBcImVuY29kaW5nXCJgLCBgXCJpbnRlcm5hbF9lbmNvZGluZ1wiYCwgb3IgYHVuZGVmaW5lZFxyXG4gIE9wYWwuc2V0X2VuY29kaW5nID0gZnVuY3Rpb24oc3RyLCBuYW1lLCB0eXBlKSB7XHJcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHR5cGUgPSBcImVuY29kaW5nXCI7XHJcbiAgICBpZiAodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgfHwgc3RyLiQkZnJvemVuID09PSB0cnVlKVxyXG4gICAgICAkcmFpc2UoT3BhbC5Gcm96ZW5FcnJvciwgXCJjYW4ndCBtb2RpZnkgZnJvemVuIFN0cmluZ1wiKTtcclxuXHJcbiAgICB2YXIgZW5jb2RpbmcgPSBPcGFsLmZpbmRfZW5jb2RpbmcobmFtZSk7XHJcblxyXG4gICAgaWYgKGVuY29kaW5nID09PSBzdHJbdHlwZV0pIHsgcmV0dXJuIHN0cjsgfVxyXG5cclxuICAgIHN0clt0eXBlXSA9IGVuY29kaW5nO1xyXG5cclxuICAgIHJldHVybiBzdHI7XHJcbiAgfTtcclxuXHJcbiAgLy8gRmV0Y2hlcyB0aGUgZW5jb2RpbmcgZm9yIHRoZSBnaXZlbiBuYW1lIG9yIHJhaXNlcyBBcmd1bWVudEVycm9yLlxyXG4gIE9wYWwuZmluZF9lbmNvZGluZyA9IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgIHZhciByZWdpc3RlciA9IE9wYWwuZW5jb2RpbmdzO1xyXG4gICAgdmFyIGVuY29kaW5nID0gcmVnaXN0ZXJbbmFtZV0gfHwgcmVnaXN0ZXJbbmFtZS50b1VwcGVyQ2FzZSgpXTtcclxuICAgIGlmICghZW5jb2RpbmcpICRyYWlzZShPcGFsLkFyZ3VtZW50RXJyb3IsIFwidW5rbm93biBlbmNvZGluZyBuYW1lIC0gXCIgKyBuYW1lKTtcclxuICAgIHJldHVybiBlbmNvZGluZztcclxuICB9XHJcblxyXG4gIC8vIEByZXR1cm5zIGEgU3RyaW5nIG9iamVjdCB3aXRoIHRoZSBlbmNvZGluZyBzZXQgZnJvbSBhIHN0cmluZyBsaXRlcmFsXHJcbiAgT3BhbC5lbmMgPSBmdW5jdGlvbihzdHIsIG5hbWUpIHtcclxuICAgIHZhciBkdXAgPSAkc3RyKHN0cik7XHJcbiAgICBkdXAgPSBPcGFsLnNldF9lbmNvZGluZyhkdXAsIG5hbWUpO1xyXG4gICAgZHVwLmludGVybmFsX2VuY29kaW5nID0gZHVwLmVuY29kaW5nO1xyXG4gICAgcmV0dXJuIGR1cFxyXG4gIH1cclxuXHJcbiAgLy8gQHJldHVybnMgYSBTdHJpbmcgb2JqZWN0IHdpdGggdGhlIGludGVybmFsIGVuY29kaW5nIHNldCB0byBCaW5hcnlcclxuICBPcGFsLmJpbmFyeSA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgdmFyIGR1cCA9ICRzdHIoc3RyKTtcclxuICAgIHJldHVybiBPcGFsLnNldF9lbmNvZGluZyhkdXAsIFwiYmluYXJ5XCIsIFwiaW50ZXJuYWxfZW5jb2RpbmdcIik7XHJcbiAgfVxyXG5cclxuICBPcGFsLmZhbGxiYWNrX3RvX3MgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHJldHVybiBgIzwke29iai4kJGNsYXNzLiR0b19zKCl9OjB4JHtPcGFsLmlkKG9iaikudG9TdHJpbmcoMTYpfT5gXHJcbiAgfVxyXG5cclxuICBPcGFsLnRvX3MgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHZhciBzdHJpbmdpZmllZDtcclxuICAgIGlmIChvYmogPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gXCJgXCIrU3RyaW5nKG9iaikrXCJgXCI7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJyB8fCAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqLiQkaXNfc3RyaW5nKSkge1xyXG4gICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob2JqLiR0b19zICE9IG51bGwgJiYgIW9iai4kdG9fcy4kJHN0dWIpIHtcclxuICAgICAgc3RyaW5naWZpZWQgPSBvYmouJHRvX3MoKTtcclxuICAgICAgaWYgKHR5cGVvZiBzdHJpbmdpZmllZCAhPT0gJ3N0cmluZycgJiYgIXN0cmluZ2lmaWVkLiQkaXNfc3RyaW5nKSB7XHJcbiAgICAgICAgc3RyaW5naWZpZWQgPSBPcGFsLmZhbGxiYWNrX3RvX3Mob2JqKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc3RyaW5naWZpZWQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgcmV0dXJuIG9iai50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgT3BhbC5sYXN0X3Byb21pc2UgPSBudWxsO1xyXG4gIE9wYWwucHJvbWlzZV91bmhhbmRsZWRfZXhjZXB0aW9uID0gZmFsc2U7XHJcblxyXG4gIC8vIFF1ZXVlXHJcbiAgLy8gLS0tLS1cclxuXHJcbiAgLy8gUnVuIGEgYmxvY2sgb2YgY29kZSwgYnV0IGlmIGl0IHJldHVybnMgYSBQcm9taXNlLCBkb24ndCBydW4gdGhlIG5leHRcclxuICAvLyBvbmUsIGJ1dCBxdWV1ZSBpdC5cclxuICBPcGFsLnF1ZXVlID0gZnVuY3Rpb24ocHJvYykge1xyXG4gICAgaWYgKE9wYWwubGFzdF9wcm9taXNlKSB7XHJcbiAgICAgIC8vIFRoZSBhc3luYyBwYXRoIGlzIHRha2VuIG9ubHkgaWYgYW55dGhpbmcgYmVmb3JlIHJldHVybmVkIGFcclxuICAgICAgLy8gUHJvbWlzZShWMikuXHJcbiAgICAgIE9wYWwubGFzdF9wcm9taXNlID0gT3BhbC5sYXN0X3Byb21pc2UudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIU9wYWwucHJvbWlzZV91bmhhbmRsZWRfZXhjZXB0aW9uKSByZXR1cm4gcHJvYyhPcGFsKTtcclxuICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24oZXJyb3IpIHtcclxuICAgICAgICBpZiAoT3BhbC5yZXNwb25kX3RvKGVycm9yLCAnJGZ1bGxfbWVzc2FnZScpKSB7XHJcbiAgICAgICAgICBlcnJvciA9IGVycm9yLiRmdWxsX21lc3NhZ2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgLy8gQWJvcnQgZnVydGhlciBleGVjdXRpb25cclxuICAgICAgICBPcGFsLnByb21pc2VfdW5oYW5kbGVkX2V4Y2VwdGlvbiA9IHRydWU7XHJcbiAgICAgICAgT3BhbC5leGl0KDEpO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIE9wYWwubGFzdF9wcm9taXNlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHZhciByZXQgPSBwcm9jKE9wYWwpO1xyXG4gICAgICBpZiAodHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHJldCA9PT0gJ29iamVjdCcgJiYgcmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xyXG4gICAgICAgIE9wYWwubGFzdF9wcm9taXNlID0gcmV0O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBPcGVyYXRvciBoZWxwZXJzXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICBmdW5jdGlvbiBhcmVfYm90aF9udW1iZXJzKGwscikgeyByZXR1cm4gdHlwZW9mKGwpID09PSAnbnVtYmVyJyAmJiB0eXBlb2YocikgPT09ICdudW1iZXInIH1cclxuXHJcbiAgT3BhbC5yYl9wbHVzICAgPSBmdW5jdGlvbihsLHIpIHsgcmV0dXJuIGFyZV9ib3RoX251bWJlcnMobCxyKSA/IGwgKyByIDogbFsnJCsnXShyKTsgfVxyXG4gIE9wYWwucmJfbWludXMgID0gZnVuY3Rpb24obCxyKSB7IHJldHVybiBhcmVfYm90aF9udW1iZXJzKGwscikgPyBsIC0gciA6IGxbJyQtJ10ocik7IH1cclxuICBPcGFsLnJiX3RpbWVzICA9IGZ1bmN0aW9uKGwscikgeyByZXR1cm4gYXJlX2JvdGhfbnVtYmVycyhsLHIpID8gbCAqIHIgOiBsWyckKiddKHIpOyB9XHJcbiAgT3BhbC5yYl9kaXZpZGUgPSBmdW5jdGlvbihsLHIpIHsgcmV0dXJuIGFyZV9ib3RoX251bWJlcnMobCxyKSA/IGwgLyByIDogbFsnJC8nXShyKTsgfVxyXG4gIE9wYWwucmJfbHQgICAgID0gZnVuY3Rpb24obCxyKSB7IHJldHVybiBhcmVfYm90aF9udW1iZXJzKGwscikgPyBsIDwgciA6IGxbJyQ8J10ocik7IH1cclxuICBPcGFsLnJiX2d0ICAgICA9IGZ1bmN0aW9uKGwscikgeyByZXR1cm4gYXJlX2JvdGhfbnVtYmVycyhsLHIpID8gbCA+IHIgOiBsWyckPiddKHIpOyB9XHJcbiAgT3BhbC5yYl9sZSAgICAgPSBmdW5jdGlvbihsLHIpIHsgcmV0dXJuIGFyZV9ib3RoX251bWJlcnMobCxyKSA/IGwgPD0gciA6IGxbJyQ8PSddKHIpOyB9XHJcbiAgT3BhbC5yYl9nZSAgICAgPSBmdW5jdGlvbihsLHIpIHsgcmV0dXJuIGFyZV9ib3RoX251bWJlcnMobCxyKSA/IGwgPj0gciA6IGxbJyQ+PSddKHIpOyB9XHJcblxyXG4gIC8vIE9wdGltaXplZCBoZWxwZXJzIGZvciBjYWxscyBsaWtlICR0cnV0aHkoKGEpWyckPT09J10oYikpIC0+ICRlcWVxZXEoYSwgYilcclxuICBmdW5jdGlvbiBhcmVfYm90aF9udW1iZXJzX29yX3N0cmluZ3MobGhzLCByaHMpIHtcclxuICAgIHJldHVybiAodHlwZW9mIGxocyA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHJocyA9PT0gJ251bWJlcicpIHx8XHJcbiAgICAgICAgICAgKHR5cGVvZiBsaHMgPT09ICdzdHJpbmcnICYmIHR5cGVvZiByaHMgPT09ICdzdHJpbmcnKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uICRlcWVxKGxocywgcmhzKSB7XHJcbiAgICByZXR1cm4gYXJlX2JvdGhfbnVtYmVyc19vcl9zdHJpbmdzKGxocyxyaHMpID8gbGhzID09PSByaHMgOiAkdHJ1dGh5KChsaHMpWyckPT0nXShyaHMpKTtcclxuICB9O1xyXG4gIE9wYWwuZXFlcSA9ICRlcWVxO1xyXG4gIE9wYWwuZXFlcWVxID0gZnVuY3Rpb24obGhzLCByaHMpIHtcclxuICAgIHJldHVybiBhcmVfYm90aF9udW1iZXJzX29yX3N0cmluZ3MobGhzLHJocykgPyBsaHMgPT09IHJocyA6ICR0cnV0aHkoKGxocylbJyQ9PT0nXShyaHMpKTtcclxuICB9O1xyXG4gIE9wYWwubmVxZXEgPSBmdW5jdGlvbihsaHMsIHJocykge1xyXG4gICAgcmV0dXJuIGFyZV9ib3RoX251bWJlcnNfb3Jfc3RyaW5ncyhsaHMscmhzKSA/IGxocyAhPT0gcmhzIDogJHRydXRoeSgobGhzKVsnJCE9J10ocmhzKSk7XHJcbiAgfTtcclxuICBPcGFsLm5vdCA9IGZ1bmN0aW9uKGFyZykge1xyXG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gYXJnIHx8IG51bGwgPT09IGFyZyB8fCBmYWxzZSA9PT0gYXJnIHx8IG5pbCA9PT0gYXJnKSByZXR1cm4gdHJ1ZTtcclxuICAgIGlmICh0cnVlID09PSBhcmcgfHwgYXJnWyckISddLiQkcHJpc3RpbmUpIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiAkdHJ1dGh5KGFyZ1snJCEnXSgpKTtcclxuICB9XHJcblxyXG4gIC8vIFNob3J0Y3V0cyAtIG9wdGltaXplZCBmdW5jdGlvbiBnZW5lcmF0b3JzIGZvciBzaW1wbGUga2luZHMgb2YgZnVuY3Rpb25zXHJcbiAgZnVuY3Rpb24gJHJldHVybl92YWwoYXJnKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBhcmc7XHJcbiAgICB9XHJcbiAgfVxyXG4gIE9wYWwucmV0dXJuX3ZhbCA9ICRyZXR1cm5fdmFsO1xyXG5cclxuICBPcGFsLnJldHVybl9zZWxmID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbiAgT3BhbC5yZXR1cm5faXZhciA9IGZ1bmN0aW9uKGl2YXIpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKHRoaXNbaXZhcl0gPT0gbnVsbCkgeyByZXR1cm4gbmlsOyB9XHJcbiAgICAgIHJldHVybiB0aGlzW2l2YXJdO1xyXG4gICAgfVxyXG4gIH1cclxuICBPcGFsLmFzc2lnbl9pdmFyID0gZnVuY3Rpb24oaXZhcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbCkge1xyXG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHRoaXMpO1xyXG4gICAgICByZXR1cm4gdGhpc1tpdmFyXSA9IHZhbDtcclxuICAgIH1cclxuICB9XHJcbiAgT3BhbC5hc3NpZ25faXZhcl92YWwgPSBmdW5jdGlvbihpdmFyLCBzdGF0aWNfdmFsKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3ModGhpcyk7XHJcbiAgICAgIHJldHVybiB0aGlzW2l2YXJdID0gc3RhdGljX3ZhbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFByaW1pdGl2ZXMgZm9yIGhhbmRsaW5nIHBhcmFtZXRlcnNcclxuICBPcGFsLmVuc3VyZV9rd2FyZ3MgPSBmdW5jdGlvbihrd2FyZ3MpIHtcclxuICAgIGlmIChrd2FyZ3MgPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gbmV3IE1hcCgpO1xyXG4gICAgfSBlbHNlIGlmIChrd2FyZ3MuJCRpc19oYXNoKSB7XHJcbiAgICAgIHJldHVybiBrd2FyZ3M7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAkcmFpc2UoT3BhbC5Bcmd1bWVudEVycm9yLCAnZXhwZWN0ZWQga3dhcmdzJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBPcGFsLmdldF9rd2FyZyA9IGZ1bmN0aW9uKGt3YXJncywga2V5KSB7XHJcbiAgICB2YXIga3dhcmcgPSBPcGFsLmhhc2hfZ2V0KGt3YXJncywga2V5KTtcclxuICAgIGlmIChrd2FyZyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICRyYWlzZShPcGFsLkFyZ3VtZW50RXJyb3IsICdtaXNzaW5nIGtleXdvcmQ6ICcra2V5KTtcclxuICAgIH1cclxuICAgIHJldHVybiBrd2FyZztcclxuICB9XHJcblxyXG4gIC8vIEFycmF5cyBvZiBzaXplID4gMzIgZWxlbWVudHMgdGhhdCBjb250YWluIG9ubHkgc3RyaW5ncyxcclxuICAvLyBzeW1ib2xzLCBpbnRlZ2VycyBhbmQgbmlscyBhcmUgY29tcGlsZWQgYXMgYSBzZWxmLWV4dHJhY3RpbmdcclxuICAvLyBzdHJpbmcuXHJcbiAgT3BhbC5sYXJnZV9hcnJheV91bnBhY2sgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgIHZhciBhcnJheSA9IHN0ci5zcGxpdChcIixcIiksIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCwgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICBzd2l0Y2goYXJyYXlbaV1bMF0pIHtcclxuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcclxuICAgICAgICAgIGFycmF5W2ldID0gbmlsXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICctJzpcclxuICAgICAgICBjYXNlICcwJzpcclxuICAgICAgICBjYXNlICcxJzpcclxuICAgICAgICBjYXNlICcyJzpcclxuICAgICAgICBjYXNlICczJzpcclxuICAgICAgICBjYXNlICc0JzpcclxuICAgICAgICBjYXNlICc1JzpcclxuICAgICAgICBjYXNlICc2JzpcclxuICAgICAgICBjYXNlICc3JzpcclxuICAgICAgICBjYXNlICc4JzpcclxuICAgICAgICBjYXNlICc5JzpcclxuICAgICAgICAgIGFycmF5W2ldID0gK2FycmF5W2ldO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJyYXk7XHJcbiAgfVxyXG5cclxuICAvLyBPcGFsMzItY2hlY2tzdW0gYWxnb3JpdGhtIGZvciAjaGFzaFxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgT3BhbC5vcGFsMzJfaW5pdCA9ICRyZXR1cm5fdmFsKDB4NGY3MDYxNmMpO1xyXG5cclxuICBmdW5jdGlvbiAkb3BhbDMyX3JvcihuLCBkKSB7XHJcbiAgICByZXR1cm4gKG4gPDwgZCl8KG4gPj4+ICgzMiAtIGQpKTtcclxuICB9O1xyXG5cclxuICBPcGFsLm9wYWwzMl9hZGQgPSBmdW5jdGlvbihoYXNoLCBuZXh0KSB7XHJcbiAgICBoYXNoIF49IG5leHQ7XHJcbiAgICBoYXNoID0gJG9wYWwzMl9yb3IoaGFzaCwgMSk7XHJcbiAgICByZXR1cm4gaGFzaDtcclxuICB9O1xyXG5cclxuICAvLyBJbml0aWFsaXphdGlvblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tXHJcbiAgT3BhbC5CYXNpY09iamVjdCA9IEJhc2ljT2JqZWN0ID0gJGFsbG9jYXRlX2NsYXNzKCdCYXNpY09iamVjdCcsIG51bGwpO1xyXG4gIE9wYWwuT2JqZWN0ICAgICAgPSBfT2JqZWN0ICAgICA9ICRhbGxvY2F0ZV9jbGFzcygnT2JqZWN0JywgT3BhbC5CYXNpY09iamVjdCk7XHJcbiAgT3BhbC5Nb2R1bGUgICAgICA9IE1vZHVsZSAgICAgID0gJGFsbG9jYXRlX2NsYXNzKCdNb2R1bGUnLCBPcGFsLk9iamVjdCk7XHJcbiAgT3BhbC5DbGFzcyAgICAgICA9IENsYXNzICAgICAgID0gJGFsbG9jYXRlX2NsYXNzKCdDbGFzcycsIE9wYWwuTW9kdWxlKTtcclxuICBPcGFsLk9wYWwgICAgICAgID0gX09wYWwgICAgICAgPSAkYWxsb2NhdGVfbW9kdWxlKCdPcGFsJyk7XHJcbiAgT3BhbC5LZXJuZWwgICAgICA9IEtlcm5lbCAgICAgID0gJGFsbG9jYXRlX21vZHVsZSgnS2VybmVsJyk7XHJcblxyXG4gICRzZXRfcHJvdG8oT3BhbC5CYXNpY09iamVjdCwgT3BhbC5DbGFzcy4kJHByb3RvdHlwZSk7XHJcbiAgJHNldF9wcm90byhPcGFsLk9iamVjdCwgT3BhbC5DbGFzcy4kJHByb3RvdHlwZSk7XHJcbiAgJHNldF9wcm90byhPcGFsLk1vZHVsZSwgT3BhbC5DbGFzcy4kJHByb3RvdHlwZSk7XHJcbiAgJHNldF9wcm90byhPcGFsLkNsYXNzLCBPcGFsLkNsYXNzLiQkcHJvdG90eXBlKTtcclxuXHJcbiAgLy8gQmFzaWNPYmplY3QgY2FuIHJlYWNoIGl0c2VsZiwgYXZvaWQgY29uc3Rfc2V0IHRvIHNraXAgdGhlICQkYmFzZV9tb2R1bGUgbG9naWNcclxuICBCYXNpY09iamVjdC4kJGNvbnN0LkJhc2ljT2JqZWN0ID0gQmFzaWNPYmplY3Q7XHJcblxyXG4gIC8vIEFzc2lnbiBiYXNpYyBjb25zdGFudHNcclxuICAkY29uc3Rfc2V0KF9PYmplY3QsIFwiQmFzaWNPYmplY3RcIiwgIEJhc2ljT2JqZWN0KTtcclxuICAkY29uc3Rfc2V0KF9PYmplY3QsIFwiT2JqZWN0XCIsICAgICAgIF9PYmplY3QpO1xyXG4gICRjb25zdF9zZXQoX09iamVjdCwgXCJNb2R1bGVcIiwgICAgICAgTW9kdWxlKTtcclxuICAkY29uc3Rfc2V0KF9PYmplY3QsIFwiQ2xhc3NcIiwgICAgICAgIENsYXNzKTtcclxuICAkY29uc3Rfc2V0KF9PYmplY3QsIFwiT3BhbFwiLCAgICAgICAgIF9PcGFsKTtcclxuICAkY29uc3Rfc2V0KF9PYmplY3QsIFwiS2VybmVsXCIsICAgICAgIEtlcm5lbCk7XHJcblxyXG4gIC8vIEZpeCBib290ZWQgY2xhc3NlcyB0byBoYXZlIGNvcnJlY3QgLmNsYXNzIHZhbHVlXHJcbiAgQmFzaWNPYmplY3QuJCRjbGFzcyA9IENsYXNzO1xyXG4gIF9PYmplY3QuJCRjbGFzcyAgICAgPSBDbGFzcztcclxuICBNb2R1bGUuJCRjbGFzcyAgICAgID0gQ2xhc3M7XHJcbiAgQ2xhc3MuJCRjbGFzcyAgICAgICA9IENsYXNzO1xyXG4gIF9PcGFsLiQkY2xhc3MgICAgICAgPSBNb2R1bGU7XHJcbiAgS2VybmVsLiQkY2xhc3MgICAgICA9IE1vZHVsZTtcclxuXHJcbiAgLy8gRm9yd2FyZCAudG9TdHJpbmcoKSB0byAjdG9fc1xyXG4gICRwcm9wKF9PYmplY3QuJCRwcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHRvX3MgPSB0aGlzLiR0b19zKCk7XHJcbiAgICBpZiAodG9fcy4kJGlzX3N0cmluZyAmJiB0eXBlb2YodG9fcykgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIC8vIGEgc3RyaW5nIGNyZWF0ZWQgdXNpbmcgbmV3IFN0cmluZygnc3RyaW5nJylcclxuICAgICAgcmV0dXJuIHRvX3MudmFsdWVPZigpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHRvX3M7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vIE1ha2UgS2VybmVsI3JlcXVpcmUgaW1tZWRpYXRlbHkgYXZhaWxhYmxlIGFzIGl0J3MgbmVlZGVkIHRvIHJlcXVpcmUgYWxsIHRoZVxyXG4gIC8vIG90aGVyIGNvcmVsaWIgZmlsZXMuXHJcbiAgJHByb3AoX09iamVjdC4kJHByb3RvdHlwZSwgJyRyZXF1aXJlJywgT3BhbC5yZXF1aXJlKTtcclxuXHJcbiAgLy8gSW5zdGFudGlhdGUgdGhlIG1haW4gb2JqZWN0XHJcbiAgT3BhbC50b3AgPSBuZXcgX09iamVjdCgpO1xyXG4gIE9wYWwudG9wLiR0b19zID0gT3BhbC50b3AuJGluc3BlY3QgPSAkcmV0dXJuX3ZhbCgnbWFpbicpO1xyXG4gIE9wYWwudG9wLiRkZWZpbmVfbWV0aG9kID0gdG9wX2RlZmluZV9tZXRob2Q7XHJcblxyXG4gIC8vIEZvd2FyZCBjYWxscyB0byBkZWZpbmVfbWV0aG9kIG9uIHRoZSB0b3Agb2JqZWN0IHRvIE9iamVjdFxyXG4gIGZ1bmN0aW9uIHRvcF9kZWZpbmVfbWV0aG9kKCkge1xyXG4gICAgdmFyIGJsb2NrID0gdG9wX2RlZmluZV9tZXRob2QuJCRwO1xyXG4gICAgdG9wX2RlZmluZV9tZXRob2QuJCRwID0gbnVsbDtcclxuICAgIHJldHVybiBPcGFsLnNlbmQoX09iamVjdCwgJ2RlZmluZV9tZXRob2QnLCBhcmd1bWVudHMsIGJsb2NrKVxyXG4gIH07XHJcblxyXG4gIC8vIE5pbFxyXG4gIE9wYWwuTmlsQ2xhc3MgPSAkYWxsb2NhdGVfY2xhc3MoJ05pbENsYXNzJywgT3BhbC5PYmplY3QpO1xyXG4gICRjb25zdF9zZXQoX09iamVjdCwgJ05pbENsYXNzJywgT3BhbC5OaWxDbGFzcyk7XHJcbiAgbmlsID0gT3BhbC5uaWwgPSBuZXcgT3BhbC5OaWxDbGFzcygpO1xyXG4gIG5pbC4kJGlkID0gbmlsX2lkO1xyXG4gIG5pbC5jYWxsID0gbmlsLmFwcGx5ID0gZnVuY3Rpb24oKSB7ICRyYWlzZShPcGFsLkxvY2FsSnVtcEVycm9yLCAnbm8gYmxvY2sgZ2l2ZW4nKTsgfTtcclxuICBuaWwuJCRmcm96ZW4gPSB0cnVlO1xyXG4gIG5pbC4kJGNvbXBhcmFibGUgPSBmYWxzZTtcclxuICBPYmplY3Quc2VhbChuaWwpO1xyXG5cclxuICBPcGFsLnRocm93ZXIgPSBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICB2YXIgdGhyb3dlciA9IHtcclxuICAgICAgJHRocm93ZXJfdHlwZTogdHlwZSxcclxuICAgICAgJHRocm93OiBmdW5jdGlvbih2YWx1ZSwgY2FsbGVkX2Zyb21fbGFtYmRhKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHZhbHVlID0gbmlsO1xyXG4gICAgICAgIGlmICh0aGlzLmlzX29ycGhhbiAmJiAhY2FsbGVkX2Zyb21fbGFtYmRhKSB7XHJcbiAgICAgICAgICAkcmFpc2UoT3BhbC5Mb2NhbEp1bXBFcnJvciwgJ3VuZXhwZWN0ZWQgJyArIHR5cGUsIHZhbHVlLCB0eXBlLiR0b19zeW0oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuJHYgPSB2YWx1ZTtcclxuICAgICAgICB0aHJvdyB0aGlzO1xyXG4gICAgICB9LFxyXG4gICAgICBpc19vcnBoYW46IGZhbHNlXHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhyb3dlcjtcclxuICB9O1xyXG5cclxuICAvLyBEZWZpbmUgYSBcIiRAXCIgZ2xvYmFsIHZhcmlhYmxlLCB3aGljaCB3b3VsZCBjb21wdXRlIGFuZCByZXR1cm4gYSBiYWNrdHJhY2Ugb24gZGVtYW5kLlxyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgkZ3ZhcnMsIFwiQFwiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKCR0cnV0aHkoJGd2YXJzW1wiIVwiXSkpIHJldHVybiAkZ3ZhcnNbXCIhXCJdLiRiYWNrdHJhY2UoKTtcclxuICAgICAgcmV0dXJuIG5pbDtcclxuICAgIH0sXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKGJ0KSB7XHJcbiAgICAgIGlmICgkdHJ1dGh5KCRndmFyc1tcIiFcIl0pKVxyXG4gICAgICAgICRndmFyc1tcIiFcIl0uJHNldF9iYWNrdHJhY2UoYnQpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgJHJhaXNlKE9wYWwuQXJndW1lbnRFcnJvciwgXCIkISBub3Qgc2V0XCIpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBPcGFsLnRfZXZhbF9yZXR1cm4gPSBPcGFsLnRocm93ZXIoXCJyZXR1cm5cIik7XHJcblxyXG4gIFR5cGVFcnJvci4kJHN1cGVyID0gRXJyb3I7XHJcblxyXG4gIC8vIElmIGVuYWJsZS1maWxlLXNvdXJjZS1lbWJlZCBjb21waWxlciBvcHRpb24gaXMgZW5hYmxlZCwgZWFjaCBtb2R1bGUgbG9hZGVkIHdpbGwgYWRkIGl0c1xyXG4gIC8vIHNvdXJjZXMgdG8gdGhpcyBvYmplY3RcclxuICBPcGFsLmZpbGVfc291cmNlcyA9IHt9O1xyXG59KS5jYWxsKHRoaXMpO1xyXG5PcGFsLmxvYWRlZChbXCJjb3JlbGliL3J1bnRpbWUuanNcIl0pOyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRjtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTs7QUFFRjtBQUNFOztBQUVGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNGOztBQUVBOztBQUVBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNFOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7QUFDQTs7O0FBR0E7QUFDRTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDRjtBQUNBOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTtBQUNBOztBQUVKO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7O0FBRUY7QUFDRTs7QUFFRjtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUY7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDQTtBQUNJO0FBQ0E7QUFDQTs7QUFFSjtBQUNFOztBQUVBO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFSjtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTtBQUNGOztBQUVBO0FBQ0k7O0FBRUo7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7OztBQUdBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNGO0FBQ0E7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNGOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0k7QUFDQTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0o7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0o7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0U7QUFDSjtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDRjtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0E7QUFDRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBOztBQUVBOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0k7QUFDQTtBQUNBOztBQUVKO0FBQ0E7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0U7QUFDRTs7QUFFRjtBQUNJOztBQUVKO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDSTs7QUFFSjtBQUNFO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0U7QUFDSTtBQUNBOztBQUVKO0FBQ0U7QUFDRTtBQUNBO0FBQ0U7QUFDSjtBQUNGO0FBQ0U7QUFDRjtBQUNGO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0k7QUFDQTs7QUFFSjtBQUNFO0FBQ0U7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7QUFDRjtBQUNGO0FBQ0U7QUFDRjtBQUNGO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTs7QUFFRjtBQUNFO0FBQ0E7QUFDRTs7QUFFRjs7QUFFQTtBQUNFOztBQUVGO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0k7QUFDQTs7QUFFSjtBQUNFO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVGO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0Y7QUFDRTtBQUNBO0FBQ0U7QUFDRTs7QUFFQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0k7QUFDQTtBQUNBOztBQUVKO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTs7QUFFQTs7QUFFQTtBQUNGO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVGO0FBQ0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDVTtBQUNBO0FBQ0E7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0E7QUFDRTtBQUNFO0FBQ0U7QUFDQTtBQUNGOztBQUVGO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVBOztBQUVBO0FBQ0U7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0E7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNPO0FBQ1Q7O0FBRUE7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNBOztBQUVBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNKO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRjtBQUNBO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0o7QUFDRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRjtBQUNBIn19LHsib2Zmc2V0Ijp7ImxpbmUiOjMyMzQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2hlbHBlcnMucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0eXBlX2Vycm9yLCBjb2VyY2VfdG9cclxuIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXHJcbiMgdXNlX3N0cmljdDogdHJ1ZVxyXG5cclxubW9kdWxlIDo6T3BhbFxyXG4gIGRlZiBzZWxmLmJyaWRnZShjb25zdHJ1Y3Rvciwga2xhc3MpXHJcbiAgICBgT3BhbC5icmlkZ2UoY29uc3RydWN0b3IsIGtsYXNzKWBcclxuICBlbmRcclxuXHJcbiAgZGVmIHNlbGYuY29lcmNlX3RvIShvYmplY3QsIHR5cGUsIG1ldGhvZCwgKmFyZ3MpXHJcbiAgICBjb2VyY2VkID0gYCRjb2VyY2VfdG8ob2JqZWN0LCB0eXBlLCBtZXRob2QsIGFyZ3MpYFxyXG5cclxuICAgIHVubGVzcyB0eXBlID09PSBjb2VyY2VkXHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIGAkdHlwZV9lcnJvcihvYmplY3QsIHR5cGUsIG1ldGhvZCwgY29lcmNlZClgXHJcbiAgICBlbmRcclxuXHJcbiAgICBjb2VyY2VkXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzZWxmLmNvZXJjZV90bz8ob2JqZWN0LCB0eXBlLCBtZXRob2QsICphcmdzKVxyXG4gICAgcmV0dXJuIHVubGVzcyBvYmplY3QucmVzcG9uZF90bz8gbWV0aG9kXHJcblxyXG4gICAgY29lcmNlZCA9IGAkY29lcmNlX3RvKG9iamVjdCwgdHlwZSwgbWV0aG9kLCBhcmdzKWBcclxuXHJcbiAgICByZXR1cm4gaWYgY29lcmNlZC5uaWw/XHJcblxyXG4gICAgdW5sZXNzIHR5cGUgPT09IGNvZXJjZWRcclxuICAgICAgOjpLZXJuZWwucmFpc2UgYCR0eXBlX2Vycm9yKG9iamVjdCwgdHlwZSwgbWV0aG9kLCBjb2VyY2VkKWBcclxuICAgIGVuZFxyXG5cclxuICAgIGNvZXJjZWRcclxuICBlbmRcclxuXHJcbiAgZGVmIHNlbGYudHJ5X2NvbnZlcnQob2JqZWN0LCB0eXBlLCBtZXRob2QpXHJcbiAgICByZXR1cm4gb2JqZWN0IGlmIHR5cGUgPT09IG9iamVjdFxyXG5cclxuICAgIGlmIG9iamVjdC5yZXNwb25kX3RvPyBtZXRob2RcclxuICAgICAgb2JqZWN0Ll9fc2VuZF9fIG1ldGhvZFxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzZWxmLmNvbXBhcmUoYSwgYilcclxuICAgIGNvbXBhcmUgPSBhIDw9PiBiXHJcblxyXG4gICAgaWYgYGNvbXBhcmUgPT09IG5pbGBcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3thLmNsYXNzfSB3aXRoICN7Yi5jbGFzc30gZmFpbGVkXCJcclxuICAgIGVuZFxyXG5cclxuICAgIGNvbXBhcmVcclxuICBlbmRcclxuXHJcbiAgZGVmIHNlbGYuZGVzdHJ1Y3R1cmUoYXJncylcclxuICAgICV4e1xyXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT0gMSkge1xyXG4gICAgICAgIHJldHVybiBhcmdzWzBdO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKGFyZ3MuJCRpc19hcnJheSkge1xyXG4gICAgICAgIHJldHVybiBhcmdzO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBhcmdzX2FyeSA9IG5ldyBBcnJheShhcmdzLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMCwgbCA9IGFyZ3NfYXJ5Lmxlbmd0aDsgaSA8IGw7IGkrKykgeyBhcmdzX2FyeVtpXSA9IGFyZ3NbaV07IH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFyZ3NfYXJ5O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzZWxmLnJlc3BvbmRfdG8/KG9iaiwgbWV0aG9kLCBpbmNsdWRlX2FsbCA9IGZhbHNlKVxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChvYmogPT0gbnVsbCB8fCAhb2JqLiQkY2xhc3MpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvYmoucmVzcG9uZF90bz8obWV0aG9kLCBpbmNsdWRlX2FsbClcclxuICBlbmRcclxuXHJcbiAgZGVmIHNlbGYuaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEobmFtZSlcclxuICAgIG5hbWUgPSA6Ok9wYWwuY29lcmNlX3RvIShuYW1lLCA6OlN0cmluZywgOnRvX3N0cilcclxuXHJcbiAgICB1bmxlc3MgYC9eQFthLXpBLVpfXVthLXpBLVowLTlfXSo/JC8udGVzdChuYW1lKWBcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpOYW1lRXJyb3IubmV3KFwiJyN7bmFtZX0nIGlzIG5vdCBhbGxvd2VkIGFzIGFuIGluc3RhbmNlIHZhcmlhYmxlIG5hbWVcIiwgbmFtZSlcclxuICAgIGVuZFxyXG5cclxuICAgIG5hbWVcclxuICBlbmRcclxuXHJcbiAgZGVmIHNlbGYuY2xhc3NfdmFyaWFibGVfbmFtZSEobmFtZSlcclxuICAgIG5hbWUgPSA6Ok9wYWwuY29lcmNlX3RvIShuYW1lLCA6OlN0cmluZywgOnRvX3N0cilcclxuXHJcbiAgICBpZiBgbmFtZS5sZW5ndGggPCAzIHx8IG5hbWUuc2xpY2UoMCwyKSAhPT0gJ0BAJ2BcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpOYW1lRXJyb3IubmV3KFwiYCN7bmFtZX0nIGlzIG5vdCBhbGxvd2VkIGFzIGEgY2xhc3MgdmFyaWFibGUgbmFtZVwiLCBuYW1lKVxyXG4gICAgZW5kXHJcblxyXG4gICAgbmFtZVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc2VsZi5jb25zdF9uYW1lPyhjb25zdF9uYW1lKVxyXG4gICAgJXh7XHJcbiAgICAgIGlmICh0eXBlb2YgY29uc3RfbmFtZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAje2NvbnN0X25hbWUgPSA6Ok9wYWwuY29lcmNlX3RvIShjb25zdF9uYW1lLCA6OlN0cmluZywgOnRvX3N0cil9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiAje2NvbnN0X25hbWV9WzBdID09PSAje2NvbnN0X25hbWV9WzBdLnRvVXBwZXJDYXNlKClcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHNlbGYuY29uc3RfbmFtZSEoY29uc3RfbmFtZSlcclxuICAgIGNvbnN0X25hbWUgPSA6Ok9wYWwuY29lcmNlX3RvIShjb25zdF9uYW1lLCA6OlN0cmluZywgOnRvX3N0cikgaWYgZGVmaW5lZD8gOjpTdHJpbmdcclxuXHJcbiAgICAleHtcclxuICAgICAgaWYgKCFjb25zdF9uYW1lIHx8IGNvbnN0X25hbWUubGVuZ3RoID09PSAwIHx8IGNvbnN0X25hbWVbMF0gIT0gY29uc3RfbmFtZVswXS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgI3tyYWlzZSA6Ok5hbWVFcnJvciwgXCJ3cm9uZyBjb25zdGFudCBuYW1lICN7Y29uc3RfbmFtZX1cIn1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0X25hbWVcclxuICBlbmRcclxuXHJcbiAgIyBAcHJpdmF0ZVxyXG4gICMgTWFyayBzb21lIG1ldGhvZHMgYXMgcHJpc3RpbmUgaW4gb3JkZXIgdG8gYXBwbHkgb3B0aW1pemF0aW9ucyB3aGVuIHRoZXlcclxuICAjIGFyZSBzdGlsbCBpbiB0aGVpciBvcmlnaW5hbCBmb3JtLiBUaGlzIGNvdWxkIHByb2JhYmx5IGJlIG1vdmVkIHRvXHJcbiAgIyB0aGUgYE9wYWwuZGVmKClgIEpTIEFQSSwgYnV0IGZvciBub3cgaXQgd2lsbCBzdGF5IG1hbnVhbC5cclxuICAjXHJcbiAgIyBAZXhhbXBsZVxyXG4gICNcclxuICAjICAgT3BhbC5wcmlzdGluZSBBcnJheSwgOmFsbG9jYXRlLCA6Y29weV9pbnN0YW5jZV92YXJpYWJsZXMsIDppbml0aWFsaXplX2R1cFxyXG4gICNcclxuICAjICAgY2xhc3MgQXJyYXlcclxuICAjICAgICBkZWYgZHVwXHJcbiAgIyAgICAgICAleHtcclxuICAjICAgICAgICAgaWYgKFxyXG4gICMgICAgICAgICAgIHNlbGYuJGFsbG9jYXRlLiQkcHJpc3RpbmUgJiZcclxuICAjICAgICAgICAgICBzZWxmLiRjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcy4kJHByaXN0aW5lICYmXHJcbiAgIyAgICAgICAgICAgc2VsZi4kaW5pdGlhbGl6ZV9kdXAuJCRwcmlzdGluZVxyXG4gICMgICAgICAgICApIHJldHVybiBzZWxmLnNsaWNlKDApO1xyXG4gICMgICAgICAgfVxyXG4gICNcclxuICAjICAgICAgIHN1cGVyXHJcbiAgIyAgICAgZW5kXHJcbiAgIyAgIGVuZFxyXG4gICNcclxuICAjIEBwYXJhbSBvd25lcl9jbGFzcyBbQ2xhc3NdIHRoZSBjbGFzcyBvd25pbmcgdGhlIG1ldGhvZHNcclxuICAjIEBwYXJhbSBtZXRob2RfbmFtZXMgW0FycmF5PFN5bWJvbD5dIHRoZSBsaXN0IG9mIG1ldGhvZHMgbmFtZXMgdG8gbWFya1xyXG4gICMgQHJldHVybiBbbmlsXVxyXG4gIGRlZiBzZWxmLnByaXN0aW5lKG93bmVyX2NsYXNzLCAqbWV0aG9kX25hbWVzKVxyXG4gICAgJXh7XHJcbiAgICAgIHZhciBtZXRob2RfbmFtZSwgbWV0aG9kO1xyXG4gICAgICBmb3IgKHZhciBpID0gbWV0aG9kX25hbWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgbWV0aG9kX25hbWUgPSBtZXRob2RfbmFtZXNbaV07XHJcbiAgICAgICAgbWV0aG9kID0gb3duZXJfY2xhc3MuJCRwcm90b3R5cGVbT3BhbC5qc2lkKG1ldGhvZF9uYW1lKV07XHJcblxyXG4gICAgICAgIGlmIChtZXRob2QgJiYgIW1ldGhvZC4kJHN0dWIpIHtcclxuICAgICAgICAgIG1ldGhvZC4kJHByaXN0aW5lID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIG5pbFxyXG4gIGVuZFxyXG5cclxuICBgdmFyIGluc3BlY3Rfc3RhY2sgPSBbXWBcclxuXHJcbiAgIyBQZXJmb3JtcyBhIHNhZmUgY2FsbCB0byBpbnNwZWN0IGZvciBhbnkgdmFsdWUsIHdoZXRoZXJcclxuICAjIG5hdGl2ZSBvciBPcGFsLXdyYXBwZWQuXHJcbiAgI1xyXG4gICMgQHBhcmFtIHZhbHVlIFtPYmplY3RdXHJcbiAgIyBAcmV0dXJuIFtTdHJpbmddXHJcbiAgZGVmIHNlbGYuaW5zcGVjdCh2YWx1ZSA9IHVuZGVmaW5lZClcclxuICAgIGB2YXIgcHVzaGVkID0gZmFsc2VgXHJcbiAgICBiZWdpblxyXG4gICAgICAleHtcclxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICAgIC8vIEpTIG51bGwgdmFsdWVcclxuICAgICAgICAgIHJldHVybiAnbnVsbCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIC8vIEpTIHVuZGVmaW5lZCB2YWx1ZVxyXG4gICAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUuJCRjbGFzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgIC8vIEpTIG9iamVjdCAvIG90aGVyIHZhbHVlIHRoYXQgaXMgbm90IGJyaWRnZWRcclxuICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlLiRpbnNwZWN0ICE9PSAnZnVuY3Rpb24nIHx8IHZhbHVlLiRpbnNwZWN0LiQkc3R1Yikge1xyXG4gICAgICAgICAgLy8gQmFzaWNPYmplY3QgYW5kIGZyaWVuZHNcclxuICAgICAgICAgIHJldHVybiAje1wiIzwje2B2YWx1ZS4kJGNsYXNzYH06MHgje3ZhbHVlLl9faWRfXy50b19zKDE2KX0+XCJ9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluc3BlY3Rfc3RhY2suaW5kZXhPZigje3ZhbHVlLl9faWRfX30pICE9PSAtMSkge1xyXG4gICAgICAgICAgLy8gaW5zcGVjdCByZWN1cnNpbmcgaW5zaWRlIGluc3BlY3QgdG8gZmluZCBvdXQgYWJvdXQgdGhlXHJcbiAgICAgICAgICAvLyBzYW1lIG9iamVjdFxyXG4gICAgICAgICAgcmV0dXJuICN7XCIjPCN7YHZhbHVlLiQkY2xhc3NgfToweCN7dmFsdWUuX19pZF9fLnRvX3MoMTYpfT5cIn1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAvLyBhbnl0aGluZyBzdXBwb3J0aW5nIE9wYWxcclxuICAgICAgICAgIGluc3BlY3Rfc3RhY2sucHVzaCgje3ZhbHVlLl9faWRfX30pO1xyXG4gICAgICAgICAgcHVzaGVkID0gdHJ1ZTtcclxuICAgICAgICAgIHJldHVybiB2YWx1ZS4kaW5zcGVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBuaWxcclxuICAgIHJlc2N1ZSA6OkV4Y2VwdGlvbiA9PiBlICMgcnVib2NvcDpkaXNhYmxlIExpbnQvUmVzY3VlRXhjZXB0aW9uXHJcbiAgICAgIFwiIzwje2B2YWx1ZS4kJGNsYXNzYH06MHgje3ZhbHVlLl9faWRfXy50b19zKDE2KX0+XCJcclxuICAgIGVuc3VyZVxyXG4gICAgICBgaWYgKHB1c2hlZCkgaW5zcGVjdF9zdGFjay5wb3AoKWBcclxuICAgIGVuZFxyXG4gIGVuZFxyXG5lbmRcclxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOk9wYWw+IiwiYnJpZGdlIiwic2VsZiIsImNvbnN0cnVjdG9yIiwia2xhc3MiLCJjb2VyY2VfdG8hIiwib2JqZWN0IiwidHlwZSIsIm1ldGhvZCIsImNvZXJjZWQiLCJLZXJuZWwiLCJyYWlzZSIsImNvZXJjZV90bz8iLCJyZXNwb25kX3RvPyIsIm5pbD8iLCJ0cnlfY29udmVydCIsIl9fc2VuZF9fIiwiY29tcGFyZSIsImEiLCJiIiwiPD0+IiwiQXJndW1lbnRFcnJvciIsImNsYXNzIiwiZGVzdHJ1Y3R1cmUiLCJhcmdzIiwib2JqIiwiaW5jbHVkZV9hbGwiLCJpbnN0YW5jZV92YXJpYWJsZV9uYW1lISIsIm5hbWUiLCJPcGFsIiwiU3RyaW5nIiwiTmFtZUVycm9yIiwibmV3IiwiY2xhc3NfdmFyaWFibGVfbmFtZSEiLCJjb25zdF9uYW1lPyIsImNvbnN0X25hbWUiLCJjb25zdF9uYW1lISIsInByaXN0aW5lIiwib3duZXJfY2xhc3MiLCJpbnNwZWN0IiwidmFsdWUiLCJfX2lkX18iLCJ0b19zIiwiMTYiLCJFeGNlcHRpb24iLCJlIl0sIm1hcHBpbmdzIjoiQUFBQUEsa0NBQUFBLGdCQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7RUFJQUEsT0FBQUM7RUFBQUE7Ozs7SUFDRUMsTUFBSUMsSUFBSkQsYUFBQUEsa0JBQWdCRSxXQUFELEVBQWNDLEtBQTdCSDtBQUFBQTtNQUNFQSxPQUFDQSwrQkFBREE7SUFERkEsQ0FBQUE7SUFJQUksTUFBSUgsSUFBSkcsaUJBQUFBLGdDQUFvQkMsTUFBRCxFQUFTQyxJQUFULEVBQWVDLE1BQWYsRUFUckIsRUFTRUg7QUFBQUEsTUFBQUE7OztNQVRGO01BUzRDO01BQ3hDSSxVQUFXSjtNQUVYLEtBQUEsUUFBT0UsSUFBUCxFQUFnQkUsT0FBaEIsQ0FBQTtRQUNFQyxPQUFRQyxPQUFBQSxDQUFRTiwwQ0FBUk07TUFEVjtNQUlBTixPQUFBSTtJQVBGSixDQUFBQSxJQUFBQTtJQVVBTyxNQUFJVixJQUFKVSxpQkFBQUEsZ0NBQW9CTixNQUFELEVBQVNDLElBQVQsRUFBZUMsTUFBZixFQW5CckIsRUFtQkVJ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UUY7QUFDdERBO0FBQ0FBO0FBQ0FBLGlCQUFvQkEsSUFBRCxHQUFBLE1BQU1BLGFBQU4sQ0FBQSxHQUFxQkEsS0FBckIsR0FBQSxNQUEwQkMsS0FBS0MsUUFBQUEsQ0FBQUEsQ0FBT0MsTUFBQUEsQ0FBTUMsRUFBTkQsQ0FBdEMsQ0FBQSxHQUFnREg7QUFDbkVBO0FBQ0FBO0FBQ0FBO0FBQ0FBLDZCQUErQkMsS0FBS0MsUUFBQUEsQ0FBQUEsQ0FBUUY7QUFDNUNBO0FBQ0FBO0FBQ0FBO0FBQ0FBO1FBQ01BLE9BQUE7TUE3QkE7UUE4QkYsc0JBQU8sQ0FBQUssZ0JBQUEsQ0FBUCxJQUFzQkMsQ0FBQUEsSUFBdEIsSUFBc0JBO1VBQXRCO1lBQ0VOLE9BQUNBLElBQUQsR0FBQSxNQUFNQSxhQUFOLENBQUEsR0FBcUJBLEtBQXJCLEdBQUEsTUFBMEJDLEtBQUtDLFFBQUFBLENBQUFBLENBQU9DLE1BQUFBLENBQU1DLEVBQU5ELENBQXRDLENBQUEsR0FBZ0RIO1VBRGxEO1FBQUEsQ0E5QkU7TUFBQTtNQUFBO1FBaUNDQTtNQWpDRCxDQUFBO0lBSEpBLENBQUFBLElBQUFBO0VBcEtGdkMsR0FBTyxJQUFQQTtBQUpBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzQ0NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbW9kdWxlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHJ1dGh5LCBjb2VyY2VfdG8sIGNvbnN0X3NldCwgT2JqZWN0LCByZXR1cm5faXZhciwgYXNzaWduX2l2YXIsIGl2YXIsIGRlbnlfZnJvemVuX2FjY2VzcywgZnJlZXplLCBwcm9wLCBqc2lkLCBlYWNoX2l2YXJcclxuIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXHJcbiMgdXNlX3N0cmljdDogdHJ1ZVxyXG5cclxuY2xhc3MgOjpNb2R1bGVcclxuICAleHtcclxuICAgIGZ1bmN0aW9uIGVuc3VyZV9zeW1ib2xfb3Jfc3RyaW5nKG5hbWUpIHtcclxuICAgICAgaWYgKG5hbWUuJCRpc19zdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgICAgfTtcclxuICAgICAgdmFyIGNvbnZlcnRlZF9uYW1lID0gI3s6Ok9wYWwudHJ5X2NvbnZlcnQoYG5hbWVgLCA6OlN0cmluZywgOnRvX3N0cil9O1xyXG4gICAgICBpZiAoY29udmVydGVkX25hbWUuJCRpc19zdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gY29udmVydGVkX25hbWU7XHJcbiAgICAgIH0gZWxzZSBpZiAoY29udmVydGVkX25hbWUgPT09IG5pbCkge1xyXG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiI3tgbmFtZWB9IGlzIG5vdCBhIHN5bWJvbCBub3IgYSBzdHJpbmdcIn1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tgbmFtZWAuY2xhc3N9IHRvIFN0cmluZyAoI3tgbmFtZWAuY2xhc3N9I3RvX3N0ciBnaXZlcyAje2Bjb252ZXJ0ZWRfbmFtZWAuY2xhc3N9XCJ9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRlZiBzZWxmLmFsbG9jYXRlXHJcbiAgICAleHtcclxuICAgICAgdmFyIG1vZHVsZSA9IE9wYWwuYWxsb2NhdGVfbW9kdWxlKG5pbCwgZnVuY3Rpb24oKXt9KTtcclxuICAgICAgLy8gTGluayB0aGUgcHJvdG90eXBlIG9mIE1vZHVsZSBzdWJjbGFzc2VzXHJcbiAgICAgIGlmIChzZWxmICE9PSBPcGFsLk1vZHVsZSkgT2JqZWN0LnNldFByb3RvdHlwZU9mKG1vZHVsZSwgc2VsZi4kJHByb3RvdHlwZSk7XHJcbiAgICAgIHJldHVybiBtb2R1bGU7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBpbml0aWFsaXplKCZibG9jaylcclxuICAgIG1vZHVsZV9ldmFsKCZibG9jaykgaWYgYmxvY2tfZ2l2ZW4/XHJcbiAgZW5kXHJcblxyXG4gIGRlZiA9PT0ob2JqZWN0KVxyXG4gICAgcmV0dXJuIGZhbHNlIGlmIGBvYmplY3QgPT0gbnVsbGBcclxuXHJcbiAgICBgT3BhbC5pc19hKG9iamVjdCwgc2VsZilgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiA8KG90aGVyKVxyXG4gICAgdW5sZXNzIDo6TW9kdWxlID09PSBvdGhlclxyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ2NvbXBhcmVkIHdpdGggbm9uIGNsYXNzL21vZHVsZSdcclxuICAgIGVuZFxyXG5cclxuICAgICMgY2xhc3MgY2Fubm90IGJlIGEgZGVzY2VuZGFudCBvZiBpdHNlbGZcclxuICAgICV4e1xyXG4gICAgICB2YXIgd29ya2luZyA9IHNlbGYsXHJcbiAgICAgICAgICBhbmNlc3RvcnMsXHJcbiAgICAgICAgICBpLCBsZW5ndGg7XHJcblxyXG4gICAgICBpZiAod29ya2luZyA9PT0gb3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAoaSA9IDAsIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKHNlbGYpLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoYW5jZXN0b3JzW2ldID09PSBvdGhlcikge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGkgPSAwLCBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhvdGhlciksIGxlbmd0aCA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChhbmNlc3RvcnNbaV0gPT09IHNlbGYpIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuaWw7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiA8PShvdGhlcilcclxuICAgIGVxdWFsPyhvdGhlcikgfHwgc2VsZiA8IG90aGVyXHJcbiAgZW5kXHJcblxyXG4gIGRlZiA+KG90aGVyKVxyXG4gICAgdW5sZXNzIDo6TW9kdWxlID09PSBvdGhlclxyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ2NvbXBhcmVkIHdpdGggbm9uIGNsYXNzL21vZHVsZSdcclxuICAgIGVuZFxyXG5cclxuICAgIG90aGVyIDwgc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgPj0ob3RoZXIpXHJcbiAgICBlcXVhbD8ob3RoZXIpIHx8IHNlbGYgPiBvdGhlclxyXG4gIGVuZFxyXG5cclxuICBkZWYgPD0+KG90aGVyKVxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChzZWxmID09PSBvdGhlcikge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdW5sZXNzIDo6TW9kdWxlID09PSBvdGhlclxyXG4gICAgICByZXR1cm4gbmlsXHJcbiAgICBlbmRcclxuXHJcbiAgICBsdCA9IHNlbGYgPCBvdGhlclxyXG4gICAgcmV0dXJuIG5pbCBpZiBsdC5uaWw/XHJcbiAgICBsdCA/IC0xIDogMVxyXG4gIGVuZFxyXG5cclxuICBkZWYgYWxpYXNfbWV0aG9kKG5ld25hbWUsIG9sZG5hbWUpXHJcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcclxuXHJcbiAgICBuZXduYW1lID0gYCRjb2VyY2VfdG8obmV3bmFtZSwgI3s6OlN0cmluZ30sICd0b19zdHInKWBcclxuICAgIG9sZG5hbWUgPSBgJGNvZXJjZV90byhvbGRuYW1lLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpYFxyXG4gICAgYE9wYWwuYWxpYXMoc2VsZiwgbmV3bmFtZSwgb2xkbmFtZSlgXHJcblxyXG4gICAgc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgYWxpYXNfbmF0aXZlKG1pZCwganNpZCA9IG1pZClcclxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxyXG5cclxuICAgIGBPcGFsLmFsaWFzX25hdGl2ZShzZWxmLCBtaWQsIGpzaWQpYFxyXG5cclxuICAgIHNlbGZcclxuICBlbmRcclxuXHJcbiAgZGVmIGFuY2VzdG9yc1xyXG4gICAgYE9wYWwuYW5jZXN0b3JzKHNlbGYpYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgYXBwZW5kX2ZlYXR1cmVzKGluY2x1ZGVyKVxyXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3MoaW5jbHVkZXIpYFxyXG5cclxuICAgIGBPcGFsLmFwcGVuZF9mZWF0dXJlcyhzZWxmLCBpbmNsdWRlcilgXHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBhdHRyX2FjY2Vzc29yKCpuYW1lcylcclxuICAgIGF0dHJfcmVhZGVyKCpuYW1lcylcclxuICAgIGF0dHJfd3JpdGVyKCpuYW1lcylcclxuICBlbmRcclxuXHJcbiAgZGVmIGF0dHIoKmFyZ3MpXHJcbiAgICAleHtcclxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09IDIgJiYgKGFyZ3NbMV0gPT09IHRydWUgfHwgYXJnc1sxXSA9PT0gZmFsc2UpKSB7XHJcbiAgICAgICAgI3t3YXJuICdvcHRpb25hbCBib29sZWFuIGFyZ3VtZW50IGlzIG9ic29sZXRlZCcsIHVwbGV2ZWw6IDF9XHJcblxyXG4gICAgICAgIGFyZ3NbMV0gPyAje2F0dHJfYWNjZXNzb3IoYGFyZ3NbMF1gKX0gOiAje2F0dHJfcmVhZGVyKGBhcmdzWzBdYCl9O1xyXG4gICAgICAgIHJldHVybiBuaWw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhdHRyX3JlYWRlcigqYXJncylcclxuICBlbmRcclxuXHJcbiAgZGVmIGF0dHJfcmVhZGVyKCpuYW1lcylcclxuICAgICV4e1xyXG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xyXG5cclxuICAgICAgdmFyIHByb3RvID0gc2VsZi4kJHByb3RvdHlwZTtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSBuYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIHZhciBuYW1lID0gbmFtZXNbaV0sXHJcbiAgICAgICAgICAgIGlkICAgPSAkanNpZChuYW1lKSxcclxuICAgICAgICAgICAgaXZhciA9ICRpdmFyKG5hbWUpO1xyXG5cclxuICAgICAgICB2YXIgYm9keSA9ICRyZXR1cm5faXZhcihpdmFyKTtcclxuXHJcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgaW5zdGFuY2UgdmFyaWFibGUgYXMgbmlsXHJcbiAgICAgICAgT3BhbC5wcm9wKHByb3RvLCBpdmFyLCBuaWwpO1xyXG5cclxuICAgICAgICBib2R5LiQkcGFyYW1ldGVycyA9IFtdO1xyXG4gICAgICAgIGJvZHkuJCRhcml0eSA9IDA7XHJcblxyXG4gICAgICAgIE9wYWwuZGVmbihzZWxmLCBpZCwgYm9keSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBuaWxcclxuICBlbmRcclxuXHJcbiAgZGVmIGF0dHJfd3JpdGVyKCpuYW1lcylcclxuICAgICV4e1xyXG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xyXG5cclxuICAgICAgdmFyIHByb3RvID0gc2VsZi4kJHByb3RvdHlwZTtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSBuYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIHZhciBuYW1lID0gbmFtZXNbaV0sXHJcbiAgICAgICAgICAgIGlkICAgPSAkanNpZChuYW1lICsgJz0nKSxcclxuICAgICAgICAgICAgaXZhciA9ICRpdmFyKG5hbWUpO1xyXG5cclxuICAgICAgICB2YXIgYm9keSA9ICRhc3NpZ25faXZhcihpdmFyKVxyXG5cclxuICAgICAgICBib2R5LiQkcGFyYW1ldGVycyA9IFtbJ3JlcSddXTtcclxuICAgICAgICBib2R5LiQkYXJpdHkgPSAxO1xyXG5cclxuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBpbnN0YW5jZSB2YXJpYWJsZSBhcyBuaWxcclxuICAgICAgICBPcGFsLnByb3AocHJvdG8sIGl2YXIsIG5pbCk7XHJcblxyXG4gICAgICAgIE9wYWwuZGVmbihzZWxmLCBpZCwgYm9keSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBuaWxcclxuICBlbmRcclxuXHJcbiAgZGVmIGF1dG9sb2FkKGNvbnN0LCBwYXRoKVxyXG4gICAgJXh7XHJcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XHJcblxyXG4gICAgICBpZiAoISN7T3BhbC5jb25zdF9uYW1lPyhjb25zdCl9KSB7XHJcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvciwgXCJhdXRvbG9hZCBtdXN0IGJlIGNvbnN0YW50IG5hbWU6ICN7Y29uc3R9XCJ9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChwYXRoID09IFwiXCIpIHtcclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2VtcHR5IGZpbGUgbmFtZSd9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghc2VsZi4kJGNvbnN0Lmhhc093blByb3BlcnR5KCN7Y29uc3R9KSkge1xyXG4gICAgICAgIGlmICghc2VsZi4kJGF1dG9sb2FkKSB7XHJcbiAgICAgICAgICBzZWxmLiQkYXV0b2xvYWQgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgT3BhbC5jb25zdF9jYWNoZV92ZXJzaW9uKys7XHJcbiAgICAgICAgc2VsZi4kJGF1dG9sb2FkWyN7Y29uc3R9XSA9IHsgcGF0aDogI3twYXRofSwgbG9hZGVkOiBmYWxzZSwgcmVxdWlyZWQ6IGZhbHNlLCBzdWNjZXNzOiBmYWxzZSwgZXhjZXB0aW9uOiBmYWxzZSB9O1xyXG5cclxuICAgICAgICBpZiAoc2VsZi4kY29uc3RfYWRkZWQgJiYgIXNlbGYuJGNvbnN0X2FkZGVkLiQkcHJpc3RpbmUpIHtcclxuICAgICAgICAgIHNlbGYuJGNvbnN0X2FkZGVkKCN7Y29uc3R9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5pbDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGF1dG9sb2FkPyhjb25zdClcclxuICAgICV4e1xyXG4gICAgICBpZiAoc2VsZi4kJGF1dG9sb2FkICYmIHNlbGYuJCRhdXRvbG9hZFsje2NvbnN0fV0gJiYgIXNlbGYuJCRhdXRvbG9hZFsje2NvbnN0fV0ucmVxdWlyZWQgJiYgIXNlbGYuJCRhdXRvbG9hZFsje2NvbnN0fV0uc3VjY2Vzcykge1xyXG4gICAgICAgIHJldHVybiBzZWxmLiQkYXV0b2xvYWRbI3tjb25zdH1dLnBhdGg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBhbmNlc3RvcnMgPSBzZWxmLiRhbmNlc3RvcnMoKTtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoYW5jZXN0b3JzW2ldLiQkYXV0b2xvYWQgJiYgYW5jZXN0b3JzW2ldLiQkYXV0b2xvYWRbI3tjb25zdH1dICYmICFhbmNlc3RvcnNbaV0uJCRhdXRvbG9hZFsje2NvbnN0fV0ucmVxdWlyZWQgJiYgIWFuY2VzdG9yc1tpXS4kJGF1dG9sb2FkWyN7Y29uc3R9XS5zdWNjZXNzKSB7XHJcbiAgICAgICAgICByZXR1cm4gYW5jZXN0b3JzW2ldLiQkYXV0b2xvYWRbI3tjb25zdH1dLnBhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuaWw7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBjbGFzc192YXJpYWJsZXNcclxuICAgIGBPYmplY3Qua2V5cyhPcGFsLmNsYXNzX3ZhcmlhYmxlcyhzZWxmKSlgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBjbGFzc192YXJpYWJsZV9nZXQobmFtZSlcclxuICAgIG5hbWUgPSA6Ok9wYWwuY2xhc3NfdmFyaWFibGVfbmFtZSEobmFtZSlcclxuXHJcbiAgICBgT3BhbC5jbGFzc192YXJpYWJsZV9nZXQoc2VsZiwgbmFtZSwgZmFsc2UpYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgY2xhc3NfdmFyaWFibGVfc2V0KG5hbWUsIHZhbHVlKVxyXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXHJcblxyXG4gICAgbmFtZSA9IDo6T3BhbC5jbGFzc192YXJpYWJsZV9uYW1lIShuYW1lKVxyXG5cclxuICAgIGBPcGFsLmNsYXNzX3ZhcmlhYmxlX3NldChzZWxmLCBuYW1lLCB2YWx1ZSlgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBjbGFzc192YXJpYWJsZV9kZWZpbmVkPyhuYW1lKVxyXG4gICAgbmFtZSA9IDo6T3BhbC5jbGFzc192YXJpYWJsZV9uYW1lIShuYW1lKVxyXG5cclxuICAgIGBPcGFsLmNsYXNzX3ZhcmlhYmxlcyhzZWxmKS5oYXNPd25Qcm9wZXJ0eShuYW1lKWBcclxuICBlbmRcclxuXHJcbiAgZGVmIGNvbnN0X2FkZGVkKG5hbWUpXHJcbiAgZW5kXHJcbiAgOjpPcGFsLnByaXN0aW5lIHNlbGYsIDpjb25zdF9hZGRlZFxyXG5cclxuICBkZWYgcmVtb3ZlX2NsYXNzX3ZhcmlhYmxlKG5hbWUpXHJcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcclxuXHJcbiAgICBuYW1lID0gOjpPcGFsLmNsYXNzX3ZhcmlhYmxlX25hbWUhKG5hbWUpXHJcblxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChPcGFsLmhhc093blByb3BlcnR5LmNhbGwoc2VsZi4kJGN2YXJzLCBuYW1lKSkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHNlbGYuJCRjdmFyc1tuYW1lXTtcclxuICAgICAgICBkZWxldGUgc2VsZi4kJGN2YXJzW25hbWVdO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLCBcImNhbm5vdCByZW1vdmUgI3tuYW1lfSBmb3IgI3tzZWxmfVwifVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBjb25zdGFudHMoaW5oZXJpdCA9IHRydWUpXHJcbiAgICBgT3BhbC5jb25zdGFudHMoc2VsZiwgaW5oZXJpdClgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzZWxmLmNvbnN0YW50cyhpbmhlcml0ID0gdW5kZWZpbmVkKVxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChpbmhlcml0ID09IG51bGwpIHtcclxuICAgICAgICB2YXIgbmVzdGluZyA9IChzZWxmLiQkbmVzdGluZyB8fCBbXSkuY29uY2F0KCRPYmplY3QpLFxyXG4gICAgICAgICAgICBjb25zdGFudCwgY29uc3RhbnRzID0ge30sXHJcbiAgICAgICAgICAgIGksIGlpO1xyXG5cclxuICAgICAgICBmb3IoaSA9IDAsIGlpID0gbmVzdGluZy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XHJcbiAgICAgICAgICBmb3IgKGNvbnN0YW50IGluIG5lc3RpbmdbaV0uJCRjb25zdCkge1xyXG4gICAgICAgICAgICBjb25zdGFudHNbY29uc3RhbnRdID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGNvbnN0YW50cyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIE9wYWwuY29uc3RhbnRzKHNlbGYsIGluaGVyaXQpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHNlbGYubmVzdGluZ1xyXG4gICAgYHNlbGYuJCRuZXN0aW5nIHx8IFtdYFxyXG4gIGVuZFxyXG5cclxuICAjIGNoZWNrIGZvciBjb25zdGFudCB3aXRoaW4gY3VycmVudCBzY29wZVxyXG4gICMgaWYgaW5oZXJpdCBpcyB0cnVlIG9yIHNlbGYgaXMgT2JqZWN0LCB3aWxsIGFsc28gY2hlY2sgYW5jZXN0b3JzXHJcbiAgZGVmIGNvbnN0X2RlZmluZWQ/KG5hbWUsIGluaGVyaXQgPSB0cnVlKVxyXG4gICAgbmFtZSA9IE9wYWwuY29uc3RfbmFtZSEobmFtZSlcclxuXHJcbiAgICA6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvci5uZXcoXCJ3cm9uZyBjb25zdGFudCBuYW1lICN7bmFtZX1cIiwgbmFtZSkgdW5sZXNzIG5hbWUgPX4gOjpPcGFsOjpDT05TVF9OQU1FX1JFR0VYUFxyXG5cclxuICAgICV4e1xyXG4gICAgICB2YXIgbW9kdWxlLCBtb2R1bGVzID0gW3NlbGZdLCBtb2R1bGVfY29uc3RhbnRzLCBpLCBpaTtcclxuXHJcbiAgICAgIC8vIEFkZCB1cCBhbmNlc3RvcnMgaWYgaW5oZXJpdCBpcyB0cnVlXHJcbiAgICAgIGlmIChpbmhlcml0KSB7XHJcbiAgICAgICAgbW9kdWxlcyA9IG1vZHVsZXMuY29uY2F0KE9wYWwuYW5jZXN0b3JzKHNlbGYpKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIE9iamVjdCdzIGFuY2VzdG9ycyBpZiBpdCdzIGEgbW9kdWxlIOKAkyBtb2R1bGVzIGhhdmUgbm8gYW5jZXN0b3JzIG90aGVyd2lzZVxyXG4gICAgICAgIGlmIChzZWxmLiQkaXNfbW9kdWxlKSB7XHJcbiAgICAgICAgICBtb2R1bGVzID0gbW9kdWxlcy5jb25jYXQoWyRPYmplY3RdKS5jb25jYXQoT3BhbC5hbmNlc3RvcnMoJE9iamVjdCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChpID0gMCwgaWkgPSBtb2R1bGVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcclxuICAgICAgICBtb2R1bGUgPSBtb2R1bGVzW2ldO1xyXG4gICAgICAgIGlmIChtb2R1bGUuJCRjb25zdFsje25hbWV9XSAhPSBudWxsKSB7IHJldHVybiB0cnVlOyB9XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgbW9kdWxlLiQkYXV0b2xvYWQgJiZcclxuICAgICAgICAgIG1vZHVsZS4kJGF1dG9sb2FkWyN7bmFtZX1dICYmXHJcbiAgICAgICAgICAhbW9kdWxlLiQkYXV0b2xvYWRbI3tuYW1lfV0ucmVxdWlyZWQgJiZcclxuICAgICAgICAgICFtb2R1bGUuJCRhdXRvbG9hZFsje25hbWV9XS5zdWNjZXNzXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGNvbnN0X2dldChuYW1lLCBpbmhlcml0ID0gdHJ1ZSlcclxuICAgIG5hbWUgPSBPcGFsLmNvbnN0X25hbWUhKG5hbWUpXHJcblxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChuYW1lLmluZGV4T2YoJzo6JykgPT09IDAgJiYgbmFtZSAhPT0gJzo6Jyl7XHJcbiAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiBgbmFtZS5pbmRleE9mKCc6OicpICE9IC0xICYmIG5hbWUgIT0gJzo6J2BcclxuICAgICAgcmV0dXJuIG5hbWUuc3BsaXQoJzo6JykuaW5qZWN0KHNlbGYpIHsgfG8sIGN8IG8uY29uc3RfZ2V0KGMpIH1cclxuICAgIGVuZFxyXG5cclxuICAgIDo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLm5ldyhcIndyb25nIGNvbnN0YW50IG5hbWUgI3tuYW1lfVwiLCBuYW1lKSB1bmxlc3MgbmFtZSA9fiA6Ok9wYWw6OkNPTlNUX05BTUVfUkVHRVhQXHJcblxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChpbmhlcml0KSB7XHJcbiAgICAgICAgcmV0dXJuIE9wYWwuJCQoW3NlbGZdLCBuYW1lKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gT3BhbC5jb25zdF9nZXRfbG9jYWwoc2VsZiwgbmFtZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGNvbnN0X21pc3NpbmcobmFtZSlcclxuICAgIGZ1bGxfY29uc3RfbmFtZSA9IHNlbGYgPT0gOjpPYmplY3QgPyBuYW1lIDogXCIje3NlbGZ9Ojoje25hbWV9XCJcclxuXHJcbiAgICA6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvci5uZXcoXCJ1bmluaXRpYWxpemVkIGNvbnN0YW50ICN7ZnVsbF9jb25zdF9uYW1lfVwiLCBuYW1lKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgY29uc3Rfc2V0KG5hbWUsIHZhbHVlKVxyXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXHJcblxyXG4gICAgbmFtZSA9IDo6T3BhbC5jb25zdF9uYW1lIShuYW1lKVxyXG5cclxuICAgIGlmIG5hbWUgIX4gOjpPcGFsOjpDT05TVF9OQU1FX1JFR0VYUCB8fCBuYW1lLnN0YXJ0X3dpdGg/KCc6OicpXHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLm5ldyhcIndyb25nIGNvbnN0YW50IG5hbWUgI3tuYW1lfVwiLCBuYW1lKVxyXG4gICAgZW5kXHJcblxyXG4gICAgYCRjb25zdF9zZXQoc2VsZiwgbmFtZSwgdmFsdWUpYFxyXG5cclxuICAgIHZhbHVlXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBwdWJsaWNfY29uc3RhbnQoY29uc3RfbmFtZSlcclxuICBlbmRcclxuXHJcbiAgZGVmIGRlZmluZV9tZXRob2QobmFtZSwgbWV0aG9kID0gdW5kZWZpbmVkLCAmYmxvY2spXHJcbiAgICAleHtcclxuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcclxuXHJcbiAgICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCAmJiBibG9jayA9PT0gbmlsKVxyXG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY3JlYXRlIGEgUHJvYyBvYmplY3Qgd2l0aG91dCBhIGJsb2NrJ31cclxuXHJcbiAgICAgIG5hbWUgPSBlbnN1cmVfc3ltYm9sX29yX3N0cmluZyhuYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiBgbWV0aG9kICE9PSB1bmRlZmluZWRgXHJcbiAgICAgIGJsb2NrID0gY2FzZSBtZXRob2RcclxuICAgICAgICAgICAgICB3aGVuIDo6UHJvY1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kXHJcblxyXG4gICAgICAgICAgICAgIHdoZW4gOjpNZXRob2RcclxuICAgICAgICAgICAgICAgIGAje21ldGhvZC50b19wcm9jfS4kJHVuYm91bmRgXHJcblxyXG4gICAgICAgICAgICAgIHdoZW4gOjpVbmJvdW5kTWV0aG9kXHJcbiAgICAgICAgICAgICAgICBgT3BhbC53cmFwX21ldGhvZF9ib2R5KG1ldGhvZC4kJG1ldGhvZClgXHJcblxyXG4gICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3ttZXRob2QuY2xhc3N9IChleHBlY3RlZCBQcm9jL01ldGhvZC9VbmJvdW5kTWV0aG9kKVwiXHJcbiAgICAgICAgICAgICAgZW5kXHJcblxyXG4gICAgICBpZiBgIW1ldGhvZC4kJGlzX3Byb2NgXHJcbiAgICAgICAgb3duZXIgPSBtZXRob2Qub3duZXJcclxuICAgICAgICBpZiBgb3duZXIuJCRpc19jbGFzc2AgJiYgIShzZWxmIDw9IG93bmVyKSAjIHJ1Ym9jb3A6ZGlzYWJsZSBTdHlsZS9JbnZlcnNlTWV0aG9kc1xyXG4gICAgICAgICAgbWVzc2FnZSA9IGBvd25lci4kJGlzX3NpbmdsZXRvbmAgPyBcImNhbid0IGJpbmQgc2luZ2xldG9uIG1ldGhvZCB0byBhIGRpZmZlcmVudCBjbGFzc1wiIDogXCJiaW5kIGFyZ3VtZW50IG11c3QgYmUgYSBzdWJjbGFzcyBvZiAje293bmVyfVwiXHJcbiAgICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgbWVzc2FnZVxyXG4gICAgICAgIGVuZFxyXG4gICAgICBlbmRcclxuICAgIGVuZFxyXG5cclxuICAgICV4e1xyXG4gICAgICBpZiAodHlwZW9mKFByb3h5KSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICB2YXIgbWV0YSA9IE9iamVjdC5jcmVhdGUobnVsbClcclxuXHJcbiAgICAgICAgYmxvY2suJCRwcm94eV90YXJnZXQgPSBibG9ja1xyXG4gICAgICAgIGJsb2NrID0gbmV3IFByb3h5KGJsb2NrLCB7XHJcbiAgICAgICAgICBhcHBseTogZnVuY3Rpb24odGFyZ2V0LCBzZWxmLCBhcmdzKSB7XHJcbiAgICAgICAgICAgIHZhciBvbGRfbmFtZSA9IHRhcmdldC4kJGpzaWQsIG9sZF9sYW1iZGEgPSB0YXJnZXQuJCRpc19sYW1iZGE7XHJcbiAgICAgICAgICAgIHRhcmdldC4kJGpzaWQgPSBuYW1lO1xyXG4gICAgICAgICAgICB0YXJnZXQuJCRpc19sYW1iZGEgPSB0cnVlO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoc2VsZiwgYXJncyk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgIGlmIChlID09PSB0YXJnZXQuJCRicmsgfHwgZSA9PT0gdGFyZ2V0LiQkcmV0KSByZXR1cm4gZS4kdjtcclxuICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgIHRhcmdldC4kJGpzaWQgPSBvbGRfbmFtZTtcclxuICAgICAgICAgICAgICB0YXJnZXQuJCRpc19sYW1iZGEgPSBvbGRfbGFtYmRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG5cclxuICAgICAgYmxvY2suJCRqc2lkICAgICAgICA9IG5hbWU7XHJcbiAgICAgIGJsb2NrLiQkcyAgICAgICAgICAgPSBudWxsO1xyXG4gICAgICBibG9jay4kJGRlZiAgICAgICAgID0gYmxvY2s7XHJcbiAgICAgIGJsb2NrLiQkZGVmaW5lX21ldGggPSB0cnVlO1xyXG5cclxuICAgICAgcmV0dXJuIE9wYWwuZGVmbihzZWxmLCAkanNpZChuYW1lKSwgYmxvY2spO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZnJlZXplXHJcbiAgICAjIFNwZWNpYWxpemVkIHZlcnNpb24gb2YgZnJlZXplLCBiZWNhdXNlIHRoZSAkJGJhc2VfbW9kdWxlIHByb3BlcnR5IG5lZWRzIHRvIGJlXHJcbiAgICAjIGFjY2Vzc2libGUgZGVzcGl0ZSB0aGUgZnJvemVuIHN0YXR1c1xyXG5cclxuICAgIHJldHVybiBzZWxmIGlmIGZyb3plbj9cclxuXHJcbiAgICAleHtcclxuICAgICAgaWYgKCFzZWxmLmhhc093blByb3BlcnR5KCckJGJhc2VfbW9kdWxlJykpIHsgJHByb3Aoc2VsZiwgJyQkYmFzZV9tb2R1bGUnLCBudWxsKTsgfVxyXG5cclxuICAgICAgcmV0dXJuICRmcmVlemUoc2VsZik7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiByZW1vdmVfbWV0aG9kKCpuYW1lcylcclxuICAgICV4e1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIG5hbWUgPSBlbnN1cmVfc3ltYm9sX29yX3N0cmluZyhuYW1lc1tpXSk7XHJcbiAgICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcclxuXHJcbiAgICAgICAgT3BhbC5yZGVmKHNlbGYsIFwiJFwiICsgbmFtZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzaW5nbGV0b25fY2xhc3M/XHJcbiAgICBgISFzZWxmLiQkaXNfc2luZ2xldG9uYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgaW5jbHVkZSgqbW9kcylcclxuICAgICV4e1xyXG4gICAgICBmb3IgKHZhciBpID0gbW9kcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIHZhciBtb2QgPSBtb2RzW2ldO1xyXG5cclxuICAgICAgICBpZiAoIW1vZC4kJGlzX21vZHVsZSkge1xyXG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7YG1vZGAuY2xhc3N9IChleHBlY3RlZCBNb2R1bGUpXCJ9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI3tgbW9kYC5hcHBlbmRfZmVhdHVyZXMgc2VsZn07XHJcbiAgICAgICAgI3tgbW9kYC5pbmNsdWRlZCBzZWxmfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNlbGZcclxuICBlbmRcclxuXHJcbiAgZGVmIGluY2x1ZGVkX21vZHVsZXNcclxuICAgIGBPcGFsLmluY2x1ZGVkX21vZHVsZXMoc2VsZilgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBpbmNsdWRlPyhtb2QpXHJcbiAgICAleHtcclxuICAgICAgaWYgKCFtb2QuJCRpc19tb2R1bGUpIHtcclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tgbW9kYC5jbGFzc30gKGV4cGVjdGVkIE1vZHVsZSlcIn07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBpLCBpaSwgbW9kMiwgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMoc2VsZik7XHJcblxyXG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XHJcbiAgICAgICAgbW9kMiA9IGFuY2VzdG9yc1tpXTtcclxuICAgICAgICBpZiAobW9kMiA9PT0gbW9kICYmIG1vZDIgIT09IHNlbGYpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgaW5zdGFuY2VfbWV0aG9kKG5hbWUpXHJcbiAgICAleHtcclxuICAgICAgdmFyIG1ldGggPSBzZWxmLiQkcHJvdG90eXBlWyRqc2lkKG5hbWUpXTtcclxuXHJcbiAgICAgIGlmICghbWV0aCB8fCBtZXRoLiQkc3R1Yikge1xyXG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpOYW1lRXJyb3IubmV3KFwidW5kZWZpbmVkIG1ldGhvZCBgI3tuYW1lfScgZm9yIGNsYXNzIGAje3NlbGYubmFtZX0nXCIsIG5hbWUpfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuICN7OjpVbmJvdW5kTWV0aG9kLm5ldyhzZWxmLCBgbWV0aC4kJG93bmVyIHx8ICN7c2VsZn1gLCBgbWV0aGAsIG5hbWUpfTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGluc3RhbmNlX21ldGhvZHMoaW5jbHVkZV9zdXBlciA9IHRydWUpXHJcbiAgICAleHtcclxuICAgICAgaWYgKCR0cnV0aHkoI3tpbmNsdWRlX3N1cGVyfSkpIHtcclxuICAgICAgICByZXR1cm4gT3BhbC5pbnN0YW5jZV9tZXRob2RzKHNlbGYpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBPcGFsLm93bl9pbnN0YW5jZV9tZXRob2RzKHNlbGYpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBpbmNsdWRlZChtb2QpXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBleHRlbmRlZChtb2QpXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBleHRlbmRfb2JqZWN0KG9iamVjdClcclxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKG9iamVjdClgXHJcbiAgICBuaWxcclxuICBlbmRcclxuXHJcbiAgZGVmIG1ldGhvZF9hZGRlZCgqKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgbWV0aG9kX3JlbW92ZWQoKilcclxuICBlbmRcclxuXHJcbiAgZGVmIG1ldGhvZF91bmRlZmluZWQoKilcclxuICBlbmRcclxuXHJcbiAgZGVmIG1vZHVsZV9ldmFsKCphcmdzLCAmYmxvY2spXHJcbiAgICBpZiBibG9jay5uaWw/ICYmIGAhIU9wYWwuY29tcGlsZWBcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMS4uMyknIHVubGVzcyAoMS4uMykuY292ZXI/IGFyZ3Muc2l6ZVxyXG5cclxuICAgICAgc3RyaW5nLCBmaWxlLCBfbGluZW5vID0gKmFyZ3NcclxuICAgICAgZGVmYXVsdF9ldmFsX29wdGlvbnMgPSB7IGZpbGU6IGZpbGUgfHwgJyhldmFsKScsIGV2YWw6IHRydWUgfVxyXG4gICAgICBjb21waWxpbmdfb3B0aW9ucyA9IF9fT1BBTF9DT01QSUxFUl9DT05GSUdfXy5tZXJnZShkZWZhdWx0X2V2YWxfb3B0aW9ucylcclxuICAgICAgY29tcGlsZWQgPSA6Ok9wYWwuY29tcGlsZSBzdHJpbmcsIGNvbXBpbGluZ19vcHRpb25zXHJcbiAgICAgIGJsb2NrID0gOjpLZXJuZWwucHJvYyBkb1xyXG4gICAgICAgICV4e25ldyBGdW5jdGlvbihcIk9wYWwsc2VsZlwiLCBcInJldHVybiBcIiArIGNvbXBpbGVkKShPcGFsLCBzZWxmKX1cclxuICAgICAgZW5kXHJcbiAgICBlbHNpZiBhcmdzLmFueT9cclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YXJncy5zaXplfSBmb3IgMClcIiBcXFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuXFxuICBOT1RFOklmIHlvdSB3YW50IHRvIGVuYWJsZSBwYXNzaW5nIGEgU3RyaW5nIGFyZ3VtZW50IHBsZWFzZSBhZGQgXFxcInJlcXVpcmUgJ29wYWwtcGFyc2VyJ1xcXCIgdG8geW91ciBzY3JpcHRcXG5cIlxyXG4gICAgZW5kXHJcblxyXG4gICAgJXh7XHJcbiAgICAgIHZhciBvbGQgPSBibG9jay4kJHMsXHJcbiAgICAgICAgICByZXN1bHQ7XHJcblxyXG4gICAgICBibG9jay4kJHMgPSBudWxsO1xyXG4gICAgICByZXN1bHQgPSBibG9jay5hcHBseShzZWxmLCBbc2VsZl0pO1xyXG4gICAgICBibG9jay4kJHMgPSBvbGQ7XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgbW9kdWxlX2V4ZWMoKmFyZ3MsICZibG9jaylcclxuICAgICV4e1xyXG4gICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xyXG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpMb2NhbEp1bXBFcnJvciwgJ25vIGJsb2NrIGdpdmVuJ31cclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGJsb2NrX3NlbGYgPSBibG9jay4kJHMsIHJlc3VsdDtcclxuXHJcbiAgICAgIGJsb2NrLiQkcyA9IG51bGw7XHJcbiAgICAgIHJlc3VsdCA9IGJsb2NrLmFwcGx5KHNlbGYsIGFyZ3MpO1xyXG4gICAgICBibG9jay4kJHMgPSBibG9ja19zZWxmO1xyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIG1ldGhvZF9kZWZpbmVkPyhtZXRob2QpXHJcbiAgICAleHtcclxuICAgICAgdmFyIGJvZHkgPSBzZWxmLiQkcHJvdG90eXBlWyRqc2lkKG1ldGhvZCldO1xyXG4gICAgICByZXR1cm4gKCEhYm9keSkgJiYgIWJvZHkuJCRzdHViO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgbW9kdWxlX2Z1bmN0aW9uKCptZXRob2RzKVxyXG4gICAgJXh7XHJcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XHJcblxyXG4gICAgICBpZiAobWV0aG9kcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBzZWxmLiQkbW9kdWxlX2Z1bmN0aW9uID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gbmlsO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBtZXRob2RzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICB2YXIgbWV0aCA9IG1ldGhvZHNbaV0sXHJcbiAgICAgICAgICAgICAgaWQgICA9ICRqc2lkKG1ldGgpLFxyXG4gICAgICAgICAgICAgIGZ1bmMgPSBzZWxmLiQkcHJvdG90eXBlW2lkXTtcclxuXHJcbiAgICAgICAgICBPcGFsLmRlZnMoc2VsZiwgaWQsIGZ1bmMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWV0aG9kcy5sZW5ndGggPT09IDEgPyBtZXRob2RzWzBdIDogbWV0aG9kcztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBuYW1lXHJcbiAgICAleHtcclxuICAgICAgaWYgKHNlbGYuJCRmdWxsX25hbWUpIHtcclxuICAgICAgICByZXR1cm4gc2VsZi4kJGZ1bGxfbmFtZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHJlc3VsdCA9IFtdLCBiYXNlID0gc2VsZjtcclxuXHJcbiAgICAgIHdoaWxlIChiYXNlKSB7XHJcbiAgICAgICAgLy8gR2l2ZSB1cCBpZiBhbnkgb2YgdGhlIGFuY2VzdG9ycyBpcyB1bm5hbWVkXHJcbiAgICAgICAgaWYgKGJhc2UuJCRuYW1lID09PSBuaWwgfHwgYmFzZS4kJG5hbWUgPT0gbnVsbCkgcmV0dXJuIG5pbDtcclxuXHJcbiAgICAgICAgcmVzdWx0LnVuc2hpZnQoYmFzZS4kJG5hbWUpO1xyXG5cclxuICAgICAgICBiYXNlID0gYmFzZS4kJGJhc2VfbW9kdWxlO1xyXG5cclxuICAgICAgICBpZiAoYmFzZSA9PT0gJE9iamVjdCkge1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBuaWw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzZWxmLiQkZnVsbF9uYW1lID0gcmVzdWx0LmpvaW4oJzo6Jyk7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBwcmVwZW5kKCptb2RzKVxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChtb2RzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoZ2l2ZW4gMCwgZXhwZWN0ZWQgMSspJ31cclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IG1vZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICB2YXIgbW9kID0gbW9kc1tpXTtcclxuXHJcbiAgICAgICAgaWYgKCFtb2QuJCRpc19tb2R1bGUpIHtcclxuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2Btb2RgLmNsYXNzfSAoZXhwZWN0ZWQgTW9kdWxlKVwifTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICN7YG1vZGAucHJlcGVuZF9mZWF0dXJlcyBzZWxmfTtcclxuICAgICAgICAje2Btb2RgLnByZXBlbmRlZCBzZWxmfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNlbGZcclxuICBlbmRcclxuXHJcbiAgZGVmIHByZXBlbmRfZmVhdHVyZXMocHJlcGVuZGVyKVxyXG4gICAgJXh7XHJcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3MocHJlcGVuZGVyKTtcclxuXHJcbiAgICAgIGlmICghc2VsZi4kJGlzX21vZHVsZSkge1xyXG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje3NlbGYuY2xhc3N9IChleHBlY3RlZCBNb2R1bGUpXCJ9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBPcGFsLnByZXBlbmRfZmVhdHVyZXMoc2VsZiwgcHJlcGVuZGVyKVxyXG4gICAgfVxyXG4gICAgc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgcHJlcGVuZGVkKG1vZClcclxuICBlbmRcclxuXHJcbiAgZGVmIHJlbW92ZV9jb25zdChuYW1lKVxyXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXHJcblxyXG4gICAgYE9wYWwuY29uc3RfcmVtb3ZlKHNlbGYsIG5hbWUpYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgdG9fc1xyXG4gICAgYE9wYWwuTW9kdWxlLiRuYW1lLmNhbGwoc2VsZilgIHx8IFwiIzwje2BzZWxmLiQkaXNfbW9kdWxlID8gJ01vZHVsZScgOiAnQ2xhc3MnYH06MHgje19faWRfXy50b19zKDE2KX0+XCJcclxuICBlbmRcclxuXHJcbiAgZGVmIHVuZGVmX21ldGhvZCgqbmFtZXMpXHJcbiAgICAleHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBuYW1lID0gZW5zdXJlX3N5bWJvbF9vcl9zdHJpbmcobmFtZXNbaV0pO1xyXG4gICAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XHJcblxyXG4gICAgICAgIE9wYWwudWRlZihzZWxmLCBcIiRcIiArIG5hbWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXHJcbiAgICBjb25zdHMgPSBjb25zdGFudHNcclxuICAgICV4e1xyXG4gICAgICB2YXIgcmVzdWx0ID0gW107XHJcblxyXG4gICAgICAkZWFjaF9pdmFyKHNlbGYsIGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICBpZiAobmFtZSAhPT0gJ2NvbnN0cnVjdG9yJyAmJiAhI3tjb25zdHMuaW5jbHVkZT8oYG5hbWVgKX0pIHtcclxuICAgICAgICAgIHJlc3VsdC5wdXNoKCdAJyArIG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICAleHtcclxuICAgIGZ1bmN0aW9uIGNvcHlJbnN0YW5jZU1ldGhvZHMoZnJvbSwgdG8pIHtcclxuICAgICAgdmFyIGksIG1ldGhvZF9uYW1lcyA9IE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMoZnJvbSk7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtZXRob2RfbmFtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgbmFtZSA9IG1ldGhvZF9uYW1lc1tpXSxcclxuICAgICAgICAgICAganNpZCA9ICRqc2lkKG5hbWUpLFxyXG4gICAgICAgICAgICBib2R5ID0gZnJvbS4kJHByb3RvdHlwZVtqc2lkXSxcclxuICAgICAgICAgICAgd3JhcHBlZCA9IE9wYWwud3JhcF9tZXRob2RfYm9keShib2R5KTtcclxuXHJcbiAgICAgICAgd3JhcHBlZC4kJGpzaWQgPSBuYW1lO1xyXG4gICAgICAgIE9wYWwuZGVmbih0bywganNpZCwgd3JhcHBlZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb3B5SW5jbHVkZWRNb2R1bGVzKGZyb20sIHRvKSB7XHJcbiAgICAgIHZhciBtb2R1bGVzID0gZnJvbS4kJG93bl9pbmNsdWRlZF9tb2R1bGVzO1xyXG4gICAgICBmb3IgKHZhciBpID0gbW9kdWxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIE9wYWwuYXBwZW5kX2ZlYXR1cmVzKG1vZHVsZXNbaV0sIHRvKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvcHlQcmVwZW5kZWRNb2R1bGVzKGZyb20sIHRvKSB7XHJcbiAgICAgIHZhciBtb2R1bGVzID0gZnJvbS4kJG93bl9wcmVwZW5kZWRfbW9kdWxlcztcclxuICAgICAgZm9yICh2YXIgaSA9IG1vZHVsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBPcGFsLnByZXBlbmRfZmVhdHVyZXMobW9kdWxlc1tpXSwgdG8pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkZWYgaW5pdGlhbGl6ZV9jb3B5KG90aGVyKVxyXG4gICAgJXh7XHJcbiAgICAgIGNvcHlJbnN0YW5jZU1ldGhvZHMob3RoZXIsIHNlbGYpO1xyXG4gICAgICBjb3B5SW5jbHVkZWRNb2R1bGVzKG90aGVyLCBzZWxmKTtcclxuICAgICAgY29weVByZXBlbmRlZE1vZHVsZXMob3RoZXIsIHNlbGYpO1xyXG4gICAgICBzZWxmLiQkY2xvbmVkX2Zyb20gPSBvdGhlci4kJGNsb25lZF9mcm9tLmNvbmNhdChvdGhlcik7XHJcbiAgICB9XHJcbiAgICBjb3B5X2NsYXNzX3ZhcmlhYmxlcyhvdGhlcilcclxuICAgIGNvcHlfY29uc3RhbnRzKG90aGVyKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgaW5pdGlhbGl6ZV9kdXAob3RoZXIpXHJcbiAgICBzdXBlclxyXG4gICAgIyBVbmxpa2Ugb3RoZXIgY2xhc3NlcywgTW9kdWxlJ3Mgc2luZ2xldG9uIG1ldGhvZHMgYXJlIGNvcGllZCBvbiBPYmplY3QjZHVwLlxyXG4gICAgY29weV9zaW5nbGV0b25fbWV0aG9kcyhvdGhlcilcclxuICBlbmRcclxuXHJcbiAgZGVmIGNvcHlfY2xhc3NfdmFyaWFibGVzKG90aGVyKVxyXG4gICAgJXh7XHJcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gb3RoZXIuJCRjdmFycykge1xyXG4gICAgICAgIHNlbGYuJCRjdmFyc1tuYW1lXSA9IG90aGVyLiQkY3ZhcnNbbmFtZV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGNvcHlfY29uc3RhbnRzKG90aGVyKVxyXG4gICAgJXh7XHJcbiAgICAgIHZhciBuYW1lLCBvdGhlcl9jb25zdGFudHMgPSBvdGhlci4kJGNvbnN0O1xyXG5cclxuICAgICAgZm9yIChuYW1lIGluIG90aGVyX2NvbnN0YW50cykge1xyXG4gICAgICAgICRjb25zdF9zZXQoc2VsZiwgbmFtZSwgb3RoZXJfY29uc3RhbnRzW25hbWVdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgcmVmaW5lKGtsYXNzLCAmYmxvY2spXHJcbiAgICByZWZpbmVtZW50X21vZHVsZSwgbSwga2xhc3NfaWQgPSBzZWxmLCBuaWwsIG5pbFxyXG4gICAgJXh7XHJcbiAgICAgIGtsYXNzX2lkID0gT3BhbC5pZChrbGFzcyk7XHJcbiAgICAgIGlmICh0eXBlb2Ygc2VsZi4kJHJlZmluZV9tb2R1bGVzID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgc2VsZi4kJHJlZmluZV9tb2R1bGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZW9mIHNlbGYuJCRyZWZpbmVfbW9kdWxlc1trbGFzc19pZF0gPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICBtID0gc2VsZi4kJHJlZmluZV9tb2R1bGVzW2tsYXNzX2lkXSA9ICN7OjpSZWZpbmVtZW50Lm5ld307XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgbSA9IHNlbGYuJCRyZWZpbmVfbW9kdWxlc1trbGFzc19pZF07XHJcbiAgICAgIH1cclxuICAgICAgbS5yZWZpbmVtZW50X21vZHVsZSA9IHJlZmluZW1lbnRfbW9kdWxlXHJcbiAgICAgIG0ucmVmaW5lZF9jbGFzcyA9IGtsYXNzXHJcbiAgICB9XHJcbiAgICBtLmNsYXNzX2V4ZWMoJmJsb2NrKVxyXG4gICAgbVxyXG4gIGVuZFxyXG5cclxuICBkZWYgcmVmaW5lbWVudHNcclxuICAgICV4e1xyXG4gICAgICB2YXIgcmVmaW5lX21vZHVsZXMgPSBzZWxmLiQkcmVmaW5lX21vZHVsZXMsIGhhc2ggPSAje3t9fTs7XHJcbiAgICAgIGlmICh0eXBlb2YgcmVmaW5lX21vZHVsZXMgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBoYXNoO1xyXG4gICAgICBmb3IgKHZhciBpZCBpbiByZWZpbmVfbW9kdWxlcykge1xyXG4gICAgICAgIGhhc2hbJyRbXT0nXShyZWZpbmVfbW9kdWxlc1tpZF0ucmVmaW5lZF9jbGFzcywgcmVmaW5lX21vZHVsZXNbaWRdKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gaGFzaDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgIyBDb21waWxlciBvdmVycmlkZXMgdGhpcyBtZXRob2RcclxuICBkZWYgdXNpbmcobW9kKVxyXG4gICAgOjpLZXJuZWwucmFpc2UgJ01vZHVsZSN1c2luZyBpcyBub3QgcGVybWl0dGVkIGluIG1ldGhvZHMnXHJcbiAgZW5kXHJcblxyXG4gIGFsaWFzIGNsYXNzX2V2YWwgbW9kdWxlX2V2YWxcclxuICBhbGlhcyBjbGFzc19leGVjIG1vZHVsZV9leGVjXHJcbiAgYWxpYXMgaW5zcGVjdCB0b19zXHJcbmVuZFxyXG5cclxuY2xhc3MgOjpSZWZpbmVtZW50IDwgOjpNb2R1bGVcclxuICBhdHRyX3JlYWRlciA6cmVmaW5lZF9jbGFzc1xyXG5cclxuICBkZWYgaW5zcGVjdFxyXG4gICAgaWYgQHJlZmluZW1lbnRfbW9kdWxlXHJcbiAgICAgIFwiIzxyZWZpbmVtZW50OiN7QHJlZmluZWRfY2xhc3MuaW5zcGVjdH1AI3tAcmVmaW5lbWVudF9tb2R1bGUuaW5zcGVjdH0+XCJcclxuICAgIGVsc2VcclxuICAgICAgc3VwZXJcclxuICAgIGVuZFxyXG4gIGVuZFxyXG5lbmRcclxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6TW9kdWxlPiIsIk9wYWwiLCJ0cnlfY29udmVydCIsIlN0cmluZyIsIktlcm5lbCIsInJhaXNlIiwiVHlwZUVycm9yIiwiY2xhc3MiLCJhbGxvY2F0ZSIsInNlbGYiLCJpbml0aWFsaXplIiwiYmxvY2tfZ2l2ZW4/IiwibW9kdWxlX2V2YWwiLCJibG9jayIsInRvX3Byb2MiLCI9PT0iLCJvYmplY3QiLCI8Iiwib3RoZXIiLCJNb2R1bGUiLCI8PSIsIiRyZXRfb3JfMSIsImVxdWFsPyIsIj4iLCI+PSIsIjw9PiIsImx0IiwibmlsPyIsIi0xIiwiMSIsImFsaWFzX21ldGhvZCIsIm5ld25hbWUiLCJvbGRuYW1lIiwiYWxpYXNfbmF0aXZlIiwibWlkIiwianNpZCIsImFuY2VzdG9ycyIsImFwcGVuZF9mZWF0dXJlcyIsImluY2x1ZGVyIiwiYXR0cl9hY2Nlc3NvciIsImF0dHJfcmVhZGVyIiwibmFtZXMiLCJhdHRyX3dyaXRlciIsImF0dHIiLCJ3YXJuIiwiYXJncyIsImF1dG9sb2FkIiwiY29uc3QkIiwicGF0aCIsImNvbnN0X25hbWU/IiwiTmFtZUVycm9yIiwiQXJndW1lbnRFcnJvciIsImF1dG9sb2FkPyIsImNsYXNzX3ZhcmlhYmxlcyIsImNsYXNzX3ZhcmlhYmxlX2dldCIsIm5hbWUiLCJjbGFzc192YXJpYWJsZV9uYW1lISIsImNsYXNzX3ZhcmlhYmxlX3NldCIsInZhbHVlIiwiY2xhc3NfdmFyaWFibGVfZGVmaW5lZD8iLCJjb25zdF9hZGRlZCIsInByaXN0aW5lIiwicmVtb3ZlX2NsYXNzX3ZhcmlhYmxlIiwiY29uc3RhbnRzIiwiaW5oZXJpdCIsIm5lc3RpbmciLCJjb25zdF9kZWZpbmVkPyIsImNvbnN0X25hbWUhIiwiPX4iLCJPcGFsOjpDT05TVF9OQU1FX1JFR0VYUCIsIm5ldyIsImNvbnN0X2dldCIsImluamVjdCIsInNwbGl0IiwiYmxvY2sgaW4gY29uc3RfZ2V0IiwibyIsImMiLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbnN0X2dldCIsImNvbnN0X21pc3NpbmciLCJmdWxsX2NvbnN0X25hbWUiLCJPYmplY3QiLCJjb25zdF9zZXQiLCIhfiIsInN0YXJ0X3dpdGg/IiwicHVibGljX2NvbnN0YW50IiwiZGVmaW5lX21ldGhvZCIsIm1ldGhvZCIsIlByb2MiLCJNZXRob2QiLCJVbmJvdW5kTWV0aG9kIiwib3duZXIiLCJtZXNzYWdlIiwiZnJlZXplIiwiZnJvemVuPyIsInJlbW92ZV9tZXRob2QiLCJzaW5nbGV0b25fY2xhc3M/IiwiaW5jbHVkZSIsImluY2x1ZGVkIiwiaW5jbHVkZWRfbW9kdWxlcyIsImluY2x1ZGU/IiwibW9kIiwiaW5zdGFuY2VfbWV0aG9kIiwiaW5zdGFuY2VfbWV0aG9kcyIsImluY2x1ZGVfc3VwZXIiLCJleHRlbmRlZCIsImV4dGVuZF9vYmplY3QiLCJtZXRob2RfYWRkZWQiLCJtZXRob2RfcmVtb3ZlZCIsIm1ldGhvZF91bmRlZmluZWQiLCIzIiwiY292ZXI/Iiwic2l6ZSIsInN0cmluZyIsImZpbGUiLCJfbGluZW5vIiwiZGVmYXVsdF9ldmFsX29wdGlvbnMiLCJjb21waWxpbmdfb3B0aW9ucyIsIl9fT1BBTF9DT01QSUxFUl9DT05GSUdfXyIsIm1lcmdlIiwiY29tcGlsZWQiLCJjb21waWxlIiwicHJvYyIsImJsb2NrIGluIG1vZHVsZV9ldmFsIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBtb2R1bGVfZXZhbCIsImFueT8iLCJtb2R1bGVfZXhlYyIsIkxvY2FsSnVtcEVycm9yIiwibWV0aG9kX2RlZmluZWQ/IiwibW9kdWxlX2Z1bmN0aW9uIiwicHJlcGVuZCIsInByZXBlbmRfZmVhdHVyZXMiLCJwcmVwZW5kZWQiLCJwcmVwZW5kZXIiLCJyZW1vdmVfY29uc3QiLCJ0b19zIiwiX19pZF9fIiwiMTYiLCJ1bmRlZl9tZXRob2QiLCJpbnN0YW5jZV92YXJpYWJsZXMiLCJjb25zdHMiLCJpbml0aWFsaXplX2NvcHkiLCJjb3B5X2NsYXNzX3ZhcmlhYmxlcyIsImNvcHlfY29uc3RhbnRzIiwiaW5pdGlhbGl6ZV9kdXAiLCJjb3B5X3NpbmdsZXRvbl9tZXRob2RzIiwicmVmaW5lIiwia2xhc3MiLCJyZWZpbmVtZW50X21vZHVsZSIsIm0iLCJrbGFzc19pZCIsIlJlZmluZW1lbnQiLCJjbGFzc19leGVjIiwicmVmaW5lbWVudHMiLCJ1c2luZyIsIjxjbGFzczpSZWZpbmVtZW50PiIsImluc3BlY3QiLCJAcmVmaW5lbWVudF9tb2R1bGUiLCJAcmVmaW5lZF9jbGFzcyJdLCJtYXBwaW5ncyI6IkFBQUFBLGlDQUFBQSxnQkFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBOztFQUlBQztFQUFBQTs7SUFBQUE7Ozs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsMkJBQTZCQyxLQUFNQyxhQUFBQSxDQUFj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bUJBQUFBO0FBQUFBLE1BQUFBOztNQUFBQTtNQUNFLElBQUEsUUFBR0Msc0JBQUgsQ0FBQTtRQUNFRCxPQUFDQSxlQUFELEdBQUEsTUFBZ0JFLGtCQUFjRixTQUFBQSxDQUFBQSxDQUE5QixDQUFBLEdBQXVDQSxHQUF2QyxHQUFBLE1BQTBDQyxzQkFBa0JELFNBQUFBLENBQUFBLENBQTVELENBQUEsR0FBcUVBO01BRHZFO1FBR0VBLE9BQUEsT0FBQWxKLElBQUEsRUFBQSxvREFBQSxXQUFBLEVBQUEsRUFBQSxFQUFBLE1BQUE7TUFIRjtJQURGa0osQ0FBQUE7RUFIRkQsR0FBTSxJQUFOQSxFQUFxQnZJLE9BQXJCdUk7QUE5MUJBM0o7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQ1MTIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2NsYXNzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxyXG4jIHVzZV9zdHJpY3Q6IHRydWVcclxuXHJcbnJlcXVpcmUgJ2NvcmVsaWIvbW9kdWxlJ1xyXG5cclxuY2xhc3MgOjpDbGFzc1xyXG4gIGRlZiBzZWxmLm5ldyhzdXBlcmNsYXNzID0gT2JqZWN0LCAmYmxvY2spXHJcbiAgICAleHtcclxuICAgICAgaWYgKCFzdXBlcmNsYXNzLiQkaXNfY2xhc3MpIHtcclxuICAgICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwic3VwZXJjbGFzcyBtdXN0IGJlIGEgQ2xhc3NcIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBrbGFzcyA9IE9wYWwuYWxsb2NhdGVfY2xhc3MobmlsLCBzdXBlcmNsYXNzKTtcclxuICAgICAgc3VwZXJjbGFzcy4kaW5oZXJpdGVkKGtsYXNzKTtcclxuICAgICAgI3tga2xhc3NgLmNsYXNzX2V2YWwoJmJsb2NrKSBpZiBibG9ja19naXZlbj99XHJcbiAgICAgIHJldHVybiBrbGFzcztcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGFsbG9jYXRlXHJcbiAgICAleHtcclxuICAgICAgdmFyIG9iaiA9IG5ldyBzZWxmLiQkY29uc3RydWN0b3IoKTtcclxuICAgICAgb2JqLiQkaWQgPSBPcGFsLnVpZCgpO1xyXG4gICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgY2xvbmUoZnJlZXplOiBuaWwpXHJcbiAgICB1bmxlc3MgZnJlZXplLm5pbD8gfHwgZnJlZXplID09IHRydWUgfHwgZnJlZXplID09IGZhbHNlXHJcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwidW5leHBlY3RlZCB2YWx1ZSBmb3IgZnJlZXplOiAje2ZyZWV6ZS5jbGFzc31cIlxyXG4gICAgZW5kXHJcblxyXG4gICAgY29weSA9IGBPcGFsLmFsbG9jYXRlX2NsYXNzKG5pbCwgc2VsZi4kJHN1cGVyKWBcclxuICAgIGNvcHkuY29weV9pbnN0YW5jZV92YXJpYWJsZXMoc2VsZilcclxuICAgIGNvcHkuY29weV9zaW5nbGV0b25fbWV0aG9kcyhzZWxmKVxyXG4gICAgY29weS5pbml0aWFsaXplX2Nsb25lKHNlbGYsIGZyZWV6ZTogZnJlZXplKVxyXG5cclxuICAgIGlmIGZyZWV6ZSA9PSB0cnVlIHx8IChmcmVlemUubmlsPyAmJiBmcm96ZW4/KVxyXG4gICAgICBjb3B5LmZyZWV6ZVxyXG4gICAgZW5kXHJcblxyXG4gICAgY29weVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZHVwXHJcbiAgICBjb3B5ID0gYE9wYWwuYWxsb2NhdGVfY2xhc3MobmlsLCBzZWxmLiQkc3VwZXIpYFxyXG5cclxuICAgIGNvcHkuY29weV9pbnN0YW5jZV92YXJpYWJsZXMoc2VsZilcclxuICAgIGNvcHkuaW5pdGlhbGl6ZV9kdXAoc2VsZilcclxuXHJcbiAgICBjb3B5XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBkZXNjZW5kYW50c1xyXG4gICAgc3ViY2xhc3NlcyArIHN1YmNsYXNzZXMubWFwKCY6ZGVzY2VuZGFudHMpLmZsYXR0ZW5cclxuICBlbmRcclxuXHJcbiAgZGVmIGluaGVyaXRlZChjbHMpXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBuZXcoKmFyZ3MsICZibG9jaylcclxuICAgICV4e1xyXG4gICAgICB2YXIgb2JqZWN0ID0gI3thbGxvY2F0ZX07XHJcbiAgICAgIE9wYWwuc2VuZChvYmplY3QsIG9iamVjdC4kaW5pdGlhbGl6ZSwgYXJncywgYmxvY2spO1xyXG4gICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc3ViY2xhc3Nlc1xyXG4gICAgJXh7XHJcbiAgICAgIGlmICh0eXBlb2YgV2Vha1JlZiAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICB2YXIgaSwgc3ViY2xhc3MsIG91dCA9IFtdO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWxmLiQkc3ViY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgc3ViY2xhc3MgPSBzZWxmLiQkc3ViY2xhc3Nlc1tpXS5kZXJlZigpO1xyXG4gICAgICAgICAgaWYgKHN1YmNsYXNzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb3V0LnB1c2goc3ViY2xhc3MpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBzZWxmLiQkc3ViY2xhc3NlcztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc3VwZXJjbGFzc1xyXG4gICAgYHNlbGYuJCRzdXBlciB8fCBuaWxgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiB0b19zXHJcbiAgICAleHtcclxuICAgICAgdmFyIHNpbmdsZXRvbl9vZiA9IHNlbGYuJCRzaW5nbGV0b25fb2Y7XHJcblxyXG4gICAgICBpZiAoc2luZ2xldG9uX29mICYmIHNpbmdsZXRvbl9vZi4kJGlzX2FfbW9kdWxlKSB7XHJcbiAgICAgICAgcmV0dXJuICN7XCIjPENsYXNzOiN7YHNpbmdsZXRvbl9vZmAubmFtZX0+XCJ9O1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKHNpbmdsZXRvbl9vZikge1xyXG4gICAgICAgIC8vIGEgc2luZ2xldG9uIGNsYXNzIGNyZWF0ZWQgZnJvbSBhbiBvYmplY3RcclxuICAgICAgICByZXR1cm4gI3tcIiM8Q2xhc3M6Izwje2BzaW5nbGV0b25fb2YuJCRjbGFzc2AubmFtZX06MHgje2BPcGFsLmlkKHNpbmdsZXRvbl9vZilgLnRvX3MoMTYpfT4+XCJ9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gI3tzdXBlcigpfTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGF0dGFjaGVkX29iamVjdFxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChzZWxmLiQkc2luZ2xldG9uX29mICE9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gc2VsZi4kJHNpbmdsZXRvbl9vZjtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImAje3NlbGZ9JyBpcyBub3QgYSBzaW5nbGV0b24gY2xhc3NcIn1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBhbGlhcyBpbnNwZWN0IHRvX3NcclxuZW5kXHJcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6Q2xhc3M+IiwibmV3Iiwic3VwZXJjbGFzcyIsIk9iamVjdCIsImJsb2NrX2dpdmVuPyIsImNsYXNzX2V2YWwiLCJibG9jayIsInRvX3Byb2MiLCJhbGxvY2F0ZSIsImNsb25lIiwiJGt3YXJncyIsImZyZWV6ZSIsIm5pbD8iLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJjbGFzcyIsImNvcHkiLCJjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyIsImNvcHlfc2luZ2xldG9uX21ldGhvZHMiLCJpbml0aWFsaXplX2Nsb25lIiwiZnJvemVuPyIsImR1cCIsImluaXRpYWxpemVfZHVwIiwiZGVzY2VuZGFudHMiLCIrIiwic3ViY2xhc3NlcyIsIm1hcCIsImZsYXR0ZW4iLCJpbmhlcml0ZWQiLCJ0b19zIiwibmFtZSIsIjE2IiwiYXR0YWNoZWRfb2JqZWN0IiwiS2VybmVsIiwiVHlwZUVycm9yIl0sIm1hcHBpbmdzIjoiQUFBQUEsZ0NBQUFBLGdCQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7O0VBR0FDLElBQUFDLFNBQUFBLENBQVFGLGdCQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7OztJQUNFQyxNQUFJSCxJQUFKRyxVQUFBQSxzQkFBYUMsVUFBYkQ7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFBYSxxQ0FBYUU7O0FBRTVCRjtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUEsTUFBUSxDQUE4QkcsZUFBOUIsR0FBQSxDQUFPQyxNQUFQSixDQUFDQSxLQUFEQSxDQUFPSSxjQUFBQSxFQUFBQSxFQUFBQSxFQUFhQyxLQUFEQyxTQUFBQSxDQUFBQSxDQUFaRixDQUFQLElBQUEsR0FBQTtBQUNSSjtBQUNBQTtJQVZFQSxDQUFBQSxJQUFBQTs7QUFhQU8sSUFBQUEsd0JBQUFBLG9CQUFBQTtBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBTEVBLENBQUFBOztBQVFBQyxJQUFBQSxxQkFBQUEsaUJBM0JGQyxPQTJCRUQ7QUFBQUEsTUFBQUE7OztNQTNCRjs7TUEyQlksc0NBQUEsNkJBQVE7TUFDaEIsS0FBTyxDQUFBLENBQUEsUUFBQUUsTUFBTUMsU0FBQUEsQ0FBQUEsQ0FBTixDQUFBLElBQUEsQ0FBQSxNQUFlRCxNQUFmLEVBQXlCLElBQXpCLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBQSxNQUFpQ0EsTUFBakMsRUFBMkMsS0FBM0MsQ0FBQSxDQUFBLENBQVA7UUFDRWIsSUFBQWUsT0FBQUEsQ0FBTUMsbUJBQU4sRUFBc0JMLCtCQUFELEdBQUEsTUFBZ0NFLE1BQU1JLE9BQUFBLENBQUFBLENB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b2Zmc2V0Ijp7ImxpbmUiOjQ2NjgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2Jhc2ljX29iamVjdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIHVzZV9zdHJpY3Q6IHRydWVcclxuIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXHJcblxyXG5jbGFzcyA6OkJhc2ljT2JqZWN0XHJcbiAgZGVmIGluaXRpYWxpemUoKilcclxuICBlbmRcclxuXHJcbiAgZGVmID09KG90aGVyKVxyXG4gICAgYHNlbGYgPT09IG90aGVyYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgZXFsPyhvdGhlcilcclxuICAgIHNlbGYgPT0gb3RoZXJcclxuICBlbmRcclxuXHJcbiAgYWxpYXMgZXF1YWw/ID09XHJcblxyXG4gIGRlZiBfX2lkX19cclxuICAgICV4e1xyXG4gICAgICBpZiAoc2VsZi4kJGlkICE9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gc2VsZi4kJGlkO1xyXG4gICAgICB9XHJcbiAgICAgIE9wYWwucHJvcChzZWxmLCAnJCRpZCcsIE9wYWwudWlkKCkpO1xyXG4gICAgICByZXR1cm4gc2VsZi4kJGlkO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgX19zZW5kX18oc3ltYm9sLCAqYXJncywgJmJsb2NrKVxyXG4gICAgJXh7XHJcbiAgICAgIGlmICghc3ltYm9sLiQkaXNfc3RyaW5nKSB7XHJcbiAgICAgICAgI3tyYWlzZSA6OlR5cGVFcnJvciwgXCIje2luc3BlY3R9IGlzIG5vdCBhIHN5bWJvbCBub3IgYSBzdHJpbmdcIn1cclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGZ1bmMgPSBzZWxmW09wYWwuanNpZChzeW1ib2wpXTtcclxuXHJcbiAgICAgIGlmIChmdW5jKSB7XHJcbiAgICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcclxuICAgICAgICAgIGZ1bmMuJCRwID0gYmxvY2s7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseShzZWxmLCBhcmdzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcclxuICAgICAgICBzZWxmLiRtZXRob2RfbWlzc2luZy4kJHAgPSBibG9jaztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHNlbGYuJG1ldGhvZF9taXNzaW5nLmFwcGx5KHNlbGYsIFtzeW1ib2xdLmNvbmNhdChhcmdzKSk7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiAhXHJcbiAgICBmYWxzZVxyXG4gIGVuZFxyXG4gIDo6T3BhbC5wcmlzdGluZSA6IVxyXG5cclxuICBkZWYgIT0ob3RoZXIpXHJcbiAgICAhKHNlbGYgPT0gb3RoZXIpXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBpbnN0YW5jZV9ldmFsKCphcmdzLCAmYmxvY2spXHJcbiAgICBpZiBibG9jay5uaWw/ICYmIGAhIU9wYWwuY29tcGlsZWBcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMS4uMyknIHVubGVzcyAoMS4uMykuY292ZXI/IGFyZ3Muc2l6ZVxyXG5cclxuICAgICAgc3RyaW5nLCBmaWxlLCBfbGluZW5vID0gKmFyZ3NcclxuICAgICAgZGVmYXVsdF9ldmFsX29wdGlvbnMgPSB7IGZpbGU6IGZpbGUgfHwgJyhldmFsKScsIGV2YWw6IHRydWUgfVxyXG4gICAgICBjb21waWxpbmdfb3B0aW9ucyA9IF9fT1BBTF9DT01QSUxFUl9DT05GSUdfXy5tZXJnZShkZWZhdWx0X2V2YWxfb3B0aW9ucylcclxuICAgICAgY29tcGlsZWQgPSA6Ok9wYWwuY29tcGlsZSBzdHJpbmcsIGNvbXBpbGluZ19vcHRpb25zXHJcbiAgICAgIGJsb2NrID0gOjpLZXJuZWwucHJvYyBkb1xyXG4gICAgICAgICV4e25ldyBGdW5jdGlvbihcIk9wYWwsc2VsZlwiLCBcInJldHVybiBcIiArIGNvbXBpbGVkKShPcGFsLCBzZWxmKX1cclxuICAgICAgZW5kXHJcbiAgICBlbHNpZiBibG9jay5uaWw/ICYmIGFyZ3MubGVuZ3RoID49IDEgJiYgYXJncy5maXJzdFswXSA9PSAnQCdcclxuICAgICAgIyBnZXQgaW5zdGFuY2UgdmFyaWFibGVcclxuICAgICAgcmV0dXJuIGluc3RhbmNlX3ZhcmlhYmxlX2dldChhcmdzLmZpcnN0KVxyXG4gICAgZWxzaWYgYXJncy5hbnk/XHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2FyZ3Muc2l6ZX0gZm9yIDApXCJcclxuICAgIGVuZFxyXG5cclxuICAgICV4e1xyXG4gICAgICB2YXIgb2xkID0gYmxvY2suJCRzLFxyXG4gICAgICAgICAgcmVzdWx0O1xyXG5cclxuICAgICAgYmxvY2suJCRzID0gbnVsbDtcclxuXHJcbiAgICAgIC8vIE5lZWQgdG8gcGFzcyAkJGV2YWwgc28gdGhhdCBtZXRob2QgZGVmaW5pdGlvbnMga25vdyBpZiB0aGlzIGlzXHJcbiAgICAgIC8vIGJlaW5nIGRvbmUgb24gYSBjbGFzcy9tb2R1bGUuIENhbm5vdCBiZSBjb21waWxlciBkcml2ZW4gc2luY2VcclxuICAgICAgLy8gc2VuZCg6aW5zdGFuY2VfZXZhbCkgbmVlZHMgdG8gd29yay5cclxuICAgICAgaWYgKHNlbGYuJCRpc19hX21vZHVsZSkge1xyXG4gICAgICAgIHNlbGYuJCRldmFsID0gdHJ1ZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgcmVzdWx0ID0gYmxvY2suY2FsbChzZWxmLCBzZWxmKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICBzZWxmLiQkZXZhbCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICByZXN1bHQgPSBibG9jay5jYWxsKHNlbGYsIHNlbGYpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBibG9jay4kJHMgPSBvbGQ7XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgaW5zdGFuY2VfZXhlYygqYXJncywgJmJsb2NrKVxyXG4gICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbm8gYmxvY2sgZ2l2ZW4nIHVubGVzcyBibG9ja1xyXG5cclxuICAgICV4e1xyXG4gICAgICB2YXIgYmxvY2tfc2VsZiA9IGJsb2NrLiQkcyxcclxuICAgICAgICAgIHJlc3VsdDtcclxuXHJcbiAgICAgIGJsb2NrLiQkcyA9IG51bGw7XHJcblxyXG4gICAgICBpZiAoc2VsZi4kJGlzX2FfbW9kdWxlKSB7XHJcbiAgICAgICAgc2VsZi4kJGV2YWwgPSB0cnVlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICByZXN1bHQgPSBibG9jay5hcHBseShzZWxmLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICBzZWxmLiQkZXZhbCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICByZXN1bHQgPSBibG9jay5hcHBseShzZWxmLCBhcmdzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYmxvY2suJCRzID0gYmxvY2tfc2VsZjtcclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzaW5nbGV0b25fbWV0aG9kX2FkZGVkKCopXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzaW5nbGV0b25fbWV0aG9kX3JlbW92ZWQoKilcclxuICBlbmRcclxuXHJcbiAgZGVmIHNpbmdsZXRvbl9tZXRob2RfdW5kZWZpbmVkKCopXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBtZXRob2RfbWlzc2luZyhzeW1ib2wsICphcmdzLCAmYmxvY2spXHJcbiAgICBpbnNwZWN0X3Jlc3VsdCA9IDo6T3BhbC5pbnNwZWN0KHNlbGYpXHJcbiAgICA6Oktlcm5lbC5yYWlzZSA6Ok5vTWV0aG9kRXJyb3IubmV3KFxyXG4gICAgICBcInVuZGVmaW5lZCBtZXRob2QgYCN7c3ltYm9sfScgZm9yICN7aW5zcGVjdF9yZXN1bHR9XCIsIHN5bWJvbCwgYXJnc1xyXG4gICAgKSwgbmlsLCA6Oktlcm5lbC5jYWxsZXIoMSlcclxuICBlbmRcclxuXHJcbiAgOjpPcGFsLnByaXN0aW5lKHNlbGYsIDptZXRob2RfbWlzc2luZylcclxuXHJcbiAgZGVmIHJlc3BvbmRfdG9fbWlzc2luZz8obWV0aG9kX25hbWUsIGluY2x1ZGVfYWxsID0gZmFsc2UpXHJcbiAgICBmYWxzZVxyXG4gIGVuZFxyXG5lbmRcclxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6QmFzaWNPYmplY3Q+IiwiaW5pdGlhbGl6ZSIsIj09Iiwib3RoZXIiLCJlcWw/Iiwic2VsZiIsIl9faWRfXyIsIl9fc2VuZF9fIiwic3ltYm9sIiwicmFpc2UiLCJUeXBlRXJyb3IiLCJpbnNwZWN0IiwiISIsIk9wYWwiLCJwcmlzdGluZSIsIiE9IiwiaW5zdGFuY2VfZXZhbCIsImJsb2NrIiwibmlsPyIsIjEiLCIzIiwiY292ZXI/IiwiYXJncyIsInNpemUiLCJLZXJuZWwiLCJBcmd1bWVudEVycm9yIiwic3RyaW5nIiwiZmlsZSIsIl9saW5lbm8iLCJkZWZhdWx0X2V2YWxfb3B0aW9ucyIsIiRyZXRfb3JfMSIsImNvbXBpbGluZ19vcHRpb25zIiwiX19PUEFMX0NPTVBJTEVSX0NPTkZJR19fIiwibWVyZ2UiLCJjb21waWxlZCIsImNvbXBpbGUiLCJwcm9jIiwiYmxvY2sgaW4gaW5zdGFuY2VfZXZhbCIsImJsb2NrICgyIGxldmVscykgaW4gaW5zdGFuY2VfZXZhbCIsIj49IiwibGVuZ3RoIiwiZmlyc3QiLCJbXSIsIjAiLCJpbnN0YW5jZV92YXJpYWJsZV9nZXQiLCJhbnk/IiwiaW5zdGFuY2VfZXhlYyIsInNpbmdsZXRvbl9tZXRob2RfYWRkZWQiLCJzaW5nbGV0b25fbWV0aG9kX3JlbW92ZWQiLCJzaW5nbGV0b25fbWV0aG9kX3VuZGVmaW5lZCIsIm1ldGhvZF9taXNzaW5nIiwiaW5zcGVjdF9yZXN1bHQiLCJOb01ldGhvZEVycm9yIiwibmV3IiwiY2FsbGVyIiwicmVzcG9uZF90b19taXNzaW5nPyIsIm1ldGhvZF9uYW1lIiwiaW5jbHVkZV9hbGwiXSwibWFwcGluZ3MiOiJBQUFBQSx1Q0FBQUEsZ0JBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTtFQUdBQSxPQUFBQztFQUFBQTs7Ozs7QUFDRUMsSUFBQUEsMEJBQUFBLHNCQUpGLEVBSUVBO0FBQUFBLE1BQUFBOzs7TUFKRjtNQUlpQjtNQUpqQkEsT0FBQTtJQUlFQSxDQUFBQSxJQUFBQTs7QUFHQUMsSUFBQUEsa0JBQUFBLCtCQUFPQyxLQUFQRDtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EsY0FBREE7SUFERkEsQ0FBQUE7O0FBSUFFLElBQUFBLG9CQUFBQSxpQ0FBU0QsS0FBVEM7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFDLElBQUtILE9BQUFBLENBQUdDLEtBQUhEO0lBRFBFLENBQUFBO0lBSUEsYUFBTSxRQUFOLEVBQWEsSUFBYjs7QUFFQUUsSUFBQUEsc0JBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBUEVBLENBQUFBOztBQVVBQyxJQUFBQSx3QkFBQUEsb0JBQWFDLE1BQUQsRUEzQmQsRUEyQkVEO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BM0JGO01BMkJ1Qjs7QUFFdkJBO0FBQ0FBLFFBQVVGLElBQUFJLE9BQUFBLENBQU1DLGdCQUFOLEVBQW1CLE1BQUdMLElBQUFNLFNBQUFBLENBQUFBLENBQUgsQ0FBQSxHQUFXSiwrQkFBOUJFO0FBQ1ZGOztBQUVBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7SUFyQkVBLENBQUFBLElBQUFBOztB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Y2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2tlcm5lbC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHRydXRoeSwgY29lcmNlX3RvLCByZXNwb25kX3RvLCBPcGFsLCBkZW55X2Zyb3plbl9hY2Nlc3MsIGZyZWV6ZSwgZnJlZXplX3Byb3BzLCBqc2lkLCBlYWNoX2l2YXIsIHNsaWNlXHJcbiMgdXNlX3N0cmljdDogdHJ1ZVxyXG4jIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcclxuXHJcbm1vZHVsZSA6Oktlcm5lbFxyXG4gIGRlZiA9fihvYmopXHJcbiAgICBmYWxzZVxyXG4gIGVuZFxyXG5cclxuICBkZWYgIX4ob2JqKVxyXG4gICAgIShzZWxmID1+IG9iailcclxuICBlbmRcclxuXHJcbiAgZGVmID09PShvdGhlcilcclxuICAgIG9iamVjdF9pZCA9PSBvdGhlci5vYmplY3RfaWQgfHwgc2VsZiA9PSBvdGhlclxyXG4gIGVuZFxyXG5cclxuICBkZWYgPD0+KG90aGVyKVxyXG4gICAgJXh7XHJcbiAgICAgIC8vIHNldCBndWFyZCBmb3IgaW5maW5pdGUgcmVjdXJzaW9uXHJcbiAgICAgIHNlbGYuJCRjb21wYXJhYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAgIHZhciB4ID0gI3tzZWxmID09IG90aGVyfTtcclxuXHJcbiAgICAgIGlmICh4ICYmIHggIT09IG5pbCkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbmlsO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgbWV0aG9kKG5hbWUpXHJcbiAgICAleHtcclxuICAgICAgdmFyIG1ldGggPSBzZWxmWyRqc2lkKG5hbWUpXTtcclxuXHJcbiAgICAgIGlmIChtZXRoICYmICFtZXRoLiQkc3R1Yikge1xyXG4gICAgICAgIHJldHVybiAjezo6TWV0aG9kLm5ldyhzZWxmLCBgbWV0aC4kJG93bmVyIHx8ICN7c2VsZi5jbGFzc31gLCBgbWV0aGAsIG5hbWUpfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHJlc3BvbmRfdG9fbWlzc2luZyA9IHNlbGZbJyRyZXNwb25kX3RvX21pc3Npbmc/J107XHJcbiAgICAgIGlmIChyZXNwb25kX3RvX21pc3NpbmcuJCRwcmlzdGluZSB8fCAhcmVzcG9uZF90b19taXNzaW5nLmNhbGwoc2VsZiwgbmFtZSwgdHJ1ZSkpIHtcclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLm5ldyhcInVuZGVmaW5lZCBtZXRob2QgYCN7bmFtZX0nIGZvciBjbGFzcyBgI3tzZWxmLmNsYXNzfSdcIiwgbmFtZSl9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBtZXRoID0gZnVuY3Rpb24gd3JhcHBlcigpIHtcclxuICAgICAgICB2YXIgbWV0aG9kX21pc3NpbmcgPSBzZWxmLiRtZXRob2RfbWlzc2luZztcclxuICAgICAgICBpZiAobWV0aG9kX21pc3NpbmcgPT0gbnVsbCkge1xyXG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvci5uZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGAje25hbWV9JyBmb3IgY2xhc3MgYCN7c2VsZi5jbGFzc30nXCIsIG5hbWUpfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWV0aG9kX21pc3NpbmcuJCRwID0gd3JhcHBlci4kJHA7XHJcbiAgICAgICAgcmV0dXJuIG1ldGhvZF9taXNzaW5nLmFwcGx5KHNlbGYsIFtuYW1lXS5jb25jYXQoJHNsaWNlKGFyZ3VtZW50cykpKTtcclxuICAgICAgfTtcclxuICAgICAgbWV0aC4kJHBhcmFtZXRlcnMgPSBbWydyZXN0J11dXHJcbiAgICAgIG1ldGguJCRhcml0eSA9IC0xO1xyXG4gICAgICByZXR1cm4gI3s6Ok1ldGhvZC5uZXcoc2VsZiwgc2VsZi5jbGFzcywgYG1ldGhgLCBuYW1lKX07XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBtZXRob2RzKGFsbCA9IHRydWUpXHJcbiAgICAleHtcclxuICAgICAgaWYgKCR0cnV0aHkoI3thbGx9KSkge1xyXG4gICAgICAgIHJldHVybiBPcGFsLm1ldGhvZHMoc2VsZik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIE9wYWwub3duX21ldGhvZHMoc2VsZik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHB1YmxpY19tZXRob2RzKGFsbCA9IHRydWUpXHJcbiAgICAleHtcclxuICAgICAgaWYgKCR0cnV0aHkoI3thbGx9KSkge1xyXG4gICAgICAgIHJldHVybiBPcGFsLm1ldGhvZHMoc2VsZik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIE9wYWwucmVjZWl2ZXJfbWV0aG9kcyhzZWxmKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgQXJyYXkob2JqZWN0KVxyXG4gICAgJXh7XHJcbiAgICAgIHZhciBjb2VyY2VkO1xyXG5cclxuICAgICAgaWYgKG9iamVjdCA9PT0gbmlsKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAob2JqZWN0LiQkaXNfYXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb2VyY2VkID0gI3s6Ok9wYWwuY29lcmNlX3RvPyhvYmplY3QsIDo6QXJyYXksIDp0b19hcnkpfTtcclxuICAgICAgaWYgKGNvZXJjZWQgIT09IG5pbCkgeyByZXR1cm4gY29lcmNlZDsgfVxyXG5cclxuICAgICAgY29lcmNlZCA9ICN7OjpPcGFsLmNvZXJjZV90bz8ob2JqZWN0LCA6OkFycmF5LCA6dG9fYSl9O1xyXG4gICAgICBpZiAoY29lcmNlZCAhPT0gbmlsKSB7IHJldHVybiBjb2VyY2VkOyB9XHJcblxyXG4gICAgICByZXR1cm4gW29iamVjdF07XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBhdF9leGl0KCZibG9jaylcclxuICAgICRfX2F0X2V4aXRfXyB8fD0gW11cclxuICAgICRfX2F0X2V4aXRfXyA8PCBibG9ja1xyXG4gICAgYmxvY2tcclxuICBlbmRcclxuXHJcbiAgZGVmIGNhbGxlcihzdGFydCA9IDEsIGxlbmd0aCA9IG5pbClcclxuICAgICV4e1xyXG4gICAgICB2YXIgc3RhY2ssIHJlc3VsdDtcclxuXHJcbiAgICAgIHN0YWNrID0gbmV3IEVycm9yKCkuJGJhY2t0cmFjZSgpO1xyXG4gICAgICByZXN1bHQgPSBbXTtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAje3N0YXJ0fSArIDEsIGlpID0gc3RhY2subGVuZ3RoOyBpIDwgaWk7IGkrKykge1xyXG4gICAgICAgIGlmICghc3RhY2tbaV0ubWF0Y2goL3J1bnRpbWVcXC5qcy8pKSB7XHJcbiAgICAgICAgICByZXN1bHQucHVzaChzdGFja1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChsZW5ndGggIT0gbmlsKSByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgbGVuZ3RoKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGNhbGxlcl9sb2NhdGlvbnMoKmFyZ3MpXHJcbiAgICBjYWxsZXIoKmFyZ3MpLm1hcCBkbyB8bG9jfFxyXG4gICAgICA6OlRocmVhZDo6QmFja3RyYWNlOjpMb2NhdGlvbi5uZXcobG9jKVxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBjbGFzc1xyXG4gICAgYHNlbGYuJCRjbGFzc2BcclxuICBlbmRcclxuXHJcbiAgZGVmIGNvcHlfaW5zdGFuY2VfdmFyaWFibGVzKG90aGVyKVxyXG4gICAgJXh7XHJcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3RoZXIpLCBpLCBpaSwgbmFtZTtcclxuICAgICAgZm9yIChpID0gMCwgaWkgPSBrZXlzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcclxuICAgICAgICBuYW1lID0ga2V5c1tpXTtcclxuICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgIT09ICckJyAmJiBvdGhlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgICAgc2VsZltuYW1lXSA9IG90aGVyW25hbWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgY29weV9zaW5nbGV0b25fbWV0aG9kcyhvdGhlcilcclxuICAgICV4e1xyXG4gICAgICB2YXIgaSwgbmFtZSwgbmFtZXMsIGxlbmd0aDtcclxuXHJcbiAgICAgIGlmIChvdGhlci5oYXNPd25Qcm9wZXJ0eSgnJCRtZXRhJykgJiYgb3RoZXIuJCRtZXRhICE9PSBudWxsKSB7XHJcbiAgICAgICAgdmFyIG90aGVyX3NpbmdsZXRvbl9jbGFzcyA9IE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhvdGhlcik7XHJcbiAgICAgICAgdmFyIHNlbGZfc2luZ2xldG9uX2NsYXNzID0gT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKHNlbGYpO1xyXG4gICAgICAgIG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob3RoZXJfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gbmFtZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIG5hbWUgPSBuYW1lc1tpXTtcclxuICAgICAgICAgIGlmIChPcGFsLmlzX21ldGhvZChuYW1lKSkge1xyXG4gICAgICAgICAgICBzZWxmX3NpbmdsZXRvbl9jbGFzcy4kJHByb3RvdHlwZVtuYW1lXSA9IG90aGVyX3NpbmdsZXRvbl9jbGFzcy4kJHByb3RvdHlwZVtuYW1lXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNlbGZfc2luZ2xldG9uX2NsYXNzLiQkY29uc3QgPSBPYmplY3QuYXNzaWduKHt9LCBvdGhlcl9zaW5nbGV0b25fY2xhc3MuJCRjb25zdCk7XHJcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKFxyXG4gICAgICAgICAgc2VsZl9zaW5nbGV0b25fY2xhc3MuJCRwcm90b3R5cGUsXHJcbiAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3RoZXJfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAoaSA9IDAsIG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob3RoZXIpLCBsZW5ndGggPSBuYW1lcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG5hbWUgPSBuYW1lc1tpXTtcclxuICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09ICckJyAmJiBuYW1lLmNoYXJBdCgxKSAhPT0gJyQnICYmIG90aGVyLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgICBzZWxmW25hbWVdID0gb3RoZXJbbmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBjbG9uZShmcmVlemU6IG5pbClcclxuICAgIHVubGVzcyBmcmVlemUubmlsPyB8fCBmcmVlemUgPT0gdHJ1ZSB8fCBmcmVlemUgPT0gZmFsc2VcclxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJ1bmV4cGVjdGVkIHZhbHVlIGZvciBmcmVlemU6ICN7ZnJlZXplLmNsYXNzfVwiXHJcbiAgICBlbmRcclxuXHJcbiAgICBjb3B5ID0gc2VsZi5jbGFzcy5hbGxvY2F0ZVxyXG5cclxuICAgIGNvcHkuY29weV9pbnN0YW5jZV92YXJpYWJsZXMoc2VsZilcclxuICAgIGNvcHkuY29weV9zaW5nbGV0b25fbWV0aG9kcyhzZWxmKVxyXG4gICAgY29weS5pbml0aWFsaXplX2Nsb25lKHNlbGYsIGZyZWV6ZTogZnJlZXplKVxyXG5cclxuICAgIGlmIGZyZWV6ZSA9PSB0cnVlIHx8IChmcmVlemUubmlsPyAmJiBmcm96ZW4/KVxyXG4gICAgICBjb3B5LmZyZWV6ZVxyXG4gICAgZW5kXHJcblxyXG4gICAgY29weVxyXG4gIGVuZFxyXG5cclxuICBkZWYgaW5pdGlhbGl6ZV9jbG9uZShvdGhlciwgZnJlZXplOiBuaWwpXHJcbiAgICBpbml0aWFsaXplX2NvcHkob3RoZXIpXHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBkZWZpbmVfc2luZ2xldG9uX21ldGhvZChuYW1lLCBtZXRob2QgPSB1bmRlZmluZWQsICZibG9jaylcclxuICAgIHNpbmdsZXRvbl9jbGFzcy5kZWZpbmVfbWV0aG9kKG5hbWUsIG1ldGhvZCwgJmJsb2NrKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZHVwXHJcbiAgICBjb3B5ID0gc2VsZi5jbGFzcy5hbGxvY2F0ZVxyXG5cclxuICAgIGNvcHkuY29weV9pbnN0YW5jZV92YXJpYWJsZXMoc2VsZilcclxuICAgIGNvcHkuaW5pdGlhbGl6ZV9kdXAoc2VsZilcclxuXHJcbiAgICBjb3B5XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBpbml0aWFsaXplX2R1cChvdGhlcilcclxuICAgIGluaXRpYWxpemVfY29weShvdGhlcilcclxuICBlbmRcclxuXHJcbiAgZGVmIGVudW1fZm9yKG1ldGhvZCA9IDplYWNoLCAqYXJncywgJmJsb2NrKVxyXG4gICAgOjpFbnVtZXJhdG9yLmZvcihzZWxmLCBtZXRob2QsICphcmdzLCAmYmxvY2spXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBlcXVhbD8ob3RoZXIpXHJcbiAgICBgc2VsZiA9PT0gb3RoZXJgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBleGl0KHN0YXR1cyA9IHRydWUpXHJcbiAgICAkX19hdF9leGl0X18gfHw9IFtdXHJcblxyXG4gICAgdW50aWwgJF9fYXRfZXhpdF9fLmVtcHR5P1xyXG4gICAgICBibG9jayA9ICRfX2F0X2V4aXRfXy5wb3BcclxuICAgICAgYmxvY2suY2FsbFxyXG4gICAgZW5kXHJcblxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChzdGF0dXMuJCRpc19ib29sZWFuKSB7XHJcbiAgICAgICAgc3RhdHVzID0gc3RhdHVzID8gMCA6IDE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3RhdHVzID0gJGNvZXJjZV90byhzdGF0dXMsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIE9wYWwuZXhpdChzdGF0dXMpO1xyXG4gICAgfVxyXG4gICAgbmlsXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBleHRlbmQoKm1vZHMpXHJcbiAgICAleHtcclxuICAgICAgaWYgKG1vZHMubGVuZ3RoID09IDApIHtcclxuICAgICAgICAje3JhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKGdpdmVuIDAsIGV4cGVjdGVkIDErKSd9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XHJcblxyXG4gICAgICB2YXIgc2luZ2xldG9uID0gI3tzaW5nbGV0b25fY2xhc3N9O1xyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IG1vZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICB2YXIgbW9kID0gbW9kc1tpXTtcclxuXHJcbiAgICAgICAgaWYgKCFtb2QuJCRpc19tb2R1bGUpIHtcclxuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2Btb2RgLmNsYXNzfSAoZXhwZWN0ZWQgTW9kdWxlKVwifTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICN7YG1vZGAuYXBwZW5kX2ZlYXR1cmVzIGBzaW5nbGV0b25gfTtcclxuICAgICAgICAje2Btb2RgLmV4dGVuZF9vYmplY3Qgc2VsZn07XHJcbiAgICAgICAgI3tgbW9kYC5leHRlbmRlZCBzZWxmfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNlbGZcclxuICBlbmRcclxuXHJcbiAgZGVmIGZyZWV6ZVxyXG4gICAgcmV0dXJuIHNlbGYgaWYgZnJvemVuP1xyXG5cclxuICAgICV4e1xyXG4gICAgICBpZiAodHlwZW9mKHNlbGYpID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgJGZyZWV6ZV9wcm9wcyhzZWxmKTtcclxuICAgICAgICByZXR1cm4gJGZyZWV6ZShzZWxmKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc2VsZjtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGZyb3plbj9cclxuICAgICV4e1xyXG4gICAgICBzd2l0Y2ggKHR5cGVvZihzZWxmKSkge1xyXG4gICAgICBjYXNlIFwic3RyaW5nXCI6XHJcbiAgICAgIGNhc2UgXCJzeW1ib2xcIjpcclxuICAgICAgY2FzZSBcIm51bWJlclwiOlxyXG4gICAgICBjYXNlIFwiYm9vbGVhblwiOlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICBjYXNlIFwib2JqZWN0XCI6XHJcbiAgICAgICAgcmV0dXJuIChzZWxmLiQkZnJvemVuIHx8IGZhbHNlKTtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGdldHMoKmFyZ3MpXHJcbiAgICAkc3RkaW4uZ2V0cygqYXJncylcclxuICBlbmRcclxuXHJcbiAgZGVmIGhhc2hcclxuICAgIF9faWRfX1xyXG4gIGVuZFxyXG5cclxuICBkZWYgaW5pdGlhbGl6ZV9jb3B5KG90aGVyKVxyXG4gIGVuZFxyXG5cclxuICBgdmFyIGluc3BlY3Rfc3RhY2sgPSBbXWBcclxuXHJcbiAgZGVmIGluc3BlY3RcclxuICAgIGl2cyA9ICcnXHJcbiAgICBpZCA9IF9faWRfX1xyXG4gICAgaWYgYGluc3BlY3Rfc3RhY2tgLmluY2x1ZGU/IGlkXHJcbiAgICAgIGl2cyA9ICcgLi4uJ1xyXG4gICAgZWxzZVxyXG4gICAgICBgaW5zcGVjdF9zdGFja2AgPDwgaWRcclxuICAgICAgcHVzaGVkID0gdHJ1ZVxyXG4gICAgICBpbnN0YW5jZV92YXJpYWJsZXMuZWFjaCBkbyB8aXxcclxuICAgICAgICBpdmFyID0gaW5zdGFuY2VfdmFyaWFibGVfZ2V0KGkpXHJcbiAgICAgICAgaW5zcGVjdCA9IE9wYWwuaW5zcGVjdChpdmFyKVxyXG4gICAgICAgIGl2cyArPSBcIiAje2l9PSN7aW5zcGVjdH1cIlxyXG4gICAgICBlbmRcclxuICAgIGVuZFxyXG4gICAgXCIjPCN7c2VsZi5jbGFzc306MHgje2lkLnRvX3MoMTYpfSN7aXZzfT5cIlxyXG4gIHJlc2N1ZSA9PiBlXHJcbiAgICBcIiM8I3tzZWxmLmNsYXNzfToweCN7aWQudG9fcygxNil9PlwiXHJcbiAgZW5zdXJlXHJcbiAgICBgaW5zcGVjdF9zdGFja2AucG9wIGlmIHB1c2hlZFxyXG4gIGVuZFxyXG5cclxuICBkZWYgaW5zdGFuY2Vfb2Y/KGtsYXNzKVxyXG4gICAgJXh7XHJcbiAgICAgIGlmICgha2xhc3MuJCRpc19jbGFzcyAmJiAha2xhc3MuJCRpc19tb2R1bGUpIHtcclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnY2xhc3Mgb3IgbW9kdWxlIHJlcXVpcmVkJ307XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzZWxmLiQkY2xhc3MgPT09IGtsYXNzO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVfZGVmaW5lZD8obmFtZSlcclxuICAgIG5hbWUgPSA6Ok9wYWwuaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEobmFtZSlcclxuXHJcbiAgICBgT3BhbC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlbGYsIG5hbWUuc3Vic3RyKDEpKWBcclxuICBlbmRcclxuXHJcbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlX2dldChuYW1lKVxyXG4gICAgbmFtZSA9IDo6T3BhbC5pbnN0YW5jZV92YXJpYWJsZV9uYW1lIShuYW1lKVxyXG5cclxuICAgICV4e1xyXG4gICAgICB2YXIgaXZhciA9IHNlbGZbT3BhbC5pdmFyKG5hbWUuc3Vic3RyKDEpKV07XHJcblxyXG4gICAgICByZXR1cm4gaXZhciA9PSBudWxsID8gbmlsIDogaXZhcjtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlX3NldChuYW1lLCB2YWx1ZSlcclxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxyXG5cclxuICAgIG5hbWUgPSA6Ok9wYWwuaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEobmFtZSlcclxuXHJcbiAgICBgc2VsZltPcGFsLml2YXIobmFtZS5zdWJzdHIoMSkpXSA9IHZhbHVlYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgcmVtb3ZlX2luc3RhbmNlX3ZhcmlhYmxlKG5hbWUpXHJcbiAgICBuYW1lID0gOjpPcGFsLmluc3RhbmNlX3ZhcmlhYmxlX25hbWUhKG5hbWUpXHJcblxyXG4gICAgJXh7XHJcbiAgICAgIHZhciBrZXkgPSBPcGFsLml2YXIobmFtZS5zdWJzdHIoMSkpLFxyXG4gICAgICAgICAgdmFsO1xyXG4gICAgICBpZiAoc2VsZi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgdmFsID0gc2VsZltrZXldO1xyXG4gICAgICAgIGRlbGV0ZSBzZWxmW2tleV07XHJcbiAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIDo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLCBcImluc3RhbmNlIHZhcmlhYmxlICN7bmFtZX0gbm90IGRlZmluZWRcIlxyXG4gIGVuZFxyXG5cclxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXHJcbiAgICAleHtcclxuICAgICAgdmFyIHJlc3VsdCA9IFtdLCBuYW1lO1xyXG5cclxuICAgICAgJGVhY2hfaXZhcihzZWxmLCBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgaWYgKG5hbWVbbmFtZS5sZW5ndGgtMV0gPT09ICckJykge1xyXG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgbmFtZS5sZW5ndGggLSAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LnB1c2goJ0AnICsgbmFtZSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIEludGVnZXIodmFsdWUsIGJhc2UgPSB1bmRlZmluZWQsIGV4Y2VwdGlvbjogdHJ1ZSlcclxuICAgICV4e1xyXG4gICAgICB2YXIgaSwgc3RyLCBiYXNlX2RpZ2l0cztcclxuXHJcbiAgICAgIGV4Y2VwdGlvbiA9ICR0cnV0aHkoI3tleGNlcHRpb259KTtcclxuXHJcbiAgICAgIGlmICghdmFsdWUuJCRpc19zdHJpbmcpIHtcclxuICAgICAgICBpZiAoYmFzZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBpZiAoZXhjZXB0aW9uKSB7XHJcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnYmFzZSBzcGVjaWZpZWQgZm9yIG5vbiBzdHJpbmcgdmFsdWUnfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5pbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbHVlID09PSBuaWwpIHtcclxuICAgICAgICAgIGlmIChleGNlcHRpb24pIHtcclxuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0IG5pbCBpbnRvIEludGVnZXJcIn1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuaWw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWx1ZS4kJGlzX251bWJlcikge1xyXG4gICAgICAgICAgaWYgKHZhbHVlID09PSBJbmZpbml0eSB8fCB2YWx1ZSA9PT0gLUluZmluaXR5IHx8IGlzTmFOKHZhbHVlKSkge1xyXG4gICAgICAgICAgICBpZiAoZXhjZXB0aW9uKSB7XHJcbiAgICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkZsb2F0RG9tYWluRXJyb3IsIHZhbHVlfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJldHVybiBuaWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCN7dmFsdWUucmVzcG9uZF90bz8oOnRvX2ludCl9KSB7XHJcbiAgICAgICAgICBpID0gI3t2YWx1ZS50b19pbnR9O1xyXG4gICAgICAgICAgaWYgKE9wYWwuaXNfYShpLCAjezo6SW50ZWdlcn0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoI3t2YWx1ZS5yZXNwb25kX3RvPyg6dG9faSl9KSB7XHJcbiAgICAgICAgICBpID0gI3t2YWx1ZS50b19pfTtcclxuICAgICAgICAgIGlmIChPcGFsLmlzX2EoaSwgI3s6OkludGVnZXJ9KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChleGNlcHRpb24pIHtcclxuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCAje3ZhbHVlLmNsYXNzfSBpbnRvIEludGVnZXJcIn1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIG5pbDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh2YWx1ZSA9PT0gXCIwXCIpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGJhc2UgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGJhc2UgPSAwO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGJhc2UgPSAkY29lcmNlX3RvKGJhc2UsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xyXG4gICAgICAgIGlmIChiYXNlID09PSAxIHx8IGJhc2UgPCAwIHx8IGJhc2UgPiAzNikge1xyXG4gICAgICAgICAgaWYgKGV4Y2VwdGlvbikge1xyXG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhZGl4ICN7YmFzZX1cIn1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuaWw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBzdHIgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLyhcXGQpXyg/PVxcZCkvZywgJyQxJyk7XHJcblxyXG4gICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXihcXHMqWystXT8pKDBbYm9keF0/KS8sIGZ1bmN0aW9uIChfLCBoZWFkLCBmbGFnKSB7XHJcbiAgICAgICAgc3dpdGNoIChmbGFnKSB7XHJcbiAgICAgICAgY2FzZSAnMGInOlxyXG4gICAgICAgICAgaWYgKGJhc2UgPT09IDAgfHwgYmFzZSA9PT0gMikge1xyXG4gICAgICAgICAgICBiYXNlID0gMjtcclxuICAgICAgICAgICAgcmV0dXJuIGhlYWQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBuby1icmVha1xyXG4gICAgICAgIGNhc2UgJzAnOlxyXG4gICAgICAgIGNhc2UgJzBvJzpcclxuICAgICAgICAgIGlmIChiYXNlID09PSAwIHx8IGJhc2UgPT09IDgpIHtcclxuICAgICAgICAgICAgYmFzZSA9IDg7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWFkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gbm8tYnJlYWtcclxuICAgICAgICBjYXNlICcwZCc6XHJcbiAgICAgICAgICBpZiAoYmFzZSA9PT0gMCB8fCBiYXNlID09PSAxMCkge1xyXG4gICAgICAgICAgICBiYXNlID0gMTA7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWFkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gbm8tYnJlYWtcclxuICAgICAgICBjYXNlICcweCc6XHJcbiAgICAgICAgICBpZiAoYmFzZSA9PT0gMCB8fCBiYXNlID09PSAxNikge1xyXG4gICAgICAgICAgICBiYXNlID0gMTY7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWFkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gbm8tYnJlYWtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV4Y2VwdGlvbikge1xyXG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCB2YWx1ZSBmb3IgSW50ZWdlcigpOiBcXFwiI3t2YWx1ZX1cXFwiXCJ9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiBuaWw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGJhc2UgPSAoYmFzZSA9PT0gMCA/IDEwIDogYmFzZSk7XHJcblxyXG4gICAgICBiYXNlX2RpZ2l0cyA9ICcwLScgKyAoYmFzZSA8PSAxMCA/IGJhc2UgLSAxIDogJzlhLScgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDk3ICsgKGJhc2UgLSAxMSkpKTtcclxuXHJcbiAgICAgIGlmICghKG5ldyBSZWdFeHAoJ15cXFxccypbKy1dP1snICsgYmFzZV9kaWdpdHMgKyAnXStcXFxccyokJykpLnRlc3Qoc3RyKSkge1xyXG4gICAgICAgIGlmIChleGNlcHRpb24pIHtcclxuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgdmFsdWUgZm9yIEludGVnZXIoKTogXFxcIiN7dmFsdWV9XFxcIlwifVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gbmlsO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaSA9IHBhcnNlSW50KHN0ciwgYmFzZSk7XHJcblxyXG4gICAgICBpZiAoaXNOYU4oaSkpIHtcclxuICAgICAgICBpZiAoZXhjZXB0aW9uKSB7XHJcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHZhbHVlIGZvciBJbnRlZ2VyKCk6IFxcXCIje3ZhbHVlfVxcXCJcIn1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIG5pbDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBpO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgRmxvYXQodmFsdWUsIGV4Y2VwdGlvbjogdHJ1ZSlcclxuICAgICV4e1xyXG4gICAgICB2YXIgc3RyO1xyXG5cclxuICAgICAgZXhjZXB0aW9uID0gJHRydXRoeSgje2V4Y2VwdGlvbn0pO1xyXG5cclxuICAgICAgaWYgKHZhbHVlID09PSBuaWwpIHtcclxuICAgICAgICBpZiAoZXhjZXB0aW9uKSB7XHJcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgbmlsIGludG8gRmxvYXRcIn1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIG5pbDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh2YWx1ZS4kJGlzX3N0cmluZykge1xyXG4gICAgICAgIHN0ciA9IHZhbHVlLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8oXFxkKV8oPz1cXGQpL2csICckMScpO1xyXG5cclxuICAgICAgICAvL1NwZWNpYWwgY2FzZSBmb3IgaGV4IHN0cmluZ3Mgb25seTpcclxuICAgICAgICBpZiAoL15cXHMqWy0rXT8wW3hYXVswLTlhLWZBLUZdK1xccyokLy50ZXN0KHN0cikpIHtcclxuICAgICAgICAgIHJldHVybiAjezo6S2VybmVsLkludGVnZXIoYHN0cmApfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghL15cXHMqWy0rXT9bMC05XSpcXC4/WzAtOV0rKFtlRV1bLStdP1swLTldKyk/XFxzKiQvLnRlc3Qoc3RyKSkge1xyXG4gICAgICAgICAgaWYgKGV4Y2VwdGlvbikge1xyXG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHZhbHVlIGZvciBGbG9hdCgpOiBcXFwiI3t2YWx1ZX1cXFwiXCJ9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmlsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGV4Y2VwdGlvbikge1xyXG4gICAgICAgIHJldHVybiAjezo6T3BhbC5jb2VyY2VfdG8hKHZhbHVlLCA6OkZsb2F0LCA6dG9fZil9O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAkY29lcmNlX3RvKHZhbHVlLCAjezo6RmxvYXR9LCAndG9fZicpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBIYXNoKGFyZylcclxuICAgIHJldHVybiB7fSBpZiBhcmcubmlsPyB8fCBhcmcgPT0gW11cclxuICAgIHJldHVybiBhcmcgaWYgOjpIYXNoID09PSBhcmdcclxuICAgIDo6T3BhbC5jb2VyY2VfdG8hKGFyZywgOjpIYXNoLCA6dG9faGFzaClcclxuICBlbmRcclxuXHJcbiAgZGVmIGlzX2E/KGtsYXNzKVxyXG4gICAgJXh7XHJcbiAgICAgIGlmICgha2xhc3MuJCRpc19jbGFzcyAmJiAha2xhc3MuJCRpc19tb2R1bGUpIHtcclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnY2xhc3Mgb3IgbW9kdWxlIHJlcXVpcmVkJ307XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBPcGFsLmlzX2Eoc2VsZiwga2xhc3MpO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgaXRzZWxmXHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBsYW1iZGEoJmJsb2NrKVxyXG4gICAgYE9wYWwubGFtYmRhKGJsb2NrKWBcclxuICBlbmRcclxuXHJcbiAgZGVmIGxvYWQoZmlsZSlcclxuICAgIGZpbGUgPSA6Ok9wYWwuY29lcmNlX3RvIShmaWxlLCA6OlN0cmluZywgOnRvX3N0cilcclxuICAgIGBPcGFsLmxvYWQoI3tmaWxlfSlgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBsb29wXHJcbiAgICByZXR1cm4gZW51bV9mb3IoOmxvb3ApIHsgOjpGbG9hdDo6SU5GSU5JVFkgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XHJcblxyXG4gICAgd2hpbGUgdHJ1ZVxyXG4gICAgICBiZWdpblxyXG4gICAgICAgIHlpZWxkXHJcbiAgICAgIHJlc2N1ZSA6OlN0b3BJdGVyYXRpb24gPT4gZVxyXG4gICAgICAgIHJldHVybiBlLnJlc3VsdFxyXG4gICAgICBlbmRcclxuICAgIGVuZFxyXG5cclxuICAgIHNlbGZcclxuICBlbmRcclxuXHJcbiAgZGVmIG5pbD9cclxuICAgIGZhbHNlXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBwcmludGYoKmFyZ3MpXHJcbiAgICByZXR1cm4gaWYgYXJncy5lbXB0eT9cclxuXHJcbiAgICBpbyA9IGBhcmdzWzBdLiQkaXNfc3RyaW5nYCA/ICRzdGRvdXQgOiBhcmdzLnNoaWZ0XHJcbiAgICBpby53cml0ZSBmb3JtYXQoKmFyZ3MpXHJcblxyXG4gICAgbmlsXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBwcm9jKCZibG9jaylcclxuICAgIHVubGVzcyBibG9ja1xyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjcmVhdGUgUHJvYyBvYmplY3Qgd2l0aG91dCBhIGJsb2NrJ1xyXG4gICAgZW5kXHJcblxyXG4gICAgYGJsb2NrLiQkaXNfbGFtYmRhID0gZmFsc2VgXHJcbiAgICBibG9ja1xyXG4gIGVuZFxyXG5cclxuICBkZWYgcHV0cygqc3RycylcclxuICAgICRzdGRvdXQucHV0cygqc3RycylcclxuICBlbmRcclxuXHJcbiAgZGVmIHAoKmFyZ3MpXHJcbiAgICBhcmdzLmVhY2ggeyB8b2JqfCAkc3Rkb3V0LnB1dHMgb2JqLmluc3BlY3QgfVxyXG5cclxuICAgIGFyZ3MubGVuZ3RoIDw9IDEgPyBhcmdzWzBdIDogYXJnc1xyXG4gIGVuZFxyXG5cclxuICBkZWYgcHJpbnQoKnN0cnMpXHJcbiAgICAkc3Rkb3V0LnByaW50KCpzdHJzKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgcmVhZGxpbmUoKmFyZ3MpXHJcbiAgICAkc3RkaW4ucmVhZGxpbmUoKmFyZ3MpXHJcbiAgZW5kXHJcblxyXG4gIGRlZiB3YXJuKCpzdHJzLCB1cGxldmVsOiBuaWwpXHJcbiAgICBpZiB1cGxldmVsXHJcbiAgICAgIHVwbGV2ZWwgPSA6Ok9wYWwuY29lcmNlX3RvISh1cGxldmVsLCA6OkludGVnZXIsIDp0b19zdHIpXHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJuZWdhdGl2ZSBsZXZlbCAoI3t1cGxldmVsfSlcIiBpZiB1cGxldmVsIDwgMFxyXG4gICAgICBsb2NhdGlvbiA9IGNhbGxlcih1cGxldmVsICsgMSwgMSkuZmlyc3QmLnNwbGl0KCc6aW4gYCcpJi5maXJzdFxyXG4gICAgICBsb2NhdGlvbiA9IFwiI3tsb2NhdGlvbn06IFwiIGlmIGxvY2F0aW9uXHJcbiAgICAgIHN0cnMgPSBzdHJzLm1hcCB7IHxzfCBcIiN7bG9jYXRpb259d2FybmluZzogI3tzfVwiIH1cclxuICAgIGVuZFxyXG5cclxuICAgICRzdGRlcnIucHV0cygqc3RycykgdW5sZXNzICRWRVJCT1NFLm5pbD8gfHwgc3Rycy5lbXB0eT9cclxuICBlbmRcclxuXHJcbiAgZGVmIHJhaXNlKGV4Y2VwdGlvbiA9IHVuZGVmaW5lZCwgc3RyaW5nID0gbmlsLCBiYWNrdHJhY2UgPSBuaWwpXHJcbiAgICAleHtcclxuICAgICAgaWYgKGV4Y2VwdGlvbiA9PSBudWxsICYmICN7JCF9ICE9PSBuaWwpIHtcclxuICAgICAgICB0aHJvdyAjeyQhfTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZXhjZXB0aW9uID09IG51bGwpIHtcclxuICAgICAgICBleGNlcHRpb24gPSAjezo6UnVudGltZUVycm9yLm5ldyAnJ307XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoJHJlc3BvbmRfdG8oZXhjZXB0aW9uLCAnJHRvX3N0cicpKSB7XHJcbiAgICAgICAgZXhjZXB0aW9uID0gI3s6OlJ1bnRpbWVFcnJvci5uZXcgZXhjZXB0aW9uLnRvX3N0cn07XHJcbiAgICAgIH1cclxuICAgICAgLy8gdXNpbmcgcmVzcG9uZF90bz8gYW5kIG5vdCBhbiB1bmRlZmluZWQgY2hlY2sgdG8gYXZvaWQgbWV0aG9kX21pc3NpbmcgbWF0Y2hpbmcgYXMgdHJ1ZVxyXG4gICAgICBlbHNlIGlmIChleGNlcHRpb24uJCRpc19jbGFzcyAmJiAkcmVzcG9uZF90byhleGNlcHRpb24sICckZXhjZXB0aW9uJykpIHtcclxuICAgICAgICBleGNlcHRpb24gPSAje2V4Y2VwdGlvbi5leGNlcHRpb24gc3RyaW5nfTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmIChleGNlcHRpb24uJCRpc19leGNlcHRpb24pIHtcclxuICAgICAgICAvLyBleGNlcHRpb24gaXMgZmluZVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGV4Y2VwdGlvbiA9ICN7OjpUeXBlRXJyb3IubmV3ICdleGNlcHRpb24gY2xhc3Mvb2JqZWN0IGV4cGVjdGVkJ307XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChiYWNrdHJhY2UgIT09IG5pbCkge1xyXG4gICAgICAgIGV4Y2VwdGlvbi4kc2V0X2JhY2t0cmFjZShiYWNrdHJhY2UpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoI3skIX0gIT09IG5pbCkge1xyXG4gICAgICAgIE9wYWwuZXhjZXB0aW9ucy5wdXNoKCN7JCF9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgI3skIX0gPSBleGNlcHRpb247XHJcblxyXG4gICAgICB0aHJvdyBleGNlcHRpb247XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiByYW5kKG1heCA9IHVuZGVmaW5lZClcclxuICAgICV4e1xyXG4gICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gI3s6OlJhbmRvbTo6REVGQVVMVC5yYW5kfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG1heC4kJGlzX251bWJlcikge1xyXG4gICAgICAgIGlmIChtYXggPCAwKSB7XHJcbiAgICAgICAgICBtYXggPSBNYXRoLmFicyhtYXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1heCAlIDEgIT09IDApIHtcclxuICAgICAgICAgIG1heCA9IG1heC4kdG9faSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1heCA9PT0gMCkge1xyXG4gICAgICAgICAgbWF4ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgOjpSYW5kb206OkRFRkFVTFQucmFuZChtYXgpXHJcbiAgZW5kXHJcblxyXG4gIGRlZiByZXNwb25kX3RvPyhuYW1lLCBpbmNsdWRlX2FsbCA9IGZhbHNlKVxyXG4gICAgJXh7XHJcbiAgICAgIHZhciBib2R5ID0gc2VsZlskanNpZChuYW1lKV07XHJcblxyXG4gICAgICBpZiAodHlwZW9mKGJvZHkpID09PSBcImZ1bmN0aW9uXCIgJiYgIWJvZHkuJCRzdHViKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzZWxmWyckcmVzcG9uZF90b19taXNzaW5nPyddLiQkcHJpc3RpbmUgPT09IHRydWUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuICN7cmVzcG9uZF90b19taXNzaW5nPyhuYW1lLCBpbmNsdWRlX2FsbCl9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiByZXNwb25kX3RvX21pc3Npbmc/KG1ldGhvZF9uYW1lLCBpbmNsdWRlX2FsbCA9IGZhbHNlKVxyXG4gICAgZmFsc2VcclxuICBlbmRcclxuXHJcbiAgOjpPcGFsLnByaXN0aW5lKHNlbGYsIDpyZXNwb25kX3RvPywgOnJlc3BvbmRfdG9fbWlzc2luZz8pXHJcblxyXG4gIGRlZiByZXF1aXJlKGZpbGUpXHJcbiAgICAleHtcclxuICAgICAgLy8gQXMgT2JqZWN0LnJlcXVpcmUgcmVmZXJzIHRvIEtlcm5lbC5yZXF1aXJlIG9uY2UgS2VybmVsIGhhcyBiZWVuIGxvYWRlZCB0aGUgU3RyaW5nXHJcbiAgICAgIC8vIGNsYXNzIG1heSBub3QgYmUgYXZhaWxhYmxlIHlldCwgdGhlIGNvZXJjaW9uIHJlcXVpcmVzIGJvdGggIFN0cmluZyBhbmQgQXJyYXkgdG8gYmUgbG9hZGVkLlxyXG4gICAgICBpZiAodHlwZW9mICN7ZmlsZX0gIT09ICdzdHJpbmcnICYmIE9wYWwuU3RyaW5nICYmIE9wYWwuQXJyYXkpIHtcclxuICAgICAgICAje2ZpbGUgPSA6Ok9wYWwuY29lcmNlX3RvIShmaWxlLCA6OlN0cmluZywgOnRvX3N0cikgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBPcGFsLnJlcXVpcmUoI3tmaWxlfSlcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHJlcXVpcmVfcmVsYXRpdmUoZmlsZSlcclxuICAgIDo6T3BhbC50cnlfY29udmVydCEoZmlsZSwgOjpTdHJpbmcsIDp0b19zdHIpXHJcbiAgICBmaWxlID0gOjpGaWxlLmV4cGFuZF9wYXRoIDo6RmlsZS5qb2luKGBPcGFsLmN1cnJlbnRfZmlsZWAsICcuLicsIGZpbGUpXHJcblxyXG4gICAgYE9wYWwucmVxdWlyZSgje2ZpbGV9KWBcclxuICBlbmRcclxuXHJcbiAgIyBgcGF0aGAgc2hvdWxkIGJlIHRoZSBmdWxsIHBhdGggdG8gYmUgZm91bmQgaW4gcmVnaXN0ZXJlZCBtb2R1bGVzIChgT3BhbC5tb2R1bGVzYClcclxuICBkZWYgcmVxdWlyZV90cmVlKHBhdGgsIGF1dG9sb2FkOiBmYWxzZSlcclxuICAgICV4e1xyXG4gICAgICB2YXIgcmVzdWx0ID0gW107XHJcblxyXG4gICAgICBwYXRoID0gI3s6OkZpbGUuZXhwYW5kX3BhdGgocGF0aCl9XHJcbiAgICAgIHBhdGggPSBPcGFsLm5vcm1hbGl6ZShwYXRoKTtcclxuICAgICAgaWYgKHBhdGggPT09ICcuJykgcGF0aCA9ICcnO1xyXG4gICAgICBmb3IgKHZhciBuYW1lIGluIE9wYWwubW9kdWxlcykge1xyXG4gICAgICAgIGlmICgje2BuYW1lYC5zdGFydF93aXRoPyhwYXRoKX0pIHtcclxuICAgICAgICAgIGlmKCEje2F1dG9sb2FkfSkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChbbmFtZSwgT3BhbC5yZXF1aXJlKG5hbWUpXSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChbbmFtZSwgdHJ1ZV0pOyAvLyBkbyBub3RoaW5nLCBkZWxlZ2F0ZWQgdG8gYSBhdXRvbG9hZGluZ1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHNpbmdsZXRvbl9jbGFzc1xyXG4gICAgYE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhzZWxmKWBcclxuICBlbmRcclxuXHJcbiAgZGVmIHNsZWVwKHNlY29uZHMgPSBuaWwpXHJcbiAgICAleHtcclxuICAgICAgaWYgKHNlY29uZHMgPT09IG5pbCkge1xyXG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCBOaWxDbGFzcyBpbnRvIHRpbWUgaW50ZXJ2YWxcIn1cclxuICAgICAgfVxyXG4gICAgICBpZiAoIXNlY29uZHMuJCRpc19udW1iZXIpIHtcclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tzZWNvbmRzLmNsYXNzfSBpbnRvIHRpbWUgaW50ZXJ2YWxcIn1cclxuICAgICAgfVxyXG4gICAgICBpZiAoc2Vjb25kcyA8IDApIHtcclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RpbWUgaW50ZXJ2YWwgbXVzdCBiZSBwb3NpdGl2ZSd9XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGdldF90aW1lID0gT3BhbC5nbG9iYWwucGVyZm9ybWFuY2UgP1xyXG4gICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBwZXJmb3JtYW5jZS5ub3coKX0gOlxyXG4gICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBuZXcgRGF0ZSgpfVxyXG5cclxuICAgICAgdmFyIHQgPSBnZXRfdGltZSgpO1xyXG4gICAgICB3aGlsZSAoZ2V0X3RpbWUoKSAtIHQgPD0gc2Vjb25kcyAqIDEwMDApO1xyXG4gICAgICByZXR1cm4gTWF0aC5yb3VuZChzZWNvbmRzKTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHNyYW5kKHNlZWQgPSBSYW5kb20ubmV3X3NlZWQpXHJcbiAgICA6OlJhbmRvbS5zcmFuZChzZWVkKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgU3RyaW5nKHN0cilcclxuICAgIDo6T3BhbC5jb2VyY2VfdG8/KHN0ciwgOjpTdHJpbmcsIDp0b19zdHIpIHx8XHJcbiAgICAgIDo6T3BhbC5jb2VyY2VfdG8hKHN0ciwgOjpTdHJpbmcsIDp0b19zKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgdGFwKCZibG9jaylcclxuICAgIHlpZWxkIHNlbGZcclxuICAgIHNlbGZcclxuICBlbmRcclxuXHJcbiAgZGVmIHRvX3Byb2NcclxuICAgIHNlbGZcclxuICBlbmRcclxuXHJcbiAgZGVmIHRvX3NcclxuICAgIGBPcGFsLmZhbGxiYWNrX3RvX3Moc2VsZilgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBjYXRjaCh0YWcgPSBuaWwpXHJcbiAgICB0YWcgfHw9IDo6T2JqZWN0Lm5ld1xyXG4gICAgeWllbGQodGFnKVxyXG4gIHJlc2N1ZSA6OlVuY2F1Z2h0VGhyb3dFcnJvciA9PiBlXHJcbiAgICByZXR1cm4gZS52YWx1ZSBpZiBlLnRhZyA9PSB0YWdcclxuICAgIDo6S2VybmVsLnJhaXNlXHJcbiAgZW5kXHJcblxyXG4gIGRlZiB0aHJvdyh0YWcsIG9iaiA9IG5pbClcclxuICAgIDo6S2VybmVsLnJhaXNlIDo6VW5jYXVnaHRUaHJvd0Vycm9yLm5ldyh0YWcsIG9iailcclxuICBlbmRcclxuXHJcbiAgIyBiYXNpYyBpbXBsZW1lbnRhdGlvbiBvZiBvcGVuLCBkZWxlZ2F0ZSB0byBGaWxlLm9wZW5cclxuICBkZWYgb3BlbigqYXJncywgJmJsb2NrKVxyXG4gICAgOjpGaWxlLm9wZW4oKmFyZ3MsICZibG9jaylcclxuICBlbmRcclxuXHJcbiAgZGVmIHlpZWxkX3NlbGZcclxuICAgIHJldHVybiBlbnVtX2Zvcig6eWllbGRfc2VsZikgeyAxIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG4gICAgeWllbGQgc2VsZlxyXG4gIGVuZFxyXG5cclxuICBhbGlhcyBmYWlsIHJhaXNlXHJcbiAgYWxpYXMga2luZF9vZj8gaXNfYT9cclxuICBhbGlhcyBvYmplY3RfaWQgX19pZF9fXHJcbiAgYWxpYXMgcHVibGljX3NlbmQgX19zZW5kX19cclxuICBhbGlhcyBzZW5kIF9fc2VuZF9fXHJcbiAgYWxpYXMgdGhlbiB5aWVsZF9zZWxmXHJcbiAgYWxpYXMgdG9fZW51bSBlbnVtX2ZvclxyXG5lbmRcclxuXHJcbmNsYXNzIDo6T2JqZWN0XHJcbiAgIyBPYmplY3QucmVxdWlyZSBoYXMgYmVlbiBzZXQgdG8gcnVudGltZS5qcyBPcGFsLnJlcXVpcmVcclxuICAjIE5vdyB3ZSBoYXZlIEtlcm5lbCBsb2FkZWQsIG1ha2Ugc3VyZSBPYmplY3QucmVxdWlyZSByZWZlcnMgdG8gS2VybmVsLnJlcXVpcmVcclxuICAjIHdoaWNoIGlzIHdoYXQgcnVieSBkb2VzIGFuZCBhbGxvd3MgZm9yIG92ZXJ3cml0aW5nIGJ5IGF1dG9sb2FkZXJzXHJcbiAgYGRlbGV0ZSAkT2JqZWN0LiQkcHJvdG90eXBlLiRyZXF1aXJlYFxyXG4gIGluY2x1ZGUgOjpLZXJuZWxcclxuZW5kXHJcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpLZXJuZWw+IiwiPX4iLCIhfiIsIm9iaiIsInNlbGYiLCIhIiwiPT09Iiwib3RoZXIiLCIkcmV0X29yXzEiLCJvYmplY3RfaWQiLCI9PSIsIjw9PiIsIm1ldGhvZCIsIm5hbWUiLCJNZXRob2QiLCJuZXciLCJjbGFzcyIsIktlcm5lbCIsInJhaXNlIiwiTmFtZUVycm9yIiwibWV0aG9kcyIsImFsbCIsInB1YmxpY19tZXRob2RzIiwiQXJyYXkiLCJvYmplY3QiLCJPcGFsIiwiY29lcmNlX3RvPyIsImF0X2V4aXQiLCIkX19hdF9leGl0X18iLCI8PCIsImJsb2NrIiwiY2FsbGVyIiwic3RhcnQiLCJsZW5ndGgiLCIxIiwiY2FsbGVyX2xvY2F0aW9ucyIsIm1hcCIsImFyZ3MiLCJibG9jayBpbiBjYWxsZXJfbG9jYXRpb25zIiwibG9jIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjYWxsZXJfbG9jYXRpb25zIiwiVGhyZWFkOjpCYWNrdHJhY2U6OkxvY2F0aW9uIiwiVGhyZWFkOjpCYWNrdHJhY2UiLCJUaHJlYWQiLCJjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyIsImNvcHlfc2luZ2xldG9uX21ldGhvZHMiLCJjbG9uZSIsIiRrd2FyZ3MiLCJmcmVlemUiLCJuaWw/IiwiQXJndW1lbnRFcnJvciIsImNvcHkiLCJhbGxvY2F0ZSIsImluaXRpYWxpemVfY2xvbmUiLCJmcm96ZW4/IiwiaW5pdGlhbGl6ZV9jb3B5IiwiZGVmaW5lX3NpbmdsZXRvbl9tZXRob2QiLCJkZWZpbmVfbWV0aG9kIiwic2luZ2xldG9uX2NsYXNzIiwidG9fcHJvYyIsImR1cCIsImluaXRpYWxpemVfZHVwIiwiZW51bV9mb3IiLCJmb3IiLCJFbnVtZXJhdG9yIiwiZXF1YWw/IiwiZXhpdCIsInN0YXR1cyIsImVtcHR5PyIsInBvcCIsImNhbGwiLCJJbnRlZ2VyIiwiZXh0ZW5kIiwiVHlwZUVycm9yIiwiYXBwZW5kX2ZlYXR1cmVzIiwiZXh0ZW5kX29iamVjdCIsImV4dGVuZGVkIiwiZ2V0cyIsIiRzdGRpbiIsImhhc2giLCJfX2lkX18iLCJpbnNwZWN0IiwiaXZzIiwiaWQiLCJpbmNsdWRlPyIsInB1c2hlZCIsImVhY2giLCJpbnN0YW5jZV92YXJpYWJsZXMiLCJibG9jayBpbiBpbnNwZWN0IiwiaSIsImJsb2NrICgyIGxldmVscykgaW4gaW5zcGVjdCIsIml2YXIiLCJpbnN0YW5jZV92YXJpYWJsZV9nZXQiLCIrIiwidG9fcyIsIjE2IiwiU3RhbmRhcmRFcnJvciIsImUiLCJpbnN0YW5jZV9vZj8iLCJrbGFzcyIsImluc3RhbmNlX3ZhcmlhYmxlX2RlZmluZWQ/IiwiaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEiLCJpbnN0YW5jZV92YXJpYWJsZV9zZXQiLCJ2YWx1ZSIsInJlbW92ZV9pbnN0YW5jZV92YXJpYWJsZSIsImV4Y2VwdGlvbiIsIkZsb2F0RG9tYWluRXJyb3IiLCJyZXNwb25kX3RvPyIsInRvX2ludCIsInRvX2kiLCJiYXNlIiwiRmxvYXQiLCJjb2VyY2VfdG8hIiwiSGFzaCIsImFyZyIsImlzX2E/IiwiaXRzZWxmIiwibGFtYmRhIiwibG9hZCIsImZpbGUiLCJTdHJpbmciLCJsb29wIiwiYmxvY2tfZ2l2ZW4/IiwiYmxvY2sgaW4gbG9vcCIsImJsb2NrICgyIGxldmVscykgaW4gbG9vcCIsIkZsb2F0OjpJTkZJTklUWSIsIlN0b3BJdGVyYXRpb24iLCJyZXN1bHQiLCJwcmludGYiLCJpbyIsIiRzdGRvdXQiLCJzaGlmdCIsIndyaXRlIiwiZm9ybWF0IiwicHJvYyIsInB1dHMiLCJzdHJzIiwicCIsImJsb2NrIGluIHAiLCJibG9jayAoMiBsZXZlbHMpIGluIHAiLCI8PSIsIltdIiwiMCIsInByaW50IiwicmVhZGxpbmUiLCJ3YXJuIiwidXBsZXZlbCIsIjwiLCJsb2NhdGlvbiIsImZpcnN0IiwiYmxvY2sgaW4gd2FybiIsInMiLCJibG9jayAoMiBsZXZlbHMpIGluIHdhcm4iLCIkVkVSQk9TRSIsIiRzdGRlcnIiLCJzdHJpbmciLCJiYWNrdHJhY2UiLCIkISIsIlJ1bnRpbWVFcnJvciIsInRvX3N0ciIsInJhbmQiLCJtYXgiLCJSYW5kb206OkRFRkFVTFQiLCJSYW5kb20iLCJpbmNsdWRlX2FsbCIsInJlc3BvbmRfdG9fbWlzc2luZz8iLCJtZXRob2RfbmFtZSIsInByaXN0aW5lIiwicmVxdWlyZSIsInJlcXVpcmVfcmVsYXRpdmUiLCJ0cnlfY29udmVydCEiLCJGaWxlIiwiZXhwYW5kX3BhdGgiLCJqb2luIiwicmVxdWlyZV90cmVlIiwicGF0aCIsInN0YXJ0X3dpdGg/IiwiYXV0b2xvYWQiLCJzbGVlcCIsInNlY29uZHMiLCJzcmFuZCIsInNlZWQiLCJuZXdfc2VlZCIsInN0ciIsInRhcCIsImNhdGNoIiwidGFnIiwiT2JqZWN0IiwiVW5jYXVnaHRUaHJvd0Vycm9yIiwidGhyb3ciLCJvcGVuIiwieWllbGRfc2VsZiIsImJsb2NrIGluIHlpZWxkX3NlbGYiLCI8Y2xhc3M6T2JqZWN0PiIsImluY2x1ZGUiXSwibWFwcGluZ3MiOiJBQUFBQSxpQ0FBQUEsZ0JBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTs7RUFJQUM7RUFBQUE7O0lBQUFBOzs7O0FBQ0VDLElBQUFBLGtCQUFBQSxZQUNFLEtBREZBLENBQUFBOztBQUlBQyxJQUFBQSxrQkFBQUEsK0JBQU9DLEdBQVBEO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFFRSxJQUFLSCxPQUFBQSxDQUFHRSxHQUFIRixDQUFQSSxNQUFBQSxDQUFBQTtJQURGSCxDQUFB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QUFENkIsU0FBQUEsQ0FBQUEsQ0FBYm1JO0lBRFJBLENBQUFBLElBQUFBOztBQUlBQyxJQUFBQSwwQkFBQUEsc0JBQUFBO0FBQUFBLE1BQUFBOztNQUFBQTs7TUFDRSxLQUEwQ3JFLGdCQUExQztRQUFBLE9BQU81RCxNQUFBMUQsSUFBQTBELFlBQUFBLEVBQUFBLENBQVMsWUFBVEEsQ0FBQUEsRUFBQWtJLFlBQXdCOUosQ0FBeEI4SixDQUFBbEk7TUFBUDtNQUNBLE9BQUEsb0JBQU0xRCxJQUFOLENBQUE7SUFGRjJMLENBQUFBO0lBS0EsYUFBTSxNQUFOLEVBQVcsT0FBWDtJQUNBLGFBQU0sVUFBTixFQUFlLE9BQWY7SUFDQSxhQUFNLFdBQU4sRUFBZ0IsUUFBaEI7SUFDQSxhQUFNLGFBQU4sRUFBa0IsVUFBbEI7SUFDQSxhQUFNLE1BQU4sRUFBVyxVQUFYO0lBQ0EsYUFBTSxNQUFOLEVBQVcsWUFBWDtJQUNBL0wsT0FBQSxhQUFNLFNBQU4sRUFBYyxVQUFkO0VBOTFCRkEsR0FBTyxJQUFQQTtFQWkyQkFELE9BQUFrTTtFQUFBQTs7OztJQUlHQTtJQUNEQSxPQUFBN0wsSUFBQThMLFNBQUFBLENBQVFqTCxPQUFSaUw7RUFMRkQsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQXIyQkFsTTsifX0seyJvZmZzZXQiOnsibGluZSI6NjA1NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbWFpbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcclxuXHJcbmNsYXNzIDw8IHNlbGZcclxuICBkZWYgdG9fc1xyXG4gICAgJ21haW4nXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBpbmNsdWRlKG1vZClcclxuICAgIDo6T2JqZWN0LmluY2x1ZGUgbW9kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBhdXRvbG9hZCgqYXJncylcclxuICAgIGBPcGFsLk9iamVjdC4kYXV0b2xvYWQuYXBwbHkoT3BhbC5PYmplY3QsIGFyZ3MpYFxyXG4gIGVuZFxyXG5cclxuICAjIENvbXBpbGVyIG92ZXJyaWRlcyB0aGlzIG1ldGhvZFxyXG4gIGRlZiB1c2luZyhtb2QpXHJcbiAgICA6Oktlcm5lbC5yYWlzZSAnbWFpbi51c2luZyBpcyBwZXJtaXR0ZWQgb25seSBhdCB0b3BsZXZlbCdcclxuICBlbmRcclxuZW5kXHJcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwidG9fcyIsImluY2x1ZGUiLCJtb2QiLCJPYmplY3QiLCJhdXRvbG9hZCIsInVzaW5nIiwiS2VybmVsIiwicmFpc2UiLCJzZWxmIl0sIm1hcHBpbmdzIjoiQUFBQUEsK0JBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQTs7OztBQUNFQyxJQUFBQSxvQkFBQUEsWUFDRSxNQURGQSxDQUFBQTs7QUFJQUMsSUFBQUEsdUJBQUFBLG1CQUFZQyxHQUFaRDtBQUFBQTtNQUNFQSxPQUFBRSxPQUFRRixTQUFBQSxDQUFTQyxHQUFURDtJQURWQSxDQUFBQTs7QUFJQUcsSUFBQUEsd0JBQUFBLG9CQVhGLEVBV0VBO0FBQUFBLE1BQUFBOzs7TUFYRjtNQVdlO01BQ1hBLE9BQUNBLDhDQUFEQTtJQURGQSxDQUFBQSxJQUFBQTtJQUtBLE9BQUFDLHFCQUFBQSxpQkFBVUgsR0FBVkc7QUFBQUE7TUFDRUEsT0FBQUMsT0FBUUMsT0FBQUEsQ0FBT0YsMENBQVBFO0lBRFZGLENBQUFBO0VBZEYsNEJBQVNHLElBQVQ7QUFGQVQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjYwODcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2Vycm9yL2Vycm5vLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxyXG4jIHVzZV9zdHJpY3Q6IHRydWVcclxuXHJcbm1vZHVsZSA6OkVycm5vXHJcbiAgZXJyb3JzID0gW1xyXG4gICAgWzpFSU5WQUwsICdJbnZhbGlkIGFyZ3VtZW50JywgMjJdLFxyXG4gICAgWzpFRVhJU1QsICdGaWxlIGV4aXN0cycsIDE3XSxcclxuICAgIFs6RUlTRElSLCAnSXMgYSBkaXJlY3RvcnknLCAyMV0sXHJcbiAgICBbOkVNRklMRSwgJ1RvbyBtYW55IG9wZW4gZmlsZXMnLCAyNF0sXHJcbiAgICBbOkVTUElQRSwgJ0lsbGVnYWwgc2VlaycsIDI5XSxcclxuICAgIFs6RUFDQ0VTLCAnUGVybWlzc2lvbiBkZW5pZWQnLCAxM10sXHJcbiAgICBbOkVQRVJNLCAnT3BlcmF0aW9uIG5vdCBwZXJtaXR0ZWQnLCAxXSxcclxuICAgIFs6RU5PRU5ULCAnTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeScsIDJdLFxyXG4gICAgWzpFTkFNRVRPT0xPTkcsICdGaWxlIG5hbWUgdG9vIGxvbmcnLCAzNl1cclxuICBdXHJcblxyXG4gIGtsYXNzID0gbmlsXHJcblxyXG4gICV4e1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgZXJyb3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIChmdW5jdGlvbigpIHsgLy8gQ3JlYXRlIGEgY2xvc3VyZVxyXG4gICAgICAgIHZhciBjbGFzc19uYW1lID0gZXJyb3JzW2ldWzBdO1xyXG4gICAgICAgIHZhciBkZWZhdWx0X21lc3NhZ2UgPSBlcnJvcnNbaV1bMV07XHJcbiAgICAgICAgdmFyIGVycm5vID0gZXJyb3JzW2ldWzJdO1xyXG5cclxuICAgICAgICBrbGFzcyA9IE9wYWwua2xhc3Moc2VsZiwgT3BhbC5TeXN0ZW1DYWxsRXJyb3IsIGNsYXNzX25hbWUpO1xyXG4gICAgICAgIGtsYXNzLmVycm5vID0gZXJybm87XHJcblxyXG4gICAgICAgICN7XHJcbiAgICAgICAgICBjbGFzcyA8PCBrbGFzc1xyXG4gICAgICAgICAgICBkZWYgbmV3KG5hbWUgPSBuaWwpXHJcbiAgICAgICAgICAgICAgbWVzc2FnZSA9IGBkZWZhdWx0X21lc3NhZ2VgXHJcbiAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAtICN7bmFtZX1cIiBpZiBuYW1lXHJcbiAgICAgICAgICAgICAgc3VwZXIobWVzc2FnZSlcclxuICAgICAgICAgICAgZW5kXHJcbiAgICAgICAgICBlbmRcclxuICAgICAgICB9XHJcbiAgICAgIH0pKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5lbmRcclxuXHJcbmNsYXNzIDo6U3lzdGVtQ2FsbEVycm9yIDwgOjpTdGFuZGFyZEVycm9yXHJcbiAgZGVmIGVycm5vXHJcbiAgICBzZWxmLmNsYXNzLmVycm5vXHJcbiAgZW5kXHJcblxyXG4gIGNsYXNzIDw8IHNlbGZcclxuICAgIGF0dHJfcmVhZGVyIDplcnJub1xyXG4gIGVuZFxyXG5lbmRcclxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkVycm5vPiIsImVycm9ycyIsIjIyIiwiMTciLCIyMSIsIjI0IiwiMjkiLCIxMyIsIjEiLCIyIiwiMzYiLCJrbGFzcyIsIm5ldyIsIm5hbWUiLCJtZXNzYWdlIiwiKyIsInNlbGYiLCI8Y2xhc3M6U3lzdGVtQ2FsbEVycm9yPiIsImVycm5vIiwiY2xhc3MiLCJhdHRyX3JlYWRlciIsIlN0YW5kYXJkRXJyb3IiXSwibWFwcGluZ3MiOiJBQUFBQSxzQ0FBQUEsZ0JBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTs7RUFHQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUMsU0FBUyxDQUNQLENBQUMsUUFBRCxFQUFVRCxrQkFBVixFQUE4QkUsRUFBOUIsQ0FETyxFQUVQLENBQUMsUUFBRCxFQUFVRixhQUFWLEVBQXlCRyxFQUF6QixDQUZPLEVBR1AsQ0FBQyxRQUFELEVBQVVILGdCQUFWLEVBQTRCSSxFQUE1QixDQUhPLEVBSVAsQ0FBQyxRQUFELEVBQVVKLHFCQUFWLEVBQWlDSyxFQUFqQyxDQUpPLEVBS1AsQ0FBQyxRQUFELEVBQVVMLGNBQVYsRUFBMEJNLEVBQTFCLENBTE8sRUFNUCxDQUFDLFFBQUQsRUFBVU4sbUJBQVYsRUFBK0JPLEVBQS9CLENBTk8sRUFPUCxDQUFDLE9BQUQsRUFBU1AseUJBQVQsRUFBb0NRLENBQXBDLENBUE8sRUFRUCxDQUFDLFFBQUQsRUFBVVIsMkJBQVYsRUFBdUNTLENBQXZDLENBUk8sRUFTUCxDQUFDLGNBQUQsRUFBZ0JULG9CQUFoQixFQUFzQ1UsRUFBdEMsQ0FUTztJQVlUQyxRQUFROztBQUdWWDtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBLFFBQ1U7O01BQ0UsT0FBQVksbUJBQUFBLGdCQUFRQyxJQUFSRDtBQUFBQSxRQUFBQTs7UUFBQUE7O1FBQVEseUJBQU87UUFDYkUsVUFBV0Y7UUFDWCxJQUFBLFFBQTJCQyxJQUEzQixDQUFBO1VBQUFDLFVBQVFDLFNBQVJELE9BQVFDLEVBQUlILEtBQUQsR0FBQSxNQUFNQyxJQUFOLENBQUhFO1FBQVI7UUFDQUgsT0FBQSxPQUFBSSxJQUFBLEVBQUEsNkNBQUEsT0FBQSxFQUFBLENBQU1GLE9BQU4sQ0FBQSxFQUFBLElBQUE7TUFIRkYsQ0FBQUEsSUFBQUE7SUFERiw0QkFBU0QsS0FBVDtBQVFWWDtBQUNBQTtBQUNBQTtFQXJDQUEsR0FBTyxJQUFQQTtFQXdDQUQsT0FBQWtCO0VBQUFBOztJQUFBQTs7OztBQUNFQyxJQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBRixJQUFJRyxPQUFBQSxDQUFBQSxDQUFNRCxPQUFBQSxDQUFBQTtJQURaQSxDQUFBQTtJQUlBRCxPQUFBOztNQUNFLE9BQUFELElBQUFJLGFBQUFBLENBQVksT0FBWkE7SUFERiw0QkFBU0osSUFBVDtFQUxGQyxHQUFNLElBQU5BLEVBQTBCSSxvQkFBMUJKO0FBM0NBbEI7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjYxNTAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2Vycm9yLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxyXG4jIHVzZV9zdHJpY3Q6IHRydWVcclxuXHJcbmNsYXNzIDo6RXhjZXB0aW9uIDwgYEVycm9yYFxyXG4gIGBPcGFsLnByb3Aoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfZXhjZXB0aW9uJywgdHJ1ZSlgXHJcbiAgYHZhciBzdGFja190cmFjZV9saW1pdGBcclxuXHJcbiAgYEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDEwMGBcclxuXHJcbiAgZGVmIHNlbGYubmV3KCphcmdzKVxyXG4gICAgJXh7XHJcbiAgICAgIHZhciBtZXNzYWdlICAgPSAoYXJncy5sZW5ndGggPiAwKSA/IGFyZ3NbMF0gOiBuaWw7XHJcbiAgICAgIHZhciBlcnJvciAgICAgPSBuZXcgc2VsZi4kJGNvbnN0cnVjdG9yKG1lc3NhZ2UpO1xyXG4gICAgICBlcnJvci5uYW1lICAgID0gc2VsZi4kJG5hbWU7XHJcbiAgICAgIGVycm9yLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICBlcnJvci5jYXVzZSAgID0gI3skIX07XHJcbiAgICAgIE9wYWwuc2VuZChlcnJvciwgZXJyb3IuJGluaXRpYWxpemUsIGFyZ3MpO1xyXG5cclxuICAgICAgLy8gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoKSB3aWxsIHVzZSAubmFtZSBhbmQgLnRvU3RyaW5nIHRvIGJ1aWxkIHRoZVxyXG4gICAgICAvLyBmaXJzdCBsaW5lIG9mIHRoZSBzdGFjayB0cmFjZSBzbyBpdCBtdXN0IGJlIGNhbGxlZCBhZnRlciB0aGUgZXJyb3JcclxuICAgICAgLy8gaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXHJcbiAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC12Ni54L2RvY3MvYXBpL2Vycm9ycy5odG1sXHJcbiAgICAgIGlmIChPcGFsLmNvbmZpZy5lbmFibGVfc3RhY2tfdHJhY2UgJiYgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcclxuICAgICAgICAvLyBQYXNzaW5nIEtlcm5lbC5yYWlzZSB3aWxsIGN1dCB0aGUgc3RhY2sgdHJhY2UgZnJvbSB0aGF0IHBvaW50IGFib3ZlXHJcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3IsIHN0YWNrX3RyYWNlX2xpbWl0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgfVxyXG4gIGVuZFxyXG4gIGBzdGFja190cmFjZV9saW1pdCA9IHNlbGYuJG5ld2BcclxuXHJcbiAgZGVmIHNlbGYuZXhjZXB0aW9uKCphcmdzKVxyXG4gICAgbmV3KCphcmdzKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgaW5pdGlhbGl6ZSgqYXJncylcclxuICAgICMgdXNpbmcgc2VsZi5tZXNzYWdlIGFrYSBAbWVzc2FnZSB0byByZXRhaW4gY29tcGF0aWJpbGl0eSB3aXRoIG5hdGl2ZSBleGNlcHRpb24ncyBtZXNzYWdlIHByb3BlcnR5XHJcbiAgICBgc2VsZi5tZXNzYWdlID0gKGFyZ3MubGVuZ3RoID4gMCkgPyBhcmdzWzBdIDogbmlsYFxyXG4gIGVuZFxyXG5cclxuICAjIFRob3NlIGluc3RhbmNlIHZhcmlhYmxlcyBhcmUgbm90IGVudW1lcmFibGUuXHJcbiAgZGVmIGNvcHlfaW5zdGFuY2VfdmFyaWFibGVzKG90aGVyKVxyXG4gICAgc3VwZXJcclxuICAgICV4e1xyXG4gICAgICBzZWxmLm1lc3NhZ2UgPSBvdGhlci5tZXNzYWdlO1xyXG4gICAgICBzZWxmLmNhdXNlID0gb3RoZXIuY2F1c2U7XHJcbiAgICAgIHNlbGYuc3RhY2sgPSBvdGhlci5zdGFjaztcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgJXh7XHJcbiAgICAvLyBDb252ZXJ0IGJhY2t0cmFjZSBmcm9tIGFueSBmb3JtYXQgdG8gUnVieSBmb3JtYXRcclxuICAgIGZ1bmN0aW9uIGNvcnJlY3RfYmFja3RyYWNlKGJhY2t0cmFjZSkge1xyXG4gICAgICB2YXIgbmV3X2J0ID0gW10sIG07XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhY2t0cmFjZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBsb2MgPSBiYWNrdHJhY2VbaV07XHJcbiAgICAgICAgaWYgKCFsb2MgfHwgIWxvYy4kJGlzX3N0cmluZykge1xyXG4gICAgICAgICAgLyogRG8gbm90aGluZyAqL1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiBDaHJvbWl1bSBmb3JtYXQgKi9cclxuICAgICAgICBlbHNlIGlmICgobSA9IGxvYy5tYXRjaCgvXiAgICBhdCAoLio/KSBcXCgoLio/KVxcKSQvKSkpIHtcclxuICAgICAgICAgIG5ld19idC5wdXNoKG1bMl0gKyBcIjppbiBgXCIgKyBtWzFdICsgXCInXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgobSA9IGxvYy5tYXRjaCgvXiAgICBhdCAoLio/KSQvKSkpIHtcclxuICAgICAgICAgIG5ld19idC5wdXNoKG1bMV0gKyBcIjppbiBgdW5kZWZpbmVkJ1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyogTm9kZSBmb3JtYXQgKi9cclxuICAgICAgICBlbHNlIGlmICgobSA9IGxvYy5tYXRjaCgvXiAgZnJvbSAoLio/KSQvKSkpIHtcclxuICAgICAgICAgIG5ld19idC5wdXNoKG1bMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiBNb3ppbGxhL0FwcGxlIGZvcm1hdCAqL1xyXG4gICAgICAgIGVsc2UgaWYgKChtID0gbG9jLm1hdGNoKC9eKC4qPylAKC4qPykkLykpKSB7XHJcbiAgICAgICAgICBuZXdfYnQucHVzaChtWzJdICsgJzppbiBgJyArIG1bMV0gKyBcIidcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbmV3X2J0O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVmIGJhY2t0cmFjZVxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChzZWxmLmJhY2t0cmFjZSkge1xyXG4gICAgICAgIC8vIG5pbCBpcyBhIHZhbGlkIGJhY2t0cmFjZVxyXG4gICAgICAgIHJldHVybiBzZWxmLmJhY2t0cmFjZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGJhY2t0cmFjZSA9IHNlbGYuc3RhY2s7XHJcblxyXG4gICAgICBpZiAodHlwZW9mKGJhY2t0cmFjZSkgIT09ICd1bmRlZmluZWQnICYmIGJhY2t0cmFjZS4kJGlzX3N0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzZWxmLmJhY2t0cmFjZSA9IGNvcnJlY3RfYmFja3RyYWNlKGJhY2t0cmFjZS5zcGxpdChcIlxcblwiKSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoYmFja3RyYWNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGYuYmFja3RyYWNlID0gY29ycmVjdF9iYWNrdHJhY2UoYmFja3RyYWNlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgYmFja3RyYWNlX2xvY2F0aW9uc1xyXG4gICAgJXh7XHJcbiAgICAgIGlmIChzZWxmLmJhY2t0cmFjZV9sb2NhdGlvbnMpIHJldHVybiBzZWxmLmJhY2t0cmFjZV9sb2NhdGlvbnM7XHJcbiAgICAgIHNlbGYuYmFja3RyYWNlX2xvY2F0aW9ucyA9ICN7YmFja3RyYWNlJi5tYXAgZG8gfGxvY3xcclxuICAgICAgICA6OlRocmVhZDo6QmFja3RyYWNlOjpMb2NhdGlvbi5uZXcobG9jKVxyXG4gICAgICBlbmR9XHJcbiAgICAgIHJldHVybiBzZWxmLmJhY2t0cmFjZV9sb2NhdGlvbnM7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBjYXVzZVxyXG4gICAgYHNlbGYuY2F1c2UgfHwgbmlsYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgZXhjZXB0aW9uKHN0ciA9IG5pbClcclxuICAgICV4e1xyXG4gICAgICBpZiAoc3RyID09PSBuaWwgfHwgc2VsZiA9PT0gc3RyKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBjbG9uZWQgPSAje2Nsb25lfTtcclxuICAgICAgY2xvbmVkLm1lc3NhZ2UgPSBzdHI7XHJcbiAgICAgIGlmIChzZWxmLmJhY2t0cmFjZSkgY2xvbmVkLmJhY2t0cmFjZSA9IHNlbGYuYmFja3RyYWNlLiRkdXAoKTtcclxuICAgICAgY2xvbmVkLnN0YWNrID0gc2VsZi5zdGFjaztcclxuICAgICAgY2xvbmVkLmNhdXNlID0gc2VsZi5jYXVzZTtcclxuICAgICAgcmV0dXJuIGNsb25lZDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgIyBub3QgdXNpbmcgYWxpYXMgbWVzc2FnZSB0b19zIGJlY2F1c2UgeW91IG5lZWQgdG8gYmUgYWJsZSB0byBvdmVycmlkZSB0b19zIGFuZCBoYXZlIG1lc3NhZ2UgdXNlIG92ZXJyaWRkZW4gbWV0aG9kLCB3b24ndCB3b3JrIHdpdGggYWxpYXNcclxuICBkZWYgbWVzc2FnZVxyXG4gICAgdG9fc1xyXG4gIGVuZFxyXG5cclxuICBkZWYgZnVsbF9tZXNzYWdlKGt3YXJncyA9IG5pbClcclxuICAgIHVubGVzcyBkZWZpbmVkPyBIYXNoXHJcbiAgICAgICMgV2UgYXJlIGRlYWxpbmcgd2l0aCBhbiB1bmZ1bGx5IGxvYWRlZCBPcGFsIGxpYnJhcnksIHNvIHdlIHNob3VsZFxyXG4gICAgICAjIGRvIHdpdGggYXMgbGl0dGxlIGFzIHdlIGNhbi5cclxuXHJcbiAgICAgIHJldHVybiBcIiN7QG1lc3NhZ2V9XFxuI3tgc2VsZi5zdGFja2B9XCJcclxuICAgIGVuZFxyXG5cclxuICAgIGt3YXJncyA9IHsgaGlnaGxpZ2h0OiAkc3RkZXJyJi50dHk/LCBvcmRlcjogOnRvcCB9Lm1lcmdlKGt3YXJncyB8fCB7fSlcclxuICAgIGhpZ2hsaWdodCwgb3JkZXIgPSBrd2FyZ3NbOmhpZ2hsaWdodF0sIGt3YXJnc1s6b3JkZXJdXHJcblxyXG4gICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImV4cGVjdGVkIHRydWUgb3IgZmFsc2UgYXMgaGlnaGxpZ2h0OiAje2hpZ2hsaWdodH1cIiB1bmxlc3MgW3RydWUsIGZhbHNlXS5pbmNsdWRlPyBoaWdobGlnaHRcclxuICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJleHBlY3RlZCA6dG9wIG9yIDpib3R0b20gYXMgb3JkZXI6ICN7b3JkZXJ9XCIgdW5sZXNzICVpW3RvcCBib3R0b21dLmluY2x1ZGU/IG9yZGVyXHJcblxyXG4gICAgaWYgaGlnaGxpZ2h0XHJcbiAgICAgIGJvbGRfdW5kZXJsaW5lID0gXCJcXGVbMTs0bVwiXHJcbiAgICAgIGJvbGQgPSBcIlxcZVsxbVwiXHJcbiAgICAgIHJlc2V0ID0gXCJcXGVbbVwiXHJcbiAgICBlbHNlXHJcbiAgICAgIGJvbGRfdW5kZXJsaW5lID0gYm9sZCA9IHJlc2V0ID0gJydcclxuICAgIGVuZFxyXG5cclxuICAgIGJ0ID0gYmFja3RyYWNlLmR1cFxyXG4gICAgYnQgPSBjYWxsZXIgaWYgIWJ0IHx8IGJ0LmVtcHR5P1xyXG4gICAgZmlyc3QgPSBidC5zaGlmdFxyXG5cclxuICAgIG1zZyA9IFwiI3tmaXJzdH06IFwiXHJcbiAgICBtc2cgKz0gXCIje2JvbGR9I3t0b19zfSAoI3tib2xkX3VuZGVybGluZX0je3NlbGYuY2xhc3N9I3tyZXNldH0je2JvbGR9KSN7cmVzZXR9XFxuXCJcclxuXHJcbiAgICBtc2cgKz0gYnQubWFwIHsgfGxvY3wgXCJcXHRmcm9tICN7bG9jfVxcblwiIH0uam9pblxyXG5cclxuICAgIG1zZyArPSBjYXVzZS5mdWxsX21lc3NhZ2UoaGlnaGxpZ2h0OiBoaWdobGlnaHQpIGlmIGNhdXNlXHJcblxyXG4gICAgaWYgb3JkZXIgPT0gOmJvdHRvbVxyXG4gICAgICBtc2cgPSBtc2cuc3BsaXQoXCJcXG5cIikucmV2ZXJzZS5qb2luKFwiXFxuXCIpXHJcbiAgICAgIG1zZyA9IFwiI3tib2xkfVRyYWNlYmFjayN7cmVzZXR9IChtb3N0IHJlY2VudCBjYWxsIGxhc3QpOlxcblwiICsgbXNnXHJcbiAgICBlbmRcclxuXHJcbiAgICBtc2dcclxuICBlbmRcclxuXHJcbiAgZGVmIGluc3BlY3RcclxuICAgIGFzX3N0ciA9IHRvX3NcclxuICAgIGFzX3N0ci5lbXB0eT8gPyBzZWxmLmNsYXNzLnRvX3MgOiBcIiM8I3tzZWxmLmNsYXNzLnRvX3N9OiAje3RvX3N9PlwiXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzZXRfYmFja3RyYWNlKGJhY2t0cmFjZSlcclxuICAgICV4e1xyXG4gICAgICB2YXIgdmFsaWQgPSB0cnVlLCBpLCBpaTtcclxuXHJcbiAgICAgIGlmIChiYWNrdHJhY2UgPT09IG5pbCkge1xyXG4gICAgICAgIHNlbGYuYmFja3RyYWNlID0gbmlsO1xyXG4gICAgICAgIHNlbGYuc3RhY2sgPSAnJztcclxuICAgICAgfSBlbHNlIGlmIChiYWNrdHJhY2UuJCRpc19zdHJpbmcpIHtcclxuICAgICAgICBzZWxmLmJhY2t0cmFjZSA9IFtiYWNrdHJhY2VdO1xyXG4gICAgICAgIHNlbGYuc3RhY2sgPSAnICBmcm9tICcgKyBiYWNrdHJhY2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGJhY2t0cmFjZS4kJGlzX2FycmF5KSB7XHJcbiAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IGJhY2t0cmFjZS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICghYmFja3RyYWNlW2ldLiQkaXNfc3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHZhbGlkID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ2JhY2t0cmFjZSBtdXN0IGJlIEFycmF5IG9mIFN0cmluZyd9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZWxmLmJhY2t0cmFjZSA9IGJhY2t0cmFjZTtcclxuICAgICAgICBzZWxmLnN0YWNrID0gI3tgYmFja3RyYWNlYC5tYXAgeyB8aXwgJyAgZnJvbSAnICsgaSB9fS5qb2luKFwiXFxuXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gYmFja3RyYWNlO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgdG9fc1xyXG4gICAgIyB1c2luZyBzZWxmLm1lc3NhZ2UgYWthIEBtZXNzYWdlIHRvIHJldGFpbiBjb21wYXRpYmlsaXR5IHdpdGggbmF0aXZlIGV4Y2VwdGlvbidzIG1lc3NhZ2UgcHJvcGVydHlcclxuICAgIChAbWVzc2FnZSAmJiBAbWVzc2FnZS50b19zKSB8fCBzZWxmLmNsYXNzLnRvX3NcclxuICBlbmRcclxuZW5kXHJcblxyXG4jIGtlZXAgdGhlIGluZGVudGF0aW9uLCBpdCBtYWtlcyB0aGUgZXhjZXB0aW9uIGhpZXJhcmNoeSBjbGVhclxyXG5jbGFzcyA6OlNjcmlwdEVycm9yICAgICAgIDwgOjpFeGNlcHRpb247IGVuZFxyXG5jbGFzcyA6OlN5bnRheEVycm9yICAgICAgICAgPCA6OlNjcmlwdEVycm9yOyBlbmRcclxuY2xhc3MgOjpMb2FkRXJyb3IgICAgICAgICAgIDwgOjpTY3JpcHRFcnJvcjsgZW5kXHJcbmNsYXNzIDo6Tm90SW1wbGVtZW50ZWRFcnJvciA8IDo6U2NyaXB0RXJyb3I7IGVuZFxyXG5cclxuY2xhc3MgOjpTeXN0ZW1FeGl0ICAgICAgICA8IDo6RXhjZXB0aW9uOyBlbmRcclxuY2xhc3MgOjpOb01lbW9yeUVycm9yICAgICA8IDo6RXhjZXB0aW9uOyBlbmRcclxuY2xhc3MgOjpTaWduYWxFeGNlcHRpb24gICA8IDo6RXhjZXB0aW9uOyBlbmRcclxuY2xhc3MgOjpJbnRlcnJ1cHQgICAgICAgICAgIDwgOjpTaWduYWxFeGNlcHRpb247IGVuZFxyXG5jbGFzcyA6OlNlY3VyaXR5RXJyb3IgICAgIDwgOjpFeGNlcHRpb247IGVuZFxyXG5jbGFzcyA6OlN5c3RlbVN0YWNrRXJyb3IgIDwgOjpFeGNlcHRpb247IGVuZFxyXG5cclxuY2xhc3MgOjpTdGFuZGFyZEVycm9yICAgICA8IDo6RXhjZXB0aW9uOyBlbmRcclxuY2xhc3MgOjpFbmNvZGluZ0Vycm9yICAgICAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcclxuY2xhc3MgOjpaZXJvRGl2aXNpb25FcnJvciAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcclxuY2xhc3MgOjpOYW1lRXJyb3IgICAgICAgICAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcclxuY2xhc3MgOjpOb01ldGhvZEVycm9yICAgICAgICAgPCA6Ok5hbWVFcnJvcjsgZW5kXHJcbmNsYXNzIDo6UnVudGltZUVycm9yICAgICAgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXHJcbmNsYXNzIDo6RnJvemVuRXJyb3IgICAgICAgICAgIDwgOjpSdW50aW1lRXJyb3I7IGVuZFxyXG5jbGFzcyA6OkxvY2FsSnVtcEVycm9yICAgICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxyXG5jbGFzcyA6OlR5cGVFcnJvciAgICAgICAgICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxyXG5jbGFzcyA6OkFyZ3VtZW50RXJyb3IgICAgICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxyXG5jbGFzcyA6OlVuY2F1Z2h0VGhyb3dFcnJvciAgICA8IDo6QXJndW1lbnRFcnJvcjsgZW5kXHJcbmNsYXNzIDo6SW5kZXhFcnJvciAgICAgICAgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXHJcbmNsYXNzIDo6U3RvcEl0ZXJhdGlvbiAgICAgICAgIDwgOjpJbmRleEVycm9yOyBlbmRcclxuY2xhc3MgOjpDbG9zZWRRdWV1ZUVycm9yICAgICAgICA8IDo6U3RvcEl0ZXJhdGlvbjsgZW5kXHJcbmNsYXNzIDo6S2V5RXJyb3IgICAgICAgICAgICAgIDwgOjpJbmRleEVycm9yOyBlbmRcclxuY2xhc3MgOjpSYW5nZUVycm9yICAgICAgICAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcclxuY2xhc3MgOjpGbG9hdERvbWFpbkVycm9yICAgICAgPCA6OlJhbmdlRXJyb3I7IGVuZFxyXG5jbGFzcyA6OklPRXJyb3IgICAgICAgICAgICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxyXG5jbGFzcyA6OkVPRkVycm9yICAgICAgICAgICAgICA8IDo6SU9FcnJvcjsgZW5kXHJcbmNsYXNzIDo6U3lzdGVtQ2FsbEVycm9yICAgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXHJcbmNsYXNzIDo6UmVnZXhwRXJyb3IgICAgICAgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXHJcbmNsYXNzIDo6VGhyZWFkRXJyb3IgICAgICAgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXHJcbmNsYXNzIDo6RmliZXJFcnJvciAgICAgICAgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXHJcblxyXG46Ok9iamVjdC5hdXRvbG9hZCA6RXJybm8sICdjb3JlbGliL2Vycm9yL2Vycm5vJ1xyXG5cclxuY2xhc3MgOjpGcm96ZW5FcnJvciA8IDo6UnVudGltZUVycm9yXHJcbiAgYXR0cl9yZWFkZXIgOnJlY2VpdmVyXHJcblxyXG4gIGRlZiBpbml0aWFsaXplKG1lc3NhZ2UsIHJlY2VpdmVyOiBuaWwpXHJcbiAgICBzdXBlciBtZXNzYWdlXHJcbiAgICBAcmVjZWl2ZXIgPSByZWNlaXZlclxyXG4gIGVuZFxyXG5lbmRcclxuXHJcbmNsYXNzIDo6VW5jYXVnaHRUaHJvd0Vycm9yIDwgOjpBcmd1bWVudEVycm9yXHJcbiAgYXR0cl9yZWFkZXIgOnRhZywgOnZhbHVlXHJcblxyXG4gIGRlZiBpbml0aWFsaXplKHRhZywgdmFsdWUgPSBuaWwpXHJcbiAgICBAdGFnID0gdGFnXHJcbiAgICBAdmFsdWUgPSB2YWx1ZVxyXG5cclxuICAgIHN1cGVyKFwidW5jYXVnaHQgdGhyb3cgI3tAdGFnLmluc3BlY3R9XCIpXHJcbiAgZW5kXHJcbmVuZFxyXG5cclxuY2xhc3MgOjpOYW1lRXJyb3JcclxuICBhdHRyX3JlYWRlciA6bmFtZVxyXG5cclxuICBkZWYgaW5pdGlhbGl6ZShtZXNzYWdlLCBuYW1lID0gbmlsKVxyXG4gICAgc3VwZXIgbWVzc2FnZVxyXG4gICAgQG5hbWUgPSBuYW1lXHJcbiAgZW5kXHJcbmVuZFxyXG5cclxuY2xhc3MgOjpOb01ldGhvZEVycm9yXHJcbiAgYXR0cl9yZWFkZXIgOmFyZ3NcclxuXHJcbiAgZGVmIGluaXRpYWxpemUobWVzc2FnZSwgbmFtZSA9IG5pbCwgYXJncyA9IFtdKVxyXG4gICAgc3VwZXIgbWVzc2FnZSwgbmFtZVxyXG4gICAgQGFyZ3MgPSBhcmdzXHJcbiAgZW5kXHJcbmVuZFxyXG5cclxuY2xhc3MgOjpTdG9wSXRlcmF0aW9uXHJcbiAgYXR0cl9yZWFkZXIgOnJlc3VsdFxyXG5lbmRcclxuXHJcbmNsYXNzIDo6S2V5RXJyb3JcclxuICBkZWYgaW5pdGlhbGl6ZShtZXNzYWdlLCByZWNlaXZlcjogbmlsLCBrZXk6IG5pbClcclxuICAgIHN1cGVyKG1lc3NhZ2UpXHJcbiAgICBAcmVjZWl2ZXIgPSByZWNlaXZlclxyXG4gICAgQGtleSA9IGtleVxyXG4gIGVuZFxyXG5cclxuICBkZWYgcmVjZWl2ZXJcclxuICAgIEByZWNlaXZlciB8fCA6Oktlcm5lbC5yYWlzZSg6OkFyZ3VtZW50RXJyb3IsICdubyByZWNlaXZlciBpcyBhdmFpbGFibGUnKVxyXG4gIGVuZFxyXG5cclxuICBkZWYga2V5XHJcbiAgICBAa2V5IHx8IDo6S2VybmVsLnJhaXNlKDo6QXJndW1lbnRFcnJvciwgJ25vIGtleSBpcyBhdmFpbGFibGUnKVxyXG4gIGVuZFxyXG5lbmRcclxuXHJcbmNsYXNzIDo6TG9jYWxKdW1wRXJyb3JcclxuICBhdHRyX3JlYWRlciA6ZXhpdF92YWx1ZSwgOnJlYXNvblxyXG5cclxuICBkZWYgaW5pdGlhbGl6ZShtZXNzYWdlLCBleGl0X3ZhbHVlID0gbmlsLCByZWFzb24gPSA6bm9yZWFzb24pXHJcbiAgICBzdXBlciBtZXNzYWdlXHJcbiAgICBAZXhpdF92YWx1ZSA9IGV4aXRfdmFsdWVcclxuICAgIEByZWFzb24gPSByZWFzb25cclxuICBlbmRcclxuZW5kXHJcblxyXG5tb2R1bGUgOjpPcGFsXHJcbiAgbW9kdWxlIFJhd1xyXG4gICAgY2xhc3MgRXJyb3JcclxuICAgIGVuZFxyXG4gIGVuZFxyXG5lbmRcclxuXHJcbm1vZHVsZSA6OkpTXHJcbiAgZGVmIHNlbGYuY29uc3RfbWlzc2luZyhjb25zdClcclxuICAgIGlmIGNvbnN0ID09IDpFcnJvclxyXG4gICAgICB3YXJuICdbT3BhbF0gSlM6OkVycm9yIGNsYXNzIGhhcyBiZWVuIHJlbmFtZWQgdG8gT3BhbDo6UmF3OjpFcnJvciBhbmQgd2lsbCBjaGFuZ2Ugc2VtYW50aWNzIGluIE9wYWwgMi4xLiAnIFxcXHJcbiAgICAgICAgICAgJ1RvIGVuc3VyZSBmb3J3YXJkIGNvbXBhdGliaWxpdHksIHBsZWFzZSB1cGRhdGUgeW91ciByZXNjdWUgY2xhdXNlcy4nXHJcblxyXG4gICAgICA6OkpTOjpSYXc6OkVycm9yXHJcbiAgICBlbHNlXHJcbiAgICAgIHN1cGVyXHJcbiAgICBlbmRcclxuICBlbmRcclxuZW5kXHJcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkV4Y2VwdGlvbj4iLCJuZXciLCJzZWxmIiwiJCEiLCJleGNlcHRpb24iLCJhcmdzIiwiaW5pdGlhbGl6ZSIsImNvcHlfaW5zdGFuY2VfdmFyaWFibGVzIiwib3RoZXIiLCJiYWNrdHJhY2UiLCJiYWNrdHJhY2VfbG9jYXRpb25zIiwiYmxvY2sgaW4gYmFja3RyYWNlX2xvY2F0aW9ucyIsImxvYyIsImJsb2NrICgyIGxldmVscykgaW4gYmFja3RyYWNlX2xvY2F0aW9ucyIsIlRocmVhZDo6QmFja3RyYWNlOjpMb2NhdGlvbiIsIlRocmVhZDo6QmFja3RyYWNlIiwiVGhyZWFkIiwiY2F1c2UiLCJzdHIiLCJjbG9uZSIsIm1lc3NhZ2UiLCJ0b19zIiwiZnVsbF9tZXNzYWdlIiwia3dhcmdzIiwiQG1lc3NhZ2UiLCIkc3RkZXJyIiwibWVyZ2UiLCIkcmV0X29yXzEiLCJbXSIsImhpZ2hsaWdodCIsIm9yZGVyIiwiaW5jbHVkZT8iLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJib2xkX3VuZGVybGluZSIsImJvbGQiLCJyZXNldCIsImJ0IiwiZHVwIiwiZW1wdHk/IiwiY2FsbGVyIiwiZmlyc3QiLCJzaGlmdCIsIm1zZyIsIisiLCJjbGFzcyIsIm1hcCIsImJsb2NrIGluIGZ1bGxfbWVzc2FnZSIsImJsb2NrICgyIGxldmVscykgaW4gZnVsbF9tZXNzYWdlIiwiam9pbiIsInNwbGl0IiwicmV2ZXJzZSIsImluc3BlY3QiLCJhc19zdHIiLCJzZXRfYmFja3RyYWNlIiwiVHlwZUVycm9yIiwiYmxvY2sgaW4gc2V0X2JhY2t0cmFjZSIsImkiLCJibG9jayAoMiBsZXZlbHMpIGluIHNldF9iYWNrdHJhY2UiLCIkcmV0X29yXzIiLCI8Y2xhc3M6U2NyaXB0RXJyb3I+IiwiRXhjZXB0aW9uIiwiPGNsYXNzOlN5bnRheEVycm9yPiIsIlNjcmlwdEVycm9yIiwiPGNsYXNzOkxvYWRFcnJvcj4iLCI8Y2xhc3M6Tm90SW1wbGVtZW50ZWRFcnJvcj4iLCI8Y2xhc3M6U3lzdGVtRXhpdD4iLCI8Y2xhc3M6Tm9NZW1vcnlFcnJvcj4iLCI8Y2xhc3M6U2lnbmFsRXhjZXB0aW9uPiIsIjxjbGFzczpJbnRlcnJ1cHQ+IiwiU2lnbmFsRXhjZXB0aW9uIiwiPGNsYXNzOlNlY3VyaXR5RXJyb3I+IiwiPGNsYXNzOlN5c3RlbVN0YWNrRXJyb3I+IiwiPGNsYXNzOlN0YW5kYXJkRXJyb3I+IiwiPGNsYXNzOkVuY29kaW5nRXJyb3I+IiwiU3RhbmRhcmRFcnJvciIsIjxjbGFzczpaZXJvRGl2aXNpb25FcnJvcj4iLCI8Y2xhc3M6TmFtZUVycm9yPiIsIjxjbGFzczpOb01ldGhvZEVycm9yPiIsIk5hbWVFcnJvciIsIjxjbGFzczpSdW50aW1lRXJyb3I+IiwiPGNsYXNzOkZyb3plbkVycm9yPiIsIlJ1bnRpbWVFcnJvciIsIjxjbGFzczpMb2NhbEp1bXBFcnJvcj4iLCI8Y2xhc3M6VHlwZUVycm9yPiIsIjxjbGFzczpBcmd1bWVudEVycm9yPiIsIjxjbGFzczpVbmNhdWdodFRocm93RXJyb3I+IiwiPGNsYXNzOkluZGV4RXJyb3I+IiwiPGNsYXNzOlN0b3BJdGVyYXRpb24+IiwiSW5kZXhFcnJvciIsIjxjbGFzczpDbG9zZWRRdWV1ZUVycm9yPiIsIlN0b3BJdGVyYXRpb24iLCI8Y2xhc3M6S2V5RXJyb3I+IiwiPGNsYXNzOlJhbmdlRXJyb3I+IiwiPGNsYXNzOkZsb2F0RG9tYWluRXJyb3I+IiwiUmFuZ2VFcnJvciIsIjxjbGFzczpJT0Vycm9yPiIsIjxjbGFzczpFT0ZFcnJvcj4iLCJJT0Vycm9yIiwiPGNsYXNzOlN5c3RlbUNhbGxFcnJvcj4iLCI8Y2xhc3M6UmVnZXhwRXJyb3I+IiwiPGNsYXNzOlRocmVhZEVycm9yPiIsIjxjbGFzczpGaWJlckVycm9yPiIsIk9iamVjdCIsImF1dG9sb2FkIiwiYXR0cl9yZWFkZXIiLCIka3dhcmdzIiwiQHJlY2VpdmVyIiwicmVjZWl2ZXIiLCJ0YWciLCJ2YWx1ZSIsIkB0YWciLCJAdmFsdWUiLCJuYW1lIiwiQG5hbWUiLCJAYXJncyIsIkBrZXkiLCJrZXkiLCJleGl0X3ZhbHVlIiwicmVhc29uIiwiQGV4aXRfdmFsdWUiLCJAcmVhc29uIiwiPG1vZHVsZTpPcGFsPiIsIjxtb2R1bGU6UmF3PiIsIjxjbGFzczpFcnJvcj4iLCI8bW9kdWxlOkpTPiIsImNvbnN0X21pc3NpbmciLCJjb25zdCQiLCJ3YXJuIiwiSlM6OlJhdzo6RXJyb3IiLCJKUzo6UmF3IiwiSlMiXSwibWFwcGluZ3MiOiJBQUFBQSxnQ0FBQUEsZ0JBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTs7RUFHQUM7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDR0E7SUFDQUE7SUFFQUE7SUFFREMsTUFBSUMsSUFBSkQsVUFBQUEsMEJBVEYsRUFTRUE7QUFBQUEsTUFBQUE7QUFBQUE7OztNQVRGO01BU2U7O0FBRWZBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLHNCQUF3QkUsV0FBR0Y7QUFDM0JBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7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QUFBLGdFQUFBLGlCQUFBLEVBQUEsQ0FBQThILE1BQUEsQ0FBQSxFQUFBLE1BQUE7TUFORjtJQURGRCxDQUFBQTtFQURGRCxHQUFPLElBQVBBO0FBaFZBL0g7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjY2MzAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2NvbnN0YW50cy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyI6OlJVQllfUExBVEZPUk0gICAgICAgPSAnb3BhbCdcclxuOjpSVUJZX0VOR0lORSAgICAgICAgID0gJ29wYWwnXHJcbjo6UlVCWV9WRVJTSU9OICAgICAgICA9ICczLjIuMCdcclxuOjpSVUJZX0VOR0lORV9WRVJTSU9OID0gJzIuMC4wZGV2J1xyXG46OlJVQllfUkVMRUFTRV9EQVRFICAgPSAnMjAyMy0xMS0xNidcclxuOjpSVUJZX1BBVENITEVWRUwgICAgID0gMFxyXG46OlJVQllfUkVWSVNJT04gICAgICAgPSAnMCdcclxuOjpSVUJZX0NPUFlSSUdIVCAgICAgID0gJ29wYWwgLSBDb3B5cmlnaHQgKEMpIDIwMTEtMjAyMyBBZGFtIEJleW5vbiBhbmQgdGhlIE9wYWwgY29udHJpYnV0b3JzJ1xyXG46OlJVQllfREVTQ1JJUFRJT04gICAgPSBcIm9wYWwgI3s6OlJVQllfRU5HSU5FX1ZFUlNJT059ICgjezo6UlVCWV9SRUxFQVNFX0RBVEV9IHJldmlzaW9uICN7OjpSVUJZX1JFVklTSU9OfSlcIlxyXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjAiLCJSVUJZX0VOR0lORV9WRVJTSU9OIiwiUlVCWV9SRUxFQVNFX0RBVEUiLCJSVUJZX1JFVklTSU9OIl0sIm1hcHBpbmdzIjoiQUFBQUEsb0NBQUFBLGdCQUFBQTtFQUFBQTs7O0VBQUEsV0FBQSxJQUFBLG1CQUF3QkEsTUFBeEI7RUFDQSxXQUFBLElBQUEsaUJBQXdCQSxNQUF4QjtFQUNBLFdBQUEsSUFBQSxrQkFBd0JBLE9BQXhCO0VBQ0EsV0FBQSxJQUFBLHlCQUF3QkEsVUFBeEI7RUFDQSxXQUFBLElBQUEsdUJBQXdCQSxZQUF4QjtFQUNBLFdBQUEsSUFBQSxxQkFBd0JDLENBQXhCO0VBQ0EsV0FBQSxJQUFBLG1CQUF3QkQsR0FBeEI7RUFDQSxXQUFBLElBQUEsb0JBQXdCQSxzRUFBeEI7RUFDQUEsT0FBQSxXQUFBLElBQUEsc0JBQXlCQSxPQUFELEdBQUEsTUFBUUUsMEJBQVIsQ0FBQSxHQUE4QkYsSUFBOUIsR0FBQSxNQUFrQ0csd0JBQWxDLENBQUEsR0FBc0RILFlBQXRELEdBQUEsTUFBa0VJLG9CQUFsRSxDQUFBLEdBQWtGSixHQUExRztBQVJBQTsifX0seyJvZmZzZXQiOnsibGluZSI6NjY0NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm9wYWwvYmFzZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyI6Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3J1bnRpbWUnXHJcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvaGVscGVycydcclxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9tb2R1bGUnXHJcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvY2xhc3MnXHJcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvYmFzaWNfb2JqZWN0J1xyXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2tlcm5lbCdcclxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9tYWluJ1xyXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2Vycm9yJ1xyXG5cclxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9jb25zdGFudHMnXHJcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiT2JqZWN0IiwicmVxdWlyZSJdLCJtYXBwaW5ncyI6IkFBQUFBLDRCQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxPQUFRQyxTQUFBQSxDQUFTRixpQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsaUJBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGdCQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixlQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixzQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsZ0JBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGNBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGVBQVRFO0VBRVJGLE9BQUFDLE9BQVFDLFNBQUFBLENBQVNGLG1CQUFURTtBQVRSRjsifX0seyJvZmZzZXQiOnsibGluZSI6NjY2MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbmlsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxyXG4jIHVzZV9zdHJpY3Q6IHRydWVcclxuXHJcbmNsYXNzIDo6TmlsQ2xhc3NcclxuICBgc2VsZi4kJHByb3RvdHlwZS4kJG1ldGEgPSAje3NlbGZ9YFxyXG5cclxuICBjbGFzcyA8PCBzZWxmXHJcbiAgICBkZWYgYWxsb2NhdGVcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiYWxsb2NhdG9yIHVuZGVmaW5lZCBmb3IgI3tuYW1lfVwiXHJcbiAgICBlbmRcclxuXHJcbiAgICB1bmRlZiA6bmV3XHJcbiAgZW5kXHJcblxyXG4gIGRlZiAhXHJcbiAgICB0cnVlXHJcbiAgZW5kXHJcblxyXG4gIGRlZiAmKG90aGVyKVxyXG4gICAgZmFsc2VcclxuICBlbmRcclxuXHJcbiAgZGVmIHwob3RoZXIpXHJcbiAgICBgb3RoZXIgIT09IGZhbHNlICYmIG90aGVyICE9PSBuaWxgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBeKG90aGVyKVxyXG4gICAgYG90aGVyICE9PSBmYWxzZSAmJiBvdGhlciAhPT0gbmlsYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgPT0ob3RoZXIpXHJcbiAgICBgb3RoZXIgPT09IG5pbGBcclxuICBlbmRcclxuXHJcbiAgZGVmIGR1cFxyXG4gICAgbmlsXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBjbG9uZShmcmVlemU6IHRydWUpXHJcbiAgICBuaWxcclxuICBlbmRcclxuXHJcbiAgZGVmIGluc3BlY3RcclxuICAgICduaWwnXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBuaWw/XHJcbiAgICB0cnVlXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzaW5nbGV0b25fY2xhc3NcclxuICAgIDo6TmlsQ2xhc3NcclxuICBlbmRcclxuXHJcbiAgZGVmIHRvX2FcclxuICAgIFtdXHJcbiAgZW5kXHJcblxyXG4gIGRlZiB0b19oXHJcbiAgICBgbmV3IE1hcCgpYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgdG9faVxyXG4gICAgMFxyXG4gIGVuZFxyXG5cclxuICBkZWYgdG9fc1xyXG4gICAgJydcclxuICBlbmRcclxuXHJcbiAgZGVmIHRvX2NcclxuICAgIDo6Q29tcGxleC5uZXcoMCwgMClcclxuICBlbmRcclxuXHJcbiAgZGVmIHJhdGlvbmFsaXplKCphcmdzKVxyXG4gICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yIGlmIGFyZ3MubGVuZ3RoID4gMVxyXG4gICAgOjpLZXJuZWwuUmF0aW9uYWwoMCwgMSlcclxuICBlbmRcclxuXHJcbiAgZGVmIHRvX3JcclxuICAgIDo6S2VybmVsLlJhdGlvbmFsKDAsIDEpXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZXNcclxuICAgIFtdXHJcbiAgZW5kXHJcblxyXG4gIGFsaWFzIHRvX2YgdG9faVxyXG5lbmRcclxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6TmlsQ2xhc3M+Iiwic2VsZiIsImFsbG9jYXRlIiwiS2VybmVsIiwicmFpc2UiLCJUeXBlRXJyb3IiLCJuYW1lIiwiISIsIiYiLCJ8Iiwib3RoZXIiLCJeIiwiPT0iLCJkdXAiLCJjbG9uZSIsIiRrd2FyZ3MiLCJpbnNwZWN0IiwibmlsPyIsInNpbmdsZXRvbl9jbGFzcyIsIk5pbENsYXNzIiwidG9fYSIsInRvX2giLCJ0b19pIiwiMCIsInRvX3MiLCJ0b19jIiwiQ29tcGxleCIsIm5ldyIsInJhdGlvbmFsaXplIiwiPiIsImFyZ3MiLCJsZW5ndGgiLCIxIiwiQXJndW1lbnRFcnJvciIsIlJhdGlvbmFsIiwidG9fciIsImluc3RhbmNlX3ZhcmlhYmxlcyJdLCJtYXBwaW5ncyI6IkFBQUFBLDhCQUFBQSxnQkFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBO0VBR0FBLE9BQUFDO0VBQUFBOztJQUFBQTs7O0lBQ0dBLDBCQUE0QkM7SUFFN0I7Ozs7QUFDRUMsTUFBQUEsd0JBQUFBLG9CQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQUMsT0FBUUMsT0FBQUEsQ0FBT0MsZ0JBQWYsRUFBNkJILDBCQUFELEdBQUEsTUFBMkJELElBQUFLLE1BQUFBLENBQUFBLENBQTNCLENBQXBCRjtNQURWRixDQUFBQTs7O01BSUEsc0JBQU0sS0FBTjtNQVhKLE9BQUE7SUFNRSw0QkFBU0QsSUFBVDs7QUFRQU0sSUFBQUEsaUJBQUFBLFlBQ0UsSUFERkEsQ0FBQUE7O0FBSUFDLElBQUFBLGlCQUFBQSxZQUNFLEtBREZBLENBQUFBOztBQUlBQyxJQUFBQSxpQkFBQUEsdUJBQU1DLEtBQU5EO0FBQUFBO01BQ0VBLE9BQUNBLGdDQUFEQTtJQURGQSxDQUFBQTs7QUFJQUUsSUFBQUEsaUJBQUFBLHVCQUFNRCxLQUFOQztBQUFBQTtNQUNFQSxPQUFDQSxnQ0FBREE7SUFERkEsQ0FBQUE7O0FBSUFDLElBQUFBLGtCQUFBQSw0QkFBT0YsS0FBUEU7QUFBQUE7TUFDRUEsT0FBQ0EsYUFBREE7SUFERkEsQ0FBQUE7O0FBSUFDLElBQUFBLG1CQUFBQSxZQUNFLEdBREZBLENBQUFBOztBQUlBQyxJQUFBQSxxQkFBQUEsaUJBdENGQyxPQXNDRUQ7QUFBQUEsTUFBQUE7OztNQXRDRjs7TUFzQ1ksc0NBQUEsNkJBQVE7TUFDaEJBLE9BQUE7SUFERkEsQ0FBQUEsSUFBQUE7O0FBSUFFLElBQUFBLHVCQUFBQSxZQUNFaEIsS0FERmdCLENBQUFBOztBQUlBQyxJQUFBQSxvQkFBQUEsWUFDRSxJQURGQSxDQUFBQTs7QUFJQUMsSUFBQUEsK0JBQUFBLDJCQUFBQTtBQUFBQTtNQUNFQSxPQUFBQztJQURGRCxDQUFBQTs7QUFJQUUsSUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQTtNQUNFQSxPQUFBO0lBREZBLENBQUFBOztBQUlBQyxJQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBO01BQ0VBLE9BQUNBLFNBQURBO0lBREZBLENBQUFBOztBQUlBQyxJQUFBQSxvQkFBQUEsWUFDRUMsQ0FERkQsQ0FBQUE7O0FBSUFFLElBQUFBLG9CQUFBQSxZQUNFeEIsRUFERndCLENBQUFBOztBQUlBQyxJQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBO01BQ0VBLE9BQUFDLGNBQVNDLEtBQUFBLENBQUtKLENBQWQsRUFBaUJBLENBQVJJO0lBRFhGLENBQUFBOztBQUlBRyxJQUFBQSwyQkFBQUEsdUJBMUVGLEVBMEVFQTtBQUFBQSxNQUFBQTs7O01BMUVGO01BMEVrQjtNQUNkLElBQUEsUUFBOENDLE9BQVpDLElBQUlDLFFBQUFBLENBQUFBLENBQVFGLEVBQUVHLENBQUZILENBQTlDLENBQUE7UUFBQTFCLE9BQVFDLE9BQUFBLENBQU82QixvQkFBUDdCO01BQVI7TUFDQXdCLE9BQUF6QixPQUFRK0IsVUFBQUEsQ0FBVVgsQ0FBbEIsRUFBcUJTLENBQWJFO0lBRlZOLENBQUFBLElBQUFBOztBQUtBTyxJQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBO01BQ0VBLE9BQUFoQyxPQUFRK0IsVUFBQUEsQ0FBVVgsQ0FBbEIsRUFBcUJTLENBQWJFO0lBRFZDLENBQUFBOztBQUlBQyxJQUFBQSxrQ0FBQUEsOEJBQUFBO0FBQUFBO01BQ0VBLE9BQUE7SUFERkEsQ0FBQUE7SUFJQXBDLE9BQUEsYUFBTSxNQUFOLEVBQVcsTUFBWDtFQXBGRkEsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQUhBRDsifX0seyJvZmZzZXQiOnsibGluZSI6Njc3MiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvYm9vbGVhbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIHVzZV9zdHJpY3Q6IHRydWVcclxuIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXHJcblxyXG5jbGFzcyA6OkJvb2xlYW4gPCBgQm9vbGVhbmBcclxuICBgT3BhbC5wcm9wKHNlbGYuJCRwcm90b3R5cGUsICckJGlzX2Jvb2xlYW4nLCB0cnVlKWBcclxuXHJcbiAgJXh7XHJcbiAgICB2YXIgcHJvcGVydGllcyA9IFsnJCRjbGFzcycsICckJG1ldGEnXTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuJCRwcm90b3R5cGUsIHByb3BlcnRpZXNbaV0sIHtcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzID09IHRydWUgID8gT3BhbC5UcnVlQ2xhc3MgOlxyXG4gICAgICAgICAgICAgICAgIHRoaXMgPT0gZmFsc2UgPyBPcGFsLkZhbHNlQ2xhc3MgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcGFsLkJvb2xlYW47XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi4kJHByb3RvdHlwZSwgXCIkJGlkXCIsIHtcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcyA9PSB0cnVlICA/IDIgOlxyXG4gICAgICAgICAgICAgICB0aGlzID09IGZhbHNlID8gMCA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuaWw7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgY2xhc3MgPDwgc2VsZlxyXG4gICAgZGVmIGFsbG9jYXRlXHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxyXG4gICAgZW5kXHJcblxyXG4gICAgdW5kZWYgOm5ld1xyXG4gIGVuZFxyXG5cclxuICBkZWYgX19pZF9fXHJcbiAgICBgc2VsZi52YWx1ZU9mKCkgPyAyIDogMGBcclxuICBlbmRcclxuXHJcbiAgZGVmICFcclxuICAgIGBzZWxmICE9IHRydWVgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiAmKG90aGVyKVxyXG4gICAgYChzZWxmID09IHRydWUpID8gKG90aGVyICE9PSBmYWxzZSAmJiBvdGhlciAhPT0gbmlsKSA6IGZhbHNlYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgfChvdGhlcilcclxuICAgIGAoc2VsZiA9PSB0cnVlKSA/IHRydWUgOiAob3RoZXIgIT09IGZhbHNlICYmIG90aGVyICE9PSBuaWwpYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgXihvdGhlcilcclxuICAgIGAoc2VsZiA9PSB0cnVlKSA/IChvdGhlciA9PT0gZmFsc2UgfHwgb3RoZXIgPT09IG5pbCkgOiAob3RoZXIgIT09IGZhbHNlICYmIG90aGVyICE9PSBuaWwpYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgPT0ob3RoZXIpXHJcbiAgICBgKHNlbGYgPT0gdHJ1ZSkgPT09IG90aGVyLnZhbHVlT2YoKWBcclxuICBlbmRcclxuXHJcbiAgZGVmIHNpbmdsZXRvbl9jbGFzc1xyXG4gICAgYHNlbGYuJCRtZXRhYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgdG9fc1xyXG4gICAgYChzZWxmID09IHRydWUpID8gJ3RydWUnIDogJ2ZhbHNlJ2BcclxuICBlbmRcclxuXHJcbiAgZGVmIGR1cFxyXG4gICAgc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgY2xvbmUoZnJlZXplOiB0cnVlKVxyXG4gICAgc2VsZlxyXG4gIGVuZFxyXG5cclxuICAjIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL29wYWwvb3BhbC9pc3N1ZXMvMjIzMFxyXG4gICNcclxuICAjIFRoaXMgaXMgYSBoYWNrIHRoYXQgYWxsb3dzIHlvdSB0byBhZGQgbWV0aG9kcyB0byBUcnVlQ2xhc3MgYW5kIEZhbHNlQ2xhc3MuXHJcbiAgIyBEbyBub3RlLCB0aGF0IHdoaWxlIHRydWUgYW5kIGZhbHNlIGhhdmUgYSBjb3JyZWN0ICQkY2xhc3MgKGl0J3MgZWl0aGVyXHJcbiAgIyBUcnVlQ2xhc3Mgb3IgRmFsc2VDbGFzcyksIHRoZWlyIHByb3RvdHlwZSBpcyBgQm9vbGVhbi4kJHByb3RvdHlwZWAsIHdoaWNoXHJcbiAgIyBiYXNpY2FsbHkgbWVhbnMgdGhhdCB3aGVuIGNhbGxpbmcgYHRydWUuc29tZXRoaW5nYCB3ZSBhY3R1YWxseSBjYWxsXHJcbiAgIyBgQm9vbGVhbiNzb21ldGhpbmdgIGluc3RlYWQgb2YgYFRydWVDbGFzcyNzb21ldGhpbmdgLiBTbyB1c2luZ1xyXG4gICMgbWV0aG9kX21pc3Npbmcgd2UgZGlzcGF0Y2ggaXQgdG8gYFRydWVDbGFzcy9GYWxzZUNsYXNzI3NvbWV0aGluZ2AgY29ycmVjdGx5LlxyXG4gICNcclxuICAjIFRoZSBkb3duc2lkZSBpcyB0aGF0IGEgY29ycmVjdCBpbXBsZW1lbnRhdGlvbiB3b3VsZCBhbHNvIGFsbG93IHVzIHRvIG92ZXJyaWRlXHJcbiAgIyB0aGUgbWV0aG9kcyBkZWZpbmVkIG9uIEJvb2xlYW4sIGJ1dCBvdXIgaW1wbGVtZW50YXRpb24gZG9lc24ndCBhbGxvdyB0aGF0LFxyXG4gICMgdW5sZXNzIHlvdSBkZWZpbmUgdGhlbSBvbiBCb29sZWFuIGFuZCBub3Qgb24gVHJ1ZUNsYXNzL0ZhbHNlQ2xhc3MuXHJcbiAgZGVmIG1ldGhvZF9taXNzaW5nKG1ldGhvZCwgKmFyZ3MsICZibG9jaylcclxuICAgIGB2YXIgYm9keSA9IHNlbGYuJCRjbGFzcy4kJHByb3RvdHlwZVtPcGFsLmpzaWQoI3ttZXRob2R9KV1gXHJcbiAgICBzdXBlciB1bmxlc3MgYHR5cGVvZiBib2R5ICE9PSAndW5kZWZpbmVkJyAmJiAhYm9keS4kJHN0dWJgXHJcbiAgICBgT3BhbC5zZW5kKHNlbGYsIGJvZHksICN7YXJnc30sICN7YmxvY2t9KWBcclxuICBlbmRcclxuXHJcbiAgZGVmIHJlc3BvbmRfdG9fbWlzc2luZz8obWV0aG9kLCBfaW5jbHVkZV9hbGwgPSBmYWxzZSlcclxuICAgIGB2YXIgYm9keSA9IHNlbGYuJCRjbGFzcy4kJHByb3RvdHlwZVtPcGFsLmpzaWQoI3ttZXRob2R9KV1gXHJcbiAgICBgdHlwZW9mIGJvZHkgIT09ICd1bmRlZmluZWQnICYmICFib2R5LiQkc3R1YmBcclxuICBlbmRcclxuXHJcbiAgYWxpYXMgZXFsPyA9PVxyXG4gIGFsaWFzIGVxdWFsPyA9PVxyXG4gIGFsaWFzIGluc3BlY3QgdG9fc1xyXG4gIGFsaWFzIG9iamVjdF9pZCBfX2lkX19cclxuZW5kXHJcblxyXG5jbGFzcyA6OlRydWVDbGFzcyA8IDo6Qm9vbGVhbjsgZW5kXHJcbmNsYXNzIDo6RmFsc2VDbGFzcyA8IDo6Qm9vbGVhbjsgZW5kXHJcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkJvb2xlYW4+IiwiYWxsb2NhdGUiLCJLZXJuZWwiLCJyYWlzZSIsIlR5cGVFcnJvciIsInNlbGYiLCJuYW1lIiwiX19pZF9fIiwiISIsIiYiLCJvdGhlciIsInwiLCJeIiwiPT0iLCJzaW5nbGV0b25fY2xhc3MiLCJ0b19zIiwiZHVwIiwiY2xvbmUiLCIka3dhcmdzIiwibWV0aG9kX21pc3NpbmciLCJtZXRob2QiLCJhcmdzIiwiYmxvY2siLCJyZXNwb25kX3RvX21pc3Npbmc/IiwiX2luY2x1ZGVfYWxsIiwiPGNsYXNzOlRydWVDbGFzcz4iLCJCb29sZWFuIiwiPGNsYXNzOkZhbHNlQ2xh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LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9jb21wYXJhYmxlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHJ1dGh5XHJcbiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxyXG5cclxubW9kdWxlIDo6Q29tcGFyYWJsZVxyXG4gICV4e1xyXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKHdoYXQpIHtcclxuICAgICAgaWYgKE9wYWwuaXNfYSh3aGF0LCBPcGFsLkludGVnZXIpKSB7IHJldHVybiB3aGF0OyB9XHJcblxyXG4gICAgICBpZiAoI3tgd2hhdGAgPiAwfSkgeyByZXR1cm4gMTsgfVxyXG4gICAgICBpZiAoI3tgd2hhdGAgPCAwfSkgeyByZXR1cm4gLTE7IH1cclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZmFpbF9jb21wYXJpc29uKGxocywgcmhzKSB7XHJcbiAgICAgIHZhciBjbGFzc19uYW1lO1xyXG4gICAgICAje1xyXG4gICAgICAgIGNhc2UgYHJoc2BcclxuICAgICAgICB3aGVuIG5pbCwgdHJ1ZSwgZmFsc2UsIDo6SW50ZWdlciwgOjpGbG9hdFxyXG4gICAgICAgICAgYGNsYXNzX25hbWUgPSByaHMuJGluc3BlY3QoKWBcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBgY2xhc3NfbmFtZSA9IHJocy4kJGNsYXNzYFxyXG4gICAgICAgIGVuZFxyXG4gICAgICB9XHJcbiAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tgbGhzYC5jbGFzc30gd2l0aCAje2BjbGFzc19uYW1lYH0gZmFpbGVkXCJ9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY21wX29yX2ZhaWwobGhzLCByaHMpIHtcclxuICAgICAgdmFyIGNtcCA9ICN7YGxoc2AgPD0+IGByaHNgfTtcclxuICAgICAgaWYgKCEkdHJ1dGh5KGNtcCkpIGZhaWxfY29tcGFyaXNvbihsaHMsIHJocyk7XHJcbiAgICAgIHJldHVybiBub3JtYWxpemUoY21wKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRlZiA9PShvdGhlcilcclxuICAgIHJldHVybiB0cnVlIGlmIGVxdWFsPyhvdGhlcilcclxuXHJcbiAgICAleHtcclxuICAgICAgaWYgKHNlbGZbXCIkPD0+XCJdID09IE9wYWwuS2VybmVsW1wiJDw9PlwiXSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gY2hlY2sgZm9yIGluZmluaXRlIHJlY3Vyc2lvblxyXG4gICAgICBpZiAoc2VsZi4kJGNvbXBhcmFibGUpIHtcclxuICAgICAgICBzZWxmLiQkY29tcGFyYWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgY21wID0gKHNlbGYgPD0+IG90aGVyKVxyXG5cclxuICAgIGBub3JtYWxpemUoY21wKSA9PSAwYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgPihvdGhlcilcclxuICAgIGBjbXBfb3JfZmFpbChzZWxmLCBvdGhlcikgPiAwYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgPj0ob3RoZXIpXHJcbiAgICBgY21wX29yX2ZhaWwoc2VsZiwgb3RoZXIpID49IDBgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiA8KG90aGVyKVxyXG4gICAgYGNtcF9vcl9mYWlsKHNlbGYsIG90aGVyKSA8IDBgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiA8PShvdGhlcilcclxuICAgIGBjbXBfb3JfZmFpbChzZWxmLCBvdGhlcikgPD0gMGBcclxuICBlbmRcclxuXHJcbiAgZGVmIGJldHdlZW4/KG1pbiwgbWF4KVxyXG4gICAgcmV0dXJuIGZhbHNlIGlmIHNlbGYgPCBtaW5cclxuICAgIHJldHVybiBmYWxzZSBpZiBzZWxmID4gbWF4XHJcbiAgICB0cnVlXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBjbGFtcChtaW4sIG1heCA9IG5pbClcclxuICAgICV4e1xyXG4gICAgICB2YXIgYywgZXhjbDtcclxuXHJcbiAgICAgIGlmIChtYXggPT09IG5pbCkge1xyXG4gICAgICAgIC8vIFdlIGFyZSBkZWFsaW5nIHdpdGggYSBuZXcgUnVieSAyLjcgYmVoYXZpb3VyIHRoYXQgd2UgYXJlIGFibGUgdG9cclxuICAgICAgICAvLyBwcm92aWRlIGEgc2luZ2xlIFJhbmdlIGFyZ3VtZW50IGluc3RlYWQgb2YgMiBDb21wYXJhYmxlcy5cclxuXHJcbiAgICAgICAgaWYgKCFPcGFsLmlzX2EobWluLCBPcGFsLlJhbmdlKSkge1xyXG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7bWluLmNsYXNzfSAoZXhwZWN0ZWQgUmFuZ2UpXCJ9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleGNsID0gbWluLmV4Y2w7XHJcbiAgICAgICAgbWF4ID0gbWluLmVuZDtcclxuICAgICAgICBtaW4gPSBtaW4uYmVnaW47XHJcblxyXG4gICAgICAgIGlmIChtYXggIT09IG5pbCAmJiBleGNsKSB7XHJcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2Nhbm5vdCBjbGFtcCB3aXRoIGFuIGV4Y2x1c2l2ZSByYW5nZSd9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobWluICE9PSBuaWwgJiYgbWF4ICE9PSBuaWwgJiYgY21wX29yX2ZhaWwobWluLCBtYXgpID4gMCkge1xyXG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbWluIGFyZ3VtZW50IG11c3QgYmUgc21hbGxlciB0aGFuIG1heCBhcmd1bWVudCd9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChtaW4gIT09IG5pbCkge1xyXG4gICAgICAgIGMgPSBjbXBfb3JfZmFpbChzZWxmLCBtaW4pO1xyXG5cclxuICAgICAgICBpZiAoYyA9PSAwKSByZXR1cm4gc2VsZjtcclxuICAgICAgICBpZiAoYyA8IDApIHJldHVybiBtaW47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChtYXggIT09IG5pbCkge1xyXG4gICAgICAgIGMgPSBjbXBfb3JfZmFpbChzZWxmLCBtYXgpO1xyXG5cclxuICAgICAgICBpZiAoYyA+IDApIHJldHVybiBtYXg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5lbmRcclxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkNvbXBhcmFibGU+IiwiPiIsIjAiLCI8IiwiJHJldF9vcl8xIiwiSW50ZWdlciIsIkZsb2F0IiwiS2VybmVsIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiY2xhc3MiLCI8PT4iLCI9PSIsIm90aGVyIiwic2VsZiIsImVxdWFsPyIsImNtcCIsIj49IiwiPD0iLCJiZXR3ZWVuPyIsIm1pbiIsIm1heCIsImNsYW1wIiwiVHlwZUVycm9yIl0sIm1hcHBpbmdzIjoiQUFBQUEscUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFHQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7O0FBRUFBO0FBQ0FBOztBQUVBQSxVQUFtQkMsT0FBTkQsSUFBTUMsRUFBRUMsQ0FBRkQsQ0FBSUQ7QUFDdkJBLFVBQW1CRyxPQUFOSCxJQUFNRyxFQUFFRCxDQUFGQyxDQUFJSDtBQUN2QkE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBLE1BRVEsQ0FqQlIsQ0FBQSxRQWlCYSxHQWpCYixFQWdCUUksQ0FBQUEsWUFBTUosR0FBTkksQ0FoQlIsQ0FBQSxJQUFBLENBQUEsQ0FBQSxRQWlCa0IsSUFqQmxCLEVBQUEsU0FBQSxDQUFBLElBQUEsQ0FBQSxDQUFBLFFBaUJ3QixLQWpCeEIsRUFBQSxTQUFBLENBQUEsSUFBQSxDQUFBLENBQUEsUUFpQitCQyxjQWpCL0IsRUFBQSxTQUFBLENBQUEsSUFBQSxDQUFBLFFBaUIwQ0MsWUFqQjFDLEVBQUEsU0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FpQlEsR0FBQSxDQUNHTiwyQkFESCxJQUFBLENBR0dBLHdCQUhILENBQUE7QUFNUkEsTUFBUU8sT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBaUNULGdCQUFELEdBQUEsTUFBaUJBLENBQUNBLEdBQURBLENBQUtVLE9BQUFBLENBQUFBLENBQXRCLENBQUEsR0FBNkJWLFFBQTdCLEdBQUEsTUFBc0NBLFVBQXRDLENBQUEsR0FBa0RBLFNBQTFFUTtBQUNoQlI7O0FBRUFBO0FBQ0FBLGdCQUFrQkEsQ0FBQ0EsR0FBREEsQ0FBTVcsUUFBQUEsQ0FBS1gsR0FBTFcsQ0FBVVg7QUFDbENBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVFWSxJQUFBQSxrQkFBQUEsOEJBQU9DLEtBQVBEO0FBQUFBLE1BQUFBOzs7TUFDRSxJQUFBLFFBQWVFLElBQUFDLFdBQUFBLENBQU9GLEtBQVBFLENBQWYsQ0FBQTtRQUFBLE9BQU87TUFBUDs7QUFHSkg7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO01BRUksS0FBQSxRQUFvQkksQ0FBQUEsTUFBT0YsSUFBS0gsUUFBQUEsQ0FBSUUsS0FBSkYsQ0FBWkssQ0FBcEIsQ0FBQTtRQUFBLE9BQU87TUFBUDtNQUVBSixPQUFDQSxtQkFBREE7SUFqQkZBLENBQUFBOztBQW9CQVgsSUFBQUEsaUJBQUFBLDJCQUFNWSxLQUFOWjtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EsNEJBQURBO0lBREZBLENBQUFBOztBQUlBZ0IsSUFBQUEsa0JBQUFBLDhCQUFPSixLQUFQSTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EsNkJBQURBO0lBREZBLENBQUFBOztBQUlBZCxJQUFBQSxpQkFBQUEsMkJBQU1VLEtBQU5WO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSw0QkFBREE7SUFERkEsQ0FBQUE7O0FBSUFlLElBQUFBLGtCQUFBQSw4QkFBT0wsS0FBUEs7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLDZCQUFEQTtJQURGQSxDQUFBQTs7QUFJQUMsSUFBQUEsd0JBQUFBLG9DQUFhQyxHQUFELEVBQU1DLEdBQWxCRjtBQUFBQSxNQUFBQTs7O01BQ0UsSUFBQSxRQUFxQmhCLE9BQUxXLElBQUtYLEVBQUVpQixHQUFGakIsQ0FBckIsQ0FBQTtRQUFBLE9BQU87TUFBUDtNQUNBLElBQUEsUUFBcUJGLE9BQUxhLElBQUtiLEVBQUVvQixHQUFGcEIsQ0FBckIsQ0FBQTtRQUFBLE9BQU87TUFBUDtNQUNBa0IsT0FBQTtJQUhGQSxDQUFBQTtJQU1BbkIsT0FBQXNCLHFCQUFBQSxpQkFBVUYsR0FBRCxFQUFNQyxHQUFmQztBQUFBQSxNQUFBQTs7O01BQWUsdUJBQU07O0FBRXZCQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLFVBQVlmLE9BQVFDLE9BQUFBLENBQU9lLGdCQUFmLEVBQTZCRCxzQkFBRCxHQUFBLE1BQXVCRixHQUFHVixPQUFBQSxDQUFBQSxDQUExQixDQUFBLEdBQWlDWSxtQkFBckRkO0FBQ3BCYzs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLFVBQVlmLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWdDYSxzQ0FBeEJkO0FBQ3BCYztBQUNBQTs7QUFFQUE7QUFDQUEsUUFBVWYsT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBZ0NhLGdEQUF4QmQ7QUFDbEJjOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7SUF2Q0VBLENBQUFBLElBQUFBO0VBeEVGdEIsR0FBTyxJQUFQQTtBQUhBRDsifX0seyJvZmZzZXQiOnsibGluZSI6NzA1NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmVnZXhwLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogY29lcmNlX3RvLCBwcm9wLCBmcmVlemUsIGFubm90YXRlX3JlZ2V4cCwgZXNjYXBlX21ldGFjaGFyYWN0ZXJzXHJcbiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxyXG4jIHVzZV9zdHJpY3Q6IHRydWVcclxuXHJcbmNsYXNzIDo6UmVnZXhwRXJyb3IgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxyXG5cclxuY2xhc3MgOjpSZWdleHAgPCBgUmVnRXhwYFxyXG4gIHNlbGY6OklHTk9SRUNBU0UgPSAxXHJcbiAgc2VsZjo6RVhURU5ERUQgPSAyXHJcbiAgc2VsZjo6TVVMVElMSU5FID0gNFxyXG4gICMgTm90IHN1cHBvcnRlZDpcclxuICBzZWxmOjpGSVhFREVOQ09ESU5HID0gMTZcclxuICBzZWxmOjpOT0VOQ09ESU5HID0gMzJcclxuXHJcbiAgYE9wYWwucHJvcChzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19yZWdleHAnLCB0cnVlKWBcclxuICBgT3BhbC5wcm9wKHNlbGYuJCRwcm90b3R5cGUsICckJHNvdXJjZScsIG51bGwpYFxyXG4gIGBPcGFsLnByb3Aoc2VsZi4kJHByb3RvdHlwZSwgJyQkb3B0aW9ucycsIG51bGwpYFxyXG4gIGBPcGFsLnByb3Aoc2VsZi4kJHByb3RvdHlwZSwgJyQkZycsIG51bGwpYFxyXG5cclxuICBjbGFzcyA8PCBzZWxmXHJcbiAgICBkZWYgYWxsb2NhdGVcclxuICAgICAgYWxsb2NhdGVkID0gc3VwZXJcclxuICAgICAgYCN7YWxsb2NhdGVkfS51bmluaXRpYWxpemVkID0gdHJ1ZWBcclxuICAgICAgYWxsb2NhdGVkXHJcbiAgICBlbmRcclxuXHJcbiAgICBkZWYgZXNjYXBlKHN0cmluZylcclxuICAgICAgJXh7XHJcbiAgICAgICAgc3RyaW5nID0gJGNvZXJjZV90byhzdHJpbmcsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XHJcbiAgICAgICAgcmV0dXJuIE9wYWwuZXNjYXBlX3JlZ2V4cChzdHJpbmcpO1xyXG4gICAgICB9XHJcbiAgICBlbmRcclxuXHJcbiAgICBkZWYgbGFzdF9tYXRjaChuID0gbmlsKVxyXG4gICAgICBpZiBuLm5pbD9cclxuICAgICAgICAkflxyXG4gICAgICBlbHNpZiAkflxyXG4gICAgICAgICR+W25dXHJcbiAgICAgIGVuZFxyXG4gICAgZW5kXHJcblxyXG4gICAgZGVmIHVuaW9uKCpwYXJ0cylcclxuICAgICAgJXh7XHJcbiAgICAgICAgZnVuY3Rpb24gZXhjbHVkZV9jb21wYXRpYmxlKGZsYWdzKSB7XHJcbiAgICAgICAgICByZXR1cm4gKGZsYWdzIHx8IDApICYgfiN7TVVMVElMSU5FfSAmIH4je0VYVEVOREVEfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gY29tcGF0aWJsZV9mbGFncyhmaXJzdCwgc2Vjb25kKSB7XHJcbiAgICAgICAgICByZXR1cm4gZXhjbHVkZV9jb21wYXRpYmxlKGZpcnN0KSA9PSBleGNsdWRlX2NvbXBhdGlibGUoc2Vjb25kKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGlzX2ZpcnN0X3BhcnRfYXJyYXksIHF1b3RlZF92YWxpZGF0ZWQsIHBhcnQsIG9wdGlvbnMsIGVhY2hfcGFydF9vcHRpb25zO1xyXG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgcmV0dXJuIC8oPyEpLztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmV0dXJuIGZhc3QgaWYgdGhlcmUncyBvbmx5IG9uZSBlbGVtZW50XHJcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PSAxICYmIHBhcnRzWzBdLiQkaXNfcmVnZXhwKSB7XHJcbiAgICAgICAgICByZXR1cm4gcGFydHNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvdmVyIHRoZSAyIGFycmF5cyBwYXNzZWQgYXMgYXJndW1lbnRzIGNhc2VcclxuICAgICAgICBpc19maXJzdF9wYXJ0X2FycmF5ID0gcGFydHNbMF0uJCRpc19hcnJheTtcclxuICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSAmJiBpc19maXJzdF9wYXJ0X2FycmF5KSB7XHJcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnbm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiBBcnJheSBpbnRvIFN0cmluZyd9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGRlYWwgd2l0aCBzcGxhdCBpc3N1ZXMgKHJlbGF0ZWQgdG8gaHR0cHM6Ly9naXRodWIuY29tL29wYWwvb3BhbC9pc3N1ZXMvODU4KVxyXG4gICAgICAgIGlmIChpc19maXJzdF9wYXJ0X2FycmF5KSB7XHJcbiAgICAgICAgICBwYXJ0cyA9IHBhcnRzWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHF1b3RlZF92YWxpZGF0ZWQgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgcGFydCA9IHBhcnRzW2ldO1xyXG4gICAgICAgICAgaWYgKHBhcnQuJCRpc19zdHJpbmcpIHtcclxuICAgICAgICAgICAgcXVvdGVkX3ZhbGlkYXRlZC5wdXNoKCN7ZXNjYXBlKGBwYXJ0YCl9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKHBhcnQuJCRpc19yZWdleHApIHtcclxuICAgICAgICAgICAgZWFjaF9wYXJ0X29wdGlvbnMgPSAje2BwYXJ0YC5vcHRpb25zfTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMgIT0gdW5kZWZpbmVkICYmICFjb21wYXRpYmxlX2ZsYWdzKG9wdGlvbnMsIGVhY2hfcGFydF9vcHRpb25zKSkge1xyXG4gICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdBbGwgZXhwcmVzc2lvbnMgbXVzdCB1c2UgdGhlIHNhbWUgb3B0aW9ucyd9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3B0aW9ucyA9IGVhY2hfcGFydF9vcHRpb25zO1xyXG4gICAgICAgICAgICBxdW90ZWRfdmFsaWRhdGVkLnB1c2goJyg/OicrI3tgcGFydGAuc291cmNlfSsnKScpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHF1b3RlZF92YWxpZGF0ZWQucHVzaCgje2VzY2FwZShgcGFydGAudG9fc3RyKX0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAjIFRha2UgYWR2YW50YWdlIG9mIGxvZ2ljIHRoYXQgY2FuIHBhcnNlIG9wdGlvbnMgZnJvbSBKUyBSZWdleFxyXG4gICAgICBuZXcoYHF1b3RlZF92YWxpZGF0ZWRgLmpvaW4oJ3wnKSwgYG9wdGlvbnNgKVxyXG4gICAgZW5kXHJcblxyXG4gICAgZGVmIG5ldyhyZWdleHAsIG9wdGlvbnMgPSB1bmRlZmluZWQpXHJcbiAgICAgICV4e1xyXG4gICAgICAgIGlmIChyZWdleHAuJCRpc19yZWdleHApIHtcclxuICAgICAgICAgIHJldHVybiAkYW5ub3RhdGVfcmVnZXhwKG5ldyBSZWdFeHAocmVnZXhwKSwgcmVnZXhwLiQkc291cmNlLCByZWdleHAuJCRvcHRpb25zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlZ2V4cCA9ICN7OjpPcGFsLmNvZXJjZV90byEocmVnZXhwLCA6OlN0cmluZywgOnRvX3N0cil9O1xyXG5cclxuICAgICAgICBpZiAocmVnZXhwLmNoYXJBdChyZWdleHAubGVuZ3RoIC0gMSkgPT09ICdcXFxcJyAmJiByZWdleHAuY2hhckF0KHJlZ2V4cC5sZW5ndGggLSAyKSAhPT0gJ1xcXFwnKSB7XHJcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6UmVnZXhwRXJyb3IsIFwidG9vIHNob3J0IGVzY2FwZSBzZXF1ZW5jZTogLyN7cmVnZXhwfS9cIn1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgfHwgI3shb3B0aW9uc30pIHtcclxuICAgICAgICAgIG9wdGlvbnMgPSAndSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuJCRpc19udW1iZXIpIHtcclxuICAgICAgICAgIHZhciB0ZW1wID0gJ3UnO1xyXG4gICAgICAgICAgaWYgKCN7SUdOT1JFQ0FTRX0gJiBvcHRpb25zKSB7IHRlbXAgKz0gJ2knOyB9XHJcbiAgICAgICAgICBpZiAoI3tNVUxUSUxJTkV9ICAmIG9wdGlvbnMpIHsgdGVtcCArPSAnbSc7IH1cclxuICAgICAgICAgIG9wdGlvbnMgPSB0ZW1wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghb3B0aW9ucy4kJGlzX3N0cmluZykge1xyXG4gICAgICAgICAgb3B0aW9ucyA9ICdpdSc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gT3BhbC50cmFuc2Zvcm1fcmVnZXhwKHJlZ2V4cCwgb3B0aW9ucyk7XHJcbiAgICAgICAgcmV0dXJuIE9wYWwuYW5ub3RhdGVfcmVnZXhwKG5ldyBSZWdFeHAocmVzdWx0WzBdLCByZXN1bHRbMV0pLCAkZXNjYXBlX21ldGFjaGFyYWN0ZXJzKHJlZ2V4cCksIG9wdGlvbnMpO1xyXG4gICAgICB9XHJcbiAgICBlbmRcclxuXHJcbiAgICBhbGlhcyBjb21waWxlIG5ld1xyXG4gICAgYWxpYXMgcXVvdGUgZXNjYXBlXHJcbiAgZW5kXHJcblxyXG4gIGRlZiA9PShvdGhlcilcclxuICAgIGBvdGhlciBpbnN0YW5jZW9mIFJlZ0V4cCAmJiBzZWxmLiRvcHRpb25zKCkgPT0gb3RoZXIuJG9wdGlvbnMoKSAmJiBzZWxmLiRzb3VyY2UoKSA9PSBvdGhlci4kc291cmNlKClgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiA9PT0oc3RyaW5nKVxyXG4gICAgYCN7bWF0Y2goOjpPcGFsLmNvZXJjZV90bz8oc3RyaW5nLCA6OlN0cmluZywgOnRvX3N0cikpfSAhPT0gbmlsYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgPX4oc3RyaW5nKVxyXG4gICAgbWF0Y2goc3RyaW5nKSAmJiAkfi5iZWdpbigwKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZnJlZXplXHJcbiAgICAjIFNwZWNpYWxpemVkIHZlcnNpb24gb2YgZnJlZXplLCBiZWNhdXNlIHRoZSAkJGdtIGFuZCAkJGcgcHJvcGVydGllcyBuZWVkIHRvIGJlIHNldFxyXG4gICAgIyBlc3BlY2lhbGx5IGZvciBSZWdFeHAuXHJcblxyXG4gICAgcmV0dXJuIHNlbGYgaWYgZnJvemVuP1xyXG5cclxuICAgICV4e1xyXG4gICAgICBpZiAoIXNlbGYuaGFzT3duUHJvcGVydHkoJyQkZycpKSB7ICRwcm9wKHNlbGYsICckJGcnLCBudWxsKTsgfVxyXG5cclxuICAgICAgcmV0dXJuICRmcmVlemUoc2VsZik7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBpbnNwZWN0XHJcbiAgICAjIFVzZSBhIHJlZ2V4cCB0byBleHRyYWN0IHRoZSByZWd1bGFyIGV4cHJlc3Npb24gYW5kIHRoZSBvcHRpb25hbCBtb2RlIG1vZGlmaWVycyBmcm9tIHRoZSBzdHJpbmcuXHJcbiAgICAjIEluIHRoZSByZWd1bGFyIGV4cHJlc3Npb24sIGVzY2FwZSBhbnkgZnJvbnQgc2xhc2ggKG5vdCBhbHJlYWR5IGVzY2FwZWQpIHdpdGggYSBiYWNrc2xhc2guXHJcbiAgICAleHtcclxuICAgICAgdmFyIHJlZ2V4cF9wYXR0ZXJuID0gc2VsZi4kc291cmNlKCk7XHJcbiAgICAgIHZhciByZWdleHBfZmxhZ3MgPSBzZWxmLiQkb3B0aW9ucyAhPSBudWxsID8gc2VsZi4kJG9wdGlvbnMgOiBzZWxmLmZsYWdzO1xyXG4gICAgICByZWdleHBfZmxhZ3MgPSByZWdleHBfZmxhZ3MucmVwbGFjZSgndScsICcnKTtcclxuICAgICAgdmFyIGNoYXJzID0gcmVnZXhwX3BhdHRlcm4uc3BsaXQoJycpO1xyXG4gICAgICB2YXIgY2hhcnNfbGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xyXG4gICAgICB2YXIgY2hhcl9lc2NhcGVkID0gZmFsc2U7XHJcbiAgICAgIHZhciByZWdleHBfcGF0dGVybl9lc2NhcGVkID0gJyc7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnNfbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgY3VycmVudF9jaGFyID0gY2hhcnNbaV07XHJcbiAgICAgICAgaWYgKCFjaGFyX2VzY2FwZWQgJiYgY3VycmVudF9jaGFyID09ICcvJykge1xyXG4gICAgICAgICAgcmVnZXhwX3BhdHRlcm5fZXNjYXBlZCArPSAnXFxcXCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlZ2V4cF9wYXR0ZXJuX2VzY2FwZWQgKz0gY3VycmVudF9jaGFyO1xyXG4gICAgICAgIGlmIChjdXJyZW50X2NoYXIgPT0gJ1xcXFwnKSB7XHJcbiAgICAgICAgICAvLyBkb2VzIG5vdCBvdmVyIGVzY2FwZVxyXG4gICAgICAgICAgY2hhcl9lc2NhcGVkID0gIWNoYXJfZXNjYXBlZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY2hhcl9lc2NhcGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAnLycgKyByZWdleHBfcGF0dGVybl9lc2NhcGVkICsgJy8nICsgcmVnZXhwX2ZsYWdzO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgbWF0Y2goc3RyaW5nLCBwb3MgPSB1bmRlZmluZWQsICZibG9jaylcclxuICAgICV4e1xyXG4gICAgICBpZiAoc2VsZi51bmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ3VuaW5pdGlhbGl6ZWQgUmVnZXhwJ31cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHBvcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaWYgKHN0cmluZyA9PT0gbmlsKSByZXR1cm4gI3skfiA9IG5pbH07XHJcbiAgICAgICAgdmFyIG0gPSBzZWxmLmV4ZWMoJGNvZXJjZV90byhzdHJpbmcsICN7OjpTdHJpbmd9LCAndG9fc3RyJykpO1xyXG4gICAgICAgIGlmIChtKSB7XHJcbiAgICAgICAgICAjeyR+ID0gOjpNYXRjaERhdGEubmV3KGBzZWxmYCwgYG1gKX07XHJcbiAgICAgICAgICByZXR1cm4gYmxvY2sgPT09IG5pbCA/ICN7JH59IDogI3t5aWVsZCAkfn07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiAjeyR+ID0gbmlsfTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHBvcyA9ICRjb2VyY2VfdG8ocG9zLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcclxuXHJcbiAgICAgIGlmIChzdHJpbmcgPT09IG5pbCkge1xyXG4gICAgICAgIHJldHVybiAjeyR+ID0gbmlsfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3RyaW5nID0gJGNvZXJjZV90byhzdHJpbmcsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XHJcblxyXG4gICAgICBpZiAocG9zIDwgMCkge1xyXG4gICAgICAgIHBvcyArPSBzdHJpbmcubGVuZ3RoO1xyXG4gICAgICAgIGlmIChwb3MgPCAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gI3skfiA9IG5pbH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBnbG9iYWwgUmVnRXhwIG1haW50YWlucyBzdGF0ZSwgc28gbm90IHVzaW5nIHNlbGYvdGhpc1xyXG4gICAgICB2YXIgbWQsIHJlID0gT3BhbC5nbG9iYWxfcmVnZXhwKHNlbGYpO1xyXG5cclxuICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICBtZCA9IHJlLmV4ZWMoc3RyaW5nKTtcclxuICAgICAgICBpZiAobWQgPT09IG51bGwpIHtcclxuICAgICAgICAgIHJldHVybiAjeyR+ID0gbmlsfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1kLmluZGV4ID49IHBvcykge1xyXG4gICAgICAgICAgI3skfiA9IDo6TWF0Y2hEYXRhLm5ldyhgcmVgLCBgbWRgKX07XHJcbiAgICAgICAgICByZXR1cm4gYmxvY2sgPT09IG5pbCA/ICN7JH59IDogI3t5aWVsZCAkfn07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlLmxhc3RJbmRleCA9IG1kLmluZGV4ICsgMTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgbWF0Y2g/KHN0cmluZywgcG9zID0gdW5kZWZpbmVkKVxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChzZWxmLnVuaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAndW5pbml0aWFsaXplZCBSZWdleHAnfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nID09PSBuaWwgPyBmYWxzZSA6IHNlbGYudGVzdCgkY29lcmNlX3RvKHN0cmluZywgI3s6OlN0cmluZ30sICd0b19zdHInKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHBvcyA9ICRjb2VyY2VfdG8ocG9zLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcclxuXHJcbiAgICAgIGlmIChzdHJpbmcgPT09IG5pbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3RyaW5nID0gJGNvZXJjZV90byhzdHJpbmcsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XHJcblxyXG4gICAgICBpZiAocG9zIDwgMCkge1xyXG4gICAgICAgIHBvcyArPSBzdHJpbmcubGVuZ3RoO1xyXG4gICAgICAgIGlmIChwb3MgPCAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBnbG9iYWwgUmVnRXhwIG1haW50YWlucyBzdGF0ZSwgc28gbm90IHVzaW5nIHNlbGYvdGhpc1xyXG4gICAgICB2YXIgbWQsIHJlID0gT3BhbC5nbG9iYWxfcmVnZXhwKHNlbGYpO1xyXG5cclxuICAgICAgbWQgPSByZS5leGVjKHN0cmluZyk7XHJcbiAgICAgIGlmIChtZCA9PT0gbnVsbCB8fCBtZC5pbmRleCA8IHBvcykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgbmFtZXNcclxuICAgIHNvdXJjZS5zY2FuKC9cXCg/PChcXHcrKT4vLCBub19tYXRjaGRhdGE6IHRydWUpLm1hcCgmOmZpcnN0KS51bmlxXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBuYW1lZF9jYXB0dXJlc1xyXG4gICAgc291cmNlLnNjYW4oL1xcKD88KFxcdyspPi8sIG5vX21hdGNoZGF0YTogdHJ1ZSkgIyBTY2FuIGZvciBjYXB0dXJlIGdyb3Vwc1xyXG4gICAgICAgICAgLm1hcCgmOmZpcnN0KSAgICAgICAgICAgICAgICAgICAgICAgICAgICMgR2V0IHRoZSBmaXJzdCByZWdleHAgbWF0Y2ggKFxcdyspXHJcbiAgICAgICAgICAuZWFjaF93aXRoX2luZGV4ICAgICAgICAgICAgICAgICAgICAgICAgIyBBZGQgaW5kZXggdG8gYW4gaXRlcmF0b3JcclxuICAgICAgICAgIC5ncm91cF9ieSgmOmZpcnN0KSAgICAgICAgICAgICAgICAgICAgICAjIEdyb3VwIGJ5IHRoZSBjYXB0dXJlIGdyb3VwIG5hbWVzXHJcbiAgICAgICAgICAudHJhbnNmb3JtX3ZhbHVlcyBkbyB8aXwgICAgICAgICAgICAgICAgIyBDb252ZXJ0IGhhc2ggdmFsdWVzXHJcbiAgICAgICAgICAgIGkubWFwIHsgfGp8IGoubGFzdCArIDEgfSAgICAgICAgICAgICAgIyBEcm9wIHRoZSBjYXB0dXJlIGdyb3VwIG5hbWVzOyBpbmNyZWFzZSBpbmRleGVzIGJ5IDFcclxuICAgICAgICAgIGVuZFxyXG4gIGVuZFxyXG5cclxuICBkZWYgflxyXG4gICAgc2VsZiA9fiAkX1xyXG4gIGVuZFxyXG5cclxuICBkZWYgc291cmNlXHJcbiAgICBgc2VsZi4kJHNvdXJjZSAhPSBudWxsID8gc2VsZi4kJHNvdXJjZSA6IHNlbGYuc291cmNlYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgb3B0aW9uc1xyXG4gICAgIyBGbGFncyB3b3VsZCBiZSBuaWNlIHRvIHVzZSB3aXRoIHRoaXMsIGJ1dCBzdGlsbCBleHBlcmltZW50YWwgLSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9SZWdFeHAvZmxhZ3NcclxuICAgICV4e1xyXG4gICAgICBpZiAoc2VsZi51bmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ3VuaW5pdGlhbGl6ZWQgUmVnZXhwJ31cclxuICAgICAgfVxyXG4gICAgICB2YXIgcmVzdWx0ID0gMDtcclxuICAgICAgLy8gc2hvdWxkIGJlIHN1cHBvcnRlZCBpbiBJRTYgYWNjb3JkaW5nIHRvIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvN2Y1ejI2dzQodj12cy45NCkuYXNweFxyXG4gICAgICBpZiAoc2VsZi4kJG9wdGlvbnMgIT0gbnVsbCA/IHNlbGYuJCRvcHRpb25zLmluY2x1ZGVzKCdtJykgOiBzZWxmLm11bHRpbGluZSkge1xyXG4gICAgICAgIHJlc3VsdCB8PSAje01VTFRJTElORX07XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNlbGYuJCRvcHRpb25zICE9IG51bGwgPyBzZWxmLiQkb3B0aW9ucy5pbmNsdWRlcygnaScpIDogc2VsZi5pZ25vcmVDYXNlKSB7XHJcbiAgICAgICAgcmVzdWx0IHw9ICN7SUdOT1JFQ0FTRX07XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNlbGYuJCRvcHRpb25zICE9IG51bGwgPyBzZWxmLiQkb3B0aW9ucy5pbmNsdWRlcygneCcpIDogZmFsc2UpIHtcclxuICAgICAgICByZXN1bHQgfD0gI3tFWFRFTkRFRH07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGNhc2Vmb2xkP1xyXG4gICAgYHNlbGYuaWdub3JlQ2FzZWBcclxuICBlbmRcclxuXHJcbiAgYWxpYXMgZXFsPyA9PVxyXG4gIGFsaWFzIHRvX3Mgc291cmNlXHJcbmVuZFxyXG5cclxuY2xhc3MgTWF0Y2hEYXRhXHJcbiAgYXR0cl9yZWFkZXIgOnBvc3RfbWF0Y2gsIDpwcmVfbWF0Y2gsIDpyZWdleHAsIDpzdHJpbmdcclxuXHJcbiAgZGVmIGluaXRpYWxpemUocmVnZXhwLCBtYXRjaF9ncm91cHMsIG5vX21hdGNoZGF0YTogZmFsc2UpXHJcbiAgICAkfiAgICAgICAgICA9IHNlbGYgdW5sZXNzIG5vX21hdGNoZGF0YVxyXG4gICAgQHJlZ2V4cCAgICAgPSByZWdleHBcclxuICAgIEBiZWdpbiAgICAgID0gYG1hdGNoX2dyb3Vwcy5pbmRleGBcclxuICAgIEBzdHJpbmcgICAgID0gYG1hdGNoX2dyb3Vwcy5pbnB1dGBcclxuICAgIEBwcmVfbWF0Y2ggID0gYG1hdGNoX2dyb3Vwcy5pbnB1dC5zbGljZSgwLCBtYXRjaF9ncm91cHMuaW5kZXgpYFxyXG4gICAgQHBvc3RfbWF0Y2ggPSBgbWF0Y2hfZ3JvdXBzLmlucHV0LnNsaWNlKG1hdGNoX2dyb3Vwcy5pbmRleCArIG1hdGNoX2dyb3Vwc1swXS5sZW5ndGgpYFxyXG4gICAgQG1hdGNoZXMgICAgPSBbXVxyXG5cclxuICAgICV4e1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbWF0Y2hfZ3JvdXBzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGdyb3VwID0gbWF0Y2hfZ3JvdXBzW2ldO1xyXG5cclxuICAgICAgICBpZiAoZ3JvdXAgPT0gbnVsbCkge1xyXG4gICAgICAgICAgI3tAbWF0Y2hlc30ucHVzaChuaWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICN7QG1hdGNoZXN9LnB1c2goZ3JvdXApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgbWF0Y2goaWR4KVxyXG4gICAgaWYgKG1hdGNoID0gc2VsZltpZHhdKVxyXG4gICAgICBtYXRjaFxyXG4gICAgZWxzaWYgaWR4LmlzX2E/KEludGVnZXIpICYmIGlkeCA+PSBsZW5ndGhcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpJbmRleEVycm9yLCBcImluZGV4ICN7aWR4fSBvdXQgb2YgbWF0Y2hlc1wiXHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmIG1hdGNoX2xlbmd0aChpZHgpXHJcbiAgICBtYXRjaChpZHgpJi5sZW5ndGhcclxuICBlbmRcclxuXHJcbiAgZGVmIFtdKCphcmdzKVxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChhcmdzWzBdLiQkaXNfc3RyaW5nKSB7XHJcbiAgICAgICAgaWYgKCN7IXJlZ2V4cC5uYW1lcy5pbmNsdWRlPyhhcmdzWzBdKX0pIHtcclxuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpJbmRleEVycm9yLCBcInVuZGVmaW5lZCBncm91cCBuYW1lIHJlZmVyZW5jZTogI3thcmdzWzBdfVwifVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gI3tuYW1lZF9jYXB0dXJlc1thcmdzWzBdXX1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gI3tAbWF0Y2hlc1sqYXJnc119XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIG9mZnNldChuKVxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChuICE9PSAwKSB7XHJcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdNYXRjaERhdGEjb2Zmc2V0IG9ubHkgc3VwcG9ydHMgMHRoIGVsZW1lbnQnfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBbc2VsZi5iZWdpbiwgc2VsZi5iZWdpbiArIHNlbGYubWF0Y2hlc1tuXS5sZW5ndGhdO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgPT0ob3RoZXIpXHJcbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIDo6TWF0Y2hEYXRhID09PSBvdGhlclxyXG5cclxuICAgIGBzZWxmLnN0cmluZyA9PSBvdGhlci5zdHJpbmdgICYmXHJcbiAgICAgIGBzZWxmLnJlZ2V4cC50b1N0cmluZygpID09IG90aGVyLnJlZ2V4cC50b1N0cmluZygpYCAmJlxyXG4gICAgICBgc2VsZi5wcmVfbWF0Y2ggPT0gb3RoZXIucHJlX21hdGNoYCAmJlxyXG4gICAgICBgc2VsZi5wb3N0X21hdGNoID09IG90aGVyLnBvc3RfbWF0Y2hgICYmXHJcbiAgICAgIGBzZWxmLmJlZ2luID09IG90aGVyLmJlZ2luYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgYmVnaW4obilcclxuICAgICV4e1xyXG4gICAgICBpZiAobiAhPT0gMCkge1xyXG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnTWF0Y2hEYXRhI2JlZ2luIG9ubHkgc3VwcG9ydHMgMHRoIGVsZW1lbnQnfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzZWxmLmJlZ2luO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZW5kKG4pXHJcbiAgICAleHtcclxuICAgICAgaWYgKG4gIT09IDApIHtcclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ01hdGNoRGF0YSNlbmQgb25seSBzdXBwb3J0cyAwdGggZWxlbWVudCd9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNlbGYuYmVnaW4gKyBzZWxmLm1hdGNoZXNbbl0ubGVuZ3RoO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgY2FwdHVyZXNcclxuICAgIGAje0BtYXRjaGVzfS5zbGljZSgxKWBcclxuICBlbmRcclxuXHJcbiAgZGVmIG5hbWVkX2NhcHR1cmVzXHJcbiAgICBtYXRjaGVzID0gY2FwdHVyZXNcclxuICAgIHJlZ2V4cC5uYW1lZF9jYXB0dXJlcy50cmFuc2Zvcm1fdmFsdWVzIGRvIHxpfFxyXG4gICAgICBtYXRjaGVzW2kubGFzdCAtIDFdXHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmIG5hbWVzXHJcbiAgICByZWdleHAubmFtZXNcclxuICBlbmRcclxuXHJcbiAgZGVmIGluc3BlY3RcclxuICAgICV4e1xyXG4gICAgICB2YXIgc3RyID0gXCIjPE1hdGNoRGF0YSBcIiArICN7YCN7QG1hdGNoZXN9WzBdYC5pbnNwZWN0fTtcclxuXHJcbiAgICAgIGlmICgje3JlZ2V4cC5uYW1lcy5lbXB0eT99KSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGxlbmd0aCA9ICN7QG1hdGNoZXN9Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBzdHIgKz0gXCIgXCIgKyBpICsgXCI6XCIgKyAje2Aje0BtYXRjaGVzfVtpXWAuaW5zcGVjdH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICN7IG5hbWVkX2NhcHR1cmVzLmVhY2ggZG8gfGssIHZ8XHJcbiAgICAgICAgICAgICAleHtcclxuICAgICAgICAgICAgICAgc3RyICs9IFwiIFwiICsgI3trfSArIFwiOlwiICsgI3t2Lmluc3BlY3R9XHJcbiAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgZW5kIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHN0ciArIFwiPlwiO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgbGVuZ3RoXHJcbiAgICBgI3tAbWF0Y2hlc30ubGVuZ3RoYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgdG9fYVxyXG4gICAgQG1hdGNoZXNcclxuICBlbmRcclxuXHJcbiAgZGVmIHRvX3NcclxuICAgIGAje0BtYXRjaGVzfVswXWBcclxuICBlbmRcclxuXHJcbiAgZGVmIHZhbHVlc19hdCgqYXJncylcclxuICAgICV4e1xyXG4gICAgICB2YXIgaSwgYSwgaW5kZXgsIHZhbHVlcyA9IFtdO1xyXG5cclxuICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuXHJcbiAgICAgICAgaWYgKGFyZ3NbaV0uJCRpc19yYW5nZSkge1xyXG4gICAgICAgICAgYSA9ICN7YGFyZ3NbaV1gLnRvX2F9O1xyXG4gICAgICAgICAgYS51bnNoaWZ0KGksIDEpO1xyXG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5hcHBseShhcmdzLCBhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGluZGV4ID0gI3s6Ok9wYWwuY29lcmNlX3RvIShgYXJnc1tpXWAsIDo6SW50ZWdlciwgOnRvX2ludCl9O1xyXG5cclxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICBpbmRleCArPSAje0BtYXRjaGVzfS5sZW5ndGg7XHJcbiAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKG5pbCk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFsdWVzLnB1c2goI3tAbWF0Y2hlc31baW5kZXhdKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHZhbHVlcztcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgYWxpYXMgZXFsPyA9PVxyXG4gIGFsaWFzIHNpemUgbGVuZ3RoXHJcbmVuZFxyXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpSZWdleHBFcnJvcj4iLCJTdGFuZGFyZEVycm9yIiwiPGNsYXNzOlJlZ2V4cD4iLCJzZWxmIiwiMSIsIjIiLCI0IiwiMTYiLCIzMiIsImFsbG9jYXRlIiwiYWxsb2NhdGVkIiwiZXNjYXBlIiwic3RyaW5nIiwiU3RyaW5nIiwibGFzdF9tYXRjaCIsIm4iLCJuaWw/IiwiJH4iLCJbXSIsInVuaW9uIiwiTVVMVElMSU5FIiwiRVhURU5ERUQiLCJLZXJuZWwiLCJyYWlzZSIsIlR5cGVFcnJvciIsIm9wdGlvbnMiLCJzb3VyY2UiLCJ0b19zdHIiLCJuZXciLCJqb2luIiwicmVnZXhwIiwiT3BhbCIsImNvZXJjZV90byEiLCJSZWdleHBFcnJvciIsIiEiLCJJR05PUkVDQVNFIiwiPT0iLCJvdGhlciIsIj09PSIsIm1hdGNoIiwiY29lcmNlX3RvPyIsIj1+IiwiJHJldF9vcl8xIiwiYmVnaW4iLCIwIiwiZnJlZXplIiwiZnJvemVuPyIsImluc3BlY3QiLCJwb3MiLCJNYXRjaERhdGEiLCJJbnRlZ2VyIiwibWF0Y2g/IiwibmFtZXMiLCJtYXAiLCJzY2FuIiwidG9fcHJvYyIsInVuaXEiLCJuYW1lZF9jYXB0dXJlcyIsInRyYW5zZm9ybV92YWx1ZXMiLCJncm91cF9ieSIsImVhY2hfd2l0aF9pbmRleCIsImJsb2NrIGluIG5hbWVkX2NhcHR1cmVzIiwiaSIsImJsb2NrICgyIGxldmVscykgaW4gbmFtZWRfY2FwdHVyZXMiLCJqIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBuYW1lZF9jYXB0dXJlcyIsIisiLCJsYXN0IiwifiIsIiRfIiwiY2FzZWZvbGQ/IiwiPGNsYXNzOk1hdGNoRGF0YT4iLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJtYXRjaF9ncm91cHMiLCIka3dhcmdzIiwibm9fbWF0Y2hkYXRhIiwiQHJlZ2V4cCIsIkBiZWdpbiIsIkBzdHJpbmciLCJAcHJlX21hdGNoIiwiQHBvc3RfbWF0Y2giLCJAbWF0Y2hlcyIsImlkeCIsImlzX2E/IiwiPj0iLCJsZW5ndGgiLCJJbmRleEVycm9yIiwibWF0Y2hfbGVuZ3RoIiwiaW5jbHVkZT8iLCJhcmdzIiwib2Zmc2V0IiwiQXJndW1lbnRFcnJvciIsIiRyZXRfb3JfMiIsIiRyZXRfb3JfMyIsIiRyZXRfb3JfNCIsImVuZCIsImNhcHR1cmVzIiwibWF0Y2hlcyIsIi0iLCJlbXB0eT8iLCJlYWNoIiwiYmxvY2sgaW4gaW5zcGVjdCIsImsiLCJ2IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbnNwZWN0IiwidG9fYSIsInRvX3MiLCJ2YWx1ZXNfYXQiXSwibWFwcGluZ3MiOiJBQUFBQSxpQ0FBQUEsZ0JBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTs7RUFJQUMsT0FBTSxJQUFOQSxFQUFzQkMsb0JBQXRCRDtFQUVBRTtFQUFBQTs7SUFBQUE7OztJQUNFLFdBQUFDLElBQUEsZ0JBQW1CQyxDQUFuQjtJQUNBLFdBQUFELElBQUEsY0FBaUJFLENBQWpCO0lBQ0EsV0FBQUYsSUFBQSxlQUFrQkcsQ0FBbEI7SUFFQSxXQUFBSCxJQUFBLG1CQUFzQkksRUFBdEI7SUFDQSxXQUFBSixJQUFBLGdCQUFtQkssRUFBbkI7SUFFQ047SUFDQUE7SUFDQUE7SUFDQUE7SUFFRDtNQUFBOzs7O0FBQ0VPLE1BQUFBLHdCQUFBQSxvQkFBQUE7QUFBQUEsUUFBQUE7O1FBQUFBOztRQUNFQyxZQUFZLE9BQUFQLElBQUEsRUFBQSxzREFBQSxZQUFBLEVBQUEsRUFBQSxFQUFBLE1BQUE7UUFDVE8sU0FBVUQ7UUFDYkEsT0FBQUM7TUFIRkQsQ0FBQUE7O0FBTUFFLE1BQUFBLHNCQUFBQSxrQkFBV0MsTUFBWEQ7QUFBQUE7O0FBRUpBLG9DQUFzQ0UsYUFBU0Y7QUFDL0NBO0FBQ0FBO01BSklBLENBQUFBOztBQU9BRyxNQUFBQSwwQkFBQUEsc0JBQWVDLENBQWZEO0FBQUFBLFFBQUFBOzs7UUFBZSxtQkFBSTtRQUNqQixJQUFBLFFBQUdDLENBQUNDLFNBQUFBLENBQUFBLENBQUosQ0FBQTtVQUNFRixPQUFBRztRQURGLE9BRUEsSUFBQSxRQUFNQSxXQUFOLENBQUE7VUFDRUgsT0FBQUcsV0FBRUMsT0FBQUEsQ0FBQ0gsQ0FBREc7UUFESjtVQXBDTkosT0FBQTtRQW9DTTtNQUhGQSxDQUFBQSxJQUFBQTs7QUFRQUssTUFBQUEscUJBQUFBLGlCQXpDSixFQXlDSUE7QUFBQUEsUUFBQUE7OztRQXpDSjtRQXlDYzs7QUFFZEE7QUFDQUEs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NkIxRCxjQUE3QixFQUF3QyxRQUFsQ2xCLENBQTJDNEU7O0FBRW5FQTtBQUNBQSxtQkFBcUIxQixZQUFTMEI7QUFDOUJBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQSxvQkFBc0IxQixZQUFTMEI7QUFDL0JBOztBQUVBQTtBQUNBQTtJQTFCRUEsQ0FBQUEsSUFBQUE7SUE2QkEsYUFBTSxNQUFOLEVBQVcsSUFBWDtJQUNBckMsT0FBQSxhQUFNLE1BQU4sRUFBVyxRQUFYO0VBdktGQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQTNUQXhFOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo3NjUwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9zdHJpbmcucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBjb2VyY2VfdG8sIHJlc3BvbmRfdG8sIGdsb2JhbF9yZWdleHAsIHByb3AsIG9wYWwzMl9pbml0LCBvcGFsMzJfYWRkLCB0cmFuc2Zvcm1fcmVnZXhwLCBzdHIsIHN0cl93aXRoX2VuY1xyXG4jIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcclxuXHJcbiMgZGVwZW5kcyBvbjpcclxuIyByZXF1aXJlICdjb3JlbGliL2NvbXBhcmFibGUnICMgcmVxdWlyZWQgYnkgbWluaVxyXG4jIHJlcXVpcmUgJ2NvcmVsaWIvcmVnZXhwJyAgICAgIyByZXF1aXJlZCBieSBtaW5pXHJcblxyXG5jbGFzcyA6OlN0cmluZyA8IGBTdHJpbmdgXHJcbiAgaW5jbHVkZSA6OkNvbXBhcmFibGVcclxuXHJcbiAgYXR0cl9yZWFkZXIgOmVuY29kaW5nLCA6aW50ZXJuYWxfZW5jb2RpbmcgIyB0aGVzZSAyIGFyZSBzZXQgdG8gZGVmYXVsdHMgYXQgdGhlIGVuZCBvZiBjb3JlbGliL3N0cmluZy9lbmNvZGluZy5yYlxyXG5cclxuICAleHtcclxuICAgIGNvbnN0IE1BWF9TVFJfTEVOID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XHJcblxyXG4gICAgT3BhbC5wcm9wKCN7c2VsZn0uJCRwcm90b3R5cGUsICckJGlzX3N0cmluZycsIHRydWUpO1xyXG5cclxuICAgIHZhciBzdHJpbmdfaWRfbWFwID0gbmV3IE1hcCgpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGZpcnN0X2NoYXIoc3RyKSB7XHJcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChzdHIuY29kZVBvaW50QXQoMCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFVURi0xNiBhd2FyZSBmaW5kX2luZGV4X29mLCBhcmdzOlxyXG4gICAgLy8gICBzdHI6IHN0cmluZ1xyXG4gICAgLy8gICBzZWFyY2g6IHRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvciBpbiBzdHJcclxuICAgIC8vICAgc2VhcmNoX2w6IGlzIG9wdGlvbmFsLCBpZiBnaXZlbiBtdXN0IGJlIHNlYXJjaC4kbGVuZ3RoKCksIGRvIE5PVCB1c2Ugc2VhcmNoLmxlbmd0aFxyXG4gICAgLy8gICBsYXN0OiBib29sZWFuLCBvcHRpb25hbCB0b28sIGlmIHRydWUgcmV0dXJucyB0aGUgbGFzdCBpbmRleCBvdGhlcndpc2UgdGhlIGZpcnN0XHJcbiAgICBmdW5jdGlvbiBmaW5kX2luZGV4X29mKHN0ciwgc2VhcmNoLCBzZWFyY2hfbCwgbGFzdCkge1xyXG4gICAgICBsZXQgc2VhcmNoX2YgPSAoc2VhcmNoLmxlbmd0aCA9PT0gMSkgPyBzZWFyY2ggOiBmaXJzdF9jaGFyKHNlYXJjaCk7XHJcbiAgICAgIGxldCBpID0gMCwgY29sID0gW10sIGwgPSAwLCBpZHggPSAtMTtcclxuICAgICAgZm9yIChjb25zdCBjIG9mIHN0cikge1xyXG4gICAgICAgIGlmIChjb2wubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgZm9yIChjb25zdCBlIG9mIGNvbCkge1xyXG4gICAgICAgICAgICBpZiAoZS5sIDwgbCkgeyBlLnNlYXJjaCArPSBjOyBlLmwrKzsgfVxyXG4gICAgICAgICAgICBpZiAoZS5sID09PSBsKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGUuc2VhcmNoID09IHNlYXJjaCkgeyBpZiAobGFzdCkgaWR4ID0gZS5pbmRleDsgZWxzZSByZXR1cm4gZS5pbmRleDsgfVxyXG4gICAgICAgICAgICAgIGUuc2VhcmNoID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCFjb2xbMF0uc2VhcmNoKSBjb2wuc2hpZnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNlYXJjaF9mID09IGMpIHtcclxuICAgICAgICAgIGlmIChzZWFyY2gubGVuZ3RoID09PSAxKSB7IGlmIChsYXN0KSBpZHggPSBpOyBlbHNlIHJldHVybiBpOyB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGwgPT09IDApIGwgPSBzZWFyY2hfbCB8fCBzZWFyY2guJGxlbmd0aCgpO1xyXG4gICAgICAgICAgICBpZiAobCA9PT0gMSkgeyBpZiAobGFzdCkgaWR4ID0gaTsgZWxzZSByZXR1cm4gaTsgfVxyXG4gICAgICAgICAgICBlbHNlIGNvbC5wdXNoKHsgaW5kZXg6IGksIHNlYXJjaDogYywgbDogMSB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaSsrO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBpZHg7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbXVsdGkgYnl0ZSBjaGFyYWN0ZXIgYXdhcmUgZmluZF9ieXRlX2luZGV4X29mLCBhcmdzOlxyXG4gICAgLy8gICBzdHI6IHN0cmluZ1xyXG4gICAgLy8gICBzZWFyY2g6IHRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvciBpbiBzdHJcclxuICAgIC8vICAgc2VhcmNoX2w6IGlzIG9wdGlvbmFsLCBpZiBnaXZlbiBtdXN0IGJlIHNlYXJjaC4kbGVuZ3RoKCksIGRvIE5PVCB1c2Ugc2VhcmNoLmxlbmd0aFxyXG4gICAgLy8gICBsYXN0OiBib29sZWFuLCBvcHRpb25hbCB0b28sIGlmIHRydWUgcmV0dXJucyB0aGUgbGFzdCBpbmRleCBvdGhlcndpc2UgdGhlIGZpcnN0XHJcbiAgICBmdW5jdGlvbiBmaW5kX2J5dGVfaW5kZXhfb2Yoc3RyLCBzZWFyY2gsIHNlYXJjaF9sLCBvZmZzZXQsIGxhc3QpIHtcclxuICAgICAgbGV0IHNlYXJjaF9mO1xyXG4gICAgICBpZiAoc2VhcmNoLmxlbmd0aCA9PT0gMCB8fCBzZWFyY2gubGVuZ3RoID09PSAxKSBzZWFyY2hfZiA9IHNlYXJjaDtcclxuICAgICAgZWxzZSBzZWFyY2hfZiA9IGZpcnN0X2NoYXIoc2VhcmNoKTtcclxuICAgICAgbGV0IGkgPSAwLCBjb2wgPSBbXSwgbCA9IDAsIGlkeCA9IC0xLCBoaXRfYm91bmRhcnkgPSAob2Zmc2V0ID09PSAwKSA/IHRydWUgOiBmYWxzZTtcclxuICAgICAgaWYgKGxhc3QpIGwgPSBzZWFyY2hfbCB8fCBzZWFyY2guJGxlbmd0aCgpO1xyXG4gICAgICBmb3IgKGNvbnN0IGMgb2Ygc3RyKSB7XHJcbiAgICAgICAgaWYgKGNvbC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgY29sKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmwgPCBsKSB7IGUuc2VhcmNoICs9IGM7IGUubCsrOyB9XHJcbiAgICAgICAgICAgIGlmIChlLmwgPT09IGwpIHtcclxuICAgICAgICAgICAgICBpZiAoZS5zZWFyY2ggPT0gc2VhcmNoKSB7IGlmIChsYXN0KSBpZHggPSBlLmluZGV4OyBlbHNlIHJldHVybiBlLmluZGV4OyB9XHJcbiAgICAgICAgICAgICAgZS5zZWFyY2ggPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoIWNvbFswXS5zZWFyY2gpIGNvbC5zaGlmdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoISghbGFzdCAmJiBvZmZzZXQgPiAwICYmIGkgPCBvZmZzZXQpKSB7XHJcbiAgICAgICAgICBpZiAobGFzdCAmJiAoKGwgPCAyICYmIGkgPiBvZmZzZXQpIHx8IChpID4gb2Zmc2V0ICsgbCkpKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChzZWFyY2hfZiA9PSBjKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWFyY2gubGVuZ3RoID09PSAxKSB7IGlmIChsYXN0ICYmIGkgPD0gb2Zmc2V0KSBpZHggPSBpOyBlbHNlIHJldHVybiBpOyB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgIGlmIChsID09PSAwKSBsID0gc2VhcmNoX2wgfHwgc2VhcmNoLiRsZW5ndGgoKTtcclxuICAgICAgICAgICAgICBpZiAobCA9PT0gMSkgeyBpZiAobGFzdCAmJiBpIDw9IG9mZnNldCkgaWR4ID0gaTsgZWxzZSByZXR1cm4gaTsgfVxyXG4gICAgICAgICAgICAgIGVsc2UgaWYgKCEobGFzdCAmJiBpID4gb2Zmc2V0KSkgY29sLnB1c2goeyBpbmRleDogaSwgc2VhcmNoOiBjLCBsOiAxIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkgKz0gYy4kYnl0ZXNpemUoKTtcclxuICAgICAgICBpZiAob2Zmc2V0ID09PSBpKSBoaXRfYm91bmRhcnkgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghbGFzdCAmJiBpIDwgb2Zmc2V0KSByZXR1cm4gLTE7XHJcbiAgICAgIGlmIChsYXN0ICYmIG9mZnNldCA+IGkpIHtcclxuICAgICAgICBpZiAoc2VhcmNoLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGk7XHJcbiAgICAgICAgcmV0dXJuIGlkeDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoKCFoaXRfYm91bmRhcnkpICYmIChpZHggPiAtMSB8fCBzZWFyY2gubGVuZ3RoID09PSAwKSlcclxuICAgICAgICAje3JhaXNlIEluZGV4RXJyb3IsIFwib2Zmc2V0ICN7YG9mZnNldGB9IGRvZXMgbm90IGxhbmQgb24gY2hhcmFjdGVyIGJvdW5kYXJ5XCJ9O1xyXG4gICAgICBpZiAoc2VhcmNoLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG9mZnNldDtcclxuICAgICAgcmV0dXJuIGlkeDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBVVEYtMTYgYXdhcmUgY3V0X2Zyb21fZW5kLCBjdXRzIGNoYXJhY3RlcnMgZnJvbSBlbmRcclxuICAgIC8vICAgc3RyOiB0aGUgc3RyaW5nIHRvIGN1dFxyXG4gICAgLy8gICBjdXRfbDogdGhlIGxlbmd0aCwgY291bnQgb2YgY2hhcmFjdGVycyB0byBjdXRcclxuICAgIGZ1bmN0aW9uIGN1dF9mcm9tX2VuZChzdHIsIGN1dF9sKSB7XHJcbiAgICAgIGxldCBpID0gc3RyLmxlbmd0aCAtIDEsIGN1cnJfY3A7XHJcbiAgICAgIGZvciAoOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIGN1cnJfY3AgPSBzdHIuY29kZVBvaW50QXQoaSk7XHJcbiAgICAgICAgaWYgKGN1cnJfY3AgPj0gMHhEQzAwICYmIGN1cnJfY3AgPD0gMHhERkZGKSBjb250aW51ZTsgLy8gbG93IHN1cnJvZ2F0ZSwgZ2V0IHRoZSBmdWxsIGNvZGUgcG9pbnRcclxuICAgICAgICBjdXRfbC0tO1xyXG4gICAgICAgIGlmIChjdXRfbCA9PT0gMCkgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHN0ci5zbGljZSgwLCBpKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYWRkaW5nKHBhZHN0ciwgd2lkdGgpIHtcclxuICAgICAgbGV0IHJlc3VsdF9sID0gMCxcclxuICAgICAgICAgIHJlc3VsdCA9ICcnLFxyXG4gICAgICAgICAgcF9sID0gcGFkc3RyLmxlbmd0aCxcclxuICAgICAgICAgIHBhZHN0cl9sID0gcF9sID09PSAxID8gcF9sIDogcGFkc3RyLiRsZW5ndGgoKTtcclxuXHJcbiAgICAgIHdoaWxlIChyZXN1bHRfbCA8IHdpZHRoKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IHBhZHN0cjtcclxuICAgICAgICByZXN1bHRfbCArPSBwYWRzdHJfbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJlc3VsdF9sID09PSB3aWR0aCkgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgaWYgKHBfbCA9PT0gcGFkc3RyX2wpIHJldHVybiByZXN1bHQuc2xpY2UoMCwgd2lkdGgpO1xyXG4gICAgICByZXR1cm4gY3V0X2Zyb21fZW5kKHJlc3VsdCwgcmVzdWx0X2wgLSB3aWR0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3RhcnRzX3dpdGhfbG93X3N1cnJvZ2F0ZShzdHIpIHtcclxuICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcclxuICAgICAgbGV0IGNwID0gc3RyLmNvZGVQb2ludEF0KDApO1xyXG4gICAgICBpZiAoY3AgPj0gMHhEQzAwICYmIGNwIDw9IDB4REZGRikgcmV0dXJuIHRydWU7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBlbmRzX3dpdGhfaGlnaF9zdXJyb2dhdGUoc3RyKSB7XHJcbiAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGxldCBjcCA9IHN0ci5jb2RlUG9pbnRBdChzdHIubGVuZ3RoIC0gMSk7XHJcbiAgICAgIGlmIChjcCA+PSAweEQ4MDAgJiYgY3AgPD0gMHhEQkZGKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN0YXJ0c193aXRoKHN0ciwgcHJlZml4KSB7XHJcbiAgICAgIHJldHVybiAoc3RyLmxlbmd0aCA+PSBwcmVmaXgubGVuZ3RoICYmICFlbmRzX3dpdGhfaGlnaF9zdXJyb2dhdGUocHJlZml4KSAmJiBzdHIuc3RhcnRzV2l0aChwcmVmaXgpKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBlbmRzX3dpdGgoc3RyLCBzdWZmaXgpIHtcclxuICAgICAgcmV0dXJuIChzdHIubGVuZ3RoID49IHN1ZmZpeC5sZW5ndGggJiYgIXN0YXJ0c193aXRoX2xvd19zdXJyb2dhdGUoc3VmZml4KSAmJiBzdHIuZW5kc1dpdGgoc3VmZml4KSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IEdSQVBIRU1FX1NFR01FTlRFUjsgLy8gaW5pdGlhbGl6ZWQgb24gZGVtYW5kIGJ5ICNlYWNoX2dyYXBoZW1lX2NsdXN0ZXIgYmVsb3cgdXNpbmc6XHJcblxyXG4gICAgZnVuY3Rpb24gZ3JhcGhlbWVfc2VnbWVudGVyKCkge1xyXG4gICAgICBpZiAoIUdSQVBIRU1FX1NFR01FTlRFUikge1xyXG4gICAgICAgIC8vIExlYXZpbmcgdGhlIGxvY2FsZSBwYXJhbWV0ZXIgYXMgdW5kZWZpbmVkLCBpbmRpY2F0aW5nIGJyb3dzZXJzIGRlZmF1bHQgbG9jYWxlLlxyXG4gICAgICAgIC8vIERlcGVuZGluZyBvbiBpbXBsZW1lbnRhdGlvbiBxdWFsaXR5IGFuZCBkZWZhdWx0IGxvY2FsZSwgdGhlcmUgaXMgYSBjaGFuY2UsXHJcbiAgICAgICAgLy8gdGhhdCBncmFwaGVtZSBzZWdtZW50YXRpb24gcmVzdWx0cyBkaWZmZXIuXHJcbiAgICAgICAgR1JBUEhFTUVfU0VHTUVOVEVSID0gbmV3IEludGwuU2VnbWVudGVyKHVuZGVmaW5lZCwgeyBncmFudWxhcml0eTogXCJncmFwaGVtZVwiIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBHUkFQSEVNRV9TRUdNRU5URVI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2hhcl9jbGFzc19mcm9tX2NoYXJfc2V0cyhzZXRzKSB7XHJcbiAgICAgIGZ1bmN0aW9uIGV4cGxvZGVfc2VxdWVuY2VzX2luX2NoYXJhY3Rlcl9zZXQoc2V0X3MpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW10sXHJcbiAgICAgICAgICAgIGksIGxlbiA9IHNldF9zLmxlbmd0aCxcclxuICAgICAgICAgICAgY3Vycl9jaGFyLFxyXG4gICAgICAgICAgICBza2lwX25leHRfZGFzaCxcclxuICAgICAgICAgICAgY29kZV9wb2ludF9mcm9tLFxyXG4gICAgICAgICAgICBjb2RlX3BvaW50X3VwdG8sXHJcbiAgICAgICAgICAgIGNvZGVfcG9pbnQ7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICBjdXJyX2NoYXIgPSBzZXRfc1tpXTtcclxuICAgICAgICAgIGlmIChjdXJyX2NoYXIgPT09ICctJyAmJiBpID4gMCAmJiBpIDwgKGxlbiAtIDEpICYmICFza2lwX25leHRfZGFzaCkge1xyXG4gICAgICAgICAgICBjb2RlX3BvaW50X2Zyb20gPSBzZXRfc1tpIC0gMV0uY29kZVBvaW50QXQoMCk7XHJcbiAgICAgICAgICAgIGNvZGVfcG9pbnRfdXB0byA9IHNldF9zW2kgKyAxXS5jb2RlUG9pbnRBdCgwKTtcclxuICAgICAgICAgICAgaWYgKGNvZGVfcG9pbnRfZnJvbSA+IGNvZGVfcG9pbnRfdXB0bykge1xyXG4gICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFuZ2UgXFxcIiN7YGNvZGVfcG9pbnRfZnJvbWB9LSN7YGNvZGVfcG9pbnRfdXB0b2B9XFxcIiBpbiBzdHJpbmcgdHJhbnNsaXRlcmF0aW9uXCJ9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChjb2RlX3BvaW50ID0gY29kZV9wb2ludF9mcm9tICsgMTsgY29kZV9wb2ludCA8IGNvZGVfcG9pbnRfdXB0byArIDE7IGNvZGVfcG9pbnQrKykge1xyXG4gICAgICAgICAgICAgIGlmIChjb2RlX3BvaW50ID49IDB4RDgwMCAmJiBjb2RlX3BvaW50IDw9IDB4REZGRikgY29kZV9wb2ludCA9IDB4RTAwMDsgLy8gZXhjbHVkZSBzdXJyb2dhdGUgcmFuZ2VcclxuICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlX3BvaW50KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2tpcF9uZXh0X2Rhc2ggPSB0cnVlO1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBza2lwX25leHRfZGFzaCA9IChjdXJyX2NoYXIgPT09ICdcXFxcJyk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJfY2hhcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGludGVyc2VjdGlvbihzZXRBLCBzZXRCKSB7XHJcbiAgICAgICAgaWYgKHNldEEubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gc2V0QjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLFxyXG4gICAgICAgICAgICBpLCBsZW4gPSBzZXRBLmxlbmd0aCxcclxuICAgICAgICAgICAgY2hyO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgY2hyID0gc2V0QVtpXTtcclxuICAgICAgICAgIGlmIChzZXRCLmluZGV4T2YoY2hyKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hyKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGksIGxlbiwgc2V0LCBzZXRfcywgbmVnLCBjaHIsIHRtcCxcclxuICAgICAgICAgIHBvc19pbnRlcnNlY3Rpb24gPSBbXSxcclxuICAgICAgICAgIG5lZ19pbnRlcnNlY3Rpb24gPSBbXTtcclxuXHJcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHNldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBzZXQgPSAkY29lcmNlX3RvKHNldHNbaV0sICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XHJcbiAgICAgICAgc2V0X3MgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGMgb2Ygc2V0KSB7XHJcbiAgICAgICAgICBsZXQgY2QgPSBjLmNvZGVQb2ludEF0KDApO1xyXG4gICAgICAgICAgaWYgKGNkIDwgMHhEODAwIHx8IGNkID4gMHhERkZGKSBzZXRfcy5wdXNoKGMpOyAvLyBleGNsdWRlIHN1cnJvZ2F0ZSByYW5nZVxyXG4gICAgICAgIH1cclxuICAgICAgICBuZWcgPSAoc2V0X3NbMF0gPT09ICdeJyAmJiBzZXRfcy5sZW5ndGggPiAxKTtcclxuICAgICAgICBzZXRfcyA9IGV4cGxvZGVfc2VxdWVuY2VzX2luX2NoYXJhY3Rlcl9zZXQobmVnID8gc2V0X3Muc2xpY2UoMSkgOiBzZXRfcyk7XHJcbiAgICAgICAgaWYgKG5lZykge1xyXG4gICAgICAgICAgbmVnX2ludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbihuZWdfaW50ZXJzZWN0aW9uLCBzZXRfcyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHBvc19pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb24ocG9zX2ludGVyc2VjdGlvbiwgc2V0X3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHBvc19pbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCAmJiBuZWdfaW50ZXJzZWN0aW9uLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0bXAgPSBbXTtcclxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwb3NfaW50ZXJzZWN0aW9uLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICBjaHIgPSBwb3NfaW50ZXJzZWN0aW9uW2ldO1xyXG4gICAgICAgICAgaWYgKG5lZ19pbnRlcnNlY3Rpb24uaW5kZXhPZihjaHIpID09PSAtMSkge1xyXG4gICAgICAgICAgICB0bXAucHVzaChjaHIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBwb3NfaW50ZXJzZWN0aW9uID0gdG1wO1xyXG4gICAgICAgIG5lZ19pbnRlcnNlY3Rpb24gPSBbXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHBvc19pbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHJldHVybiAnWycgKyAjezo6UmVnZXhwLmVzY2FwZShgcG9zX2ludGVyc2VjdGlvbi5qb2luKCcnKWApfSArICddJztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG5lZ19pbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHJldHVybiAnW14nICsgI3s6OlJlZ2V4cC5lc2NhcGUoYG5lZ19pbnRlcnNlY3Rpb24uam9pbignJylgKX0gKyAnXSc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNsaWNlX2J5X3N0cmluZyhzdHJpbmcsIGluZGV4LCBsZW5ndGgpIHtcclxuICAgICAgaWYgKGxlbmd0aCAhPSBudWxsKSAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yfTtcclxuICAgICAgaWYgKGZpbmRfaW5kZXhfb2Yoc3RyaW5nLCBpbmRleCkgPT09IC0xKSByZXR1cm4gbmlsO1xyXG4gICAgICByZXR1cm4gaW5kZXgudG9TdHJpbmcoKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzbGljZV9ieV9yZWdleHAoc3RyaW5nLCBpbmRleCwgbGVuZ3RoKSB7XHJcbiAgICAgIGxldCBtYXRjaCA9IHN0cmluZy5tYXRjaChpbmRleCk7XHJcbiAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xyXG4gICAgICAgICN7JH4gPSBuaWx9XHJcbiAgICAgICAgcmV0dXJuIG5pbDtcclxuICAgICAgfVxyXG4gICAgICAjeyR+ID0gOjpNYXRjaERhdGEubmV3KGBpbmRleGAsIGBtYXRjaGApfVxyXG4gICAgICBpZiAobGVuZ3RoID09IG51bGwpIHJldHVybiBtYXRjaFswXTtcclxuICAgICAgbGVuZ3RoID0gJGNvZXJjZV90byhsZW5ndGgsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xyXG4gICAgICBpZiAobGVuZ3RoIDwgMCAmJiAtbGVuZ3RoIDwgbWF0Y2gubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoW2xlbmd0aCArPSBtYXRjaC5sZW5ndGhdO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChsZW5ndGggPj0gMCAmJiBsZW5ndGggPCBtYXRjaC5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbWF0Y2hbbGVuZ3RoXTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmlsO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNsaWNlX2J5X2luZGV4X25lZyhzdHJpbmcsIGluZGV4LCBsZW5ndGgpIHtcclxuICAgICAgLy8gbmVnYXRpdmUgaW5kZXgsIHdhbGsgZnJvbSB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsXHJcbiAgICAgIGlmIChpbmRleCA8IC1zdHJpbmcubGVuZ3RoIHx8IGxlbmd0aCA8IC1zdHJpbmcubGVuZ3RoKSByZXR1cm4gbmlsO1xyXG4gICAgICBsZXQgaiA9IHN0cmluZy5sZW5ndGggLSAxLCBpID0gLTEsIHJlc3VsdCA9ICcnLCByZXN1bHRfbCA9IDAsIGN1cnJfY3AsIGlkeF9lbmQsIG1heDtcclxuICAgICAgaWYgKGxlbmd0aCAhPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIG1heCA9IGxlbmd0aDtcclxuICAgICAgICBlbHNlIGlmIChsZW5ndGggPT09IEluZmluaXR5IHx8IChpbmRleCArIGxlbmd0aCA+PSAwKSkgbWF4ID0gLTE7XHJcbiAgICAgICAgZWxzZSBtYXggPSBpbmRleCArIGxlbmd0aCAtIDE7XHJcbiAgICAgIH1cclxuICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XHJcbiAgICAgICAgY3Vycl9jcCA9IHN0cmluZy5jb2RlUG9pbnRBdChqKTtcclxuICAgICAgICBpZiAoY3Vycl9jcCA+PSAweERDMDAgJiYgY3Vycl9jcCA8PSAweERGRkYpIGNvbnRpbnVlOyAvLyBsb3cgc3Vycm9nYXRlLCBnZXQgdGhlIGZ1bGwgY29kZSBwb2ludCBuZXh0XHJcbiAgICAgICAgaWYgKGxlbmd0aCAhPSBudWxsICYmIGkgPD0gbWF4KSB7XHJcbiAgICAgICAgICBpZiAoIWlkeF9lbmQpIGlkeF9lbmQgPSAoY3Vycl9jcCA+IDB4REZGRikgPyBqICsgMiA6IGogKyAxO1xyXG4gICAgICAgICAgcmVzdWx0X2wrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGkgPT09IGluZGV4KSB7XHJcbiAgICAgICAgICBpZiAobGVuZ3RoID09PSAwIHx8IGluZGV4ID09PSBsZW5ndGgpIHJldHVybiBcIlwiO1xyXG4gICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMSB8fCBsZW5ndGggPT0gbnVsbCkgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KGN1cnJfY3ApO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGktLTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocmVzdWx0X2wgPiAwKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gc3RyaW5nLnNsaWNlKGosIGlkeF9lbmQpO1xyXG4gICAgICAgIGlmIChsZW5ndGggPCAwICYmICgocmVzdWx0X2wgKyBsZW5ndGgpIDwgMCkpIHJldHVybiBcIlwiO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5pbDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzbGljZV9ieV9pbmRleF96ZXJvKHN0cmluZywgbGVuZ3RoKSB7XHJcbiAgICAgIC8vIHNwZWNpYWwgY29uZGl0aW9uc1xyXG4gICAgICBpZiAobGVuZ3RoID09PSAwIHx8IHN0cmluZy5sZW5ndGggPT09IDApIHJldHVybiAobGVuZ3RoICE9IG51bGwpID8gXCJcIiA6IG5pbDtcclxuICAgICAgaWYgKGxlbmd0aCA9PT0gMSB8fCBsZW5ndGggPT0gbnVsbCkgcmV0dXJuIGZpcnN0X2NoYXIoc3RyaW5nKTtcclxuICAgICAgaWYgKGxlbmd0aCA9PT0gSW5maW5pdHkpIHJldHVybiBzdHJpbmcudG9TdHJpbmcoKTtcclxuICAgICAgLy8gd2FsayB0aGUgc3RyaW5nXHJcbiAgICAgIGxldCBpID0gMCwgcmVzdWx0ID0gJyc7XHJcbiAgICAgIGZvciAoY29uc3QgYyBvZiBzdHJpbmcpIHtcclxuICAgICAgICByZXN1bHQgKz0gYztcclxuICAgICAgICBpKys7XHJcbiAgICAgICAgaWYgKGkgPT09IGxlbmd0aCkgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGxlbmd0aCA8IDApIHtcclxuICAgICAgICAvLyBpZiBsZW5ndGggaXMgYSBuZWdhdGl2ZSBpbmRleCBmcm9tIGEgcmFuZ2UsIHdlIHdhbGtlZCB0byB0aGUgZW5kLCBzbyBzaG9ydGVuIHRoZSByZXN1bHRcclxuICAgICAgICBpZiAoKGkgKyBsZW5ndGgpID4gMCkgcmV0dXJuIGN1dF9mcm9tX2VuZChyZXN1bHQsIC1sZW5ndGgpO1xyXG4gICAgICAgIGVsc2UgcmV0dXJuIFwiXCI7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzbGljZV9ieV9pbmRleF9wb3Moc3RyaW5nLCBpbmRleCwgbGVuZ3RoKSB7XHJcbiAgICAgIGxldCBpID0gMCwgcmVzdWx0X2wgPSAwLCByZXN1bHQ7XHJcbiAgICAgIGZvciAoY29uc3QgYyBvZiBzdHJpbmcpIHtcclxuICAgICAgICBpZiAoaSA8IGluZGV4KSB7XHJcbiAgICAgICAgICBpKys7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpID09PSBpbmRleCkge1xyXG4gICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMSB8fCBsZW5ndGggPT0gbnVsbCkgcmV0dXJuIGM7XHJcbiAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gXCJcIjtcclxuICAgICAgICAgIHJlc3VsdCA9IGM7XHJcbiAgICAgICAgICBpKys7IHJlc3VsdF9sKys7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpID4gaW5kZXgpIHtcclxuICAgICAgICAgIGlmIChyZXN1bHRfbCA8IGxlbmd0aCB8fCBsZW5ndGggPCAwKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBjO1xyXG4gICAgICAgICAgICBpKys7IHJlc3VsdF9sKys7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aCA+IDAgJiYgcmVzdWx0X2wgPj0gbGVuZ3RoKSBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XHJcbiAgICAgICAgICAvLyBpZiBsZW5ndGggaXMgYSBuZWdhdGl2ZSBpbmRleCBmcm9tIGEgcmFuZ2UsIHdlIHdhbGtlZCB0byB0aGUgZW5kLCBzbyBzaG9ydGVuIHRoZSByZXN1bHRcclxuICAgICAgICAgIGlmICgocmVzdWx0X2wgKyBsZW5ndGgpID4gMCkgcmV0dXJuIGN1dF9mcm9tX2VuZChyZXN1bHQsIC1sZW5ndGgpO1xyXG4gICAgICAgICAgZWxzZSByZXR1cm4gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3VsdF9sID4gMCAmJiBpbmRleCA8PSBpICYmIGxlbmd0aCA+IDEpIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH1cclxuICAgICAgLy8gc3BlY2lhbCBjb25kaXRpb24gZm9yIHJ1Ynkgd2VpcmRuZXNzXHJcbiAgICAgIGlmIChpID09PSBpbmRleCAmJiBsZW5ndGggIT0gbnVsbCkgcmV0dXJuIFwiXCI7XHJcbiAgICAgIHJldHVybiBuaWw7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2xpY2Uoc3RyaW5nLCBpbmRleCwgbGVuZ3RoKSB7XHJcbiAgICAgIGlmIChpbmRleC4kJGlzX3N0cmluZykgcmV0dXJuIHNsaWNlX2J5X3N0cmluZyhzdHJpbmcsIGluZGV4LCBsZW5ndGgpO1xyXG4gICAgICBpZiAoaW5kZXguJCRpc19yZWdleHApIHJldHVybiBzbGljZV9ieV9yZWdleHAoc3RyaW5nLCBpbmRleCwgbGVuZ3RoKTtcclxuXHJcbiAgICAgIGlmIChpbmRleC4kJGlzX3JhbmdlKSB7XHJcbiAgICAgICAgaWYgKGxlbmd0aCkgI3tyYWlzZSBUeXBlRXJyb3IsICdsZW5ndGggbm90IGFsbG93ZWQgaWYgcmFuZ2UgaXMgZ2l2ZW4nfTtcclxuICAgICAgICAvLyBUaGlzIHBhcnQgc2V0cyBpbmRleCBhbmQgbGVuZ3RoLCBiYXNpY2FsbHkgY29udmVydGluZyBzdHJpbmdbMi4uM10gcmFuZ2VcclxuICAgICAgICAvLyB0byBzdHJpbmdbMiwgMV0gaW5kZXggKyBsZW5ndGggYW5kIGxldHRpbmcgdGhlIHJhbmdlIGdldCBoYW5kbGVkIGJ5IHRoZVxyXG4gICAgICAgIC8vIGluZGV4ICsgbGVuZ3RoIGNvZGUgYmVsb3cuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBGb3IgcmFuZ2VzLCBmaXJzdCBpbmRleCBhbHdheXMgaXMgYSBpbmRleCwgcG9zc2libHkgbmVnYXRpdmUuXHJcbiAgICAgICAgLy8gTGVuZ3RoIGlzIGVpdGhlciB0aGUgbGVuZ3RoLCBpZiBpdCBjYW4gYmUgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXhlcyBvZiB0aGUgcmFuZ2UsXHJcbiAgICAgICAgLy8gb3IgaXRzIGEgcG9zc2libHkgbmVnYXRpdmUgaW5kZXgsIGJlY2F1c2UgdGhlIGV4YWN0IHN0cmluZyBsZW5ndGggaXMgbm90IGtub3duLFxyXG4gICAgICAgIC8vIG9yIEluZmluaXR5LCB3aXRoIEluZmluaXR5IGluZGljYXRpbmcgJ3dhbGsgdG8gZW5kIG9mIHN0cmluZycuXHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBpbmRleDtcclxuICAgICAgICBjb25zdCByX2VuZCA9IHJhbmdlLmVuZCA9PT0gbmlsID8gSW5maW5pdHkgOiAkY29lcmNlX3RvKHJhbmdlLmVuZCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XHJcbiAgICAgICAgaW5kZXggPSByYW5nZS5iZWdpbiA9PT0gbmlsID8gMCA6ICRjb2VyY2VfdG8ocmFuZ2UuYmVnaW4sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xyXG5cclxuICAgICAgICBpZiAoKChpbmRleCA+IDAgJiYgcl9lbmQgPiAwKSB8fCAoaW5kZXggPCAwICYmIHJfZW5kIDwgMCkpICYmIGluZGV4ID4gcl9lbmQpIHtcclxuICAgICAgICAgIGxlbmd0aCA9IDA7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gcl9lbmQpIHtcclxuICAgICAgICAgIGxlbmd0aCA9IHJhbmdlLmV4Y2wgPyAwIDogMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc3QgZSA9IHJhbmdlLmV4Y2wgPyAwIDogMTtcclxuICAgICAgICAgIGlmICgoIXJhbmdlLmV4Y2wgJiYgcl9lbmQgPT09IC0xKSB8fCByX2VuZCA9PT0gSW5maW5pdHkpIGxlbmd0aCA9IEluZmluaXR5O1xyXG4gICAgICAgICAgZWxzZSBpZiAoaW5kZXggPT0gMCB8fCAoaW5kZXggPiAwICYmIHJfZW5kIDwgMCkpIGxlbmd0aCA9IHJfZW5kID09PSBJbmZpbml0eSA/IEluZmluaXR5IDogKHJfZW5kICsgZSk7XHJcbiAgICAgICAgICBlbHNlIGlmIChpbmRleCA8IDAgJiYgcl9lbmQgPj0gMCkgbGVuZ3RoID0gMDtcclxuICAgICAgICAgIGVsc2UgaWYgKChpbmRleCA8IDAgJiYgcl9lbmQgPCAwKSB8fCAoaW5kZXggPiAwICYmIHJfZW5kID4gMCkpIHtcclxuICAgICAgICAgICAgbGVuZ3RoID0gcl9lbmQgPT09IEluZmluaXR5ID8gSW5maW5pdHkgOiAocl9lbmQgLSBpbmRleCArIGUpO1xyXG4gICAgICAgICAgICBpZiAobGVuZ3RoIDwgMCkgbGVuZ3RoID0gMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaW5kZXggPSAkY29lcmNlX3RvKGluZGV4LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcclxuICAgICAgICBpZiAobGVuZ3RoICE9IG51bGwpIGxlbmd0aCA9ICRjb2VyY2VfdG8obGVuZ3RoLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcclxuICAgICAgICBpZiAobGVuZ3RoIDwgMCkgcmV0dXJuIG5pbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGluZGV4ID4gTUFYX1NUUl9MRU4pICN7cmFpc2UgUmFuZ2VFcnJvciwgJ2luZGV4IHRvbyBsYXJnZSd9O1xyXG4gICAgICBpZiAobGVuZ3RoICE9PSBJbmZpbml0eSAmJiBsZW5ndGggPiBNQVhfU1RSX0xFTikgI3tyYWlzZSBSYW5nZUVycm9yLCAnbGVuZ3RoIHRvbyBsYXJnZSd9O1xyXG4gICAgICBpZiAoaW5kZXggPCAwKSByZXR1cm4gc2xpY2VfYnlfaW5kZXhfbmVnKHN0cmluZywgaW5kZXgsIGxlbmd0aCk7XHJcbiAgICAgIGlmIChpbmRleCA9PT0gMCkgcmV0dXJuIHNsaWNlX2J5X2luZGV4X3plcm8oc3RyaW5nLCBsZW5ndGgpO1xyXG4gICAgICByZXR1cm4gc2xpY2VfYnlfaW5kZXhfcG9zKHN0cmluZywgaW5kZXgsIGxlbmd0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmFpc2VfaWZfbm90X3N0cmluZ2lzaChvYmopIHtcclxuICAgICAgaWYgKG9iaiA9PT0gbmlsKSAje3JhaXNlIFR5cGVFcnJvciwgJ25vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgbmlsIGludG8gU3RyaW5nJ307XHJcbiAgICAgIGlmICh0eXBlb2Ygb2JqID09PSBcIm51bWJlclwiKSAje3JhaXNlIFR5cGVFcnJvciwgJ25vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgSW50ZWdlciBpbnRvIFN0cmluZyd9O1xyXG4gICAgICBpZiAob2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UpICN7cmFpc2UgVHlwZUVycm9yLCBcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgI3tgb2JqYH0gaW50byBTdHJpbmdcIn07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2FzZV9vcHRpb25zX2hhdmVfYXNjaWkob3B0aW9ucywgYWxsb3dfZm9sZCkge1xyXG4gICAgICBsZXQgYXNjaWkgPSBmYWxzZSwgZm9sZCA9IGZhbHNlO1xyXG4gICAgICBpZiAob3B0aW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgZm9yKGNvbnN0IG9wdGlvbiBvZiBvcHRpb25zKSB7XHJcbiAgICAgICAgICBpZiAob3B0aW9uID09IFwiYXNjaWlcIikgYXNjaWkgPSB0cnVlO1xyXG4gICAgICAgICAgZWxzZSBpZiAob3B0aW9ucyA9PSBcImZvbGRcIikgZm9sZCA9IHRydWU7XHJcbiAgICAgICAgICBlbHNlICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJ1bmtub3duIG9wdGlvbiA6I3tgb3B0aW9uYH1cIn1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFhbGxvd19mb2xkKSB7XHJcbiAgICAgICAgICBpZiAoZm9sZCAmJiBhc2NpaSkgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAndG9vIG1hbnkgb3B0aW9ucyd9O1xyXG4gICAgICAgICAgaWYgKGZvbGQpICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJzpmb2xkIG5vdCBhbGxvd2VkJ307XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBhc2NpaTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gICMgRm9yY2Ugc3RyaWN0IG1vZGUgdG8gc3VwcHJlc3MgYXV0b2JveGluZyBvZiBgdGhpc2BcclxuICAleHtcclxuICAgIChmdW5jdGlvbigpIHtcclxuICAgICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgICAje1xyXG4gICAgICAgIGRlZiBfX2lkX19cclxuICAgICAgICAgICV4e1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbGYgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICN7c3VwZXJ9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0cmluZ19pZF9tYXAuaGFzKHNlbGYpKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ19pZF9tYXAuZ2V0KHNlbGYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpZCA9IE9wYWwudWlkKCk7XHJcbiAgICAgICAgICAgIHN0cmluZ19pZF9tYXAuc2V0KHNlbGYsIGlkKTtcclxuICAgICAgICAgICAgcmV0dXJuIGlkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIGVuZFxyXG5cclxuICAgICAgICBkZWYgaGFzaFxyXG4gICAgICAgICAgJXh7XHJcbiAgICAgICAgICAgIHZhciBoYXNoID0gJG9wYWwzMl9pbml0KCksIGksIGxlbmd0aCA9IHNlbGYubGVuZ3RoO1xyXG4gICAgICAgICAgICBoYXNoID0gJG9wYWwzMl9hZGQoaGFzaCwgMHg1KTtcclxuICAgICAgICAgICAgaGFzaCA9ICRvcGFsMzJfYWRkKGhhc2gsIGxlbmd0aCk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIGhhc2ggPSAkb3BhbDMyX2FkZChoYXNoLCBzZWxmLmNoYXJDb2RlQXQoaSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBoYXNoO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIGVuZFxyXG4gICAgICB9XHJcbiAgICB9KSgpO1xyXG4gIH1cclxuXHJcbiAgZGVmIHNlbGYudHJ5X2NvbnZlcnQod2hhdClcclxuICAgIDo6T3BhbC5jb2VyY2VfdG8/KHdoYXQsIDo6U3RyaW5nLCA6dG9fc3RyKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc2VsZi5uZXcoKmFyZ3MpXHJcbiAgICAleHtcclxuICAgICAgdmFyIHN0ciA9IGFyZ3NbMF0gfHwgXCJcIjtcclxuICAgICAgdmFyIG9wdHMgPSBhcmdzW2FyZ3MubGVuZ3RoLTFdO1xyXG4gICAgICBzdHIgPSAkY29lcmNlX3RvKHN0ciwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcclxuICAgICAgaWYgKHNlbGYuJCRjb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7XHJcbiAgICAgICAgc3RyID0gJHN0cihzdHIpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN0ciA9IG5ldyBzZWxmLiQkY29uc3RydWN0b3Ioc3RyKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAob3B0cyAmJiBvcHRzLiQkaXNfaGFzaCkge1xyXG4gICAgICAgIGlmIChvcHRzLmhhcygnZW5jb2RpbmcnKSkgc3RyID0gc3RyLiRmb3JjZV9lbmNvZGluZyhvcHRzLmdldCgnZW5jb2RpbmcnKSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFzdHIuJGluaXRpYWxpemUuJCRwcmlzdGluZSkgI3tgc3RyYC5pbml0aWFsaXplKCphcmdzKX07XHJcbiAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gICMgT3VyIGluaXRpYWxpemUgbWV0aG9kIGRvZXMgbm90aGluZywgdGhlIHN0cmluZyB2YWx1ZSBzZXR1cCBpcyBiZWluZ1xyXG4gICMgZG9uZSBieSBTdHJpbmcubmV3LiBUaGVyZWZvcmUgbm90IGFsbCBraW5kcyBvZiBzdWJjbGFzc2luZyB3aWxsIHdvcmsuXHJcbiAgIyBBcyBhIHJ1bGUgb2YgdGh1bWIsIHdoZW4gc3ViY2xhc3NpbmcgU3RyaW5nLCBlaXRoZXIgbWFrZSBzdXJlIHRvIG92ZXJyaWRlXHJcbiAgIyAubmV3IG9yIG1ha2Ugc3VyZSB0aGF0IHRoZSBmaXJzdCBhcmd1bWVudCBnaXZlbiB0byBhIGNvbnN0cnVjdG9yIGlzXHJcbiAgIyBhIHN0cmluZyB3ZSB3YW50IG91ciBzdWJjbGFzcy1zdHJpbmcgdG8gaG9sZC5cclxuICBkZWYgaW5pdGlhbGl6ZShzdHIgPSB1bmRlZmluZWQsIGVuY29kaW5nOiBuaWwsIGNhcGFjaXR5OiBuaWwpXHJcbiAgZW5kXHJcblxyXG4gIGRlZiAlKGRhdGEpXHJcbiAgICBpZiA6OkFycmF5ID09PSBkYXRhXHJcbiAgICAgIGZvcm1hdChzZWxmLCAqZGF0YSlcclxuICAgIGVsc2VcclxuICAgICAgZm9ybWF0KHNlbGYsIGRhdGEpXHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmICooY291bnQpXHJcbiAgICAleHtcclxuICAgICAgY291bnQgPSAkY29lcmNlX3RvKGNvdW50LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcclxuXHJcbiAgICAgIGlmIChjb3VudCA8IDApIHtcclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFyZ3VtZW50J31cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgcmVzdWx0ID0gJycsXHJcbiAgICAgICAgICBzdHJpbmcgPSBzZWxmLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAvLyBBbGwgY3JlZGl0IGZvciB0aGUgYml0LXR3aWRkbGluZyBtYWdpYyBjb2RlIGJlbG93IGdvZXMgdG8gTW96aWxsYVxyXG4gICAgICAvLyBwb2x5ZmlsbCBpbXBsZW1lbnRhdGlvbiBvZiBTdHJpbmcucHJvdG90eXBlLnJlcGVhdCgpIHBvc3RlZCBoZXJlOlxyXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvcmVwZWF0XHJcblxyXG4gICAgICBpZiAoc3RyaW5nLmxlbmd0aCAqIGNvdW50ID49IE1BWF9TVFJfTEVOKSB7XHJcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsICdtdWx0aXBseSBjb3VudCBtdXN0IG5vdCBvdmVyZmxvdyBtYXhpbXVtIHN0cmluZyBzaXplJ31cclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yICg7Oykge1xyXG4gICAgICAgIGlmICgoY291bnQgJiAxKSA9PT0gMSkge1xyXG4gICAgICAgICAgcmVzdWx0ICs9IHN0cmluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgY291bnQgPj4+PSAxO1xyXG4gICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0cmluZyArPSBzdHJpbmc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiArKG90aGVyKVxyXG4gICAgb3RoZXIgPSBgJGNvZXJjZV90bygje290aGVyfSwgI3s6OlN0cmluZ30sICd0b19zdHInKWBcclxuICAgICV4e1xyXG4gICAgICBpZiAob3RoZXIubGVuZ3RoID09PSAwICYmIHNlbGYuJCRjbGFzcyA9PT0gT3BhbC5TdHJpbmcpIHJldHVybiBzZWxmO1xyXG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IDAgJiYgb3RoZXIuJCRjbGFzcyA9PT0gT3BhbC5TdHJpbmcpIHJldHVybiBvdGhlcjtcclxuICAgICAgdmFyIG91dCA9IHNlbGYgKyBvdGhlcjtcclxuICAgICAgaWYgKHNlbGYuZW5jb2RpbmcgPT09IG91dC5lbmNvZGluZyAmJiBvdGhlci5lbmNvZGluZyA9PT0gb3V0LmVuY29kaW5nKSByZXR1cm4gb3V0O1xyXG4gICAgICBpZiAoc2VsZi5lbmNvZGluZy5uYW1lID09PSBcIlVURi04XCIgfHwgb3RoZXIuZW5jb2RpbmcubmFtZSA9PT0gXCJVVEYtOFwiKSByZXR1cm4gb3V0O1xyXG4gICAgICByZXR1cm4gT3BhbC5lbmMob3V0LCBzZWxmLmVuY29kaW5nKTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmICtAXHJcbiAgICBmcm96ZW4/ID8gZHVwIDogc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgLUBcclxuICAgICV4e1xyXG4gICAgICBpZiAodHlwZW9mIHNlbGYgPT09ICdzdHJpbmcnIHx8IHNlbGYuJCRmcm96ZW4pIHJldHVybiBzZWxmO1xyXG4gICAgICBpZiAoc2VsZi5lbmNvZGluZy5uYW1lID09ICdVVEYtOCcgJiYgc2VsZi5pbnRlcm5hbF9lbmNvZGluZy5uYW1lID09ICdVVEYtOCcpIHJldHVybiBzZWxmLnRvU3RyaW5nKCk7XHJcbiAgICAgIHJldHVybiBzZWxmLiRkdXAoKS4kZnJlZXplKCk7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gICMgPDwgLSBub3Qgc3VwcG9ydGVkLCBtdXRhdGVzIHN0cmluZ1xyXG5cclxuICBkZWYgPD0+KG90aGVyKVxyXG4gICAgaWYgb3RoZXIucmVzcG9uZF90bz8gOnRvX3N0clxyXG4gICAgICBvdGhlciA9IG90aGVyLnRvX3N0ci50b19zXHJcblxyXG4gICAgICBgc2VsZiA+IG90aGVyID8gMSA6IChzZWxmIDwgb3RoZXIgPyAtMSA6IDApYFxyXG4gICAgZWxzZVxyXG4gICAgICAleHtcclxuICAgICAgICB2YXIgY21wID0gI3tvdGhlciA8PT4gc2VsZn07XHJcblxyXG4gICAgICAgIGlmIChjbXAgPT09IG5pbCkge1xyXG4gICAgICAgICAgcmV0dXJuIG5pbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gY21wID4gMCA/IC0xIDogKGNtcCA8IDAgPyAxIDogMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmID09KG90aGVyKVxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChvdGhlci4kJGlzX3N0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzZWxmLnRvU3RyaW5nKCkgPT09IG90aGVyLnRvU3RyaW5nKCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCRyZXNwb25kX3RvKG90aGVyLCAnJHRvX3N0cicpKSB7XHJcbiAgICAgICAgcmV0dXJuICN7b3RoZXIgPT0gc2VsZn07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBhbGlhcyA9PT0gPT1cclxuXHJcbiAgZGVmID1+KG90aGVyKVxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChvdGhlci4kJGlzX3N0cmluZykge1xyXG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICd0eXBlIG1pc21hdGNoOiBTdHJpbmcgZ2l2ZW4nfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuICN7b3RoZXIgPX4gc2VsZn07XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBbXShpbmRleCwgbGVuZ3RoID0gdW5kZWZpbmVkKVxyXG4gICAgcmVzdWx0ID0gYHNsaWNlKHNlbGYsIGluZGV4LCBsZW5ndGgpYFxyXG4gICAgaWYgcmVzdWx0XHJcbiAgICAgICV4e1xyXG4gICAgICAgIGlmIChzZWxmLmVuY29kaW5nID09PSBPcGFsLkVuY29kaW5nPy5VVEZfOCkgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICByZXR1cm4gJHN0cl93aXRoX2VuYyhyZXN1bHQsIHNlbGYuZW5jb2RpbmcpO1xyXG4gICAgICB9XHJcbiAgICBlbmRcclxuICAgIG5pbFxyXG4gIGVuZFxyXG5cclxuICAjIFtdPSAtIG5vdCBzdXBwb3J0ZWQsIG11dGF0ZXMgc3RyaW5nXHJcbiAgIyBhcHBlbmRfYXNfYnl0ZXMgLSBub3Qgc3VwcG9ydGVkLCBtdXRhdGVzIHN0cmluZ1xyXG5cclxuICBkZWYgYXNjaWlfb25seT9cclxuICAgICMgbm9uLUFTQ0lJLWNvbXBhdGlibGUgZW5jb2RpbmcgbXVzdCByZXR1cm4gZmFsc2VcclxuICAgICV4e1xyXG4gICAgICBpZiAoIXNlbGYuZW5jb2Rpbmc/LmFzY2lpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIHJldHVybiAvXltcXHgwMC1cXHg3Rl0qJC8udGVzdChzZWxmKTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGJcclxuICAgIGAkc3RyX3dpdGhfZW5jKHNlbGYsICdiaW5hcnknKWBcclxuICBlbmRcclxuXHJcbiAgZGVmIGJ5dGVpbmRleChzZWFyY2gsIG9mZnNldCA9IDApXHJcbiAgICAleHtcclxuICAgICAgbGV0IGluZGV4LCBtYXRjaCwgcmVnZXg7XHJcblxyXG4gICAgICBpZiAob2Zmc2V0ID09IG5pbCB8fCBvZmZzZXQgPT0gbnVsbCkge1xyXG4gICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgb2Zmc2V0ID0gJGNvZXJjZV90byhvZmZzZXQsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XHJcbiAgICAgICAgICBvZmZzZXQgKz0gc2VsZi4kYnl0ZXNpemUoKTtcclxuICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSByZXR1cm4gbmlsO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmFpc2VfaWZfbm90X3N0cmluZ2lzaChzZWFyY2gpO1xyXG5cclxuICAgICAgaWYgKHNlYXJjaC4kJGlzX3JlZ2V4cCkge1xyXG4gICAgICAgIGxldCBzdHIsIGJfc2l6ZTtcclxuICAgICAgICBpZiAob2Zmc2V0ID4gMCkge1xyXG4gICAgICAgICAgLy8gYmVjYXVzZSB3ZSBjYW5ub3QgZG8gYmluYXJ5IFJlZ0V4cCwgd2UgYnl0ZXNsaWNlIHNlbGYgZnJvbSBvZmZzZXRcclxuICAgICAgICAgIC8vIHRoZW4gZXhlYyB0aGUgcmVnZXhwIG9uIHRoZSByZW1haW5pbmcgc3RyaW5nLCBnZXR0aW5nIHRoZVxyXG4gICAgICAgICAgLy8gY2hhciBpbmRleCwgYW5kIHRoZW4gbWVhc3VyZSB0aGUgYnl0ZXNpemUgdW50aWwgdGhlIGNoYXIgaW5kZXhcclxuICAgICAgICAgIGJfc2l6ZSA9IHNlbGYuJGJ5dGVzaXplKCk7XHJcbiAgICAgICAgICBpZiAob2Zmc2V0ID4gYl9zaXplKSByZXR1cm4gbmlsO1xyXG4gICAgICAgICAgc3RyID0gc2VsZi4kYnl0ZXNsaWNlKG9mZnNldCwgYl9zaXplIC0gb2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBzdHIgPSBzZWxmO1xyXG4gICAgICAgIHJlZ2V4ID0gJGdsb2JhbF9yZWdleHAoc2VhcmNoKTtcclxuICAgICAgICBtYXRjaCA9IHJlZ2V4LmV4ZWMoc3RyKTtcclxuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcclxuICAgICAgICAgICN7JH4gPSBuaWx9O1xyXG4gICAgICAgICAgcmV0dXJuIG5pbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgI3skfiA9IDo6TWF0Y2hEYXRhLm5ldyhgcmVnZXhgLCBgbWF0Y2hgKX07XHJcbiAgICAgICAgaW5kZXggPSBtYXRjaC5pbmRleDtcclxuICAgICAgICBpZiAoaW5kZXggPT09IDApIHJldHVybiBvZmZzZXQ7XHJcbiAgICAgICAgcmV0dXJuIG9mZnNldCArICN7aW50ZXJuYWxfZW5jb2RpbmcuYnl0ZXNpemUoYHN0cmAsIGBpbmRleCAtIDFgKX07XHJcbiAgICAgIH1cclxuICAgICAgc2VhcmNoID0gJGNvZXJjZV90byhzZWFyY2gsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XHJcbiAgICAgIGluZGV4ID0gZmluZF9ieXRlX2luZGV4X29mKHNlbGYsIHNlYXJjaCwgc2VhcmNoLiRsZW5ndGgoKSwgb2Zmc2V0LCBmYWxzZSk7XHJcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiBuaWw7XHJcbiAgICAgIHJldHVybiBpbmRleDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGJ5dGVyaW5kZXgoc2VhcmNoLCBvZmZzZXQgPSB1bmRlZmluZWQpXHJcbiAgICAleHtcclxuICAgICAgbGV0IGluZGV4LCBtYXRjaCwgcmVnZXgsIF9tO1xyXG5cclxuICAgICAgaWYgKG9mZnNldCA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBvZmZzZXQgPSBzZWxmLiRieXRlc2l6ZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG9mZnNldCA9ICRjb2VyY2VfdG8ob2Zmc2V0LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcclxuICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xyXG4gICAgICAgICAgb2Zmc2V0ICs9IHNlbGYuJGJ5dGVzaXplKCk7XHJcbiAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkgcmV0dXJuIG5pbDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJhaXNlX2lmX25vdF9zdHJpbmdpc2goc2VhcmNoKTtcclxuXHJcbiAgICAgIGlmIChzZWFyY2guJCRpc19yZWdleHApIHtcclxuICAgICAgICBsZXQgYnJfaWR4LCBiX2xlbmd0aCA9IHNlbGYuJGJ5dGVzaXplKCk7XHJcbiAgICAgICAgaWYgKG9mZnNldCA8IGJfbGVuZ3RoKVxyXG4gICAgICAgICAgYnJfaWR4ID0gc2VsZi4kYnl0ZXNsaWNlKDAsIG9mZnNldCArIDEpLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgbWF0Y2ggPSBudWxsO1xyXG4gICAgICAgIHJlZ2V4ID0gJGdsb2JhbF9yZWdleHAoc2VhcmNoKTtcclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgX20gPSByZWdleC5leGVjKHNlbGYpO1xyXG4gICAgICAgICAgaWYgKF9tID09PSBudWxsIHx8IF9tLmluZGV4ID4gYnJfaWR4KSBicmVhaztcclxuICAgICAgICAgIG1hdGNoID0gX207XHJcbiAgICAgICAgICByZWdleC5sYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgI3skfiA9IG5pbH1cclxuICAgICAgICAgIHJldHVybiBuaWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICN7JH4gPSA6Ok1hdGNoRGF0YS5uZXcgYHJlZ2V4YCwgYG1hdGNoYH07XHJcbiAgICAgICAgaW5kZXggPSBtYXRjaC5pbmRleDtcclxuICAgICAgICBpZiAoaW5kZXggPT09IDApIHJldHVybiAwO1xyXG4gICAgICAgIHJldHVybiAje2ludGVybmFsX2VuY29kaW5nLmJ5dGVzaXplKGBzZWxmYCwgYGluZGV4IC0gMWApfTtcclxuICAgICAgfVxyXG4gICAgICBzZWFyY2ggPSAkY29lcmNlX3RvKHNlYXJjaCwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcclxuICAgICAgaW5kZXggPSBmaW5kX2J5dGVfaW5kZXhfb2Yoc2VsZiwgc2VhcmNoLCBzZWFyY2guJGxlbmd0aCgpLCBvZmZzZXQsIHRydWUpO1xyXG4gICAgICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gbmlsO1xyXG4gICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBieXRlcygmYmxvY2spXHJcbiAgICByZXMgPSBlYWNoX2J5dGUudG9fYVxyXG4gICAgcmV0dXJuIHJlcyB1bmxlc3MgYmxvY2tfZ2l2ZW4/XHJcbiAgICByZXMuZWFjaCgmYmxvY2spXHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBieXRlc2l6ZVxyXG4gICAgaW50ZXJuYWxfZW5jb2RpbmcuYnl0ZXNpemUoc2VsZiwgYHNlbGYubGVuZ3RoYClcclxuICBlbmRcclxuXHJcbiAgZGVmIGJ5dGVzbGljZShpbmRleCwgbGVuZ3RoID0gdW5kZWZpbmVkKVxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChpbmRleC4kJGlzX3JhbmdlKSB7XHJcbiAgICAgICAgaWYgKGxlbmd0aCkgI3tyYWlzZSBUeXBlRXJyb3IsICdsZW5ndGggbm90IGFsbG93ZWQgaWYgcmFuZ2UgaXMgZ2l2ZW4nfTtcclxuICAgICAgICAvLyBUaGlzIHBhcnQgc2V0cyBpbmRleCBhbmQgbGVuZ3RoLCBiYXNpY2FsbHkgY29udmVydGluZyBzZWxmWzIuLjNdIHJhbmdlXHJcbiAgICAgICAgLy8gdG8gc2VsZlsyLCAxXSBpbmRleCArIGxlbmd0aCBhbmQgbGV0dGluZyB0aGUgcmFuZ2UgZ2V0IGhhbmRsZWQgYnkgdGhlXHJcbiAgICAgICAgLy8gaW5kZXggKyBsZW5ndGggY29kZSBiZWxvdy5cclxuICAgICAgICBjb25zdCByYW5nZSA9IGluZGV4O1xyXG4gICAgICAgIGNvbnN0IHJfZW5kID0gaW5kZXguZW5kID09PSBuaWwgPyBJbmZpbml0eSA6ICRjb2VyY2VfdG8ocmFuZ2UuZW5kLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcclxuICAgICAgICBpbmRleCA9IHJhbmdlLmJlZ2luID09PSBuaWwgPyAwIDogJGNvZXJjZV90byhyYW5nZS5iZWdpbiwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XHJcblxyXG4gICAgICAgIGlmICgoKGluZGV4ID4gMCAmJiByX2VuZCA+IDApIHx8IChpbmRleCA8IDAgJiYgcl9lbmQgPDApKSAmJiBpbmRleCA+IHJfZW5kKSB7XHJcbiAgICAgICAgICBsZW5ndGggPSAwO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IHJfZW5kKSB7XHJcbiAgICAgICAgICBsZW5ndGggPSByYW5nZS5leGNsID8gMCA6IDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnN0IGUgPSByYW5nZS5leGNsID8gMCA6IDE7XHJcbiAgICAgICAgICBpZiAoKCFyYW5nZS5leGNsICYmIHJfZW5kID09PSAtMSkgfHwgcl9lbmQgPT09IEluZmluaXR5KSBsZW5ndGggPSBJbmZpbml0eTtcclxuICAgICAgICAgIGVsc2UgaWYgKGluZGV4ID09IDAgfHwgKGluZGV4ID4gMCAmJiByX2VuZCA8IDApKSBsZW5ndGggPSByX2VuZCA9PT0gSW5maW5pdHkgPyBJbmZpbml0eSA6IChyX2VuZCArIGUpO1xyXG4gICAgICAgICAgZWxzZSBpZiAoaW5kZXggPCAwICYmIHJfZW5kID49IDApIGxlbmd0aCA9IDA7XHJcbiAgICAgICAgICBlbHNlIGlmICgoaW5kZXggPCAwICYmIHJfZW5kIDwgMCkgfHwgKGluZGV4ID4gMCAmJiByX2VuZCA+IDApKSB7XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IHJfZW5kID09PSBJbmZpbml0eSA/IEluZmluaXR5IDogKHJfZW5kIC0gaW5kZXggKyBlKTtcclxuICAgICAgICAgICAgaWYgKGxlbmd0aCA8IDApIGxlbmd0aCA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGluZGV4ID0gJGNvZXJjZV90byhpbmRleCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XHJcbiAgICAgICAgaWYgKGxlbmd0aCAhPSBudWxsKSBsZW5ndGggPSAkY29lcmNlX3RvKGxlbmd0aCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XHJcbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHJldHVybiBuaWw7XHJcbiAgICAgICAgaWYgKGxlbmd0aCA9PSBudWxsIHx8IGxlbmd0aCA9PT0gbmlsKSB7XHJcbiAgICAgICAgICBpZiAoc2VsZi5sZW5ndGggPT09IDApIHJldHVybiBuaWw7IC8vIG5vIG1hdGNoIHBvc3NpYmxlXHJcbiAgICAgICAgICBsZW5ndGggPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoaW5kZXggPiBNQVhfU1RSX0xFTikgI3tyYWlzZSBSYW5nZUVycm9yLCAnaW5kZXggdG9vIGxhcmdlJ307XHJcbiAgICAgIGlmIChsZW5ndGggIT09IEluZmluaXR5ICYmIGxlbmd0aCA+IE1BWF9TVFJfTEVOKSAje3JhaXNlIFJhbmdlRXJyb3IsICdsZW5ndGggdG9vIGxhcmdlJ307XHJcbiAgICB9XHJcbiAgICByZXN1bHQgPSBpbnRlcm5hbF9lbmNvZGluZy5ieXRlc2xpY2Uoc2VsZiwgaW5kZXgsIGxlbmd0aClcclxuICAgIGlmIHJlc3VsdFxyXG4gICAgICAleHtcclxuICAgICAgICBpZiAoc2VsZi5lbmNvZGluZyA9PT0gT3BhbC5FbmNvZGluZz8uVVRGXzgpIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgcmV0dXJuICRzdHJfd2l0aF9lbmMocmVzdWx0LCBzZWxmLmVuY29kaW5nKTtcclxuICAgICAgfVxyXG4gICAgZW5kXHJcbiAgICByZXN1bHRcclxuICBlbmRcclxuXHJcbiAgIyBieXRlc3BsaWNlIC0gbm90IHN1cHBvcnRlZCwgbXV0YXRlcyBzdHJpbmdcclxuXHJcbiAgZGVmIGNhcGl0YWxpemUoKm9wdGlvbnMpXHJcbiAgICAleHtcclxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XHJcbiAgICAgIGxldCBmaXJzdCA9IGZpcnN0X2NoYXIoc2VsZik7XHJcbiAgICAgIGlmIChjYXNlX29wdGlvbnNfaGF2ZV9hc2NpaShvcHRpb25zKSAmJiBmaXJzdC5jb2RlUG9pbnRBdCgwKSA+IDEyNykgcmV0dXJuIHNlbGY7XHJcbiAgICAgIGxldCBmaXJzdF91cHBlciA9IGZpcnN0LnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgIGlmIChmaXJzdF91cHBlci5sZW5ndGggPiBmaXJzdC5sZW5ndGggJiYgZmlyc3RfdXBwZXIuY29kZVBvaW50QXQoMCkgPCAxMjgpIHtcclxuICAgICAgICBmaXJzdF91cHBlciA9IGZpcnN0X3VwcGVyWzBdICsgZmlyc3RfdXBwZXJbMV0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgY2FweiA9IGZpcnN0X3VwcGVyICsgc2VsZi5zdWJzdHJpbmcoZmlyc3QubGVuZ3RoKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICByZXR1cm4gY2Fwei4kZm9yY2VfZW5jb2Rpbmcoc2VsZi5lbmNvZGluZyk7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gICMgY2FwaXRhbGl6ZSEgLSBub3Qgc3VwcG9ydGVkLCBtdXRhdGVzIHN0cmluZ1xyXG5cclxuICBkZWYgY2FzZWNtcChvdGhlcilcclxuICAgIHJldHVybiBuaWwgdW5sZXNzIG90aGVyLnJlc3BvbmRfdG8/KDp0b19zdHIpXHJcbiAgICBvdGhlciA9IGAkY29lcmNlX3RvKG90aGVyLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpYC50b19zXHJcbiAgICBkb3duY2FzZSg6YXNjaWkpIDw9PiBvdGhlci5kb3duY2FzZSg6YXNjaWkpXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBjYXNlY21wPyhvdGhlcilcclxuICAgIHJldHVybiBuaWwgdW5sZXNzIG90aGVyLnJlc3BvbmRfdG8/KDp0b19zdHIpXHJcbiAgICBvdGhlciA9IGAkY29lcmNlX3RvKG90aGVyLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpYC50b19zXHJcbiAgICBjID0gZG93bmNhc2UoOmZvbGQpIDw9PiBvdGhlci5kb3duY2FzZSg6Zm9sZClcclxuICAgIHJldHVybiB0cnVlIGlmIGMgPT0gMFxyXG4gICAgcmV0dXJuIG5pbCBpZiBjLm5pbD9cclxuICAgIGZhbHNlXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBjZW50ZXIod2lkdGgsIHBhZHN0ciA9ICcgJylcclxuICAgIHdpZHRoICA9IGAkY29lcmNlX3RvKCN7d2lkdGh9LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcclxuICAgIHBhZHN0ciA9IGAkY29lcmNlX3RvKCN7cGFkc3RyfSwgI3s6OlN0cmluZ30sICd0b19zdHInKWAudG9fc1xyXG5cclxuICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3plcm8gd2lkdGggcGFkZGluZycgaWYgcGFkc3RyLmVtcHR5P1xyXG5cclxuICAgIGwgPSBsZW5ndGhcclxuXHJcbiAgICByZXR1cm4gc2VsZiBpZiB3aWR0aCA8PSBsXHJcblxyXG4gICAgJXh7XHJcbiAgICAgIHJldHVybiAocGFkZGluZyhwYWRzdHIsIE1hdGguZmxvb3IoKHdpZHRoICsgbCkgLyAyKSAtIGwpICtcclxuICAgICAgICAgICAgIHNlbGYgK1xyXG4gICAgICAgICAgICAgcGFkZGluZyhwYWRzdHIsIE1hdGguY2VpbCgod2lkdGggKyBsKSAvIDIpIC0gbCkpXHJcbiAgICAgICAgICAgICAuJGZvcmNlX2VuY29kaW5nKHNlbGYuZW5jb2RpbmcpO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgY2hhcnMoJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVhY2hfY2hhcigmYmxvY2spIGlmIGJsb2NrX2dpdmVuP1xyXG4gICAgIyBjYW5ub3QgdXNlIHRoZSBzaG9ydGN1dCBbLi4uc2VsZl0gaGVyZSxcclxuICAgICMgYmVjYXVzZSBlbmNvZGluZyBtdXN0IGJlIHNldCBvbiBlYWNoIGNoYXJcclxuICAgIGVhY2hfY2hhci50b19hXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBjaG9tcChzZXBhcmF0b3IgPSAkLylcclxuICAgIHJldHVybiBzZWxmIGlmIGBzZXBhcmF0b3IgPT09IG5pbCB8fCBzZWxmLmxlbmd0aCA9PT0gMGBcclxuXHJcbiAgICBzZXBhcmF0b3IgPSA6Ok9wYWwuY29lcmNlX3RvIShzZXBhcmF0b3IsIDo6U3RyaW5nLCA6dG9fc3RyKS50b19zXHJcblxyXG4gICAgJXh7XHJcbiAgICAgIHZhciByZXN1bHQ7XHJcblxyXG4gICAgICBpZiAoc2VwYXJhdG9yID09PSBcIlxcblwiKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gc2VsZi5yZXBsYWNlKC9cXHI/XFxuPyQvLCAnJyk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoc2VwYXJhdG9yLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJlc3VsdCA9IHNlbGYucmVwbGFjZSgvKFxccj9cXG4pKyQvLCAnJyk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoc2VsZi5sZW5ndGggPj0gc2VwYXJhdG9yLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAgICAhc3RhcnRzX3dpdGhfbG93X3N1cnJvZ2F0ZShzZXBhcmF0b3IpICYmXHJcbiAgICAgICAgICAgICAgICFlbmRzX3dpdGhfaGlnaF9zdXJyb2dhdGUoc2VwYXJhdG9yKSkge1xyXG5cclxuICAgICAgICAvLyBjb21wYXJlIHRhaWwgd2l0aCBzZXBhcmF0b3JcclxuICAgICAgICBpZiAoc2VsZi5zdWJzdHJpbmcoc2VsZi5sZW5ndGggLSBzZXBhcmF0b3IubGVuZ3RoKSA9PT0gc2VwYXJhdG9yKSB7XHJcbiAgICAgICAgICByZXN1bHQgPSBzZWxmLnN1YnN0cmluZygwLCBzZWxmLmxlbmd0aCAtIHNlcGFyYXRvci5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC4kZm9yY2VfZW5jb2Rpbmcoc2VsZi5lbmNvZGluZyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gICMgY2hvbXAhIC0gbm90IHN1cHBvcnRlZCwgbXV0YXRlcyBzdHJpbmdcclxuXHJcbiAgZGVmIGNob3BcclxuICAgICV4e1xyXG4gICAgICB2YXIgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIHJlc3VsdDtcclxuXHJcbiAgICAgIGlmIChsZW5ndGggPD0gMSkge1xyXG4gICAgICAgIHJlc3VsdCA9IFwiXCI7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2VsZi5jaGFyQXQobGVuZ3RoIC0gMSkgPT09IFwiXFxuXCIgJiYgc2VsZi5jaGFyQXQobGVuZ3RoIC0gMikgPT09IFwiXFxyXCIpIHtcclxuICAgICAgICByZXN1bHQgPSBzZWxmLnN1YnN0cmluZygwLCBsZW5ndGggLSAyKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsZXQgY3V0ID0gc2VsZi5jb2RlUG9pbnRBdChsZW5ndGggLSAyKSA+IDB4RkZGRiA/IDIgOiAxO1xyXG4gICAgICAgIHJlc3VsdCA9IHNlbGYuc3Vic3RyaW5nKDAsIGxlbmd0aCAtIGN1dCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdC4kZm9yY2VfZW5jb2Rpbmcoc2VsZi5lbmNvZGluZyk7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gICMgY2hvcCEgLSBub3Qgc3VwcG9ydGVkLCBtdXRhdGVzIHN0cmluZ1xyXG5cclxuICBkZWYgY2hyXHJcbiAgICAleHtcclxuICAgICAgbGV0IHJlc3VsdCA9IHNlbGYubGVuZ3RoID4gMCA/IGZpcnN0X2NoYXIoc2VsZikgOiAnJztcclxuICAgICAgcmV0dXJuIHJlc3VsdC4kZm9yY2VfZW5jb2Rpbmcoc2VsZi5lbmNvZGluZyk7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gICMgY2xlYXIgLSBub3Qgc3VwcG9ydGVkLCBtdXRhdGVzIHN0cmluZ1xyXG5cclxuICBkZWYgY2xvbmUoZnJlZXplOiBuaWwpXHJcbiAgICB1bmxlc3MgZnJlZXplLm5pbD8gfHwgZnJlZXplID09IHRydWUgfHwgZnJlZXplID09IGZhbHNlXHJcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwidW5leHBlY3RlZCB2YWx1ZSBmb3IgZnJlZXplOiAje2ZyZWV6ZS5jbGFzc31cIlxyXG4gICAgZW5kXHJcblxyXG4gICAgY29weSA9IGAkc3RyKHNlbGYpYFxyXG4gICAgY29weS5jb3B5X3NpbmdsZXRvbl9tZXRob2RzKHNlbGYpXHJcbiAgICBjb3B5LmluaXRpYWxpemVfY2xvbmUoc2VsZiwgZnJlZXplOiBmcmVlemUpXHJcblxyXG4gICAgaWYgZnJlZXplID09IHRydWVcclxuICAgICAgYGlmICghY29weS4kJGZyb3plbikgY29weS4kJGZyb3plbiA9IHRydWU7YFxyXG4gICAgZWxzaWYgZnJlZXplLm5pbD9cclxuICAgICAgYGlmIChzZWxmLiQkZnJvemVuKSBjb3B5LiQkZnJvemVuID0gdHJ1ZTtgXHJcbiAgICBlbmRcclxuXHJcbiAgICBjb3B5XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBjb2RlcG9pbnRzKCZibG9jaylcclxuICAgICMgSWYgYSBibG9jayBpcyBnaXZlbiwgd2hpY2ggaXMgYSBkZXByZWNhdGVkIGZvcm0sIHdvcmtzIHRoZSBzYW1lIGFzIGVhY2hfY29kZXBvaW50LlxyXG4gICAgcmV0dXJuIGVhY2hfY29kZXBvaW50KCZibG9jaykgaWYgYmxvY2tfZ2l2ZW4/XHJcblxyXG4gICAgZWFjaF9jb2RlcG9pbnQudG9fYVxyXG4gIGVuZFxyXG5cclxuICAjIGNvbmNhdCAtIG5vdCBzdXBwb3J0ZWQsIG11dGF0ZXMgc3RyaW5nXHJcblxyXG4gIGRlZiBjb3VudCgqc2V0cylcclxuICAgICV4e1xyXG4gICAgICBpZiAoc2V0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ0FyZ3VtZW50RXJyb3I6IHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDAgZm9yIDErKSd9XHJcbiAgICAgIH1cclxuICAgICAgbGV0IGNoYXJfY2xhc3MgPSBjaGFyX2NsYXNzX2Zyb21fY2hhcl9zZXRzKHNldHMpO1xyXG4gICAgICBpZiAoY2hhcl9jbGFzcyA9PT0gbnVsbCkgcmV0dXJuIDA7XHJcblxyXG4gICAgICBsZXQgcGF0dGVybl9mbGFncyA9ICR0cmFuc2Zvcm1fcmVnZXhwKGNoYXJfY2xhc3MsICdndScpO1xyXG4gICAgICByZXR1cm4gc2VsZi4kbGVuZ3RoKCkgLSBzZWxmLnJlcGxhY2UobmV3IFJlZ0V4cChwYXR0ZXJuX2ZsYWdzWzBdLCBwYXR0ZXJuX2ZsYWdzWzFdKSwgJycpLiRsZW5ndGgoKTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgIyBjcnlwdCAtIG5vdCBpbXBsZW1lbnRlZCwgY3J5cHQoMykgbWlzc2luZ1xyXG4gICMgZGVkdXAgLSBub3QgaW1wbGVtZW50ZWRcclxuXHJcbiAgZGVmIGRlbGV0ZSgqc2V0cylcclxuICAgICV4e1xyXG4gICAgICBpZiAoc2V0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ0FyZ3VtZW50RXJyb3I6IHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDAgZm9yIDErKSd9XHJcbiAgICAgIH1cclxuICAgICAgbGV0IGNoYXJfY2xhc3MgPSBjaGFyX2NsYXNzX2Zyb21fY2hhcl9zZXRzKHNldHMpO1xyXG4gICAgICBpZiAoY2hhcl9jbGFzcyA9PT0gbnVsbCkgcmV0dXJuIHNlbGY7XHJcblxyXG4gICAgICBsZXQgcGF0dGVybl9mbGFncyA9ICR0cmFuc2Zvcm1fcmVnZXhwKGNoYXJfY2xhc3MsICdndScpO1xyXG4gICAgICByZXR1cm4gc2VsZi5yZXBsYWNlKG5ldyBSZWdFeHAocGF0dGVybl9mbGFnc1swXSwgcGF0dGVybl9mbGFnc1sxXSksICcnKVxyXG4gICAgICAgICAgICAgLiRmb3JjZV9lbmNvZGluZyhzZWxmLmVuY29kaW5nKTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgIyBkZWxldGUhIC0gbm90IHN1cHBvcnRlZCwgbXV0YXRlcyBzdHJpbmdcclxuXHJcbiAgZGVmIGRlbGV0ZV9wcmVmaXgocHJlZml4KVxyXG4gICAgJXh7XHJcbiAgICAgIGlmICghcHJlZml4LiQkaXNfc3RyaW5nKSB7XHJcbiAgICAgICAgcHJlZml4ID0gJGNvZXJjZV90byhwcmVmaXgsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHN0YXJ0c193aXRoKHNlbGYsIHByZWZpeCkpIHtcclxuICAgICAgICByZXR1cm4gc2VsZi5zbGljZShwcmVmaXgubGVuZ3RoKS4kZm9yY2VfZW5jb2Rpbmcoc2VsZi5lbmNvZGluZyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gICMgZGVsZXRlX3ByZWZpeCEgLSBub3Qgc3VwcG9ydGVkLCBtdXRhdGVzIHN0cmluZ1xyXG5cclxuICBkZWYgZGVsZXRlX3N1ZmZpeChzdWZmaXgpXHJcbiAgICAleHtcclxuICAgICAgaWYgKCFzdWZmaXguJCRpc19zdHJpbmcpIHtcclxuICAgICAgICBzdWZmaXggPSAkY29lcmNlX3RvKHN1ZmZpeCwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZW5kc193aXRoKHNlbGYsIHN1ZmZpeCkpIHtcclxuICAgICAgICByZXR1cm4gc2VsZi5zbGljZSgwLCBzZWxmLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpLiRmb3JjZV9lbmNvZGluZyhzZWxmLmVuY29kaW5nKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc2VsZjtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgIyBkZWxldGVfc3VmZml4ISAtIG5vdCBzdXBwb3J0ZWQsIG11dGF0ZXMgc3RyaW5nXHJcblxyXG4gIGRlZiBkb3duY2FzZSgqb3B0aW9ucylcclxuICAgICV4e1xyXG4gICAgICBsZXQgc3RyID0gc2VsZjtcclxuXHJcbiAgICAgIGlmIChvcHRpb25zLmxlbmd0aCA+IDApe1xyXG4gICAgICAgIGlmIChjYXNlX29wdGlvbnNfaGF2ZV9hc2NpaShvcHRpb25zLCB0cnVlKSkge1xyXG4gICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL1tBLVpdKy9nLCAobWF0Y2gpPT57IHJldHVybiBtYXRjaC50b0xvd2VyQ2FzZSgpOyB9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaW5jbHVkZXMoJ2ZvbGQnKSkge1xyXG4gICAgICAgICAgc3RyID0gc3RyLnRvVXBwZXJDYXNlKCk7IC8vIMOfIC0+IFNTXHJcbiAgICAgICAgICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTsgLy8gU1MgLT4gc3NcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHN0ci4kZm9yY2VfZW5jb2Rpbmcoc2VsZi5lbmNvZGluZyk7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gICMgZG93bmNhc2UhIC0gbm90IHN1cHBvcnRlZCwgbXV0YXRlcyBzdHJpbmdcclxuXHJcbiAgZGVmIGR1bXBcclxuICAgICV4e1xyXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1taXNsZWFkaW5nLWNoYXJhY3Rlci1jbGFzcyAqL1xyXG4gICAgICBsZXQgZSA9IFwiW1xcXFxcXFxcXFxcIlxceDAwLVxceDFGXFx4N0YtXFx4RkZcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcIiArXHJcbiAgICAgICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MDApICsgJy0nICsgU3RyaW5nLmZyb21DaGFyQ29kZSgweGRmZmYpICsgXCJcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXVwiLFxyXG4gICAgICAgICAgZXNjYXBhYmxlID0gbmV3IFJlZ0V4cChlLCAnZycpLFxyXG4gICAgICAgICAgbWV0YSA9IHtcclxuICAgICAgICAgICAgJ1xcdTAwMDcnOiAnXFxcXGEnLFxyXG4gICAgICAgICAgICAnXFx1MDAxYic6ICdcXFxcZScsXHJcbiAgICAgICAgICAgICdcXGInOiAnXFxcXGInLFxyXG4gICAgICAgICAgICAnXFx0JzogJ1xcXFx0JyxcclxuICAgICAgICAgICAgJ1xcbic6ICdcXFxcbicsXHJcbiAgICAgICAgICAgICdcXGYnOiAnXFxcXGYnLFxyXG4gICAgICAgICAgICAnXFxyJzogJ1xcXFxyJyxcclxuICAgICAgICAgICAgJ1xcdic6ICdcXFxcdicsXHJcbiAgICAgICAgICAgICdcIicgOiAnXFxcXFwiJyxcclxuICAgICAgICAgICAgJ1xcXFwnOiAnXFxcXFxcXFwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgcHJldl9jaHIgPSAnJyxcclxuICAgICAgICAgIGlzX3V0ZjggPSAoc2VsZi5lbmNvZGluZyA9PSBPcGFsLkVuY29kaW5nLlVURl84KSxcclxuICAgICAgICAgIGVzY2FwZWQgPSBzZWxmLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbiAoY2hyKSB7XHJcbiAgICAgICAgICAgIGlmIChtZXRhW2Nocl0pIHJldHVybiBtZXRhW2Nocl07XHJcbiAgICAgICAgICAgIGNvbnN0IGNoYXJfY29kZSA9IGNoci5jaGFyQ29kZUF0KDApO1xyXG4gICAgICAgICAgICBpZiAoKCFpc191dGY4ICYmIGNoYXJfY29kZSA8PSAweGZmKSB8fCAoaXNfdXRmOCAmJiBjaGFyX2NvZGUgPCAweDgwKSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiAnXFxcXHgnICsgKCcwMCcgKyBjaGFyX2NvZGUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC0yKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyX2NvZGUgPj0gMHhEODAwICYmIGNoYXJfY29kZSA8PSAweERCRkYpIHtcclxuICAgICAgICAgICAgICBwcmV2X2NociA9IGNocjtcclxuICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhcl9jb2RlID49IDB4REMwMCAmJiBjaGFyX2NvZGUgPD0gMHhERkZGKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICdcXFxcdXsnICsgKHByZXZfY2hyICsgY2hyKS5jb2RlUG9pbnRBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArICd9JztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXR1cm4gJ1xcXFx1JyArICgnMDAwMCcgKyBjaGFyX2NvZGUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC00KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgIHJldHVybiAoJ1wiJyArIGVzY2FwZWQucmVwbGFjZSgvXFwjW1xcJFxcQFxce10vZywgJ1xcXFwkJicpICsgJ1wiJykuJGZvcmNlX2VuY29kaW5nKHNlbGYuZW5jb2RpbmcpO1xyXG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW1pc2xlYWRpbmctY2hhcmFjdGVyLWNsYXNzICovXHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBkdXBcclxuICAgIGNvcHkgPSBgJHN0cihzZWxmKWBcclxuICAgIGNvcHkuaW5pdGlhbGl6ZV9kdXAoc2VsZilcclxuICAgIGNvcHlcclxuICBlbmRcclxuXHJcbiAgZGVmIGVhY2hfYnl0ZSgmYmxvY2spXHJcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfYnl0ZSkgeyBieXRlc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cclxuICAgIGludGVybmFsX2VuY29kaW5nLmVhY2hfYnl0ZShzZWxmLCAmYmxvY2spXHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBlYWNoX2NoYXIoJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX2NoYXIpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cclxuICAgICV4e1xyXG4gICAgICBmb3IgKGxldCBjIG9mIHNlbGYpIHtcclxuICAgICAgICBjID0gJHN0cl93aXRoX2VuYyhjLCBzZWxmLmVuY29kaW5nKTtcclxuICAgICAgICBjLmVuY29kaW5nID0gc2VsZi5lbmNvZGluZztcclxuICAgICAgICAje3lpZWxkIGBjYH07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHNlbGZcclxuICBlbmRcclxuXHJcbiAgZGVmIGVhY2hfY29kZXBvaW50KCZibG9jaylcclxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9jb2RlcG9pbnQpIHsgbGVuZ3RoIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG4gICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3N0cmluZyBoYXMgaW52YWxpZCBlbmNvZGluZycgdW5sZXNzIHZhbGlkX2VuY29kaW5nP1xyXG4gICAgYGZvciAoY29uc3QgYyBvZiBzZWxmKSAje3lpZWxkIGBjLmNvZGVQb2ludEF0KDApYH1gXHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBlYWNoX2dyYXBoZW1lX2NsdXN0ZXIoJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX2dyYXBoZW1lX2NsdXN0ZXIpIHsgbGVuZ3RoIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG4gICAgY2x1c3RlcnMgPSBgZ3JhcGhlbWVfc2VnbWVudGVyKCkuc2VnbWVudChzZWxmKWBcclxuICAgIGBmb3IgKGNvbnN0IGNsdXN0ZXIgb2YgY2x1c3RlcnMpICN7eWllbGQgYGNsdXN0ZXIuc2VnbWVudC4kZm9yY2VfZW5jb2Rpbmcoc2VsZi5lbmNvZGluZylgfWBcclxuICAgIHNlbGZcclxuICBlbmRcclxuXHJcbiAgZGVmIGVhY2hfbGluZShzZXBhcmF0b3IgPSAkLywgY2hvbXA6IGZhbHNlLCAmYmxvY2spXHJcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2hfbGluZSwgc2VwYXJhdG9yLCBjaG9tcDogY2hvbXAgdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG5cclxuICAgICV4e1xyXG4gICAgICBpZiAoc2VwYXJhdG9yID09PSBuaWwpIHtcclxuICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgc2VsZik7XHJcblxyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzZXBhcmF0b3IgPSAkY29lcmNlX3RvKHNlcGFyYXRvciwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcclxuXHJcbiAgICAgIHZhciBhLCBpLCBuLCBsZW5ndGgsIGNob21wZWQsIHRyYWlsaW5nLCBzcGxpdHRlZCwgdmFsdWU7XHJcblxyXG4gICAgICBpZiAoc2VwYXJhdG9yLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGZvciAoYSA9IHNlbGYuc3BsaXQoLygoPzpcXHI/XFxuKXsyfSkoPzooPzpcXHI/XFxuKSopLyksIGkgPSAwLCBuID0gYS5sZW5ndGg7IGkgPCBuOyBpICs9IDIpIHtcclxuICAgICAgICAgIGlmIChhW2ldIHx8IGFbaSArIDFdKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gKGFbaV0gfHwgXCJcIikgKyAoYVtpICsgMV0gfHwgXCJcIik7XHJcbiAgICAgICAgICAgIGlmIChjaG9tcCkge1xyXG4gICAgICAgICAgICAgIHZhbHVlID0gI3tgdmFsdWVgLmNob21wKFwiXFxuXCIpfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgdmFsdWUuJGZvcmNlX2VuY29kaW5nKHNlbGYuZW5jb2RpbmcpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjaG9tcGVkICA9ICN7Y2hvbXAoc2VwYXJhdG9yKX07XHJcbiAgICAgIHRyYWlsaW5nID0gc2VsZi5sZW5ndGggIT0gY2hvbXBlZC5sZW5ndGg7XHJcblxyXG4gICAgICBpZiAoc3RhcnRzX3dpdGhfbG93X3N1cnJvZ2F0ZShzZXBhcmF0b3IpIHx8IGVuZHNfd2l0aF9oaWdoX3N1cnJvZ2F0ZShzZXBhcmF0b3IpKSB7XHJcbiAgICAgICAgc3BsaXR0ZWQgPSBbY2hvbXBlZF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3BsaXR0ZWQgPSBjaG9tcGVkLnNwbGl0KHNlcGFyYXRvcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNwbGl0dGVkLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFsdWUgPSBzcGxpdHRlZFtpXTtcclxuICAgICAgICBpZiAoaSA8IGxlbmd0aCAtIDEgfHwgdHJhaWxpbmcpIHtcclxuICAgICAgICAgIHZhbHVlICs9IHNlcGFyYXRvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNob21wKSB7XHJcbiAgICAgICAgICB2YWx1ZSA9ICN7YHZhbHVlYC5jaG9tcChzZXBhcmF0b3IpfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgT3BhbC55aWVsZDEoYmxvY2ssIHZhbHVlLiRmb3JjZV9lbmNvZGluZyhzZWxmLmVuY29kaW5nKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBlbXB0eT9cclxuICAgIGBzZWxmLmxlbmd0aCA9PT0gMGBcclxuICBlbmRcclxuXHJcbiAgZGVmIGVuY29kZShlbmNvZGluZylcclxuICAgIGBPcGFsLmVuYyhzZWxmLCBlbmNvZGluZylgXHJcbiAgZW5kXHJcblxyXG4gICMgZW5jb2RlISAtIG5vdCBzdXBwb3J0ZWQsIG11dGF0ZXMgc3RyaW5nXHJcbiAgIyBlbmNvZGluZyAtIHJlYWQgb25seSBhY2Nlc3Nvciwgc2VlIGFib3ZlXHJcblxyXG4gIGRlZiBlbmRfd2l0aD8oKnN1ZmZpeGVzKVxyXG4gICAgJXh7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBzdWZmaXhlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBzdWZmaXggPSAkY29lcmNlX3RvKHN1ZmZpeGVzW2ldLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpLiR0b19zKCk7XHJcbiAgICAgICAgaWYgKGVuZHNfd2l0aChzZWxmLCBzdWZmaXgpKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZhbHNlXHJcbiAgZW5kXHJcblxyXG4gIGFsaWFzIGVxbD8gPT1cclxuICBhbGlhcyBlcXVhbD8gPT09XHJcblxyXG4gIGRlZiBmb3JjZV9lbmNvZGluZyhlbmNvZGluZylcclxuICAgIGBpZiAoZW5jb2RpbmcgPT09IHNlbGYuZW5jb2RpbmcpIHJldHVybiBzZWxmO2BcclxuICAgIHVubGVzcyBlbmNvZGluZy5pc19hPyg6OkVuY29kaW5nKVxyXG4gICAgICAleHtcclxuICAgICAgICBlbmNvZGluZyA9ICN7OjpPcGFsLmNvZXJjZV90byEoZW5jb2RpbmcsIDo6U3RyaW5nLCA6dG9fc3RyKX07XHJcbiAgICAgICAgZW5jb2RpbmcgPSAjezo6RW5jb2RpbmcuZmluZChlbmNvZGluZyl9O1xyXG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gc2VsZi5lbmNvZGluZykgcmV0dXJuIHNlbGY7XHJcbiAgICAgIH1cclxuICAgIGVuZFxyXG4gICAgYE9wYWwuc2V0X2VuY29kaW5nKHNlbGYsIGVuY29kaW5nLm5hbWUpYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgZ2V0Ynl0ZShpZHgpXHJcbiAgICBpZHggPSA6Ok9wYWwuY29lcmNlX3RvIShpZHgsIDo6SW50ZWdlciwgOnRvX2ludClcclxuXHJcbiAgICByZXR1cm4gYnl0ZXNbaWR4XSBpZiBpZHggPCAwXHJcblxyXG4gICAgaSA9IDBcclxuICAgIGVhY2hfYnl0ZSBkbyB8YnxcclxuICAgICAgcmV0dXJuIGIgaWYgaSA9PSBpZHhcclxuICAgICAgaSArPSAxXHJcbiAgICBlbmRcclxuICAgIG5pbFxyXG4gIGVuZFxyXG5cclxuICBkZWYgZ3JhcGhlbWVfY2x1c3RlcnMoJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVhY2hfZ3JhcGhlbWVfY2x1c3RlcigmYmxvY2spIGlmIGJsb2NrX2dpdmVuP1xyXG5cclxuICAgIGVhY2hfZ3JhcGhlbWVfY2x1c3Rlci50b19hXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBnc3ViKHBhdHRlcm4sIHJlcGxhY2VtZW50ID0gdW5kZWZpbmVkLCAmYmxvY2spXHJcbiAgICAleHtcclxuICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbCkge1xyXG4gICAgICAgIHJldHVybiAje2VudW1fZm9yIDpnc3ViLCBwYXR0ZXJufTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHJlc3VsdCA9ICcnLCBtYXRjaF9kYXRhID0gbmlsLCBpbmRleCA9IDAsIG1hdGNoLCBfcmVwbGFjZW1lbnQ7XHJcblxyXG4gICAgICBpZiAocGF0dGVybi4kJGlzX3JlZ2V4cCkge1xyXG4gICAgICAgIHBhdHRlcm4gPSAkZ2xvYmFsX3JlZ2V4cChwYXR0ZXJuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwYXR0ZXJuID0gJGNvZXJjZV90byhwYXR0ZXJuLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xyXG4gICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4ucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2d1LCAnXFxcXCQmJyksICdnbXUnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGxhc3RJbmRleDtcclxuICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICBtYXRjaCA9IHBhdHRlcm4uZXhlYyhzZWxmKTtcclxuXHJcbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XHJcbiAgICAgICAgICAjeyR+ID0gbmlsfVxyXG4gICAgICAgICAgcmVzdWx0ICs9IHNlbGYuc2xpY2UoaW5kZXgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtYXRjaF9kYXRhID0gI3s6Ok1hdGNoRGF0YS5uZXcgYHBhdHRlcm5gLCBgbWF0Y2hgfTtcclxuXHJcbiAgICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGxhc3RJbmRleCA9IHBhdHRlcm4ubGFzdEluZGV4O1xyXG4gICAgICAgICAgX3JlcGxhY2VtZW50ID0gYmxvY2sobWF0Y2hbMF0pO1xyXG4gICAgICAgICAgcGF0dGVybi5sYXN0SW5kZXggPSBsYXN0SW5kZXg7IC8vIHNhdmUgYW5kIHJlc3RvcmUgbGFzdEluZGV4XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJlcGxhY2VtZW50LiQkaXNfaGFzaCkge1xyXG4gICAgICAgICAgX3JlcGxhY2VtZW50ID0gI3tgcmVwbGFjZW1lbnRgW2BtYXRjaFswXWBdLnRvX3N9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIGlmICghcmVwbGFjZW1lbnQuJCRpc19zdHJpbmcpIHtcclxuICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSAkY29lcmNlX3RvKHJlcGxhY2VtZW50LCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgX3JlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQucmVwbGFjZSgvKFtcXFxcXSspKFswLTkrJmAnXSkvZywgZnVuY3Rpb24gKG9yaWdpbmFsLCBzbGFzaGVzLCBjb21tYW5kKSB7XHJcbiAgICAgICAgICAgIGlmIChzbGFzaGVzLmxlbmd0aCAlIDIgPT09IDApIHtcclxuICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3dpdGNoIChjb21tYW5kKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCIrXCI6XHJcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IG1hdGNoLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYXRjaFtpXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgbWF0Y2hbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgY2FzZSBcIiZcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBtYXRjaFswXTtcclxuICAgICAgICAgICAgY2FzZSBcImBcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBzZWxmLnNsaWNlKDAsIG1hdGNoLmluZGV4KTtcclxuICAgICAgICAgICAgY2FzZSBcIidcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBzZWxmLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcclxuICAgICAgICAgICAgZGVmYXVsdDogIHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgKG1hdGNoW2NvbW1hbmRdIHx8ICcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSkucmVwbGFjZSgvXFxcXFxcXFwvZywgJ1xcXFwnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwYXR0ZXJuLmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHtcclxuICAgICAgICAgIHJlc3VsdCArPSAoc2VsZi5zbGljZShpbmRleCwgbWF0Y2guaW5kZXgpICsgX3JlcGxhY2VtZW50ICsgKHNlbGZbbWF0Y2guaW5kZXhdIHx8IFwiXCIpKTtcclxuICAgICAgICAgIHBhdHRlcm4ubGFzdEluZGV4ICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgcmVzdWx0ICs9IChzZWxmLnNsaWNlKGluZGV4LCBtYXRjaC5pbmRleCkgKyBfcmVwbGFjZW1lbnQpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluZGV4ID0gcGF0dGVybi5sYXN0SW5kZXg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgICN7JH4gPSBgbWF0Y2hfZGF0YWB9XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gICMgZ3N1YiEgLSBub3Qgc3VwcG9ydGVkLCBtdXRhdGVzIHN0cmluZ1xyXG5cclxuICBkZWYgaGV4XHJcbiAgICB0b19pIDE2XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBpbmNsdWRlPyhvdGhlcilcclxuICAgICV4e1xyXG4gICAgICBpZiAoIW90aGVyLiQkaXNfc3RyaW5nKSB7XHJcbiAgICAgICAgb3RoZXIgPSAkY29lcmNlX3RvKG90aGVyLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChvdGhlci5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xyXG4gICAgICByZXR1cm4gZmluZF9pbmRleF9vZihzZWxmLCBvdGhlcikgIT09IC0xO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgaW5kZXgoc2VhcmNoLCBvZmZzZXQgPSB1bmRlZmluZWQpXHJcbiAgICAleHtcclxuICAgICAgbGV0IGluZGV4O1xyXG5cclxuICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSBvZmZzZXQgPSAwO1xyXG4gICAgICBlbHNlIG9mZnNldCA9ICRjb2VyY2VfdG8ob2Zmc2V0LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcclxuXHJcbiAgICAgIGlmIChzZWFyY2guJCRpc19yZWdleHApIHtcclxuICAgICAgICBsZXQgcmVnZXggPSAkZ2xvYmFsX3JlZ2V4cChzZWFyY2gpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XHJcbiAgICAgICAgICBvZmZzZXQgKz0gc2VsZi4kbGVuZ3RoKCk7XHJcbiAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkgcmV0dXJuIG5pbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgIGxldCBtYXRjaCA9IHJlZ2V4LmV4ZWMoc2VsZik7XHJcbiAgICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcclxuICAgICAgICAgICAgI3skfiA9IG5pbH07XHJcbiAgICAgICAgICAgIHJldHVybiBuaWw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAobWF0Y2guaW5kZXggPj0gb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICN7JH4gPSA6Ok1hdGNoRGF0YS5uZXcoYHJlZ2V4YCwgYG1hdGNoYCl9XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaC5pbmRleDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJlZ2V4Lmxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2VhcmNoID0gJGNvZXJjZV90byhzZWFyY2gsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XHJcbiAgICAgICAgaWYgKHNlYXJjaC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIGxldCBsID0gc2VsZi4kbGVuZ3RoKCk7XHJcbiAgICAgICAgICBpZiAob2Zmc2V0ID4gbCkgcmV0dXJuIG5pbDtcclxuICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XHJcbiAgICAgICAgICAgIG9mZnNldCArPSBsO1xyXG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkgcmV0dXJuIG5pbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBvZmZzZXQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGxldCBzdHIgPSBzZWxmO1xyXG4gICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IHNlbGYuJGxlbmd0aCgpO1xyXG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkgcmV0dXJuIG5pbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChvZmZzZXQgPiAwKSB7XHJcbiAgICAgICAgICAgIHN0ciA9IHNlbGZbXCIkW11cIl0ob2Zmc2V0LCBJbmZpbml0eSk7XHJcbiAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwIHx8IHN0ciA9PT0gbmlsKSByZXR1cm4gbmlsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaW5kZXggPSBmaW5kX2luZGV4X29mKHN0ciwgc2VhcmNoKTtcclxuICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiBuaWw7XHJcbiAgICAgICAgICByZXR1cm4gaW5kZXggKyBvZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbmlsO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgaW5pdGlhbGl6ZV9jb3B5KG90aGVyKVxyXG4gICAgJXh7XHJcbiAgICAgIHNlbGYuZW5jb2RpbmcgPSBvdGhlci5lbmNvZGluZztcclxuICAgICAgc2VsZi5pbnRlcm5hbF9lbmNvZGluZyA9IG90aGVyLmludGVybmFsX2VuY29kaW5nO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICAjIGluc2VydCAtIG5vdCBzdXBwb3J0ZWQsIG11dGF0ZXMgc3RyaW5nXHJcblxyXG4gIGRlZiBpbnNwZWN0XHJcbiAgICAleHtcclxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tbWlzbGVhZGluZy1jaGFyYWN0ZXItY2xhc3MgKi9cclxuICAgICAgbGV0IGVzY2FwYWJsZSA9IC9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdGLVxceEZGXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcclxuICAgICAgICAgIG1ldGEgPSB7XHJcbiAgICAgICAgICAgICdcXHUwMDA3JzogJ1xcXFxhJyxcclxuICAgICAgICAgICAgJ1xcdTAwMWInOiAnXFxcXGUnLFxyXG4gICAgICAgICAgICAnXFxiJzogJ1xcXFxiJyxcclxuICAgICAgICAgICAgJ1xcdCc6ICdcXFxcdCcsXHJcbiAgICAgICAgICAgICdcXG4nOiAnXFxcXG4nLFxyXG4gICAgICAgICAgICAnXFxmJzogJ1xcXFxmJyxcclxuICAgICAgICAgICAgJ1xccic6ICdcXFxccicsXHJcbiAgICAgICAgICAgICdcXHYnOiAnXFxcXHYnLFxyXG4gICAgICAgICAgICAnXCInIDogJ1xcXFxcIicsXHJcbiAgICAgICAgICAgICdcXFxcJzogJ1xcXFxcXFxcJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGNoYXJfY29kZSxcclxuICAgICAgICAgIGlzX2JpbmFyeSA9IHNlbGYuZW5jb2RpbmdbXCIkYmluYXJ5P1wiXSgpIHx8IHNlbGYuaW50ZXJuYWxfZW5jb2RpbmdbXCIkYmluYXJ5P1wiXSgpLFxyXG4gICAgICAgICAgZXh0ZXJuYWxfaXNfdXRmOCA9IE9wYWwuRW5jb2RpbmcuZGVmYXVsdF9leHRlcm5hbCA9PSBPcGFsLkVuY29kaW5nLlVURl84LFxyXG4gICAgICAgICAgZXNjYXBlZCA9IHNlbGYucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uIChjaHIpIHtcclxuICAgICAgICAgICAgaWYgKG1ldGFbY2hyXSkgcmV0dXJuIG1ldGFbY2hyXTtcclxuICAgICAgICAgICAgY2hhcl9jb2RlID0gY2hyLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgICAgIGlmIChpc19iaW5hcnkgJiYgY2hhcl9jb2RlIDw9IDB4ZmYpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gJ1xcXFx4JyArICgnMDAnICsgY2hhcl9jb2RlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKS5zbGljZSgtMik7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXh0ZXJuYWxfaXNfdXRmOCAmJiBjaGFyX2NvZGUgPj0gMHhBMCAmJiBjaGFyX2NvZGUgPD0gMHhmZikge1xyXG4gICAgICAgICAgICAgIHJldHVybiBjaHI7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICdcXFxcdScgKyAoJzAwMDAnICsgY2hhcl9jb2RlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKS5zbGljZSgtNCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gJ1wiJyArIGVzY2FwZWQucmVwbGFjZSgvXFwjW1xcJFxcQFxce10vZywgJ1xcXFwkJicpICsgJ1wiJztcclxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1taXNsZWFkaW5nLWNoYXJhY3Rlci1jbGFzcyAqL1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgaW50ZXJuXHJcbiAgICAjIHNwZWNzIGV4cGVjdCB0aGUgZXhjZXB0aW9uIHRvIGhhdmUgdGhlIGludmFsaWQgY2hhcmFjdGVyOiBcIihpbnZhbGlkIHN5bWJvbCBpbiBlbmNvZGluZyBVVEYtOCA6XCJcXHhDM1wiKVwiXHJcbiAgICAjIHJhaXNlIEVuY29kaW5nRXJyb3IsIFwiaW52YWxpZCBzeW1ib2wgaW4gZW5jb2RpbmcgI3tlbmNvZGluZy5uYW1lfVwiIHVubGVzcyB2YWxpZF9lbmNvZGluZz9cclxuICAgICMgcmV0dXJuIGBzZWxmLnRvU3RyaW5nKCkuJGZvcmNlX2VuY29kaW5nKE9wYWwuRW5jb2RpbmcuVVNfQVNDSUkpYCBpZiBhc2NpaV9vbmx5P1xyXG4gICAgIyBidXQgbGV0cyBrZWVwIHRoaW5ncyBmYXN0IHVudGlsIHdlIGhhdmUgcmVhbCBTeW1ib2xzXHJcbiAgICBgc2VsZi50b1N0cmluZygpYCAjIC4kZm9yY2VfZW5jb2Rpbmcoc2VsZi5lbmNvZGluZylcclxuICBlbmRcclxuXHJcbiAgZGVmIGxlbmd0aFxyXG4gICAgJXh7XHJcbiAgICAgIGxldCBsZW5ndGggPSAwO1xyXG4gICAgICBmb3IgKGxldCBfYyBvZiBzZWxmKSB7IGxlbmd0aCsrOyB9XHJcbiAgICAgIHJldHVybiBsZW5ndGg7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBsaW5lcyhzZXBhcmF0b3IgPSAkLywgY2hvbXA6IGZhbHNlLCAmYmxvY2spXHJcbiAgICBlID0gZWFjaF9saW5lKHNlcGFyYXRvciwgY2hvbXA6IGNob21wLCAmYmxvY2spXHJcbiAgICBibG9jayA/IHNlbGYgOiBlLnRvX2FcclxuICBlbmRcclxuXHJcbiAgZGVmIGxqdXN0KHdpZHRoLCBwYWRzdHIgPSAnICcpXHJcbiAgICB3aWR0aCAgPSBgJGNvZXJjZV90bygje3dpZHRofSwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXHJcbiAgICBwYWRzdHIgPSBgJGNvZXJjZV90bygje3BhZHN0cn0sICN7OjpTdHJpbmd9LCAndG9fc3RyJylgLnRvX3NcclxuXHJcbiAgICBpZiBwYWRzdHIuZW1wdHk/XHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3plcm8gd2lkdGggcGFkZGluZydcclxuICAgIGVuZFxyXG5cclxuICAgIGwgPSBzaXplXHJcblxyXG4gICAgcmV0dXJuIHNlbGYgaWYgd2lkdGggPD0gbFxyXG5cclxuICAgIGAoc2VsZiArIHBhZGRpbmcocGFkc3RyLCB3aWR0aCAtIGwpKS4kZm9yY2VfZW5jb2Rpbmcoc2VsZi5lbmNvZGluZylgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBsc3RyaXBcclxuICAgIGBzZWxmLnJlcGxhY2UoL15bXFx4MDBcXHgwOVxceDBhLVxceDBkXFx4MjBdKi8sICcnKWBcclxuICBlbmRcclxuXHJcbiAgIyBsc3RyaXAhIC0gbm90IHN1cHBvcnRlZCwgbXV0YXRlcyBzdHJpbmdcclxuXHJcbiAgZGVmIG1hdGNoKHBhdHRlcm4sIHBvcyA9IHVuZGVmaW5lZCwgJmJsb2NrKVxyXG4gICAgaWYgU3RyaW5nID09PSBwYXR0ZXJuIHx8IHBhdHRlcm4ucmVzcG9uZF90bz8oOnRvX3N0cilcclxuICAgICAgcGF0dGVybiA9IDo6UmVnZXhwLm5ldyhwYXR0ZXJuLnRvX3N0cilcclxuICAgIGVuZFxyXG5cclxuICAgIHVubGVzcyA6OlJlZ2V4cCA9PT0gcGF0dGVyblxyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7cGF0dGVybi5jbGFzc30gKGV4cGVjdGVkIFJlZ2V4cClcIlxyXG4gICAgZW5kXHJcblxyXG4gICAgcGF0dGVybi5tYXRjaChzZWxmLCBwb3MsICZibG9jaylcclxuICBlbmRcclxuXHJcbiAgZGVmIG1hdGNoPyhwYXR0ZXJuLCBwb3MgPSB1bmRlZmluZWQpXHJcbiAgICBpZiBTdHJpbmcgPT09IHBhdHRlcm4gfHwgcGF0dGVybi5yZXNwb25kX3RvPyg6dG9fc3RyKVxyXG4gICAgICBwYXR0ZXJuID0gOjpSZWdleHAubmV3KHBhdHRlcm4udG9fc3RyKVxyXG4gICAgZW5kXHJcblxyXG4gICAgdW5sZXNzIDo6UmVnZXhwID09PSBwYXR0ZXJuXHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3twYXR0ZXJuLmNsYXNzfSAoZXhwZWN0ZWQgUmVnZXhwKVwiXHJcbiAgICBlbmRcclxuXHJcbiAgICBwYXR0ZXJuLm1hdGNoPyhzZWxmLCBwb3MpXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBuZXh0XHJcbiAgICAleHtcclxuICAgICAgbGV0IGkgPSBzZWxmLmxlbmd0aDtcclxuICAgICAgaWYgKGkgPT09IDApIHJldHVybiAnJztcclxuXHJcbiAgICAgIGxldCByZXN1bHQgPSBzZWxmLFxyXG4gICAgICAgICAgZmlyc3RfYWxwaGFudW1fY2hhcl9pbmRleCA9IHNlbGYuc2VhcmNoKC9bYS16QS1aMC05XS8pLFxyXG4gICAgICAgICAgY2FycnkgPSBmYWxzZSxcclxuICAgICAgICAgIGNvZGUgPSBudWxsLFxyXG4gICAgICAgICAgcHJpb3JfY29kZTtcclxuICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIGNvZGUgPSBzZWxmLmNvZGVQb2ludEF0KGkpO1xyXG4gICAgICAgIGlmIChjb2RlID49IDB4REMwMCAmJiBjb2RlIDw9IDB4REZGRikgY29udGludWU7IC8vIGxvdyBzdXJyb2dhdGUsIGdldCB0aGUgZnVsbCBjb2RlIGF0IG5leHQgaXRlcmF0aW9uXHJcbiAgICAgICAgaWYgKChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHx8XHJcbiAgICAgICAgICAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwKSB8fFxyXG4gICAgICAgICAgKGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMjIpKSB7XHJcbiAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcclxuICAgICAgICAgIGNhc2UgNTc6XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29kZSA9IDQ4O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgOTA6XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29kZSA9IDY1O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgMTIyOlxyXG4gICAgICAgICAgICBjYXJyeSA9IHRydWU7XHJcbiAgICAgICAgICAgIGNvZGUgPSA5NztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBjYXJyeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb2RlICs9IDE7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmIChmaXJzdF9hbHBoYW51bV9jaGFyX2luZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gMjU1IHx8IGNvZGUgPT09IDB4MTBGRkZGKSB7XHJcbiAgICAgICAgICAgICAgY2FycnkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIGNvZGUgPSAwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGNhcnJ5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IDB4RDdGRikgY29kZSA9IDB4RTAwMDtcclxuICAgICAgICAgICAgICBlbHNlIGNvZGUgKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2FycnkgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgaSkgKyBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlKSArIHJlc3VsdC5zbGljZShpICsgMSk7XHJcbiAgICAgICAgaWYgKGNhcnJ5ICYmIChpID09PSAwIHx8IGkgPT09IGZpcnN0X2FscGhhbnVtX2NoYXJfaW5kZXgpKSB7XHJcbiAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcclxuICAgICAgICAgIGNhc2UgNjU6XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSA5NzpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBjb2RlICs9IDE7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlKSArIHJlc3VsdDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBpKSArIFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGUpICsgcmVzdWx0LnNsaWNlKGkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY2FycnkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFjYXJyeSkgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdC4kZm9yY2VfZW5jb2Rpbmcoc2VsZi5lbmNvZGluZyk7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gICMgbmV4dCEgLSBub3Qgc3VwcG9ydGVkLCBtdXRhdGVzIHN0cmluZ1xyXG5cclxuICBkZWYgb2N0XHJcbiAgICAleHtcclxuICAgICAgdmFyIHJlc3VsdCxcclxuICAgICAgICAgIHN0cmluZyA9IHNlbGYsXHJcbiAgICAgICAgICByYWRpeCA9IDg7XHJcblxyXG4gICAgICBpZiAoL15cXHMqXy8udGVzdChzdHJpbmcpKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9eKFxccypbKy1dPykoMFtib2R4XT8pKC4rKSQvaSwgZnVuY3Rpb24gKG9yaWdpbmFsLCBoZWFkLCBmbGFnLCB0YWlsKSB7XHJcbiAgICAgICAgc3dpdGNoICh0YWlsLmNoYXJBdCgwKSkge1xyXG4gICAgICAgIGNhc2UgJysnOlxyXG4gICAgICAgIGNhc2UgJy0nOlxyXG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xyXG4gICAgICAgIGNhc2UgJzAnOlxyXG4gICAgICAgICAgaWYgKHRhaWwuY2hhckF0KDEpID09PSAneCcgJiYgZmxhZyA9PT0gJzB4Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAoZmxhZykge1xyXG4gICAgICAgIGNhc2UgJzBiJzpcclxuICAgICAgICAgIHJhZGl4ID0gMjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJzAnOlxyXG4gICAgICAgIGNhc2UgJzBvJzpcclxuICAgICAgICAgIHJhZGl4ID0gODtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJzBkJzpcclxuICAgICAgICAgIHJhZGl4ID0gMTA7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICcweCc6XHJcbiAgICAgICAgICByYWRpeCA9IDE2O1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXN1bHQgPSBwYXJzZUludChzdHJpbmcucmVwbGFjZSgvXyg/IV8pL2csICcnKSwgcmFkaXgpO1xyXG4gICAgICByZXR1cm4gaXNOYU4ocmVzdWx0KSA/IDAgOiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBvcmRcclxuICAgIGBzZWxmLmNvZGVQb2ludEF0KDApYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgcGFydGl0aW9uKHNlcClcclxuICAgICV4e1xyXG4gICAgICB2YXIgaSwgbTtcclxuXHJcbiAgICAgIGlmIChzZXAuJCRpc19yZWdleHApIHtcclxuICAgICAgICBtID0gc2VwLmV4ZWMoc2VsZik7XHJcbiAgICAgICAgaWYgKG0gPT09IG51bGwpIHtcclxuICAgICAgICAgIGkgPSAtMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgI3s6Ok1hdGNoRGF0YS5uZXcgYHNlcGAsIGBtYH07XHJcbiAgICAgICAgICBzZXAgPSBtWzBdO1xyXG4gICAgICAgICAgaSA9IG0uaW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNlcCA9ICRjb2VyY2VfdG8oc2VwLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xyXG4gICAgICAgIGlmIChzdGFydHNfd2l0aF9sb3dfc3Vycm9nYXRlKHNlcCkgfHwgZW5kc193aXRoX2hpZ2hfc3Vycm9nYXRlKHNlcCkpIGkgPSAtMTtcclxuICAgICAgICBlbHNlIGkgPSBzZWxmLmluZGV4T2Yoc2VwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGkgPT09IC0xKSByZXR1cm4gW3NlbGYsICcnLiRmb3JjZV9lbmNvZGluZyhzZXAuZW5jb2RpbmcpLCAnJy4kZm9yY2VfZW5jb2Rpbmcoc2VsZi5lbmNvZGluZyldO1xyXG5cclxuICAgICAgcmV0dXJuIFtcclxuICAgICAgICBzZWxmLnNsaWNlKDAsIGkpLiRmb3JjZV9lbmNvZGluZyhzZWxmLmVuY29kaW5nKSxcclxuICAgICAgICBzZWxmLnNsaWNlKGksIGkgKyBzZXAubGVuZ3RoKS4kZm9yY2VfZW5jb2Rpbmcoc2VwLmVuY29kaW5nKSxcclxuICAgICAgICBzZWxmLnNsaWNlKGkgKyBzZXAubGVuZ3RoKS4kZm9yY2VfZW5jb2Rpbmcoc2VsZi5lbmNvZGluZylcclxuICAgICAgXTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgIyBwcmVwZW5kIC0gbm90IHN1cHBvcnRlZCwgbXV0YXRlcyBzdHJpbmdcclxuICAjIHJlcGxhY2UgLSBub3Qgc3VwcG9ydGVkLCBtdXRhdGVzIHN0cmluZ1xyXG5cclxuICBkZWYgcmV2ZXJzZVxyXG4gICAgJXh7XHJcbiAgICAgIGxldCByZXMgPSAnJztcclxuICAgICAgZm9yIChjb25zdCBjIG9mIHNlbGYpIHsgcmVzID0gYyArIHJlczsgfVxyXG4gICAgICByZXR1cm4gcmVzLiRmb3JjZV9lbmNvZGluZyhzZWxmLmVuY29kaW5nKTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgIyByZXZlcnNlISAtIG5vdCBzdXBwb3J0ZWQsIG11dGF0ZXMgc3RyaW5nXHJcblxyXG4gIGRlZiByaW5kZXgoc2VhcmNoLCBvZmZzZXQgPSB1bmRlZmluZWQpXHJcbiAgICAleHtcclxuICAgICAgbGV0IGluZGV4LCBtLCByLCBfbTtcclxuXHJcbiAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIG9mZnNldCA9IEluZmluaXR5OyAvLyB0byBhdm9pZCBjYWxsaW5nICNzaXplIGhlcmUsIHRvIGNhbGwgaXQgb25seSB3aGVuIG5lY2Vzc2FyeSBsYXRlciBvblxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG9mZnNldCA9ICRjb2VyY2VfdG8ob2Zmc2V0LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcclxuICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xyXG4gICAgICAgICAgb2Zmc2V0ICs9IHNlbGYuJGxlbmd0aCgpO1xyXG4gICAgICAgICAgaWYgKG9mZnNldCA8IDApIHJldHVybiBuaWw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2VhcmNoLiQkaXNfcmVnZXhwKSB7XHJcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gSW5maW5pdHkpIG9mZnNldCA9IHNlbGYuJGxlbmd0aCgpO1xyXG4gICAgICAgIG0gPSBudWxsO1xyXG4gICAgICAgIHIgPSAkZ2xvYmFsX3JlZ2V4cChzZWFyY2gpO1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICBfbSA9IHIuZXhlYyhzZWxmKTtcclxuICAgICAgICAgIGlmIChfbSA9PT0gbnVsbCB8fCBfbS5pbmRleCA+IG9mZnNldCkgYnJlYWs7XHJcbiAgICAgICAgICBtID0gX207XHJcbiAgICAgICAgICByLmxhc3RJbmRleCA9IG0uaW5kZXggKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgI3skfiA9IG5pbH1cclxuICAgICAgICAgIHJldHVybiBuaWw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICN7OjpNYXRjaERhdGEubmV3IGByYCwgYG1gfTtcclxuICAgICAgICAgIHJldHVybiBtLmluZGV4O1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzZWFyY2ggPSAkY29lcmNlX3RvKHNlYXJjaCwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcclxuICAgICAgICBpZiAoc2VhcmNoLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgbGV0IHN0cl9sID0gc2VsZi4kbGVuZ3RoKCk7XHJcbiAgICAgICAgICBpZiAob2Zmc2V0ID4gc3RyX2wpIGluZGV4ID0gc3RyX2w7XHJcbiAgICAgICAgICBlbHNlIGluZGV4ID0gb2Zmc2V0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBsZXQgc3RyID0gc2VsZixcclxuICAgICAgICAgICAgICBzZWFyY2hfbCA9IHNlYXJjaC4kbGVuZ3RoKCk7XHJcbiAgICAgICAgICBpZiAob2Zmc2V0ICE9PSBJbmZpbml0eSAmJiBvZmZzZXQgKyBzZWFyY2hfbCA8IHNlbGYuJGxlbmd0aCgpKSB7XHJcbiAgICAgICAgICAgIHN0ciA9IHNlbGZbXCIkW11cIl0oMCwgb2Zmc2V0ICsgc2VhcmNoX2wpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaW5kZXggPSBmaW5kX2luZGV4X29mKHN0ciwgc2VhcmNoLCBzZWFyY2hfbCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gaW5kZXggPT09IC0xID8gbmlsIDogaW5kZXg7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiByanVzdCh3aWR0aCwgcGFkc3RyID0gJyAnKVxyXG4gICAgd2lkdGggID0gYCRjb2VyY2VfdG8oI3t3aWR0aH0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxyXG4gICAgcGFkc3RyID0gYCRjb2VyY2VfdG8oI3twYWRzdHJ9LCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpYC50b19zXHJcblxyXG4gICAgaWYgcGFkc3RyLmVtcHR5P1xyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd6ZXJvIHdpZHRoIHBhZGRpbmcnXHJcbiAgICBlbmRcclxuXHJcbiAgICBsID0gc2l6ZVxyXG5cclxuICAgIHJldHVybiBzZWxmIGlmIHdpZHRoIDw9IGxcclxuXHJcbiAgICBgKHBhZGRpbmcocGFkc3RyLCB3aWR0aCAtIGwpICsgc2VsZikuJGZvcmNlX2VuY29kaW5nKHNlbGYuZW5jb2RpbmcpYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgcnBhcnRpdGlvbihzZXApXHJcbiAgICAleHtcclxuICAgICAgdmFyIGksIG0sIHIsIF9tO1xyXG5cclxuICAgICAgaWYgKHNlcC4kJGlzX3JlZ2V4cCkge1xyXG4gICAgICAgIG0gPSBudWxsO1xyXG4gICAgICAgIHIgPSAkZ2xvYmFsX3JlZ2V4cChzZXApO1xyXG5cclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgX20gPSByLmV4ZWMoc2VsZik7XHJcbiAgICAgICAgICBpZiAoX20gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBtID0gX207XHJcbiAgICAgICAgICByLmxhc3RJbmRleCA9IG0uaW5kZXggKyAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG0gPT09IG51bGwpIHtcclxuICAgICAgICAgIGkgPSAtMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgI3s6Ok1hdGNoRGF0YS5uZXcgYHJgLCBgbWB9O1xyXG4gICAgICAgICAgc2VwID0gbVswXTtcclxuICAgICAgICAgIGkgPSBtLmluZGV4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2VwID0gJGNvZXJjZV90byhzZXAsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XHJcbiAgICAgICAgaWYgKHN0YXJ0c193aXRoX2xvd19zdXJyb2dhdGUoc2VwKSB8fCBlbmRzX3dpdGhfaGlnaF9zdXJyb2dhdGUoc2VwKSkgaSA9IC0xO1xyXG4gICAgICAgIGVsc2UgaSA9IHNlbGYubGFzdEluZGV4T2Yoc2VwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGkgPT09IC0xKSByZXR1cm4gWycnLiRmb3JjZV9lbmNvZGluZyhzZWxmLmVuY29kaW5nKSwgJycuJGZvcmNlX2VuY29kaW5nKHNlcC5lbmNvZGluZyksIHNlbGZdO1xyXG5cclxuICAgICAgcmV0dXJuIFtcclxuICAgICAgICBzZWxmLnNsaWNlKDAsIGkpLiRmb3JjZV9lbmNvZGluZyhzZWxmLmVuY29kaW5nKSxcclxuICAgICAgICBzZWxmLnNsaWNlKGksIGkgKyBzZXAubGVuZ3RoKS4kZm9yY2VfZW5jb2Rpbmcoc2VwLmVuY29kaW5nKSxcclxuICAgICAgICBzZWxmLnNsaWNlKGkgKyBzZXAubGVuZ3RoKS4kZm9yY2VfZW5jb2Rpbmcoc2VsZi5lbmNvZGluZylcclxuICAgICAgXTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHJzdHJpcFxyXG4gICAgYHNlbGYucmVwbGFjZSgvW1xceDAwXFx4MDlcXHgwYS1cXHgwZFxceDIwXSokLywgJycpLiRmb3JjZV9lbmNvZGluZyhzZWxmLmVuY29kaW5nKWBcclxuICBlbmRcclxuXHJcbiAgIyByc3RyaXAhIC0gbm90IHN1cHBvcnRlZCwgbXV0YXRlcyBzdHJpbmdcclxuXHJcbiAgZGVmIHNjYW4ocGF0dGVybiwgbm9fbWF0Y2hkYXRhOiBmYWxzZSwgJmJsb2NrKVxyXG4gICAgJXh7XHJcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcclxuICAgICAgICAgIG1hdGNoX2RhdGEgPSBuaWwsXHJcbiAgICAgICAgICBtYXRjaCwgbWF0Y2hfbywgY2FwdHVyZXM7XHJcblxyXG4gICAgICBpZiAocGF0dGVybi4kJGlzX3JlZ2V4cCkge1xyXG4gICAgICAgIHBhdHRlcm4gPSAkZ2xvYmFsX3JlZ2V4cChwYXR0ZXJuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwYXR0ZXJuID0gJGNvZXJjZV90byhwYXR0ZXJuLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xyXG4gICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4ucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2d1LCAnXFxcXCQmJyksICdnbXUnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgd2hpbGUgKChtYXRjaCA9IHBhdHRlcm4uZXhlYyhzZWxmKSkgIT0gbnVsbCkge1xyXG4gICAgICAgIG1hdGNoX2RhdGEgPSAjezo6TWF0Y2hEYXRhLm5ldyBgcGF0dGVybmAsIGBtYXRjaGAsIG5vX21hdGNoZGF0YTogbm9fbWF0Y2hkYXRhfTtcclxuICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICBtYXRjaF9vID0gbWF0Y2hbMF0uJGZvcmNlX2VuY29kaW5nKHNlbGYuZW5jb2RpbmcpO1xyXG4gICAgICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHJlc3VsdC5wdXNoKG1hdGNoX28pO1xyXG4gICAgICAgICAgZWxzZSBPcGFsLnlpZWxkMShibG9jaywgbWF0Y2hfbyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNhcHR1cmVzID0gI3tgbWF0Y2hfZGF0YWAuY2FwdHVyZXMubWFwIHsgfGN8IGMmLmZvcmNlX2VuY29kaW5nKGVuY29kaW5nKSB9fTtcclxuICAgICAgICAgIGlmIChibG9jayA9PT0gbmlsKSByZXN1bHQucHVzaChjYXB0dXJlcyk7XHJcbiAgICAgICAgICBlbHNlIE9wYWwueWllbGQxKGJsb2NrLCBjYXB0dXJlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXR0ZXJuLmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHtcclxuICAgICAgICAgIHBhdHRlcm4ubGFzdEluZGV4ICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIW5vX21hdGNoZGF0YSkgI3skfiA9IGBtYXRjaF9kYXRhYH07XHJcblxyXG4gICAgICByZXR1cm4gKGJsb2NrICE9PSBuaWwgPyBzZWxmIDogcmVzdWx0KTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHNjcnViKHJlcGxhY2VtZW50X3N0cmluZyA9IG5pbCwgJmJsb2NrKVxyXG4gICAgaWYgcmVwbGFjZW1lbnRfc3RyaW5nLmlzX2E/KFN0cmluZylcclxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3JlcGxhY2VtZW50IHN0cmluZyBoYXMgaW52YWxpZCBlbmNvZGluZycgdW5sZXNzIHJlcGxhY2VtZW50X3N0cmluZy52YWxpZF9lbmNvZGluZz9cclxuICAgICAgcmVwbGFjZW1lbnRfc3RyaW5nID0gYHJlcGxhY2VtZW50X3N0cmluZy50b1N0cmluZygpYFxyXG4gICAgZWxzaWYgIXJlcGxhY2VtZW50X3N0cmluZy5uaWw/XHJcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgJ3JlcGxhY2VtZW50IG11c3QgYmUgYSBTdHJpbmcnXHJcbiAgICBlbmRcclxuXHJcbiAgICBlbmNvZGluZy5zY3J1YihzZWxmLCByZXBsYWNlbWVudF9zdHJpbmcpXHJcbiAgZW5kXHJcblxyXG4gICMgc2NydWIhIC0gbm90IHN1cHBvcnRlZCwgbXV0YXRlcyBzdHJpbmdcclxuICAjIHNldGJ5dGUgLSBub3Qgc3VwcG9ydGVkLCBtdXRhdGVzIHN0cmluZ1xyXG4gICMgc2hlbGxlc2NhcGUgLSBkZWZpbmVkIGluIHN0ZGxpYi9zaGVsbGVzY2FwZVxyXG4gICMgc2hlbGxzcGxpdCAtIGRlZmluZWQgaW4gc3RkbGliL3NoZWxsZXNjYXBlXHJcblxyXG4gICMgV2UgcmVkZWZpbmUgdGhpcyBtZXRob2Qgb24gU3RyaW5nLCBhcyBrZXJuZWwucmIgaXMgaW4gc3RyaWN0IG1vZGVcclxuICAjIHNvIHRoYXQgdGhpbmdzIGxpa2UgQm9vbGVhbiBkb24ndCBnZXQgYm94ZWQuIEZvciBTdHJpbmcgdGhvdWdoIC1cclxuICAjIHdlIGVpdGhlciBuZWVkIHRvIGJveCBpdCB0byBkZWZpbmUgcHJvcGVydGllcyBvbiBpdCwgb3IgcnVuIGl0IGluXHJcbiAgIyBub24tc3RyaWN0IG1vZGUuIFRoaXMgaXMgYSBtZXNzIGFuZCB3ZSBuZWVkIHRvIGNvbWUgYmFjayB0byBpdFxyXG4gICMgYXQgYSBsYXRlciB0aW1lLlxyXG4gIGRlZiBzaW5nbGV0b25fY2xhc3NcclxuICAgIGBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Moc2VsZilgXHJcbiAgZW5kXHJcblxyXG4gIGFsaWFzIHNpemUgbGVuZ3RoXHJcblxyXG4gIGFsaWFzIHNsaWNlIFtdXHJcblxyXG4gICMgc2xpY2UhIC0gbm90IHN1cHBvcnRlZCwgbXV0YXRlcyBzdHJpbmdcclxuXHJcbiAgZGVmIHNwbGl0KHBhdHRlcm4gPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCAmYmxvY2spXHJcbiAgICAleHtcclxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAwKSByZXR1cm4gKGJsb2NrICYmIGJsb2NrICE9PSBuaWwpID8gc2VsZiA6IFtdO1xyXG5cclxuICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBsaW1pdCA9IDA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGltaXQgPSAjezo6T3BhbC5jb2VyY2VfdG8hKGxpbWl0LCA6OkludGVnZXIsIDp0b19pbnQpfTtcclxuICAgICAgICBpZiAobGltaXQgPT09IDEpIHtcclxuICAgICAgICAgIGlmIChibG9jayAmJiBibG9jayAhPT0gbmlsKSB7XHJcbiAgICAgICAgICAgICN7eWllbGQgc2VsZn07XHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIFtzZWxmXVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGltaXQgPiBNQVhfU1RSX0xFTikgI3tyYWlzZSBSYW5nZUVycm9yLCAnbGltaXQgdG9vIGxhcmdlJ307XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQgfHwgcGF0dGVybiA9PT0gbmlsKSB7XHJcbiAgICAgICAgcGF0dGVybiA9ICN7JDsgfHwgJyAnfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHJlc3VsdCxcclxuICAgICAgICAgIHN0cmluZyA9IHNlbGYudG9TdHJpbmcoKSxcclxuICAgICAgICAgIGluZGV4ID0gMCxcclxuICAgICAgICAgIG1hdGNoLFxyXG4gICAgICAgICAgbWF0Y2hfY291bnQgPSAwLFxyXG4gICAgICAgICAgdmFsaWRfcmVzdWx0X2xlbmd0aCA9IDAsXHJcbiAgICAgICAgICBpLCBtYXg7XHJcblxyXG4gICAgICBpZiAocGF0dGVybi4kJGlzX3JlZ2V4cCkge1xyXG4gICAgICAgIHBhdHRlcm4gPSAkZ2xvYmFsX3JlZ2V4cChwYXR0ZXJuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwYXR0ZXJuID0gJGNvZXJjZV90byhwYXR0ZXJuLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xyXG5cclxuICAgICAgICBpZiAoIXBhdHRlcm5bXCIkdmFsaWRfZW5jb2Rpbmc/XCJdKCkpICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ3BhdHRlcm4gaGFzIGludmFsaWQgZW5jb2RpbmcnfTtcclxuICAgICAgICBpZiAocGF0dGVybiA9PT0gJyAnKSB7XHJcbiAgICAgICAgICBwYXR0ZXJuID0gL1tcXGZcXG5cXHJcXHRcXHZcXHUwMDIwXFx1MDBhMF0rL2dtdTtcclxuICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9eW1xcZlxcblxcclxcdFxcdlxcdTAwMjBcXHUwMGEwXSsvdSwgJycpO1xyXG4gICAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcclxuICAgICAgICB9IGVsc2UgaWYgKHBhdHRlcm4ubGVuZ3RoID4gMCAmJiAoc3RhcnRzX3dpdGhfbG93X3N1cnJvZ2F0ZShwYXR0ZXJuKSB8fCBlbmRzX3dpdGhfaGlnaF9zdXJyb2dhdGUocGF0dGVybikpKSB7XHJcbiAgICAgICAgICByZXN1bHQgPSBbc3RyaW5nXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgcmVzdWx0ID0gKHBhdHRlcm4ubGVuZ3RoID09PSAwKSA/IFsuLi5zdHJpbmddIDogc3RyaW5nLnNwbGl0KHBhdHRlcm4pO1xyXG5cclxuICAgICAgICBpZiAoIShyZXN1bHQubGVuZ3RoID09PSAxICYmIHJlc3VsdFswXSA9PT0gc3RyaW5nKSkge1xyXG4gICAgICAgICAgd2hpbGUgKChpID0gcmVzdWx0LmluZGV4T2YodW5kZWZpbmVkKSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGxpbWl0ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHdoaWxlIChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID09PSAnJykge1xyXG4gICAgICAgICAgICAgIHJlc3VsdC5wb3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCFwYXR0ZXJuLiQkaXNfcmVnZXhwKSB7XHJcbiAgICAgICAgICAgICAgcGF0dGVybiA9IE9wYWwuZXNjYXBlX3JlZ2V4cChwYXR0ZXJuKTtcclxuICAgICAgICAgICAgICBsZXQgcGF0dGVybl9mbGFncyA9ICR0cmFuc2Zvcm1fcmVnZXhwKHBhdHRlcm4sICdnbXUnKTtcclxuICAgICAgICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuX2ZsYWdzWzBdLCBwYXR0ZXJuX2ZsYWdzWzFdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc3RyaW5nKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChsaW1pdCA8IDApIHtcclxuICAgICAgICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwgJiYgbWF0Y2hbMF0gPT09ICcnICYmIHBhdHRlcm4uc291cmNlLmluZGV4T2YoJyg/PScpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbWF4ID0gbWF0Y2gubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlICBpZiAobWF0Y2ggIT09IG51bGwgJiYgbWF0Y2hbMF0gPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgdmFsaWRfcmVzdWx0X2xlbmd0aCA9IChtYXRjaC5sZW5ndGggLSAxKSAqIChsaW1pdCAtIDEpICsgbGltaXRcclxuICAgICAgICAgICAgICByZXN1bHQuc3BsaWNlKHZhbGlkX3Jlc3VsdF9sZW5ndGggLSAxLCByZXN1bHQubGVuZ3RoIC0gMSwgcmVzdWx0LnNsaWNlKHZhbGlkX3Jlc3VsdF9sZW5ndGggLSAxKS5qb2luKCcnKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGltaXQgPCByZXN1bHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgd2hpbGUgKG1hdGNoICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaF9jb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBwYXR0ZXJuLmxhc3RJbmRleDtcclxuICAgICAgICAgICAgICAgIHZhbGlkX3Jlc3VsdF9sZW5ndGggKz0gbWF0Y2gubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hfY291bnQgKyAxID09PSBsaW1pdCkge1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1hdGNoID0gcGF0dGVybi5leGVjKHN0cmluZyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJlc3VsdC5zcGxpY2UodmFsaWRfcmVzdWx0X2xlbmd0aCwgcmVzdWx0Lmxlbmd0aCAtIDEsIHN0cmluZy5zbGljZShpbmRleCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5tYXAoKHN1YnN0cik9PnN1YnN0ci4kZm9yY2VfZW5jb2Rpbmcoc2VsZi5lbmNvZGluZykpO1xyXG4gICAgICBpZiAoYmxvY2sgJiYgYmxvY2sgIT09IG5pbCkge1xyXG4gICAgICAgIGZvciAoY29uc3Qgc3Vic3RyIG9mIHJlc3VsdCkgeyN7eWllbGQgYHN1YnN0cmB9fVxyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzcXVlZXplKCpzZXRzKVxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChzZXRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBzZWxmLnJlcGxhY2UoLyguKVxcMSsvZywgJyQxJykuJGZvcmNlX2VuY29kaW5nKHNlbGYuZW5jb2RpbmcpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBjaGFyX2NsYXNzID0gY2hhcl9jbGFzc19mcm9tX2NoYXJfc2V0cyhzZXRzKTtcclxuICAgICAgaWYgKGNoYXJfY2xhc3MgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgICAgfVxyXG4gICAgICBsZXQgcGF0dGVybl9mbGFncyA9ICR0cmFuc2Zvcm1fcmVnZXhwKCcoJyArIGNoYXJfY2xhc3MgKyAnKVxcXFwxKycsICdndScpO1xyXG4gICAgICByZXR1cm4gc2VsZi5yZXBsYWNlKG5ldyBSZWdFeHAocGF0dGVybl9mbGFnc1swXSwgcGF0dGVybl9mbGFnc1sxXSksICckMScpXHJcbiAgICAgICAgICAgICAgICAgLiRmb3JjZV9lbmNvZGluZyhzZWxmLmVuY29kaW5nKTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgIyBzcXVlZXplISAtIG5vdCBzdXBwb3J0ZWQsIG11dGF0ZXMgc3RyaW5nXHJcblxyXG4gIGRlZiBzdGFydF93aXRoPygqcHJlZml4ZXMpXHJcbiAgICAleHtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHByZWZpeGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHByZWZpeGVzW2ldLiQkaXNfcmVnZXhwKSB7XHJcbiAgICAgICAgICB2YXIgcmVnZXhwID0gcHJlZml4ZXNbaV07XHJcbiAgICAgICAgICB2YXIgbWF0Y2ggPSByZWdleHAuZXhlYyhzZWxmKTtcclxuXHJcbiAgICAgICAgICBpZiAobWF0Y2ggIT0gbnVsbCAmJiBtYXRjaC5pbmRleCA9PT0gMCkge1xyXG4gICAgICAgICAgICAjeyR+ID0gOjpNYXRjaERhdGEubmV3KGByZWdleHBgLCBgbWF0Y2hgKX07XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgI3skfiA9IG5pbH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbGV0IHByZWZpeCA9ICRjb2VyY2VfdG8ocHJlZml4ZXNbaV0sICN7OjpTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcclxuICAgICAgICAgIC8vIHRoaXMgaXMgY29ycmVjdCBiZWhhdmlvciBzaW5jZSBydWJ5IDMuM1xyXG4gICAgICAgICAgLy8gc3BlY3Mgd29yayB3aGVuIFJVQllfVkVSU0lPTiBpcyBzZXQgdG8gYXQgbGVhc3QgMy4zXHJcbiAgICAgICAgICBpZiAoc3RhcnRzX3dpdGgoc2VsZiwgcHJlZml4KSB8fCBwcmVmaXgubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHN0cmlwXHJcbiAgICBgc2VsZi5yZXBsYWNlKC9eW1xceDAwXFx4MDlcXHgwYS1cXHgwZFxceDIwXSp8W1xceDAwXFx4MDlcXHgwYS1cXHgwZFxceDIwXSokL2csICcnKS4kZm9yY2VfZW5jb2Rpbmcoc2VsZi5lbmNvZGluZylgXHJcbiAgZW5kXHJcblxyXG4gICMgc3RyaXAhIC0gbm90IHN1cHBvcnRlZCwgbXV0YXRlcyBzdHJpbmdcclxuXHJcbiAgZGVmIHN1YihwYXR0ZXJuLCByZXBsYWNlbWVudCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxyXG4gICAgJXh7XHJcbiAgICAgIGlmICghcGF0dGVybi4kJGlzX3JlZ2V4cCkge1xyXG4gICAgICAgIHBhdHRlcm4gPSAkY29lcmNlX3RvKHBhdHRlcm4sICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XHJcbiAgICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAocGF0dGVybi5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZ3UsICdcXFxcJCYnKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciByZXN1bHQsIG1hdGNoID0gcGF0dGVybi5leGVjKHNlbGYpO1xyXG5cclxuICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XHJcbiAgICAgICAgI3skfiA9IG5pbH1cclxuICAgICAgICByZXN1bHQgPSBzZWxmLnRvU3RyaW5nKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgI3s6Ok1hdGNoRGF0YS5uZXcgYHBhdHRlcm5gLCBgbWF0Y2hgfVxyXG5cclxuICAgICAgICBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xyXG5cclxuICAgICAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XHJcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMSBmb3IgMiknfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyBibG9jayhtYXRjaFswXSkgKyBzZWxmLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmIChyZXBsYWNlbWVudC4kJGlzX2hhc2gpIHtcclxuXHJcbiAgICAgICAgICByZXN1bHQgPSBzZWxmLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICN7YHJlcGxhY2VtZW50YFtgbWF0Y2hbMF1gXS50b19zfSArIHNlbGYuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIHJlcGxhY2VtZW50ID0gJGNvZXJjZV90byhyZXBsYWNlbWVudCwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcclxuXHJcbiAgICAgICAgICByZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50LnJlcGxhY2UoLyhbXFxcXF0rKShbMC05KyZgJ10pL2csIGZ1bmN0aW9uIChvcmlnaW5hbCwgc2xhc2hlcywgY29tbWFuZCkge1xyXG4gICAgICAgICAgICBpZiAoc2xhc2hlcy5sZW5ndGggJSAyID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xyXG4gICAgICAgICAgICBjYXNlIFwiK1wiOlxyXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSBtYXRjaC5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hbaV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIG1hdGNoW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIGNhc2UgXCImXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgbWF0Y2hbMF07XHJcbiAgICAgICAgICAgIGNhc2UgXCJgXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCk7XHJcbiAgICAgICAgICAgIGNhc2UgXCInXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgc2VsZi5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6ICByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIChtYXRjaFtjb21tYW5kXSB8fCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pLnJlcGxhY2UoL1xcXFxcXFxcL2csICdcXFxcJyk7XHJcblxyXG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyByZXBsYWNlbWVudCArIHNlbGYuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgIyBzdWIhIC0gbm90IHN1cHBvcnRlZCwgbXV0YXRlcyBzdHJpbmdcclxuXHJcbiAgYWxpYXMgc3VjYyBuZXh0XHJcblxyXG4gICMgc3VjYyEgLSBub3Qgc3VwcG9ydGVkLCBtdXRhdGVzIHN0cmluZ1xyXG5cclxuICBkZWYgc3VtKG4gPSAxNilcclxuICAgICV4e1xyXG4gICAgICBuID0gJGNvZXJjZV90byhuLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcclxuXHJcbiAgICAgIHZhciByZXN1bHQgPSAwLFxyXG4gICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGgsXHJcbiAgICAgICAgICBpID0gMDtcclxuXHJcbiAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICByZXN1bHQgKz0gc2VsZi5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobiA8PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdCAmIChNYXRoLnBvdygyLCBuKSAtIDEpO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc3dhcGNhc2UoKm9wdGlvbnMpXHJcbiAgICAleHtcclxuICAgICAgaWYgKGNhc2Vfb3B0aW9uc19oYXZlX2FzY2lpKG9wdGlvbnMpKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGYucmVwbGFjZSgvKFthLXpdKyl8KFtBLVpdKykvZywgZnVuY3Rpb24oJDAsJDEsJDIpIHtcclxuICAgICAgICAgIHJldHVybiAkMSA/ICQwLnRvVXBwZXJDYXNlKCkgOiAkMC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBzdHIgPSBcIlwiLCBjdTtcclxuICAgICAgZm9yIChjb25zdCBjIG9mIHNlbGYpIHtcclxuICAgICAgICAgIGN1ID0gYy50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgICAgc3RyICs9IChjdSA9PSBjKSA/IGMudG9Mb3dlckNhc2UoKSA6IGN1O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzdHIuJGZvcmNlX2VuY29kaW5nKHNlbGYuZW5jb2RpbmcpO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICAjIHN3YXBjYXNlISAtIG5vdCBzdXBwb3J0ZWQsIG11dGF0ZXMgc3RyaW5nXHJcblxyXG4gICMgdG9fYyAtIGRlZmluZWQgaW4gY29yZWxpYi9jb21wbGV4XHJcblxyXG4gIGRlZiB0b19mXHJcbiAgICAleHtcclxuICAgICAgaWYgKHNlbGYuY2hhckF0KDApID09PSAnXycpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlRmxvYXQoc2VsZi5yZXBsYWNlKC9fL2csICcnKSk7XHJcblxyXG4gICAgICBpZiAoaXNOYU4ocmVzdWx0KSB8fCByZXN1bHQgPT0gSW5maW5pdHkgfHwgcmVzdWx0ID09IC1JbmZpbml0eSkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHRvX2koYmFzZSA9IDEwKVxyXG4gICAgJXh7XHJcbiAgICAgIGxldCByZXN1bHQsXHJcbiAgICAgICAgICBzdHJpbmcgPSBzZWxmLnRvTG93ZXJDYXNlKCksXHJcbiAgICAgICAgICByYWRpeCA9ICRjb2VyY2VfdG8oYmFzZSwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XHJcblxyXG4gICAgICBpZiAocmFkaXggPT09IDEgfHwgcmFkaXggPCAwIHx8IHJhZGl4ID4gMzYpIHtcclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhZGl4ICN7YHJhZGl4YH1cIn1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKC9eXFxzKl8vLnRlc3Qoc3RyaW5nKSkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXihcXHMqWystXT8pKDBbYm9keF0/KSguKykkLywgZnVuY3Rpb24gKG9yaWdpbmFsLCBoZWFkLCBmbGFnLCB0YWlsKSB7XHJcbiAgICAgICAgc3dpdGNoICh0YWlsLmNoYXJBdCgwKSkge1xyXG4gICAgICAgIGNhc2UgJysnOlxyXG4gICAgICAgIGNhc2UgJy0nOlxyXG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xyXG4gICAgICAgIGNhc2UgJzAnOlxyXG4gICAgICAgICAgaWYgKHRhaWwuY2hhckF0KDEpID09PSAneCcgJiYgZmxhZyA9PT0gJzB4JyAmJiAocmFkaXggPT09IDAgfHwgcmFkaXggPT09IDE2KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAoZmxhZykge1xyXG4gICAgICAgIGNhc2UgJzBiJzpcclxuICAgICAgICAgIGlmIChyYWRpeCA9PT0gMCB8fCByYWRpeCA9PT0gMikge1xyXG4gICAgICAgICAgICByYWRpeCA9IDI7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJzAnOlxyXG4gICAgICAgIGNhc2UgJzBvJzpcclxuICAgICAgICAgIGlmIChyYWRpeCA9PT0gMCB8fCByYWRpeCA9PT0gOCkge1xyXG4gICAgICAgICAgICByYWRpeCA9IDg7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJzBkJzpcclxuICAgICAgICAgIGlmIChyYWRpeCA9PT0gMCB8fCByYWRpeCA9PT0gMTApIHtcclxuICAgICAgICAgICAgcmFkaXggPSAxMDtcclxuICAgICAgICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnMHgnOlxyXG4gICAgICAgICAgaWYgKHJhZGl4ID09PSAwIHx8IHJhZGl4ID09PSAxNikge1xyXG4gICAgICAgICAgICByYWRpeCA9IDE2O1xyXG4gICAgICAgICAgICByZXR1cm4gaGVhZCArIHRhaWw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmVzdWx0ID0gcGFyc2VJbnQoc3RyaW5nLnJlcGxhY2UoL18oPyFfKS9nLCAnJyksIHJhZGl4KTtcclxuICAgICAgcmV0dXJuIGlzTmFOKHJlc3VsdCkgPyAwIDogcmVzdWx0O1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgdG9fcHJvY1xyXG4gICAgbWV0aG9kX25hbWUgPSBgc2VsZi52YWx1ZU9mKClgXHJcbiAgICBqc2lkID0gYE9wYWwuanNpZChtZXRob2RfbmFtZSlgXHJcblxyXG4gICAgcHJvYyA9IDo6S2VybmVsLnByb2MgZG8gfCphcmdzLCAmYmxvY2t8XHJcbiAgICAgICV4e1xyXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdubyByZWNlaXZlciBnaXZlbid9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmVjdiA9IGFyZ3NbMF07XHJcblxyXG4gICAgICAgIGlmIChyZWN2ID09IG51bGwpIHJlY3YgPSBuaWw7XHJcblxyXG4gICAgICAgIHZhciBib2R5ID0gcmVjdltqc2lkXTtcclxuXHJcbiAgICAgICAgaWYgKCFib2R5KSB7XHJcbiAgICAgICAgICBib2R5ID0gcmVjdi4kbWV0aG9kX21pc3Npbmc7XHJcbiAgICAgICAgICBhcmdzWzBdID0gI3ttZXRob2RfbmFtZX07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGFyZ3MgPSBhcmdzLnNsaWNlKDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBibG9jayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgYm9keS4kJHAgPSBibG9jaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgcmV0dXJuIGJvZHkuY2FsbChyZWN2KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIGJvZHkuYXBwbHkocmVjdiwgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICBlbmRcclxuXHJcbiAgICBgcHJvYy4kJHNvdXJjZV9sb2NhdGlvbiA9IG5pbGBcclxuXHJcbiAgICBwcm9jXHJcbiAgZW5kXHJcblxyXG4gICMgdG9fciAtIGRlZmluZWQgaW4gY29yZWxpYi9yYXRpb25hbC9iYXNlXHJcblxyXG4gIGRlZiB0b19zXHJcbiAgICBgc2VsZi50b1N0cmluZygpYFxyXG4gIGVuZFxyXG5cclxuICBhbGlhcyB0b19zdHIgdG9fc1xyXG5cclxuICBhbGlhcyB0b19zeW0gaW50ZXJuXHJcblxyXG4gICV4e1xyXG4gICAgZnVuY3Rpb24gZXhwYW5kX2NoYXJzKGNoYXJzKSB7XHJcbiAgICAgIGxldCBsZW5ndGggPSBjaGFycy5sZW5ndGgsXHJcbiAgICAgICAgICBleHBhbmRlZCA9IFtdLFxyXG4gICAgICAgICAgY2gsIGxhc3RfY2gsIHN0YXJ0LCBlbmQsXHJcbiAgICAgICAgICBjLCBpID0gMCwgaW5fcmFuZ2U7XHJcbiAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjaCA9IGNoYXJzW2ldO1xyXG4gICAgICAgIGlmIChsYXN0X2NoID09IG51bGwpIHtcclxuICAgICAgICAgIGxhc3RfY2ggPSBjaDtcclxuICAgICAgICAgIGV4cGFuZGVkLnB1c2goY2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaCA9PSAnLScgJiYgIWluX3JhbmdlKSB7XHJcbiAgICAgICAgICBpZiAoaSA+IDAgJiYgaSA8IGxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgaW5fcmFuZ2UgPSB0cnVlO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZXhwYW5kZWQucHVzaCgnLScpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpbl9yYW5nZSkge1xyXG4gICAgICAgICAgc3RhcnQgPSBsYXN0X2NoLmNvZGVQb2ludEF0KDApO1xyXG4gICAgICAgICAgZW5kID0gY2guY29kZVBvaW50QXQoMCk7XHJcbiAgICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHtcclxuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYW5nZSBcXFwiI3tgU3RyaW5nLmZyb21Db2RlUG9pbnQoc3RhcnQpYH0tI3tgU3RyaW5nLmZyb21Db2RlUG9pbnQoZW5kKWB9XFxcIiBpbiBzdHJpbmcgdHJhbnNsaXRlcmF0aW9uXCJ9XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0ICE9PSBlbmQpIHtcclxuICAgICAgICAgICAgZm9yIChjID0gc3RhcnQgKyAxOyBjIDwgZW5kOyBjKyspIHtcclxuICAgICAgICAgICAgICBleHBhbmRlZC5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KGMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBleHBhbmRlZC5wdXNoKGNoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGluX3JhbmdlID0gbnVsbDtcclxuICAgICAgICAgIGxhc3RfY2ggPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBleHBhbmRlZC5wdXNoKGNoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGV4cGFuZGVkO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbW1vbl90cihzZWxmLCBmcm9tLCB0bywgaXNfdHJfcykge1xyXG4gICAgICBmcm9tID0gJGNvZXJjZV90byhmcm9tLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpLiR0b19zKCk7XHJcbiAgICAgIHRvID0gJGNvZXJjZV90byh0bywgI3s6OlN0cmluZ30sICd0b19zdHInKS4kdG9fcygpO1xyXG5cclxuICAgICAgaWYgKGZyb20ubGVuZ3RoID09IDApIHJldHVybiBzZWxmO1xyXG5cclxuICAgICAgdmFyIGksIGluX3JhbmdlLCBjLCBjaCwgc3RhcnQsIGVuZCwgbGVuZ3RoO1xyXG4gICAgICB2YXIgc3VicyA9IHt9O1xyXG4gICAgICB2YXIgZnJvbV9jaGFycyA9IFsuLi5mcm9tXTtcclxuICAgICAgdmFyIGZyb21fbGVuZ3RoID0gZnJvbV9jaGFycy5sZW5ndGg7XHJcbiAgICAgIHZhciB0b19jaGFycyA9IFsuLi50b107XHJcbiAgICAgIHZhciB0b19sZW5ndGggPSB0b19jaGFycy5sZW5ndGg7XHJcblxyXG4gICAgICB2YXIgaW52ZXJzZSA9IGZhbHNlO1xyXG4gICAgICB2YXIgZ2xvYmFsX3N1YiA9IG51bGw7XHJcbiAgICAgIGlmIChmcm9tX2NoYXJzWzBdID09ICdeJyAmJiBmcm9tX2NoYXJzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICBpbnZlcnNlID0gdHJ1ZTtcclxuICAgICAgICBmcm9tX2NoYXJzLnNoaWZ0KCk7XHJcbiAgICAgICAgZ2xvYmFsX3N1YiA9IHRvX2NoYXJzW3RvX2xlbmd0aCAtIDFdXHJcbiAgICAgICAgZnJvbV9sZW5ndGggLT0gMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnJvbV9jaGFycyA9IGV4cGFuZF9jaGFycyhmcm9tX2NoYXJzKTtcclxuICAgICAgZnJvbV9sZW5ndGggPSBmcm9tX2NoYXJzLmxlbmd0aDtcclxuXHJcbiAgICAgIGlmIChpbnZlcnNlKSB7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZyb21fbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIHN1YnNbZnJvbV9jaGFyc1tpXV0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAodG9fbGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgdG9fY2hhcnMgPSBleHBhbmRfY2hhcnModG9fY2hhcnMpO1xyXG4gICAgICAgICAgdG9fbGVuZ3RoID0gdG9fY2hhcnMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxlbmd0aF9kaWZmID0gZnJvbV9sZW5ndGggLSB0b19sZW5ndGg7XHJcbiAgICAgICAgaWYgKGxlbmd0aF9kaWZmID4gMCkge1xyXG4gICAgICAgICAgdmFyIHBhZF9jaGFyID0gKHRvX2xlbmd0aCA+IDAgPyB0b19jaGFyc1t0b19sZW5ndGggLSAxXSA6ICcnKTtcclxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGhfZGlmZjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRvX2NoYXJzLnB1c2gocGFkX2NoYXIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZyb21fbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIHN1YnNbZnJvbV9jaGFyc1tpXV0gPSB0b19jaGFyc1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBuZXdfc3RyID0gJycsXHJcbiAgICAgICAgICBzdWI7XHJcblxyXG4gICAgICBpZiAoaXNfdHJfcykge1xyXG4gICAgICAgIHZhciBsYXN0X3N1YnN0aXR1dGUgPSBudWxsXHJcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiBzZWxmKSB7XHJcbiAgICAgICAgICBzdWIgPSBzdWJzW2NoXVxyXG4gICAgICAgICAgaWYgKGludmVyc2UpIHtcclxuICAgICAgICAgICAgaWYgKHN1YiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGxhc3Rfc3Vic3RpdHV0ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdfc3RyICs9IGdsb2JhbF9zdWI7XHJcbiAgICAgICAgICAgICAgICBsYXN0X3N1YnN0aXR1dGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBuZXdfc3RyICs9IGNoO1xyXG4gICAgICAgICAgICAgIGxhc3Rfc3Vic3RpdHV0ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChzdWIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgIGlmIChsYXN0X3N1YnN0aXR1dGUgPT0gbnVsbCB8fCBsYXN0X3N1YnN0aXR1dGUgIT09IHN1Yikge1xyXG4gICAgICAgICAgICAgICAgbmV3X3N0ciArPSBzdWI7XHJcbiAgICAgICAgICAgICAgICBsYXN0X3N1YnN0aXR1dGUgPSBzdWI7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIG5ld19zdHIgKz0gY2g7XHJcbiAgICAgICAgICAgICAgbGFzdF9zdWJzdGl0dXRlID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHNlbGYpIHtcclxuICAgICAgICAgIHN1YiA9IHN1YnNbY2hdO1xyXG4gICAgICAgICAgaWYgKGludmVyc2UpIHtcclxuICAgICAgICAgICAgbmV3X3N0ciArPSAoc3ViID09IG51bGwgPyBnbG9iYWxfc3ViIDogY2gpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbmV3X3N0ciArPSAoc3ViICE9IG51bGwgPyBzdWIgOiBjaCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuZXdfc3RyO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVmIHRyKGZyb20sIHRvKVxyXG4gICAgYGNvbW1vbl90cihzZWxmLCBmcm9tLCB0bywgZmFsc2UpYFxyXG4gIGVuZFxyXG5cclxuICAjIHRyISAtIG5vdCBzdXBwb3J0ZWQsIG11dGF0ZXMgc3RyaW5nXHJcblxyXG4gIGRlZiB0cl9zKGZyb20sIHRvKVxyXG4gICAgYGNvbW1vbl90cihzZWxmLCBmcm9tLCB0bywgdHJ1ZSlgXHJcbiAgZW5kXHJcblxyXG4gICMgdHJfcyEgLSBub3Qgc3VwcG9ydGVkLCBtdXRhdGVzIHN0cmluZ1xyXG5cclxuICAjIGRlZiB1bmR1bXBcclxuICAjICAjIFRPRE9cclxuICAjIGVuZFxyXG5cclxuICBkZWYgdW5pY29kZV9ub3JtYWxpemUoZm9ybSA9IDpuZmMpXHJcbiAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiSW52YWxpZCBub3JtYWxpemF0aW9uIGZvcm0gI3tmb3JtfVwiIHVubGVzcyAlaVtuZmMgbmZkIG5ma2MgbmZrZF0uaW5jbHVkZT8oZm9ybSlcclxuICAgIGBzZWxmLm5vcm1hbGl6ZSgje2Zvcm0udXBjYXNlfSlgXHJcbiAgZW5kXHJcblxyXG4gICMgdW5pY29kZV9ub3JtYWxpemUhIC0gbm90IHN1cHBvcnRlZCwgbXV0YXRlcyBzdHJpbmdcclxuXHJcbiAgZGVmIHVuaWNvZGVfbm9ybWFsaXplZD8oZm9ybSA9IDpuZmMpXHJcbiAgICB1bmljb2RlX25vcm1hbGl6ZShmb3JtKSA9PSBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiB1bnBhY2soZm9ybWF0KVxyXG4gICAgOjpLZXJuZWwucmFpc2UgXCJUbyB1c2UgU3RyaW5nI3VucGFjaywgeW91IG11c3QgZmlyc3QgcmVxdWlyZSAnY29yZWxpYi9zdHJpbmcvdW5wYWNrJy5cIlxyXG4gIGVuZFxyXG5cclxuICBkZWYgdW5wYWNrMShmb3JtYXQpXHJcbiAgICA6Oktlcm5lbC5yYWlzZSBcIlRvIHVzZSBTdHJpbmcjdW5wYWNrMSwgeW91IG11c3QgZmlyc3QgcmVxdWlyZSAnY29yZWxpYi9zdHJpbmcvdW5wYWNrJy5cIlxyXG4gIGVuZFxyXG5cclxuICBkZWYgdXBjYXNlKCpvcHRpb25zKVxyXG4gICAgJXh7XHJcbiAgICAgIGxldCByZXN1bHQ7XHJcbiAgICAgIGlmIChjYXNlX29wdGlvbnNfaGF2ZV9hc2NpaShvcHRpb25zKSkge1xyXG4gICAgICAgIHJlc3VsdCA9IHNlbGYucmVwbGFjZSgvW2Etel0rL2csIChtYXRjaCk9PnsgcmV0dXJuIG1hdGNoLnRvVXBwZXJDYXNlKCk7IH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdCA9IHNlbGYudG9VcHBlckNhc2UoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0LiRmb3JjZV9lbmNvZGluZyhzZWxmLmVuY29kaW5nKVxyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICAjIHVwY2FzZSEgLW5vdCBzdXBwb3J0ZWQsIG11dGF0ZXMgc3RyaW5nXHJcblxyXG4gIGRlZiB1cHRvKHN0b3AsIGV4Y2wgPSBmYWxzZSwgJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVudW1fZm9yIDp1cHRvLCBzdG9wLCBleGNsIHVubGVzcyBibG9ja19naXZlbj9cclxuICAgICV4e1xyXG4gICAgICB2YXIgYSwgYiwgcyA9IHNlbGYudG9TdHJpbmcoKTtcclxuXHJcbiAgICAgIHN0b3AgPSAkY29lcmNlX3RvKHN0b3AsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XHJcblxyXG4gICAgICBsZXQgc3RyX2wgPSBzZWxmLiRsZW5ndGgoKSxcclxuICAgICAgICAgIHN0b3BfbCA9IHN0b3AuJGxlbmd0aCgpO1xyXG5cclxuICAgICAgaWYgKHN0cl9sID09PSAxICYmIHN0b3BfbCA9PT0gMSkge1xyXG5cclxuICAgICAgICBhID0gc2VsZi5jb2RlUG9pbnRBdCgwKTtcclxuICAgICAgICBiID0gc3RvcC5jb2RlUG9pbnRBdCgwKTtcclxuICAgICAgICBpZiAoYiA+PSAweEQ4MDAgJiYgYiA8PSAweERGRkYpIGIgPSAwOyAvLyBleGNsdWRlIHN1cnJvZ2F0ZSByYW5nZSBmb3IgYlxyXG5cclxuICAgICAgICB3aGlsZSAoYSA8PSBiKSB7XHJcbiAgICAgICAgICBpZiAoZXhjbCAmJiBhID09PSBiKSBicmVhaztcclxuXHJcbiAgICAgICAgICBibG9jayhTdHJpbmcuZnJvbUNvZGVQb2ludChhKSk7XHJcblxyXG4gICAgICAgICAgYSArPSAxO1xyXG4gICAgICAgICAgaWYgKGEgPj0gMHhEODAwICYmIGEgPD0gMHhERkZGKSBhID0gMHhFMDAwOyAvLyBleGNsdWRlIHN1cnJvZ2F0ZSByYW5nZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0gZWxzZSBpZiAocGFyc2VJbnQocywgMTApLnRvU3RyaW5nKCkgPT09IHMgJiYgcGFyc2VJbnQoc3RvcCwgMTApLnRvU3RyaW5nKCkgPT09IHN0b3ApIHtcclxuXHJcbiAgICAgICAgYSA9IHBhcnNlSW50KHMsIDEwKTtcclxuICAgICAgICBiID0gcGFyc2VJbnQoc3RvcCwgMTApO1xyXG5cclxuICAgICAgICB3aGlsZSAoYSA8PSBiKSB7XHJcbiAgICAgICAgICBpZiAoZXhjbCAmJiBhID09PSBiKSBicmVhaztcclxuXHJcbiAgICAgICAgICBibG9jayhhLnRvU3RyaW5nKCkpO1xyXG5cclxuICAgICAgICAgIGEgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IHNfbDtcclxuICAgICAgICB3aGlsZSAoc3RyX2wgPD0gc3RvcF9sICYmIHMgPD0gc3RvcCkge1xyXG4gICAgICAgICAgaWYgKGV4Y2wgJiYgcyA9PSBzdG9wKSBicmVhaztcclxuXHJcbiAgICAgICAgICBibG9jayhzKTtcclxuXHJcbiAgICAgICAgICBzX2wgPSBzLmxlbmd0aDtcclxuICAgICAgICAgIHMgPSBzLiRuZXh0KCk7XHJcbiAgICAgICAgICBpZiAocy5sZW5ndGggIT09IHNfbCkgc3RyX2wgPSBzLiRsZW5ndGgoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgdmFsaWRfZW5jb2Rpbmc/XHJcbiAgICBlbmNvZGluZy52YWxpZF9lbmNvZGluZz8oc2VsZilcclxuICBlbmRcclxuXHJcbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlc1xyXG4gICAgW11cclxuICBlbmRcclxuXHJcbiAgZGVmIHNlbGYuX2xvYWQoKmFyZ3MpXHJcbiAgICBuZXcoKmFyZ3MpXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBmcmVlemVcclxuICAgICV4e1xyXG4gICAgICBpZiAodHlwZW9mIHNlbGYgPT09ICdzdHJpbmcnKSB7IHJldHVybiBzZWxmOyB9XHJcbiAgICAgICRwcm9wKHNlbGYsIFwiJCRmcm96ZW5cIiwgdHJ1ZSk7XHJcbiAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZnJvemVuP1xyXG4gICAgYHR5cGVvZiBzZWxmID09PSAnc3RyaW5nJyB8fCBzZWxmLiQkZnJvemVuID09PSB0cnVlYFxyXG4gIGVuZFxyXG5cclxuICBhbGlhcyBvYmplY3RfaWQgX19pZF9fXHJcblxyXG4gIDo6T3BhbC5wcmlzdGluZSBzZWxmLCA6aW5pdGlhbGl6ZVxyXG5lbmRcclxuXHJcblN5bWJvbCA9IFN0cmluZ1xyXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpTdHJpbmc+Iiwic2VsZiIsImluY2x1ZGUiLCJDb21wYXJhYmxlIiwiYXR0cl9yZWFkZXIiLCJyYWlzZSIsIkluZGV4RXJyb3IiLCJLZXJuZWwiLCJBcmd1bWVudEVycm9yIiwiU3RyaW5nIiwiUmVnZXhwIiwiZXNjYXBlIiwiVHlwZUVycm9yIiwiJH4iLCJNYXRjaERhdGEiLCJuZXciLCJJbnRlZ2VyIiwiUmFuZ2VFcnJvciIsIl9faWRfXyIsImhhc2giLCJ0cnlfY29udmVydCIsIndoYXQiLCJPcGFsIiwiY29lcmNlX3RvPyIsImluaXRpYWxpemUiLCJhcmdzIiwiJSIsImRhdGEiLCJBcnJheSIsImZvcm1hdCIsIioiLCJjb3VudCIsIisiLCJvdGhlciIsIitAIiwiZnJvemVuPyIsImR1cCIsIi1AIiwiPD0+IiwicmVzcG9uZF90bz8iLCJ0b19zdHIiLCJ0b19zIiwiPT0iLCI9fiIsIltdIiwiaW5kZXgiLCJsZW5ndGgiLCJyZXN1bHQiLCJhc2NpaV9vbmx5PyIsImIiLCJieXRlaW5kZXgiLCJzZWFyY2giLCJvZmZzZXQiLCIwIiwiaW50ZXJuYWxfZW5jb2RpbmciLCJieXRlc2l6ZSIsImJ5dGVyaW5kZXgiLCJieXRlcyIsInJlcyIsImVhY2hfYnl0ZSIsInRvX2EiLCJibG9ja19naXZlbj8iLCJlYWNoIiwiYmxvY2siLCJ0b19wcm9jIiwiYnl0ZXNsaWNlIiwiY2FwaXRhbGl6ZSIsImNhc2VjbXAiLCJkb3duY2FzZSIsImNhc2VjbXA/IiwiYyIsIm5pbD8iLCJjZW50ZXIiLCJ3aWR0aCIsInBhZHN0ciIsImVtcHR5PyIsImwiLCI8PSIsImNoYXJzIiwiZWFjaF9jaGFyIiwiY2hvbXAiLCJzZXBhcmF0b3IiLCIkLyIsImNvZXJjZV90byEiLCJjaG9wIiwiY2hyIiwiY2xvbmUiLCIka3dhcmdzIiwiZnJlZXplIiwiY2xhc3MiLCJjb3B5IiwiY29weV9zaW5nbGV0b25fbWV0aG9kcyIsImluaXRpYWxpemVfY2xvbmUiLCJjb2RlcG9pbnRzIiwiZWFjaF9jb2RlcG9pbnQiLCJkZWxldGUiLCJkZWxldGVfcHJlZml4IiwicHJlZml4IiwiZGVsZXRlX3N1ZmZpeCIsInN1ZmZpeCIsImR1bXAiLCJpbml0aWFsaXplX2R1cCIsImVudW1fZm9yIiwiYmxvY2sgaW4gZWFjaF9ieXRlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX2J5dGUiLCJibG9jayBpbiBlYWNoX2NoYXIiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfY2hhciIsInNpemUiLCJibG9jayBpbiBlYWNoX2NvZGVwb2ludCIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF9jb2RlcG9pbnQiLCJ2YWxpZF9lbmNvZGluZz8iLCJlYWNoX2dyYXBoZW1lX2NsdXN0ZXIiLCJibG9jayBpbiBlYWNoX2dyYXBoZW1lX2NsdXN0ZXIiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfZ3JhcGhlbWVfY2x1c3RlciIsImNsdXN0ZXJzIiwiZWFjaF9saW5lIiwiZW5jb2RlIiwiZW5jb2RpbmciLCJlbmRfd2l0aD8iLCJmb3JjZV9lbmNvZGluZyIsImlzX2E/IiwiRW5jb2RpbmciLCJmaW5kIiwiZ2V0Ynl0ZSIsImlkeCIsIjwiLCJpIiwiYmxvY2sgaW4gZ2V0Ynl0ZSIsImJsb2NrICgyIGxldmVscykgaW4gZ2V0Ynl0ZSIsIjEiLCJncmFwaGVtZV9jbHVzdGVycyIsImdzdWIiLCJwYXR0ZXJuIiwicmVwbGFjZW1lbnQiLCJoZXgiLCJ0b19pIiwiMTYiLCJpbmNsdWRlPyIsImluaXRpYWxpemVfY29weSIsImluc3BlY3QiLCJpbnRlcm4iLCJsaW5lcyIsImUiLCJsanVzdCIsImxzdHJpcCIsIm1hdGNoIiwicG9zIiwibWF0Y2g/IiwibmV4dCIsIm9jdCIsIm9yZCIsInBhcnRpdGlvbiIsInNlcCIsInJldmVyc2UiLCJyaW5kZXgiLCJyanVzdCIsInJwYXJ0aXRpb24iLCJyc3RyaXAiLCJzY2FuIiwibm9fbWF0Y2hkYXRhIiwibWFwIiwiY2FwdHVyZXMiLCJibG9jayBpbiBzY2FuIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzY2FuIiwic2NydWIiLCJyZXBsYWNlbWVudF9zdHJpbmciLCJzaW5nbGV0b25fY2xhc3MiLCJzcGxpdCIsImxpbWl0IiwiJHJldF9vcl8xIiwiJDsiLCJzcXVlZXplIiwic3RhcnRfd2l0aD8iLCJzdHJpcCIsInN1YiIsInN1bSIsIm4iLCJzd2FwY2FzZSIsInRvX2YiLCJiYXNlIiwiMTAiLCJtZXRob2RfbmFtZSIsImpzaWQiLCJwcm9jIiwiYmxvY2sgaW4gdG9fcHJvYyIsImJsb2NrICgyIGxldmVscykgaW4gdG9fcHJvYyIsInRyIiwiZnJvbSIsInRvIiwidHJfcyIsInVuaWNvZGVfbm9ybWFsaXplIiwiZm9ybSIsInVwY2FzZSIsInVuaWNvZGVfbm9ybWFsaXplZD8iLCJ1bnBhY2siLCJ1bnBhY2sxIiwidXB0byIsInN0b3AiLCJleGNsIiwiaW5zdGFuY2VfdmFyaWFibGVzIiwiX2xvYWQiLCJwcmlzdGluZSJdLCJtYXBwaW5ncyI6IkFBQUFBLGlDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQU9BQztFQUFBQTs7SUFBQUE7OztJQUNFQyxJQUFBQyxTQUFBQSxDQUFRQyxpQkFBUkQ7SUFFQUQsSUFBQUcsYUFBQUEsQ0FBWSxVQUFaLEVBQXVCLG1CQUF2QkE7O0FBR0ZKOztBQUVBQSxjQUFnQkMsSUFBS0Q7O0FBRXJCQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNB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T0FBQXpMLE1BQUFkLElBQUFjLE9BQUFBLEVBQUksTUFBQ1UsSUFBRCxDQUFKVjtJQURGeUwsQ0FBQUEsSUFBQUE7O0FBSUFoSCxJQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7SUFMRUEsQ0FBQUE7O0FBUUFyRCxJQUFBQSx1QkFBQUEsZ0NBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxrREFBREE7SUFERkEsQ0FBQUE7SUFJQSxhQUFNLFdBQU4sRUFBZ0IsUUFBaEI7SUFFQW5DLE9BQUFzQixLQUFNbUwsVUFBQUEsQ0FBVXhNLElBQWhCLEVBQXNCLFlBQWhCd007RUFoM0VSek0sR0FBTSxJQUFOQSxFQUFrQkQsTUFBbEJDO0VBbTNFQUQsT0FBQSxrQ0FBU1UsWUFBVDtBQTEzRUFWOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxMDM2NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvc3RyaW5nL211dGFibGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyB1c2Vfc3RyaWN0OiB0cnVlXHJcblxyXG4jIEluIHNob3J0LCBob3cgZG8gd2UgbWFrZSBhIHN0cmluZyBtdXRhYmxlOlxyXG4jXHJcbiMgMS4gV2UgZW5zdXJlIGFsbCBTdHJpbmcgY2FsbHMgaW4gT3BhbCBhY3R1YWxseSBjYWxsIHRvU3RyaW5nKCkgb3JcclxuIyAgICB2YWx1ZU9mKCkgYmVmb3JlIHJlc29sdXRpb24uXHJcbiMgMi4gV2Ugb3ZlcnJpZGUgdGhvc2UgbWV0aG9kcyB1c2luZyBhIHJlcGxhY2UgY2FsbCAtIGJ1dCBvbmx5IGlmXHJcbiMgICAgd2UgZG8gaXQgb24gYSBib3hlZCBzdHJpbmcsIG90aGVyd2lzZSBpdCB3b3VsZG4ndCBiZSBwb3NzaWJsZS5cclxuXHJcbiMgVGhpcyBtZWFucywgdGhhdCBmb3IgYWxsIGludGVudHMgYW5kIHB1cnBvc2VzIHlvdSBhcmUgYWx3YXlzIGFibGVcclxuIyB0byB1c2UgYSBTdHJpbmcgYXMgeW91IGhhdmUgdXNlZCBpdCBiZWZvcmUgdGhpcyBzdXBwb3J0LiBCVVQgaWYgeW91XHJcbiMgd2FudCB0byBzZW5kIGEgbXV0YXRlZCBzdHJpbmcgdG8gSmF2YVNjcmlwdCwgeW91IG11c3QgZWl0aGVyIGNhbGxcclxuIyBgI3RvX25gIGZyb20gdGhlIGBuYXRpdmVgIG1vZHVsZSwgb3IgdXNlIHRvU3RyaW5nKCkgeW91cnNlbGYuIE9SIHlvdVxyXG4jIG5lZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGxpYnJhcnkgeW91IGFyZSB1c2luZyBpcyBkb2luZyBpdC4gQSB3b3JkXHJcbiMgb2Ygd2FybmluZzogdXNpbmcgdGhlIG11dGFibGUgc3RyaW5nIGZ1bmN0aW9ucyBXSUxMIE5PVCBiZSBtb3JlXHJcbiMgcGVyZm9ybWFudCBpbiBPcGFsIGFzIGl0IGlzIGluIFJ1YnkuXHJcblxyXG5jbGFzcyBTdHJpbmdcclxuICAleHtcclxuICAgIGZ1bmN0aW9uICRkZW55X2Zyb3plbl9hY2Nlc3Moc3RyKSB7XHJcbiAgICAgIGlmICh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIuJCRmcm96ZW4gPT09IHRydWUpIHtcclxuICAgICAgICAgICRyYWlzZShPcGFsLkZyb3plbkVycm9yLCBcImNhbid0IG1vZGlmeSBmcm96ZW4gU3RyaW5nOiBcIiArIHN0ci4kaW5zcGVjdCgpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgIyByZXR1cm5fbmlsIGFyZ3VtZW50IGlzIHByaXZhdGVcclxuICBkZWYgcmVwbGFjZShvdGhlciwgcmV0dXJuX25pbCA9IGZhbHNlKVxyXG4gICAgJXh7XHJcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XHJcblxyXG4gICAgICB2YXIgb2xkc3RyID0gc2VsZi50b1N0cmluZygpO1xyXG4gICAgICB2YXIgbmV3c3RyID0gb3RoZXIudG9TdHJpbmcoKTtcclxuXHJcbiAgICAgIGlmIChvbGRzdHIgPT09IG5ld3N0cikgcmV0dXJuIHJldHVybl9uaWwgPyBuaWwgOiBzZWxmO1xyXG5cclxuICAgICAgc2VsZi4kJHN0cmluZyA9IG5ld3N0clxyXG5cclxuICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiA8PChvdGhlcilcclxuICAgIHJlcGxhY2Uoc2VsZiArIG90aGVyKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgY2FwaXRhbGl6ZSFcclxuICAgIHJlcGxhY2UoY2FwaXRhbGl6ZSwgdHJ1ZSlcclxuICBlbmRcclxuXHJcbiAgZGVmIGNob21wISgqYXJncylcclxuICAgIHJlcGxhY2UoY2hvbXAoKmFyZ3MpLCB0cnVlKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgY29uY2F0KCphcmdzKVxyXG4gICAgYXJncy5lYWNoIHsgfGFyZ3wgc2VsZiA8PCBhcmcgfVxyXG4gICAgc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgY2hvcCFcclxuICAgIHJlcGxhY2UoY2hvcCwgdHJ1ZSlcclxuICBlbmRcclxuXHJcbiAgZGVmIGRvd25jYXNlISgqKVxyXG4gICAgcmVwbGFjZShkb3duY2FzZSgqYXJncyksIHRydWUpXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBnc3ViISgqYXJncywgJmJsb2NrKVxyXG4gICAgcmVwbGFjZShnc3ViKCphcmdzLCAmYmxvY2spLCB0cnVlKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgbHN0cmlwIVxyXG4gICAgcmVwbGFjZShsc3RyaXAsIHRydWUpXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzdWNjIVxyXG4gICAgcmVwbGFjZShzdWNjKVxyXG4gIGVuZFxyXG5cclxuICBhbGlhcyBuZXh0ISBzdWNjIVxyXG5cclxuICBkZWYgcmV2ZXJzZSEoKilcclxuICAgIHJlcGxhY2UocmV2ZXJzZSlcclxuICBlbmRcclxuXHJcbiAgZGVmIHNxdWVlemUhKCphcmdzKVxyXG4gICAgcmVwbGFjZShzcXVlZXplKCphcmdzKSwgdHJ1ZSlcclxuICBlbmRcclxuXHJcbiAgZGVmIHN0cmlwIVxyXG4gICAgcmVwbGFjZShzdHJpcCwgdHJ1ZSlcclxuICBlbmRcclxuXHJcbiAgZGVmIHN1YiEoKilcclxuICAgIHJlcGxhY2Uoc3ViKCphcmdzLCAmYmxvY2spLCB0cnVlKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc3dhcGNhc2UhXHJcbiAgICByZXBsYWNlKHN3YXBjYXNlLCB0cnVlKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgdHIhKCphcmdzKVxyXG4gICAgcmVwbGFjZSh0cigqYXJncyksIHRydWUpXHJcbiAgZW5kXHJcblxyXG4gIGRlZiB0cl9zISgqYXJncylcclxuICAgIHJlcGxhY2UodHJfcygqYXJncyksIHRydWUpXHJcbiAgZW5kXHJcblxyXG4gIGRlZiB1cGNhc2UhKCopXHJcbiAgICByZXBsYWNlKHVwY2FzZSwgdHJ1ZSlcclxuICBlbmRcclxuXHJcbiAgIyBUT0RPOiBTdXBwb3J0IGZvciBjb2RlcG9pbnRzXHJcbiAgZGVmIGNvbmNhdCgqc3RycylcclxuICAgIHJlcGxhY2UoKFtzZWxmXSArIHN0cnMpLmpvaW4pXHJcbiAgZW5kXHJcblxyXG4gICMgVE9ETzogU3VwcG9ydCBmb3IgY29kZXBvaW50c1xyXG4gIGRlZiBwcmVwZW5kKCpzdHJzKVxyXG4gICAgcmVwbGFjZSgoc3RycyArIFtzZWxmXSkuam9pbilcclxuICBlbmRcclxuXHJcbiAgZGVmIFtdPSgqKVxyXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvclxyXG4gIGVuZFxyXG5cclxuICBkZWYgY2xlYXIoKilcclxuICAgIHJlcGxhY2UoJycpXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBlbmNvZGUhKCphcmdzKVxyXG4gICAgcmVwbGFjZShlbmNvZGUoKmFyZ3MpKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgdW5pY29kZV9ub3JtYWxpemUhKCphcmdzKVxyXG4gICAgcmVwbGFjZSh1bmljb2RlX25vcm1hbGl6ZSgqYXJncykpXHJcbiAgZW5kXHJcbmVuZFxyXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpTdHJpbmc+IiwicmVwbGFjZSIsIm90aGVyIiwicmV0dXJuX25pbCIsIjw8Iiwic2VsZiIsIisiLCJjYXBpdGFsaXplISIsImNhcGl0YWxpemUiLCJjaG9tcCEiLCJjaG9tcCIsImFyZ3MiLCJjb25jYXQiLCJlYWNoIiwiYmxvY2sgaW4gY29uY2F0IiwiYXJnIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb25jYXQiLCJjaG9wISIsImNob3AiLCJkb3duY2FzZSEiLCJkb3duY2FzZSIsImdzdWIhIiwiZ3N1YiIsImJsb2NrIiwidG9fcHJvYyIsImxzdHJpcCEiLCJsc3RyaXAiLCJzdWNjISIsInN1Y2MiLCJyZXZlcnNlISIsInJldmVyc2UiLCJzcXVlZXplISIsInNxdWVlemUiLCJzdHJpcCEiLCJzdHJpcCIsInN1YiEiLCJzdWIiLCJzd2FwY2FzZSEiLCJzd2FwY2FzZSIsInRyISIsInRyIiwidHJfcyEiLCJ0cl9zIiwidXBjYXNlISIsInVwY2FzZSIsInN0cnMiLCJqb2luIiwicHJlcGVuZCIsIltdPSIsInJhaXNlIiwiTm90SW1wbGVtZW50ZWRFcnJvciIsImNsZWFyIiwiZW5jb2RlISIsImVuY29kZSIsInVuaWNvZGVfbm9ybWFsaXplISIsInVuaWNvZGVfbm9ybWFsaXplIl0sIm1hcHBpbmdzIjoiQUFBQUEseUNBQUFBLGdCQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7RUFpQkFBLE9BQUFDO0VBQUFBOztJQUFBQTs7OztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFHRUMsSUFBQUEsdUJBQUFBLG1CQUFZQyxLQUFELEVBQVFDLFVBQW5CRjtBQUFBQSxNQUFBQTs7O01BQW1CLHFDQUFhOztBQUVsQ0E7O0FBRUFBO0FBQ0FBOztBQUVBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBO0lBWkVBLENBQUFBLElBQUFBOztBQWVBRyxJQUFBQSxrQkFBQUEsMEJBQU9GLEtBQVBFO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBQyxJQUFBSixTQUFBQSxDQUFhSyxTQUFMRCxJQUFLQyxFQUFF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b24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZW51bWVyYWJsZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHRydXRoeSwgY29lcmNlX3RvLCB5aWVsZDEsIHlpZWxkWCwgZGVueV9mcm96ZW5fYWNjZXNzXHJcbiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxyXG4jIHVzZV9zdHJpY3Q6IHRydWVcclxuXHJcbm1vZHVsZSA6OkVudW1lcmFibGVcclxuICAleHtcclxuICAgIGZ1bmN0aW9uIGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKSB7XHJcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICB2YWx1ZSA9IFtuaWxdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodmFsdWUubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVmIGFsbD8ocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxyXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZGBcclxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxyXG4gICAgICAgIGNvbXBhcmFibGUgPSBgY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpYFxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2UgdW5sZXNzIHBhdHRlcm4ucHVibGljX3NlbmQoOj09PSwgKmNvbXBhcmFibGUpXHJcbiAgICAgIGVuZFxyXG4gICAgZWxzaWYgYmxvY2tfZ2l2ZW4/XHJcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcclxuICAgICAgICB1bmxlc3MgeWllbGQoKnZhbHVlKVxyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgZW5kXHJcbiAgICAgIGVuZFxyXG4gICAgZWxzZVxyXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XHJcbiAgICAgICAgdW5sZXNzIDo6T3BhbC5kZXN0cnVjdHVyZSh2YWx1ZSlcclxuICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgIGVuZFxyXG4gICAgICBlbmRcclxuICAgIGVuZFxyXG5cclxuICAgIHRydWVcclxuICBlbmRcclxuXHJcbiAgZGVmIGFueT8ocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxyXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZGBcclxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxyXG4gICAgICAgIGNvbXBhcmFibGUgPSBgY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpYFxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZSBpZiBwYXR0ZXJuLnB1YmxpY19zZW5kKDo9PT0sICpjb21wYXJhYmxlKVxyXG4gICAgICBlbmRcclxuICAgIGVsc2lmIGJsb2NrX2dpdmVuP1xyXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XHJcbiAgICAgICAgaWYgeWllbGQoKnZhbHVlKVxyXG4gICAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgICBlbmRcclxuICAgICAgZW5kXHJcbiAgICBlbHNlXHJcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcclxuICAgICAgICBpZiA6Ok9wYWwuZGVzdHJ1Y3R1cmUodmFsdWUpXHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICAgIGVuZFxyXG4gICAgICBlbmRcclxuICAgIGVuZFxyXG5cclxuICAgIGZhbHNlXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBjaHVuaygmYmxvY2spXHJcbiAgICByZXR1cm4gdG9fZW51bSg6Y2h1bmspIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG5cclxuICAgIDo6RW51bWVyYXRvci5uZXcgZG8gfHlpZWxkZXJ8XHJcbiAgICAgICV4e1xyXG4gICAgICAgIHZhciBwcmV2aW91cyA9IG5pbCwgYWNjdW11bGF0ZSA9IFtdO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWxlYXNlQWNjdW11bGF0ZSgpIHtcclxuICAgICAgICAgIGlmIChhY2N1bXVsYXRlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgI3t5aWVsZGVyLnlpZWxkKGBwcmV2aW91c2AsIGBhY2N1bXVsYXRlYCl9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICB2YXIga2V5ID0gJHlpZWxkMShibG9jaywgdmFsdWUpO1xyXG5cclxuICAgICAgICAgIGlmIChrZXkgPT09IG5pbCkge1xyXG4gICAgICAgICAgICByZWxlYXNlQWNjdW11bGF0ZSgpO1xyXG4gICAgICAgICAgICBhY2N1bXVsYXRlID0gW107XHJcbiAgICAgICAgICAgIHByZXZpb3VzID0gbmlsO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHByZXZpb3VzID09PSBuaWwgfHwgcHJldmlvdXMgPT09IGtleSkge1xyXG4gICAgICAgICAgICAgIGFjY3VtdWxhdGUucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmVsZWFzZUFjY3VtdWxhdGUoKTtcclxuICAgICAgICAgICAgICBhY2N1bXVsYXRlID0gW3ZhbHVlXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHJldmlvdXMgPSBrZXk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZWxmLiRlYWNoKCk7XHJcblxyXG4gICAgICAgIHJlbGVhc2VBY2N1bXVsYXRlKCk7XHJcbiAgICAgIH1cclxuICAgIGVuZFxyXG4gIGVuZFxyXG5cclxuICBkZWYgY2h1bmtfd2hpbGUoJmJsb2NrKVxyXG4gICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbm8gYmxvY2sgZ2l2ZW4nIHVubGVzcyBibG9ja19naXZlbj9cclxuXHJcbiAgICBzbGljZV93aGVuIHsgfGJlZm9yZSwgYWZ0ZXJ8ICEoeWllbGQgYmVmb3JlLCBhZnRlcikgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgY29sbGVjdCgmYmxvY2spXHJcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbGxlY3QpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG5cclxuICAgICV4e1xyXG4gICAgICB2YXIgcmVzdWx0ID0gW107XHJcblxyXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9ICR5aWVsZFgoYmxvY2ssIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHNlbGYuJGVhY2goKTtcclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBjb2xsZWN0X2NvbmNhdCgmYmxvY2spXHJcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbGxlY3RfY29uY2F0KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cclxuICAgIG1hcCgmYmxvY2spLmZsYXR0ZW4oMSlcclxuICBlbmRcclxuXHJcbiAgZGVmIGNvbXBhY3RcclxuICAgIHRvX2EuY29tcGFjdFxyXG4gIGVuZFxyXG5cclxuICBkZWYgY291bnQob2JqZWN0ID0gdW5kZWZpbmVkLCAmYmxvY2spXHJcbiAgICByZXN1bHQgPSAwXHJcblxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiBibG9jayAhPT0gbmlsKSB7XHJcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBnaXZlbiBibG9jayBub3QgdXNlZCcpfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgYG9iamVjdCAhPSBudWxsYFxyXG4gICAgICBibG9jayA9IDo6S2VybmVsLnByb2MgZG8gfCphcmdzfFxyXG4gICAgICAgIDo6T3BhbC5kZXN0cnVjdHVyZShhcmdzKSA9PSBvYmplY3RcclxuICAgICAgZW5kXHJcbiAgICBlbHNpZiBibG9jay5uaWw/XHJcbiAgICAgIGJsb2NrID0gOjpLZXJuZWwucHJvYyB7IHRydWUgfVxyXG4gICAgZW5kXHJcblxyXG4gICAgZWFjaCBkbyB8KmFyZ3N8XHJcbiAgICAgIGByZXN1bHQrK2AgaWYgYCR5aWVsZFgoYmxvY2ssIGFyZ3MpYFxyXG4gICAgZW5kXHJcblxyXG4gICAgcmVzdWx0XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBjeWNsZShuID0gbmlsLCAmYmxvY2spXHJcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XHJcbiAgICAgIHJldHVybiBlbnVtX2Zvcig6Y3ljbGUsIG4pIGRvXHJcbiAgICAgICAgaWYgbi5uaWw/XHJcbiAgICAgICAgICByZXNwb25kX3RvPyg6c2l6ZSkgPyA6OkZsb2F0OjpJTkZJTklUWSA6IG5pbFxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIG4gPSA6Ok9wYWwuY29lcmNlX3RvIShuLCA6OkludGVnZXIsIDp0b19pbnQpXHJcbiAgICAgICAgICBuID4gMCA/IGVudW1lcmF0b3Jfc2l6ZSAqIG4gOiAwXHJcbiAgICAgICAgZW5kXHJcbiAgICAgIGVuZFxyXG4gICAgZW5kXHJcblxyXG4gICAgdW5sZXNzIG4ubmlsP1xyXG4gICAgICBuID0gOjpPcGFsLmNvZXJjZV90byEgbiwgOjpJbnRlZ2VyLCA6dG9faW50XHJcblxyXG4gICAgICByZXR1cm4gaWYgYG4gPD0gMGBcclxuICAgIGVuZFxyXG5cclxuICAgICV4e1xyXG4gICAgICB2YXIgYWxsID0gW10sIGksIGxlbmd0aCwgdmFsdWU7XHJcblxyXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXHJcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgcGFyYW0pO1xyXG5cclxuICAgICAgICBhbGwucHVzaChwYXJhbSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNlbGYuJGVhY2goKTtcclxuXHJcbiAgICAgIGlmIChhbGwubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIG5pbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG4gPT09IG5pbCkge1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhbGwubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBhbGxbaV0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB3aGlsZSAobiA+IDEpIHtcclxuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFsbC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIGFsbFtpXSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgbi0tO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZGV0ZWN0KGlmbm9uZSA9IHVuZGVmaW5lZCwgJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVudW1fZm9yIDpkZXRlY3QsIGlmbm9uZSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XHJcblxyXG4gICAgZWFjaCBkbyB8KmFyZ3N8XHJcbiAgICAgIHZhbHVlID0gOjpPcGFsLmRlc3RydWN0dXJlKGFyZ3MpXHJcbiAgICAgIGlmIHlpZWxkKHZhbHVlKVxyXG4gICAgICAgIHJldHVybiB2YWx1ZVxyXG4gICAgICBlbmRcclxuICAgIGVuZFxyXG5cclxuICAgICV4e1xyXG4gICAgICBpZiAoaWZub25lICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAodHlwZW9mKGlmbm9uZSkgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIHJldHVybiBpZm5vbmUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIGlmbm9uZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBuaWxcclxuICBlbmRcclxuXHJcbiAgZGVmIGRyb3AobnVtYmVyKVxyXG4gICAgbnVtYmVyID0gYCRjb2VyY2VfdG8obnVtYmVyLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcclxuXHJcbiAgICBpZiBgbnVtYmVyIDwgMGBcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnYXR0ZW1wdCB0byBkcm9wIG5lZ2F0aXZlIHNpemUnXHJcbiAgICBlbmRcclxuXHJcbiAgICAleHtcclxuICAgICAgdmFyIHJlc3VsdCAgPSBbXSxcclxuICAgICAgICAgIGN1cnJlbnQgPSAwO1xyXG5cclxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAobnVtYmVyIDw9IGN1cnJlbnQpIHtcclxuICAgICAgICAgIHJlc3VsdC5wdXNoKCN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY3VycmVudCsrO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgc2VsZi4kZWFjaCgpXHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZHJvcF93aGlsZSgmYmxvY2spXHJcbiAgICByZXR1cm4gZW51bV9mb3IgOmRyb3Bfd2hpbGUgdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG5cclxuICAgICV4e1xyXG4gICAgICB2YXIgcmVzdWx0ICAgPSBbXSxcclxuICAgICAgICAgIGRyb3BwaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcclxuXHJcbiAgICAgICAgaWYgKGRyb3BwaW5nKSB7XHJcbiAgICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBwYXJhbSk7XHJcblxyXG4gICAgICAgICAgaWYgKCEkdHJ1dGh5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICBkcm9wcGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJhbSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgcmVzdWx0LnB1c2gocGFyYW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIHNlbGYuJGVhY2goKTtcclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBlYWNoX2NvbnMobiwgJmJsb2NrKVxyXG4gICAgaWYgYGFyZ3VtZW50cy5sZW5ndGggIT0gMWBcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBmb3IgMSlcIlxyXG4gICAgZW5kXHJcblxyXG4gICAgbiA9IDo6T3BhbC50cnlfY29udmVydCBuLCA6OkludGVnZXIsIDp0b19pbnRcclxuXHJcbiAgICBpZiBgbiA8PSAwYFxyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdpbnZhbGlkIHNpemUnXHJcbiAgICBlbmRcclxuXHJcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XHJcbiAgICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9jb25zLCBuKSBkb1xyXG4gICAgICAgIGVudW1fc2l6ZSA9IGVudW1lcmF0b3Jfc2l6ZVxyXG4gICAgICAgIGlmIGVudW1fc2l6ZS5uaWw/XHJcbiAgICAgICAgICBuaWxcclxuICAgICAgICBlbHNpZiBlbnVtX3NpemUgPT0gMCB8fCBlbnVtX3NpemUgPCBuXHJcbiAgICAgICAgICAwXHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgZW51bV9zaXplIC0gbiArIDFcclxuICAgICAgICBlbmRcclxuICAgICAgZW5kXHJcbiAgICBlbmRcclxuXHJcbiAgICAleHtcclxuICAgICAgdmFyIGJ1ZmZlciA9IFtdO1xyXG5cclxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgZWxlbWVudCA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XHJcbiAgICAgICAgYnVmZmVyLnB1c2goZWxlbWVudCk7XHJcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiBuKSB7XHJcbiAgICAgICAgICBidWZmZXIuc2hpZnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT0gbikge1xyXG4gICAgICAgICAgJHlpZWxkMShibG9jaywgYnVmZmVyLnNsaWNlKDAsIG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNlbGYuJGVhY2goKTtcclxuXHJcbiAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZWFjaF9lbnRyeSgqZGF0YSwgJmJsb2NrKVxyXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG4gICAgICByZXR1cm4gdG9fZW51bSg6ZWFjaF9lbnRyeSwgKmRhdGEpIHsgZW51bWVyYXRvcl9zaXplIH1cclxuICAgIGVuZFxyXG5cclxuICAgICV4e1xyXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBpdGVtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcclxuXHJcbiAgICAgICAgJHlpZWxkMShibG9jaywgaXRlbSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNlbGYuJGVhY2guYXBwbHkoc2VsZiwgZGF0YSk7XHJcblxyXG4gICAgICByZXR1cm4gc2VsZjtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGVhY2hfc2xpY2UobiwgJmJsb2NrKVxyXG4gICAgbiA9IGAkY29lcmNlX3RvKCN7bn0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxyXG5cclxuICAgIGlmIGBuIDw9IDBgXHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2ludmFsaWQgc2xpY2Ugc2l6ZSdcclxuICAgIGVuZFxyXG5cclxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9zbGljZSwgbikgeyByZXNwb25kX3RvPyg6c2l6ZSkgPyAoc2l6ZSAvIG4pLmNlaWwgOiBuaWwgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XHJcblxyXG4gICAgJXh7XHJcbiAgICAgIHZhciBzbGljZSA9IFtdXHJcblxyXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XHJcblxyXG4gICAgICAgIHNsaWNlLnB1c2gocGFyYW0pO1xyXG5cclxuICAgICAgICBpZiAoc2xpY2UubGVuZ3RoID09PSBuKSB7XHJcbiAgICAgICAgICAkeWllbGQxKGJsb2NrLCBzbGljZSk7XHJcbiAgICAgICAgICBzbGljZSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIHNlbGYuJGVhY2goKTtcclxuXHJcbiAgICAgIC8vIG91ciBcImxhc3RcIiBncm91cCwgaWYgc21hbGxlciB0aGFuIG4gdGhlbiB3b24ndCBoYXZlIGJlZW4geWllbGRlZFxyXG4gICAgICBpZiAoc2xpY2UubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICR5aWVsZDEoYmxvY2ssIHNsaWNlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNlbGZcclxuICBlbmRcclxuXHJcbiAgZGVmIGVhY2hfd2l0aF9pbmRleCgqYXJncywgJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3dpdGhfaW5kZXgsICphcmdzKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cclxuXHJcbiAgICAleHtcclxuICAgICAgdmFyIGluZGV4ID0gMDtcclxuXHJcbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcclxuXHJcbiAgICAgICAgYmxvY2socGFyYW0sIGluZGV4KTtcclxuXHJcbiAgICAgICAgaW5kZXgrKztcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHNlbGYuJGVhY2guYXBwbHkoc2VsZiwgYXJncyk7XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgZWFjaF93aXRoX29iamVjdChvYmplY3QsICZibG9jaylcclxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF93aXRoX29iamVjdCwgb2JqZWN0KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cclxuXHJcbiAgICAleHtcclxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xyXG5cclxuICAgICAgICBibG9jayhwYXJhbSwgb2JqZWN0KTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHNlbGYuJGVhY2goKTtcclxuICAgIH1cclxuXHJcbiAgICBvYmplY3RcclxuICBlbmRcclxuXHJcbiAgZGVmIGVudHJpZXMoKmFyZ3MpXHJcbiAgICAleHtcclxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG5cclxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXN1bHQucHVzaCgjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9KTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHNlbGYuJGVhY2guYXBwbHkoc2VsZiwgYXJncyk7XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZmlsdGVyX21hcCgmYmxvY2spXHJcbiAgICByZXR1cm4gZW51bV9mb3IoOmZpbHRlcl9tYXApIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG5cclxuICAgIG1hcCgmYmxvY2spLnNlbGVjdCgmOml0c2VsZilcclxuICBlbmRcclxuXHJcbiAgZGVmIGZpbmRfYWxsKCZibG9jaylcclxuICAgIHJldHVybiBlbnVtX2Zvcig6ZmluZF9hbGwpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG5cclxuICAgICV4e1xyXG4gICAgICB2YXIgcmVzdWx0ID0gW107XHJcblxyXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXHJcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgcGFyYW0pO1xyXG5cclxuICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcclxuICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcmFtKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBzZWxmLiRlYWNoKCk7XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZmluZF9pbmRleChvYmplY3QgPSB1bmRlZmluZWQsICZibG9jaylcclxuICAgIHJldHVybiBlbnVtX2ZvciA6ZmluZF9pbmRleCBpZiBgb2JqZWN0ID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbGBcclxuXHJcbiAgICAleHtcclxuICAgICAgaWYgKG9iamVjdCAhPSBudWxsICYmIGJsb2NrICE9PSBuaWwpIHtcclxuICAgICAgICAje3dhcm4oJ3dhcm5pbmc6IGdpdmVuIGJsb2NrIG5vdCB1c2VkJyl9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpbmRleCA9IDBcclxuXHJcbiAgICBpZiBgb2JqZWN0ICE9IG51bGxgXHJcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcclxuICAgICAgICBpZiA6Ok9wYWwuZGVzdHJ1Y3R1cmUodmFsdWUpID09IG9iamVjdFxyXG4gICAgICAgICAgcmV0dXJuIGluZGV4XHJcbiAgICAgICAgZW5kXHJcblxyXG4gICAgICAgIGBpbmRleCArPSAxYFxyXG4gICAgICBlbmRcclxuICAgIGVsc2VcclxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxyXG4gICAgICAgIGlmIHlpZWxkKCp2YWx1ZSlcclxuICAgICAgICAgIHJldHVybiBpbmRleFxyXG4gICAgICAgIGVuZFxyXG5cclxuICAgICAgICBgaW5kZXggKz0gMWBcclxuICAgICAgZW5kXHJcbiAgICBlbmRcclxuXHJcbiAgICBuaWxcclxuICBlbmRcclxuXHJcbiAgZGVmIGZpcnN0KG51bWJlciA9IHVuZGVmaW5lZClcclxuICAgIGlmIGBudW1iZXIgPT09IHVuZGVmaW5lZGBcclxuICAgICAgZWFjaCBkbyB8dmFsdWV8XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlXHJcbiAgICAgIGVuZFxyXG4gICAgZWxzZVxyXG4gICAgICByZXN1bHQgPSBbXVxyXG4gICAgICBudW1iZXIgPSBgJGNvZXJjZV90byhudW1iZXIsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxyXG5cclxuICAgICAgaWYgYG51bWJlciA8IDBgXHJcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnYXR0ZW1wdCB0byB0YWtlIG5lZ2F0aXZlIHNpemUnXHJcbiAgICAgIGVuZFxyXG5cclxuICAgICAgaWYgYG51bWJlciA9PSAwYFxyXG4gICAgICAgIHJldHVybiBbXVxyXG4gICAgICBlbmRcclxuXHJcbiAgICAgIGN1cnJlbnQgPSAwXHJcblxyXG4gICAgICBlYWNoIGRvIHwqYXJnc3xcclxuICAgICAgICBgcmVzdWx0LnB1c2goI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYXJncyl9KWBcclxuXHJcbiAgICAgICAgaWYgYG51bWJlciA8PSArK2N1cnJlbnRgXHJcbiAgICAgICAgICByZXR1cm4gcmVzdWx0XHJcbiAgICAgICAgZW5kXHJcbiAgICAgIGVuZFxyXG5cclxuICAgICAgcmVzdWx0XHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmIGdyZXAocGF0dGVybiwgJmJsb2NrKVxyXG4gICAgcmVzdWx0ID0gW11cclxuXHJcbiAgICBlYWNoIGRvIHwqdmFsdWV8XHJcbiAgICAgIGNtcCA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXHJcbiAgICAgIG5leHQgdW5sZXNzIHBhdHRlcm4uX19zZW5kX18oOj09PSwgKmNtcClcclxuICAgICAgaWYgYmxvY2tfZ2l2ZW4/XHJcbiAgICAgICAgdmFsdWUgPSBbdmFsdWVdIGlmIHZhbHVlLmxlbmd0aCA+IDFcclxuICAgICAgICB2YWx1ZSA9IHlpZWxkKCp2YWx1ZSlcclxuICAgICAgZWxzaWYgdmFsdWUubGVuZ3RoIDw9IDFcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdXHJcbiAgICAgIGVuZFxyXG5cclxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpXHJcbiAgICBlbmRcclxuXHJcbiAgICByZXN1bHRcclxuICBlbmRcclxuXHJcbiAgZGVmIGdyZXBfdihwYXR0ZXJuLCAmYmxvY2spXHJcbiAgICByZXN1bHQgPSBbXVxyXG5cclxuICAgIGVhY2ggZG8gfCp2YWx1ZXxcclxuICAgICAgY21wID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcclxuICAgICAgbmV4dCBpZiBwYXR0ZXJuLl9fc2VuZF9fKDo9PT0sICpjbXApXHJcbiAgICAgIGlmIGJsb2NrX2dpdmVuP1xyXG4gICAgICAgIHZhbHVlID0gW3ZhbHVlXSBpZiB2YWx1ZS5sZW5ndGggPiAxXHJcbiAgICAgICAgdmFsdWUgPSB5aWVsZCgqdmFsdWUpXHJcbiAgICAgIGVsc2lmIHZhbHVlLmxlbmd0aCA8PSAxXHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZVswXVxyXG4gICAgICBlbmRcclxuXHJcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKVxyXG4gICAgZW5kXHJcblxyXG4gICAgcmVzdWx0XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBncm91cF9ieSgmYmxvY2spXHJcbiAgICByZXR1cm4gZW51bV9mb3IoOmdyb3VwX2J5KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cclxuXHJcbiAgICBoYXNoID0ge31cclxuXHJcbiAgICAleHtcclxuICAgICAgdmFyIHJlc3VsdDtcclxuXHJcbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcclxuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBwYXJhbSk7XHJcblxyXG4gICAgICAgICN7KGhhc2hbYHZhbHVlYF0gfHw9IFtdKSA8PCBgcGFyYW1gfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc2VsZi4kZWFjaCgpO1xyXG5cclxuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGhhc2hcclxuICBlbmRcclxuXHJcbiAgZGVmIGluY2x1ZGU/KG9iailcclxuICAgIGVhY2ggZG8gfCphcmdzfFxyXG4gICAgICBpZiA6Ok9wYWwuZGVzdHJ1Y3R1cmUoYXJncykgPT0gb2JqXHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgZW5kXHJcbiAgICBlbmRcclxuXHJcbiAgICBmYWxzZVxyXG4gIGVuZFxyXG5cclxuICBkZWYgaW5qZWN0KG9iamVjdCA9IHVuZGVmaW5lZCwgc3ltID0gdW5kZWZpbmVkLCAmYmxvY2spXHJcbiAgICAleHtcclxuICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdDtcclxuXHJcbiAgICAgIGlmIChibG9jayAhPT0gbmlsICYmIHN5bSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHZhciB2YWx1ZSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XHJcblxyXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFsdWUgPSAkeWllbGRYKGJsb2NrLCBbcmVzdWx0LCB2YWx1ZV0pO1xyXG5cclxuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKHN5bSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBpZiAoISN7OjpTeW1ib2wgPT09IG9iamVjdH0pIHtcclxuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCIje29iamVjdC5pbnNwZWN0fSBpcyBub3QgYSBTeW1ib2xcIn07XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgc3ltICAgID0gb2JqZWN0O1xyXG4gICAgICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHZhciB2YWx1ZSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XHJcblxyXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmVzdWx0ID0gI3tgcmVzdWx0YC5fX3NlbmRfXyBzeW0sIGB2YWx1ZWB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNlbGYuJGVhY2goKTtcclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQgPT0gdW5kZWZpbmVkID8gbmlsIDogcmVzdWx0O1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgbGF6eVxyXG4gICAgOjpFbnVtZXJhdG9yOjpMYXp5Lm5ldyhzZWxmLCBlbnVtZXJhdG9yX3NpemUpIGRvIHxlbnVtLCAqYXJnc3xcclxuICAgICAgZW51bS55aWVsZCgqYXJncylcclxuICAgIGVuZFxyXG4gIGVuZFxyXG5cclxuICBkZWYgZW51bWVyYXRvcl9zaXplXHJcbiAgICByZXNwb25kX3RvPyg6c2l6ZSkgPyBzaXplIDogbmlsXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBtYXgobiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChuID09PSB1bmRlZmluZWQgfHwgbiA9PT0gbmlsKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCwgdmFsdWU7XHJcblxyXG4gICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB2YXIgaXRlbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XHJcblxyXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGl0ZW07XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZFgoYmxvY2ssIFtpdGVtLCByZXN1bHRdKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gI3tgaXRlbWAgPD0+IGByZXN1bHRgfTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xyXG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2NvbXBhcmlzb24gZmFpbGVkJ307XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHZhbHVlID4gMCkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBpdGVtO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2VsZi4kZWFjaCgpO1xyXG5cclxuICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHJldHVybiBuaWw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBuID0gJGNvZXJjZV90byhuLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcclxuICAgIH1cclxuXHJcbiAgICBzb3J0KCZibG9jaykucmV2ZXJzZS5maXJzdChuKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgbWF4X2J5KG4gPSBuaWwsICZibG9jaylcclxuICAgIHJldHVybiBlbnVtX2Zvcig6bWF4X2J5LCBuKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja1xyXG5cclxuICAgIHVubGVzcyBuLm5pbD9cclxuICAgICAgcmV0dXJuIHNvcnRfYnkoJmJsb2NrKS5yZXZlcnNlLnRha2UgblxyXG4gICAgZW5kXHJcblxyXG4gICAgJXh7XHJcbiAgICAgIHZhciByZXN1bHQsXHJcbiAgICAgICAgICBieTtcclxuXHJcbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcclxuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBwYXJhbSk7XHJcblxyXG4gICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgcmVzdWx0ID0gcGFyYW07XHJcbiAgICAgICAgICBieSAgICAgPSB2YWx1ZTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgje2B2YWx1ZWAgPD0+IGBieWB9ID4gMCkge1xyXG4gICAgICAgICAgcmVzdWx0ID0gcGFyYW1cclxuICAgICAgICAgIGJ5ICAgICA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIHNlbGYuJGVhY2goKTtcclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IG5pbCA6IHJlc3VsdDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIG1pbihuID0gbmlsLCAmYmxvY2spXHJcbiAgICB1bmxlc3Mgbi5uaWw/XHJcbiAgICAgIGlmIGJsb2NrX2dpdmVuP1xyXG4gICAgICAgIHJldHVybiBzb3J0IHsgfGEsIGJ8IHlpZWxkIGEsIGIgfS50YWtlIG5cclxuICAgICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBzb3J0LnRha2UgblxyXG4gICAgICBlbmRcclxuICAgIGVuZFxyXG5cclxuICAgICV4e1xyXG4gICAgICB2YXIgcmVzdWx0O1xyXG5cclxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcclxuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcclxuXHJcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcGFyYW07XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgdmFsdWUgPSBibG9jayhwYXJhbSwgcmVzdWx0KTtcclxuXHJcbiAgICAgICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xyXG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2NvbXBhcmlzb24gZmFpbGVkJ307XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHZhbHVlIDwgMCkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xyXG5cclxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmICgjezo6T3BhbC5jb21wYXJlKGBwYXJhbWAsIGByZXN1bHRgKX0gPCAwKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcmFtO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNlbGYuJGVhY2goKTtcclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IG5pbCA6IHJlc3VsdDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIG1pbl9ieShuID0gbmlsLCAmYmxvY2spXHJcbiAgICByZXR1cm4gZW51bV9mb3IoOm1pbl9ieSwgbikgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tcclxuXHJcbiAgICB1bmxlc3Mgbi5uaWw/XHJcbiAgICAgIHJldHVybiBzb3J0X2J5KCZibG9jaykudGFrZSBuXHJcbiAgICBlbmRcclxuXHJcbiAgICAleHtcclxuICAgICAgdmFyIHJlc3VsdCxcclxuICAgICAgICAgIGJ5O1xyXG5cclxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxyXG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHBhcmFtKTtcclxuXHJcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcclxuICAgICAgICAgIGJ5ICAgICA9IHZhbHVlO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCN7YHZhbHVlYCA8PT4gYGJ5YH0gPCAwKSB7XHJcbiAgICAgICAgICByZXN1bHQgPSBwYXJhbVxyXG4gICAgICAgICAgYnkgICAgID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgc2VsZi4kZWFjaCgpO1xyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gbmlsIDogcmVzdWx0O1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgbWlubWF4KCZibG9jaylcclxuICAgIGJsb2NrIHx8PSA6Oktlcm5lbC5wcm9jIHsgfGEsIGJ8IGEgPD0+IGIgfVxyXG5cclxuICAgICV4e1xyXG4gICAgICB2YXIgbWluID0gbmlsLCBtYXggPSBuaWwsIGZpcnN0X3RpbWUgPSB0cnVlO1xyXG5cclxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgZWxlbWVudCA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XHJcbiAgICAgICAgaWYgKGZpcnN0X3RpbWUpIHtcclxuICAgICAgICAgIG1pbiA9IG1heCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICBmaXJzdF90aW1lID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHZhciBtaW5fY21wID0gI3tibG9jay5jYWxsKGBtaW5gLCBgZWxlbWVudGApfTtcclxuXHJcbiAgICAgICAgICBpZiAobWluX2NtcCA9PT0gbmlsKSB7XHJcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnY29tcGFyaXNvbiBmYWlsZWQnfVxyXG4gICAgICAgICAgfSBlbHNlIGlmIChtaW5fY21wID4gMCkge1xyXG4gICAgICAgICAgICBtaW4gPSBlbGVtZW50O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHZhciBtYXhfY21wID0gI3tibG9jay5jYWxsKGBtYXhgLCBgZWxlbWVudGApfTtcclxuXHJcbiAgICAgICAgICBpZiAobWF4X2NtcCA9PT0gbmlsKSB7XHJcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnY29tcGFyaXNvbiBmYWlsZWQnfVxyXG4gICAgICAgICAgfSBlbHNlIGlmIChtYXhfY21wIDwgMCkge1xyXG4gICAgICAgICAgICBtYXggPSBlbGVtZW50O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgc2VsZi4kZWFjaCgpO1xyXG5cclxuICAgICAgcmV0dXJuIFttaW4sIG1heF07XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBtaW5tYXhfYnkoJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVudW1fZm9yKDptaW5tYXhfYnkpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrXHJcblxyXG4gICAgJXh7XHJcbiAgICAgIHZhciBtaW5fcmVzdWx0ID0gbmlsLFxyXG4gICAgICAgICAgbWF4X3Jlc3VsdCA9IG5pbCxcclxuICAgICAgICAgIG1pbl9ieSxcclxuICAgICAgICAgIG1heF9ieTtcclxuXHJcbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcclxuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBwYXJhbSk7XHJcblxyXG4gICAgICAgIGlmICgobWluX2J5ID09PSB1bmRlZmluZWQpIHx8ICN7YHZhbHVlYCA8PT4gYG1pbl9ieWB9IDwgMCkge1xyXG4gICAgICAgICAgbWluX3Jlc3VsdCA9IHBhcmFtO1xyXG4gICAgICAgICAgbWluX2J5ICAgICA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKChtYXhfYnkgPT09IHVuZGVmaW5lZCkgfHwgI3tgdmFsdWVgIDw9PiBgbWF4X2J5YH0gPiAwKSB7XHJcbiAgICAgICAgICBtYXhfcmVzdWx0ID0gcGFyYW07XHJcbiAgICAgICAgICBtYXhfYnkgICAgID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgc2VsZi4kZWFjaCgpO1xyXG5cclxuICAgICAgcmV0dXJuIFttaW5fcmVzdWx0LCBtYXhfcmVzdWx0XTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIG5vbmU/KHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcclxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWRgXHJcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcclxuICAgICAgICBjb21wYXJhYmxlID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlIGlmIHBhdHRlcm4ucHVibGljX3NlbmQoOj09PSwgKmNvbXBhcmFibGUpXHJcbiAgICAgIGVuZFxyXG4gICAgZWxzaWYgYmxvY2tfZ2l2ZW4/XHJcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcclxuICAgICAgICBpZiB5aWVsZCgqdmFsdWUpXHJcbiAgICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgICBlbmRcclxuICAgICAgZW5kXHJcbiAgICBlbHNlXHJcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcclxuICAgICAgICBpdGVtID0gOjpPcGFsLmRlc3RydWN0dXJlKHZhbHVlKVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2UgaWYgaXRlbVxyXG4gICAgICBlbmRcclxuICAgIGVuZFxyXG5cclxuICAgIHRydWVcclxuICBlbmRcclxuXHJcbiAgZGVmIG9uZT8ocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxyXG4gICAgY291bnQgPSAwXHJcblxyXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZGBcclxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxyXG4gICAgICAgIGNvbXBhcmFibGUgPSBgY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpYFxyXG5cclxuICAgICAgICBpZiBwYXR0ZXJuLnB1YmxpY19zZW5kKDo9PT0sICpjb21wYXJhYmxlKVxyXG4gICAgICAgICAgY291bnQgKz0gMVxyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlIGlmIGNvdW50ID4gMVxyXG4gICAgICAgIGVuZFxyXG4gICAgICBlbmRcclxuICAgIGVsc2lmIGJsb2NrX2dpdmVuP1xyXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XHJcbiAgICAgICAgbmV4dCB1bmxlc3MgeWllbGQoKnZhbHVlKVxyXG4gICAgICAgIGNvdW50ICs9IDFcclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlIGlmIGNvdW50ID4gMVxyXG4gICAgICBlbmRcclxuICAgIGVsc2VcclxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxyXG4gICAgICAgIG5leHQgdW5sZXNzIDo6T3BhbC5kZXN0cnVjdHVyZSh2YWx1ZSlcclxuICAgICAgICBjb3VudCArPSAxXHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZSBpZiBjb3VudCA+IDFcclxuICAgICAgZW5kXHJcbiAgICBlbmRcclxuXHJcbiAgICBjb3VudCA9PSAxXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBwYXJ0aXRpb24oJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVudW1fZm9yKDpwYXJ0aXRpb24pIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG5cclxuICAgICV4e1xyXG4gICAgICB2YXIgdHJ1dGh5ID0gW10sIGZhbHN5ID0gW10sIHJlc3VsdDtcclxuXHJcbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcclxuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBwYXJhbSk7XHJcblxyXG4gICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSkge1xyXG4gICAgICAgICAgdHJ1dGh5LnB1c2gocGFyYW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIGZhbHN5LnB1c2gocGFyYW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIHNlbGYuJGVhY2goKTtcclxuXHJcbiAgICAgIHJldHVybiBbdHJ1dGh5LCBmYWxzeV07XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiByZWplY3QoJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZWplY3QpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG5cclxuICAgICV4e1xyXG4gICAgICB2YXIgcmVzdWx0ID0gW107XHJcblxyXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXHJcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgcGFyYW0pO1xyXG5cclxuICAgICAgICBpZiAoISR0cnV0aHkodmFsdWUpKSB7XHJcbiAgICAgICAgICByZXN1bHQucHVzaChwYXJhbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgc2VsZi4kZWFjaCgpO1xyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHJldmVyc2VfZWFjaCgmYmxvY2spXHJcbiAgICByZXR1cm4gZW51bV9mb3IoOnJldmVyc2VfZWFjaCkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XHJcblxyXG4gICAgJXh7XHJcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuXHJcbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmVzdWx0LnB1c2goYXJndW1lbnRzKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHNlbGYuJGVhY2goKTtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSByZXN1bHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAkeWllbGRYKGJsb2NrLCByZXN1bHRbaV0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc2xpY2VfYmVmb3JlKHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcclxuICAgIGlmIGBwYXR0ZXJuID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbGBcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnYm90aCBwYXR0ZXJuIGFuZCBibG9jayBhcmUgZ2l2ZW4nXHJcbiAgICBlbmRcclxuXHJcbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkICYmIGJsb2NrICE9PSBuaWwgfHwgYXJndW1lbnRzLmxlbmd0aCA+IDFgXHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcmd1bWVudHMubGVuZ3RoYH0gZXhwZWN0ZWQgMSlcIlxyXG4gICAgZW5kXHJcblxyXG4gICAgOjpFbnVtZXJhdG9yLm5ldyBkbyB8ZXxcclxuICAgICAgJXh7XHJcbiAgICAgICAgdmFyIHNsaWNlID0gW107XHJcblxyXG4gICAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XHJcbiAgICAgICAgICBpZiAocGF0dGVybiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcclxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBwYXJhbSk7XHJcblxyXG4gICAgICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSAmJiBzbGljZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAje2UgPDwgYHNsaWNlYH07XHJcbiAgICAgICAgICAgICAgICBzbGljZSA9IFtdO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgc2xpY2UucHVzaChwYXJhbSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IGJsb2NrKHBhcmFtLCAje3BhdHRlcm4uZHVwfSk7XHJcblxyXG4gICAgICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSAmJiBzbGljZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAje2UgPDwgYHNsaWNlYH07XHJcbiAgICAgICAgICAgICAgICBzbGljZSA9IFtdO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgc2xpY2UucHVzaChwYXJhbSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gI3twYXR0ZXJuID09PSBgcGFyYW1gfTtcclxuXHJcbiAgICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSAmJiBzbGljZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgI3tlIDw8IGBzbGljZWB9O1xyXG4gICAgICAgICAgICAgIHNsaWNlID0gW107XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHNsaWNlLnB1c2gocGFyYW0pO1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNlbGYuJGVhY2goKTtcclxuXHJcbiAgICAgICAgaWYgKHNsaWNlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICN7ZSA8PCBgc2xpY2VgfTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIGVuZFxyXG4gIGVuZFxyXG5cclxuICBkZWYgc2xpY2VfYWZ0ZXIocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxyXG4gICAgaWYgYHBhdHRlcm4gPT09IHVuZGVmaW5lZCAmJiBibG9jayA9PT0gbmlsYFxyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdib3RoIHBhdHRlcm4gYW5kIGJsb2NrIGFyZSBnaXZlbidcclxuICAgIGVuZFxyXG5cclxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWQgJiYgYmxvY2sgIT09IG5pbCB8fCBhcmd1bWVudHMubGVuZ3RoID4gMWBcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBleHBlY3RlZCAxKVwiXHJcbiAgICBlbmRcclxuXHJcbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkYFxyXG4gICAgICBibG9jayA9IDo6S2VybmVsLnByb2MgeyB8ZXwgcGF0dGVybiA9PT0gZSB9XHJcbiAgICBlbmRcclxuXHJcbiAgICA6OkVudW1lcmF0b3IubmV3IGRvIHx5aWVsZGVyfFxyXG4gICAgICAleHtcclxuICAgICAgICB2YXIgYWNjdW11bGF0ZTtcclxuXHJcbiAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHZhciBlbGVtZW50ID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcclxuICAgICAgICAgICAgICBlbmRfY2h1bmsgPSAkeWllbGQxKGJsb2NrLCBlbGVtZW50KTtcclxuXHJcbiAgICAgICAgICBpZiAoYWNjdW11bGF0ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGFjY3VtdWxhdGUgPSBbXTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoJHRydXRoeShlbmRfY2h1bmspKSB7XHJcbiAgICAgICAgICAgIGFjY3VtdWxhdGUucHVzaChlbGVtZW50KTtcclxuICAgICAgICAgICAgI3t5aWVsZGVyLnlpZWxkKGBhY2N1bXVsYXRlYCl9O1xyXG4gICAgICAgICAgICBhY2N1bXVsYXRlID0gbnVsbDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGFjY3VtdWxhdGUucHVzaChlbGVtZW50KVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2VsZi4kZWFjaCgpO1xyXG5cclxuICAgICAgICBpZiAoYWNjdW11bGF0ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAje3lpZWxkZXIueWllbGQoYGFjY3VtdWxhdGVgKX07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmIHNsaWNlX3doZW4oJmJsb2NrKVxyXG4gICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMSknIHVubGVzcyBibG9ja19naXZlbj9cclxuXHJcbiAgICA6OkVudW1lcmF0b3IubmV3IGRvIHx5aWVsZGVyfFxyXG4gICAgICAleHtcclxuICAgICAgICB2YXIgc2xpY2UgPSBuaWwsIGxhc3RfYWZ0ZXIgPSBuaWw7XHJcblxyXG4gICAgICAgIHNlbGYuJGVhY2hfY29ucy4kJHAgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHZhciBwYXJhbXMgPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxyXG4gICAgICAgICAgICAgIGJlZm9yZSA9IHBhcmFtc1swXSxcclxuICAgICAgICAgICAgICBhZnRlciA9IHBhcmFtc1sxXSxcclxuICAgICAgICAgICAgICBtYXRjaCA9ICR5aWVsZFgoYmxvY2ssIFtiZWZvcmUsIGFmdGVyXSk7XHJcblxyXG4gICAgICAgICAgbGFzdF9hZnRlciA9IGFmdGVyO1xyXG5cclxuICAgICAgICAgIGlmIChzbGljZSA9PT0gbmlsKSB7XHJcbiAgICAgICAgICAgIHNsaWNlID0gW107XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKCR0cnV0aHkobWF0Y2gpKSB7XHJcbiAgICAgICAgICAgIHNsaWNlLnB1c2goYmVmb3JlKTtcclxuICAgICAgICAgICAgI3t5aWVsZGVyLnlpZWxkKGBzbGljZWApfTtcclxuICAgICAgICAgICAgc2xpY2UgPSBbXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNsaWNlLnB1c2goYmVmb3JlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNlbGYuJGVhY2hfY29ucygyKTtcclxuXHJcbiAgICAgICAgaWYgKHNsaWNlICE9PSBuaWwpIHtcclxuICAgICAgICAgIHNsaWNlLnB1c2gobGFzdF9hZnRlcik7XHJcbiAgICAgICAgICAje3lpZWxkZXIueWllbGQoYHNsaWNlYCl9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzb3J0KCZibG9jaylcclxuICAgIGFyeSA9IHRvX2FcclxuICAgIGJsb2NrID0gLT4oYSwgYikgeyBhIDw9PiBiIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG4gICAgYXJ5LnNvcnQoJmJsb2NrKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc29ydF9ieSgmYmxvY2spXHJcbiAgICByZXR1cm4gZW51bV9mb3IoOnNvcnRfYnkpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG5cclxuICAgIGR1cCA9IG1hcCBkb1xyXG4gICAgICBhcmcgPSA6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApXHJcbiAgICAgIFt5aWVsZChhcmcpLCBhcmddXHJcbiAgICBlbmRcclxuICAgIGR1cC5zb3J0ISB7IHxhLCBifCBgYVswXWAgPD0+IGBiWzBdYCB9XHJcbiAgICBkdXAubWFwISB7IHxpfCBgaVsxXWAgfVxyXG4gIGVuZFxyXG5cclxuICAjIFRoaXMgbWV0aG9kIGltcGxlbWVudHMgdGhlIEthaGFuIHN1bW1hdGlvbiBhbGdvcml0aG0gaWYgaXQgaXMgcG9zc2libGUgdG8gYXBwbHkgb25lLlxyXG4gIGRlZiBzdW0oaW5pdGlhbCA9IDApXHJcbiAgICByZXN1bHQgPSBpbml0aWFsXHJcbiAgICBjb21wZW5zYXRpb24gPSAwXHJcblxyXG4gICAgZWFjaCBkbyB8KmFyZ3N8XHJcbiAgICAgIGl0ZW0gPSBpZiBibG9ja19naXZlbj9cclxuICAgICAgICAgICAgICAgeWllbGQoKmFyZ3MpXHJcbiAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgIDo6T3BhbC5kZXN0cnVjdHVyZShhcmdzKVxyXG4gICAgICAgICAgICAgZW5kXHJcblxyXG4gICAgICBpZiAhWzo6RmxvYXQ6OklORklOSVRZLCAtOjpGbG9hdDo6SU5GSU5JVFldLmluY2x1ZGU/KGl0ZW0pICYmIGl0ZW0ucmVzcG9uZF90bz8oOi0pXHJcbiAgICAgICAgeSA9IGl0ZW0gLSBjb21wZW5zYXRpb25cclxuICAgICAgICB0ID0gcmVzdWx0ICsgeVxyXG4gICAgICAgIGNvbXBlbnNhdGlvbiA9ICh0IC0gcmVzdWx0KSAtIHlcclxuICAgICAgICByZXN1bHQgPSB0XHJcbiAgICAgIGVsc2VcclxuICAgICAgICByZXN1bHQgKz0gaXRlbVxyXG4gICAgICBlbmRcclxuICAgIGVuZFxyXG5cclxuICAgIHJlc3VsdFxyXG4gIGVuZFxyXG5cclxuICBkZWYgdGFrZShudW0pXHJcbiAgICBmaXJzdChudW0pXHJcbiAgZW5kXHJcblxyXG4gIGRlZiB0YWtlX3doaWxlKCZibG9jaylcclxuICAgIHJldHVybiBlbnVtX2ZvciA6dGFrZV93aGlsZSB1bmxlc3MgYmxvY2tcclxuXHJcbiAgICByZXN1bHQgPSBbXVxyXG5cclxuICAgIGVhY2ggZG8gfCphcmdzfFxyXG4gICAgICB2YWx1ZSA9IDo6T3BhbC5kZXN0cnVjdHVyZShhcmdzKVxyXG5cclxuICAgICAgdW5sZXNzIHlpZWxkKHZhbHVlKVxyXG4gICAgICAgIHJldHVybiByZXN1bHRcclxuICAgICAgZW5kXHJcblxyXG4gICAgICBgcmVzdWx0LnB1c2godmFsdWUpYFxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiB1bmlxKCZibG9jaylcclxuICAgIGhhc2ggPSB7fVxyXG5cclxuICAgIGVhY2ggZG8gfCphcmdzfFxyXG4gICAgICB2YWx1ZSA9IDo6T3BhbC5kZXN0cnVjdHVyZShhcmdzKVxyXG5cclxuICAgICAgcHJvZHVjZWQgPSBpZiBibG9ja19naXZlbj9cclxuICAgICAgICAgICAgICAgICAgIHlpZWxkKHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgZW5kXHJcblxyXG4gICAgICB1bmxlc3MgaGFzaC5rZXk/KHByb2R1Y2VkKVxyXG4gICAgICAgIGhhc2hbcHJvZHVjZWRdID0gdmFsdWVcclxuICAgICAgZW5kXHJcbiAgICBlbmRcclxuXHJcbiAgICBoYXNoLnZhbHVlc1xyXG4gIGVuZFxyXG5cclxuICBkZWYgdGFsbHkoaGFzaCA9IHVuZGVmaW5lZClcclxuICAgIGBpZiAoaGFzaCAmJiBoYXNoICE9PSBuaWwpIHsgJGRlbnlfZnJvemVuX2FjY2VzcyhoYXNoKTsgfWBcclxuXHJcbiAgICBvdXQgPSBncm91cF9ieSgmOml0c2VsZikudHJhbnNmb3JtX3ZhbHVlcygmOmNvdW50KVxyXG4gICAgaWYgaGFzaFxyXG4gICAgICBvdXQuZWFjaCB7IHxrLCB2fCBoYXNoW2tdID0gaGFzaC5mZXRjaChrLCAwKSArIHYgfVxyXG4gICAgICBoYXNoXHJcbiAgICBlbHNlXHJcbiAgICAgIG91dFxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiB0b19oKCphcmdzLCAmYmxvY2spXHJcbiAgICByZXR1cm4gbWFwKCZibG9jaykudG9faCgqYXJncykgaWYgYmxvY2tfZ2l2ZW4/XHJcblxyXG4gICAgJXh7XHJcbiAgICAgIHZhciBoYXNoID0gI3t7fX07XHJcblxyXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XHJcbiAgICAgICAgdmFyIGFyeSA9ICN7OjpPcGFsLmNvZXJjZV90bz8oYHBhcmFtYCwgOjpBcnJheSwgOnRvX2FyeSl9LCBrZXksIHZhbDtcclxuICAgICAgICBpZiAoIWFyeS4kJGlzX2FycmF5KSB7XHJcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIndyb25nIGVsZW1lbnQgdHlwZSAje2BwYXJhbWAuY2xhc3N9IChleHBlY3RlZCBhcnJheSlcIn1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFyeS5sZW5ndGggIT09IDIpIHtcclxuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImVsZW1lbnQgaGFzIHdyb25nIGFycmF5IGxlbmd0aCAoZXhwZWN0ZWQgMiwgd2FzICN7YGFyeWAubGVuZ3RofSlcIn1cclxuICAgICAgICB9XHJcbiAgICAgICAga2V5ID0gYXJ5WzBdO1xyXG4gICAgICAgIHZhbCA9IGFyeVsxXTtcclxuXHJcbiAgICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBrZXksIHZhbCk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBzZWxmLiRlYWNoLmFwcGx5KHNlbGYsIGFyZ3MpO1xyXG5cclxuICAgICAgcmV0dXJuIGhhc2g7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiB0b19zZXQoa2xhc3MgPSBTZXQsICphcmdzLCAmYmxvY2spXHJcbiAgICBrbGFzcy5uZXcoc2VsZiwgKmFyZ3MsICZibG9jaylcclxuICBlbmRcclxuXHJcbiAgZGVmIHppcCgqb3RoZXJzLCAmYmxvY2spXHJcbiAgICB0b19hLnppcCgqb3RoZXJzKVxyXG4gIGVuZFxyXG5cclxuICBhbGlhcyBmaW5kIGRldGVjdFxyXG4gIGFsaWFzIGZpbHRlciBmaW5kX2FsbFxyXG4gIGFsaWFzIGZsYXRfbWFwIGNvbGxlY3RfY29uY2F0XHJcbiAgYWxpYXMgbWFwIGNvbGxlY3RcclxuICBhbGlhcyBtZW1iZXI/IGluY2x1ZGU/XHJcbiAgYWxpYXMgcmVkdWNlIGluamVjdFxyXG4gIGFsaWFzIHNlbGVjdCBmaW5kX2FsbFxyXG4gIGFsaWFzIHRvX2EgZW50cmllc1xyXG5lbmRcclxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkVudW1lcmFibGU+IiwiYWxsPyIsInBhdHRlcm4iLCJlYWNoIiwic2VsZiIsImJsb2NrIGluIGFsbD8iLCJibG9jayAoMiBsZXZlbHMpIGluIGFsbD8iLCJjb21wYXJhYmxlIiwicHVibGljX3NlbmQiLCJibG9ja19naXZlbj8iLCJ2YWx1ZSIsIk9wYWwiLCJkZXN0cnVjdHVyZSIsImFueT8iLCJibG9jayBpbiBhbnk/IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBhbnk/IiwiY2h1bmsiLCJ0b19lbnVtIiwiYmxvY2sgaW4gY2h1bmsiLCJibG9jayAoMiBsZXZlbHMpIGluIGNodW5rIiwiZW51bWVyYXRvcl9zaXplIiwibmV3IiwiRW51bWVyYXRvciIsInlpZWxkZXIiLCJ5aWVsZCIsImNodW5rX3doaWxlIiwiS2VybmVsIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwic2xpY2Vfd2hlbiIsImJsb2NrIGluIGNodW5rX3doaWxlIiwiYmVmb3JlIiwiYWZ0ZXIiLCJibG9jayAoMiBsZXZlbHMpIGluIGNodW5rX3doaWxlIiwiISIsImNvbGxlY3QiLCJlbnVtX2ZvciIsImJsb2NrIGluIGNvbGxlY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbGxlY3QiLCJjb2xsZWN0X2NvbmNhdCIsImJsb2NrIGluIGNvbGxlY3RfY29uY2F0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb2xsZWN0X2NvbmNhdCIsIm1hcCIsImJsb2NrIiwidG9fcHJvYyIsImZsYXR0ZW4iLCIxIiwiY29tcGFjdCIsInRvX2EiLCJjb3VudCIsIm9iamVjdCIsInJlc3VsdCIsIjAiLCJ3YXJuIiwicHJvYyIsImJsb2NrIGluIGNvdW50IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb3VudCIsImFyZ3MiLCI9PSIsIm5pbD8iLCJjeWNsZSIsIm4iLCJibG9jayBpbiBjeWNsZSIsImJsb2NrICgyIGxldmVscykgaW4gY3ljbGUiLCJyZXNwb25kX3RvPyIsIkZsb2F0OjpJTkZJTklUWSIsIkZsb2F0IiwiY29lcmNlX3RvISIsIkludGVnZXIiLCI+IiwiKiIsImRldGVjdCIsImlmbm9uZSIsImJsb2NrIGluIGRldGVjdCIsImJsb2NrICgyIGxldmVscykgaW4gZGV0ZWN0IiwiZHJvcCIsIm51bWJlciIsImRyb3Bfd2hpbGUiLCJlYWNoX2NvbnMiLCJ0cnlfY29udmVydCIsImJsb2NrIGluIGVhY2hfY29ucyIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF9jb25zIiwiZW51bV9zaXplIiwiPCIsIisiLCItIiwiZWFjaF9lbnRyeSIsImRhdGEiLCJibG9jayBpbiBlYWNoX2VudHJ5IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX2VudHJ5IiwiZWFjaF9zbGljZSIsImJsb2NrIGluIGVhY2hfc2xpY2UiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfc2xpY2UiLCIvIiwic2l6ZSIsImNlaWwiLCJlYWNoX3dpdGhfaW5kZXgiLCJibG9jayBpbiBlYWNoX3dpdGhfaW5kZXgiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfd2l0aF9pbmRleCIsImVhY2hfd2l0aF9vYmplY3QiLCJibG9jayBpbiBlYWNoX3dpdGhfb2JqZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX3dpdGhfb2JqZWN0IiwiZW50cmllcyIsImZpbHRlcl9tYXAiLCJibG9jayBpbiBmaWx0ZXJfbWFwIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmaWx0ZXJfbWFwIiwic2VsZWN0IiwiZmluZF9hbGwiLCJibG9jayBpbiBmaW5kX2FsbCIsImJsb2NrICgyIGxldmVscykgaW4gZmluZF9hbGwiLCJmaW5kX2luZGV4IiwiaW5kZXgiLCJibG9jayBpbiBmaW5kX2luZGV4IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmaW5kX2luZGV4IiwiZmlyc3QiLCJibG9jayBpbiBmaXJzdCIsImN1cnJlbnQiLCJibG9jayAoMiBsZXZlbHMpIGluIGZpcnN0IiwiZ3JlcCIsImJsb2NrIGluIGdyZXAiLCJibG9jayAoMiBsZXZlbHMpIGluIGdyZXAiLCJjbXAiLCJfX3NlbmRfXyIsImxlbmd0aCIsIjw9IiwiW10iLCJwdXNoIiwiZ3JlcF92IiwiYmxvY2sgaW4gZ3JlcF92IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBncmVwX3YiLCJncm91cF9ieSIsImJsb2NrIGluIGdyb3VwX2J5IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBncm91cF9ieSIsImhhc2giLCIkcmV0X29yXzEiLCJbXT0iLCI8PCIsImluY2x1ZGU/Iiwib2JqIiwiYmxvY2sgaW4gaW5jbHVkZT8iLCJibG9jayAoMiBsZXZlbHMpIGluIGluY2x1ZGU/IiwiaW5qZWN0Iiwic3ltIiwiU3ltYm9sIiwiPT09IiwiVHlwZUVycm9yIiwiaW5zcGVjdCIsImxhenkiLCJFbnVtZXJhdG9yOjpMYXp5IiwiYmxvY2sgaW4gbGF6eSIsImVudW0kIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBsYXp5IiwibWF4IiwiPD0+Iiwic29ydCIsInJldmVyc2UiLCJtYXhfYnkiLCJibG9jayBpbiBtYXhfYnkiLCJibG9jayAoMiBsZXZlbHMpIGluIG1heF9ieSIsInNvcnRfYnkiLCJ0YWtlIiwibWluIiwiYmxvY2sgaW4gbWluIiwiYSIsImIiLCJjb21wYXJlIiwibWluX2J5IiwiYmxvY2sgaW4gbWluX2J5IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBtaW5fYnkiLCJtaW5tYXgiLCJibG9jayBpbiBtaW5tYXgiLCJibG9jayAoMiBsZXZlbHMpIGluIG1pbm1heCIsImNhbGwiLCJtaW5tYXhfYnkiLCJibG9jayBpbiBtaW5tYXhfYnkiLCJibG9jayAoMiBsZXZlbHMpIGluIG1pbm1heF9ieSIsIm5vbmU/IiwiYmxvY2sgaW4gbm9uZT8iLCJibG9jayAoMiBsZXZlbHMpIGluIG5vbmU/IiwiaXRlbSIsIm9uZT8iLCJibG9jayBpbiBvbmU/IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBvbmU/IiwicGFydGl0aW9uIiwiYmxvY2sgaW4gcGFydGl0aW9uIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwYXJ0aXRpb24iLCJyZWplY3QiLCJibG9jayBpbiByZWplY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIHJlamVjdCIsInJldmVyc2VfZWFjaCIsImJsb2NrIGluIHJldmVyc2VfZWFjaCIsImJsb2NrICgyIGxldmVscykgaW4gcmV2ZXJzZV9lYWNoIiwic2xpY2VfYmVmb3JlIiwiYmxvY2sgaW4gc2xpY2VfYmVmb3JlIiwiZSIsImJsb2NrICgyIGxldmVscykgaW4gc2xpY2VfYmVmb3JlIiwiZHVwIiwic2xpY2VfYWZ0ZXIiLCJibG9jayBpbiBzbGljZV9hZnRlciIsImJsb2NrICgyIGxldmVscykgaW4gc2xpY2VfYWZ0ZXIiLCJibG9jayBpbiBzbGljZV93aGVuIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzbGljZV93aGVuIiwiYXJ5IiwiYmxvY2sgaW4gc29ydCIsImJsb2NrICgyIGxldmVscykgaW4gc29ydCIsImJsb2NrIGluIHNvcnRfYnkiLCJibG9jayAoMiBsZXZlbHMpIGluIHNvcnRfYnkiLCJhcmciLCJzb3J0ISIsIm1hcCEiLCJpIiwic3VtIiwiaW5pdGlhbCIsImNvbXBlbnNhdGlvbiIsImJsb2NrIGluIHN1bSIsImJsb2NrICgyIGxldmVscykgaW4gc3VtIiwiLUAiLCJ5IiwidCIsIm51bSIsInRha2Vfd2hpbGUiLCJibG9jayBpbiB0YWtlX3doaWxlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0YWtlX3doaWxlIiwidW5pcSIsImJsb2NrIGluIHVuaXEiLCJibG9jayAoMiBsZXZlbHMpIGluIHVuaXEiLCJwcm9kdWNlZCIsImtleT8iLCJ2YWx1ZXMiLCJ0YWxseSIsIm91dCIsInRyYW5zZm9ybV92YWx1ZXMiLCJibG9jayBpbiB0YWxseSIsImsiLCJ2IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0YWxseSIsImZldGNoIiwidG9faCIsImNvZXJjZV90bz8iLCJBcnJheSIsImNsYXNzIiwidG9fc2V0IiwiU2V0Iiwia2xhc3MiLCJ6aXAiLCJvdGhlcnMiXSwibWFwcGluZ3MiOiJBQUFBQSxxQ0FBQUEsZ0JBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTtFQUlBQSxPQUFBQztFQUFBQTs7SUFBQUE7Ozs7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O0FBRUFBO0FBQ0FBO0lBeEJFQSxDQUFBQSxJQUFBQTs7QUEyQkFJLElBQUFBLHNCQUFBQSxrQkF4dkNGLEVBd3ZDWSxFQXh2Q1osRUF3dkNFQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQXh2Q0Y7O01Bd3ZDYSxzREFBQSwyQkFBUUM7TUFBSztNQUN0QkQsT0FBSzVOLE1BQUw4TixLQUFLOU4sT0FBQUEsRUFBTCxDQUFVakIsSUFBVixDQUFBLFFBQWdCLE1BQUNxRCxJQUFELENBQWhCLENBQUtwQyxFQUFtQnNCLEtBQURDLFNBQUFBLENBQUFBLENBQWxCdkI7SUFEUDROLENBQUFBLElBQUFBOztBQUlBRyxJQUFBQSxtQkFBQUEsZUE1dkNGLEVBNHZDRUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUE1dkNGO01BNHZDVTtNQUNOQSxPQUFJQSxNQUFKaFAsSUFBQTRDLE1BQUFBLENBQUFBLENBQUlvTSxPQUFBQSxFQUFLLE1BQUNDLE1BQUQsQ0FBTEQ7SUFETkEsQ0FBQUEsSUFBQUE7SUFJQSxhQUFNLE1BQU4sRUFBVyxRQUFYO0lBQ0EsYUFBTSxRQUFOLEVBQWEsVUFBYjtJQUNBLGFBQU0sVUFBTixFQUFlLGdCQUFmO0lBQ0EsYUFBTSxLQUFOLEVBQVUsU0FBVjtJQUNBLGFBQU0sU0FBTixFQUFjLFVBQWQ7SUFDQSxhQUFNLFFBQU4sRUFBYSxRQUFiO0lBQ0EsYUFBTSxRQUFOLEVBQWEsVUFBYjtJQUNBcFAsT0FBQSxhQUFNLE1BQU4sRUFBVyxTQUFYO0VBbndDRkEsR0FBTyxJQUFQQTtBQUpBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MTIzODIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2VudW1lcmF0b3IvYXJpdGhtZXRpY19zZXF1ZW5jZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcclxuIyB1c2Vfc3RyaWN0OiB0cnVlXHJcblxyXG5jbGFzcyA6OkVudW1lcmF0b3JcclxuICBjbGFzcyBzZWxmOjpBcml0aG1ldGljU2VxdWVuY2UgPCBzZWxmXHJcbiAgICBgT3BhbC5wcm9wKHNlbGYuJCRwcm90b3R5cGUsICckJGlzX2FyaXRobWV0aWNfc2VxJywgdHJ1ZSlgXHJcblxyXG4gICAgYHZhciBpbmYgPSBJbmZpbml0eWBcclxuXHJcbiAgICAjIEBwcml2YXRlXHJcbiAgICBkZWYgaW5pdGlhbGl6ZShyYW5nZSwgc3RlcCA9IHVuZGVmaW5lZCwgY3JlYXRpb25fbWV0aG9kID0gOnN0ZXApXHJcbiAgICAgIEBjcmVhdGlvbl9tZXRob2QgPSBjcmVhdGlvbl9tZXRob2RcclxuICAgICAgaWYgcmFuZ2UuaXNfYT8gOjpBcnJheVxyXG4gICAgICAgIEBzdGVwX2FyZzEsIEBzdGVwX2FyZzIsIEB0b3BmeCwgQGJ5cGZ4ID0gKnJhbmdlXHJcbiAgICAgICAgQHJlY2VpdmVyX251bSA9IHN0ZXBcclxuICAgICAgICBAc3RlcCA9IDFcclxuXHJcbiAgICAgICAgQHJhbmdlID0gaWYgQHN0ZXBfYXJnMlxyXG4gICAgICAgICAgICAgICAgICAgQHN0ZXAgPSBAc3RlcF9hcmcyXHJcbiAgICAgICAgICAgICAgICAgICAoQHJlY2VpdmVyX251bS4uQHN0ZXBfYXJnMSlcclxuICAgICAgICAgICAgICAgICBlbHNpZiBAc3RlcF9hcmcxXHJcbiAgICAgICAgICAgICAgICAgICAoQHJlY2VpdmVyX251bS4uQHN0ZXBfYXJnMSlcclxuICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAoQHJlY2VpdmVyX251bS4ubmlsKVxyXG4gICAgICAgICAgICAgICAgIGVuZFxyXG4gICAgICBlbHNlXHJcbiAgICAgICAgQHNraXBwZWRfYXJnID0gdHJ1ZSB1bmxlc3Mgc3RlcFxyXG4gICAgICAgIEByYW5nZSwgQHN0ZXAgPSByYW5nZSwgc3RlcCB8fCAxXHJcbiAgICAgIGVuZFxyXG5cclxuICAgICAgQG9iamVjdCA9IHNlbGZcclxuXHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIEFyZ3VtZW50RXJyb3IsIFwic3RlcCBjYW4ndCBiZSAwXCIgaWYgQHN0ZXAgPT0gMFxyXG4gICAgICB1bmxlc3MgQHN0ZXAucmVzcG9uZF90bz8gOnRvX2ludFxyXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIEFyZ3VtZW50RXJyb3IsIFwibm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiAje0BzdGVwLmNsYXNzfSBcIiBcXFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpbnRvIEludGVnZXInXHJcbiAgICAgIGVuZFxyXG4gICAgZW5kXHJcblxyXG4gICAgYXR0cl9yZWFkZXIgOnN0ZXBcclxuXHJcbiAgICBkZWYgYmVnaW5cclxuICAgICAgQHJhbmdlLmJlZ2luXHJcbiAgICBlbmRcclxuXHJcbiAgICBkZWYgZW5kXHJcbiAgICAgIEByYW5nZS5lbmRcclxuICAgIGVuZFxyXG5cclxuICAgIGRlZiBleGNsdWRlX2VuZD9cclxuICAgICAgQHJhbmdlLmV4Y2x1ZGVfZW5kP1xyXG4gICAgZW5kXHJcblxyXG4gICAgIyBAcHJpdmF0ZVxyXG4gICAgZGVmIF9sZXNzZXJfdGhhbl9lbmQ/KHZhbClcclxuICAgICAgZW5kXyA9IHNlbGYuZW5kIHx8IGBpbmZgXHJcbiAgICAgIGlmIHN0ZXAgPiAwXHJcbiAgICAgICAgZXhjbHVkZV9lbmQ/ID8gdmFsIDwgZW5kXyA6IHZhbCA8PSBlbmRfXHJcbiAgICAgIGVsc2VcclxuICAgICAgICBleGNsdWRlX2VuZD8gPyB2YWwgPiBlbmRfIDogdmFsID49IGVuZF9cclxuICAgICAgZW5kXHJcbiAgICBlbmRcclxuXHJcbiAgICAjIEBwcml2YXRlXHJcbiAgICBkZWYgX2dyZWF0ZXJfdGhhbl9iZWdpbj8odmFsKVxyXG4gICAgICBiZWdpbl8gPSBzZWxmLmJlZ2luIHx8IC1gaW5mYFxyXG4gICAgICBpZiBzdGVwID4gMFxyXG4gICAgICAgIHZhbCA+IGJlZ2luX1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgdmFsIDwgYmVnaW5fXHJcbiAgICAgIGVuZFxyXG4gICAgZW5kXHJcblxyXG4gICAgZGVmIGZpcnN0KGNvdW50ID0gdW5kZWZpbmVkKVxyXG4gICAgICBpdGVyID0gc2VsZi5iZWdpbiB8fCAtYGluZmBcclxuXHJcbiAgICAgIHJldHVybiBfbGVzc2VyX3RoYW5fZW5kPyhpdGVyKSA/IGl0ZXIgOiBuaWwgdW5sZXNzIGNvdW50XHJcblxyXG4gICAgICBvdXQgPSBbXVxyXG5cclxuICAgICAgd2hpbGUgX2xlc3Nlcl90aGFuX2VuZD8oaXRlcikgJiYgY291bnQgPiAwXHJcbiAgICAgICAgb3V0IDw8IGl0ZXJcclxuICAgICAgICBpdGVyICs9IHN0ZXBcclxuICAgICAgICBjb3VudCAtPSAxXHJcbiAgICAgIGVuZFxyXG5cclxuICAgICAgb3V0XHJcbiAgICBlbmRcclxuXHJcbiAgICBkZWYgZWFjaCgmYmxvY2spXHJcbiAgICAgIHJldHVybiBzZWxmIHVubGVzcyBibG9ja19naXZlbj9cclxuXHJcbiAgICAgIGNhc2Ugc2VsZi5iZWdpblxyXG4gICAgICB3aGVuIG5pbFxyXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIFR5cGVFcnJvciwgXCJuaWwgY2FuJ3QgYmUgY29lcmNlZCBpbnRvIEludGVnZXJcIlxyXG4gICAgICBlbmRcclxuXHJcbiAgICAgIGl0ZXIgPSBzZWxmLmJlZ2luIHx8IC1gaW5mYFxyXG5cclxuICAgICAgd2hpbGUgX2xlc3Nlcl90aGFuX2VuZD8oaXRlcilcclxuICAgICAgICB5aWVsZCBpdGVyXHJcbiAgICAgICAgaXRlciArPSBzdGVwXHJcbiAgICAgIGVuZFxyXG4gICAgICBzZWxmXHJcbiAgICBlbmRcclxuXHJcbiAgICBkZWYgbGFzdChjb3VudCA9IHVuZGVmaW5lZClcclxuICAgICAgY2FzZSBzZWxmLmVuZFxyXG4gICAgICB3aGVuIGBpbmZgLCAtYGluZmBcclxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkZsb2F0RG9tYWluRXJyb3IsIHNlbGYuZW5kXHJcbiAgICAgIHdoZW4gbmlsXHJcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCAnY2Fubm90IGdldCB0aGUgbGFzdCBlbGVtZW50IG9mIGVuZGxlc3MgYXJpdGhtZXRpYyBzZXF1ZW5jZSdcclxuICAgICAgZW5kXHJcblxyXG4gICAgICBpdGVyID0gc2VsZi5lbmQgLSAoKHNlbGYuZW5kIC0gc2VsZi5iZWdpbikgJSBzdGVwKVxyXG4gICAgICBpdGVyIC09IHN0ZXAgdW5sZXNzIF9sZXNzZXJfdGhhbl9lbmQ/KGl0ZXIpXHJcblxyXG4gICAgICByZXR1cm4gX2dyZWF0ZXJfdGhhbl9iZWdpbj8oaXRlcikgPyBpdGVyIDogbmlsIHVubGVzcyBjb3VudFxyXG5cclxuICAgICAgb3V0ID0gW11cclxuXHJcbiAgICAgIHdoaWxlIF9ncmVhdGVyX3RoYW5fYmVnaW4/KGl0ZXIpICYmIGNvdW50ID4gMFxyXG4gICAgICAgIG91dCA8PCBpdGVyXHJcbiAgICAgICAgaXRlciAtPSBzdGVwXHJcbiAgICAgICAgY291bnQgLT0gMVxyXG4gICAgICBlbmRcclxuXHJcbiAgICAgIG91dC5yZXZlcnNlXHJcbiAgICBlbmRcclxuXHJcbiAgICBkZWYgc2l6ZVxyXG4gICAgICBzdGVwX3NpZ24gPSBzdGVwID4gMCA/IDEgOiAtMVxyXG5cclxuICAgICAgaWYgIV9sZXNzZXJfdGhhbl9lbmQ/KHNlbGYuYmVnaW4pXHJcbiAgICAgICAgMFxyXG4gICAgICBlbHNpZiBbLWBpbmZgLCBgaW5mYF0uaW5jbHVkZT8oc3RlcClcclxuICAgICAgICAxXHJcbiAgICAgIGVsc2lmIFstYGluZmAgKiBzdGVwX3NpZ24sIG5pbF0uaW5jbHVkZT8oc2VsZi5iZWdpbikgfHxcclxuICAgICAgICAgICAgW2BpbmZgICogc3RlcF9zaWduLCBuaWxdLmluY2x1ZGU/KHNlbGYuZW5kKVxyXG4gICAgICAgIGBpbmZgXHJcbiAgICAgIGVsc2VcclxuICAgICAgICBpdGVyID0gc2VsZi5lbmQgLSAoKHNlbGYuZW5kIC0gc2VsZi5iZWdpbikgJSBzdGVwKVxyXG4gICAgICAgIGl0ZXIgLT0gc3RlcCB1bmxlc3MgX2xlc3Nlcl90aGFuX2VuZD8oaXRlcilcclxuICAgICAgICAoKGl0ZXIgLSBzZWxmLmJlZ2luKSAvIHN0ZXApLmFicy50b19pICsgMVxyXG4gICAgICBlbmRcclxuICAgIGVuZFxyXG5cclxuICAgIGRlZiA9PShvdGhlcilcclxuICAgICAgc2VsZi5jbGFzcyA9PSBvdGhlci5jbGFzcyAmJlxyXG4gICAgICAgIHNlbGYuYmVnaW4gPT0gb3RoZXIuYmVnaW4gJiZcclxuICAgICAgICBzZWxmLmVuZCA9PSBvdGhlci5lbmQgJiZcclxuICAgICAgICBzdGVwID09IG90aGVyLnN0ZXAgJiZcclxuICAgICAgICBleGNsdWRlX2VuZD8gPT0gb3RoZXIuZXhjbHVkZV9lbmQ/XHJcbiAgICBlbmRcclxuXHJcbiAgICBkZWYgaGFzaFxyXG4gICAgICBbQXJpdGhtZXRpY1NlcXVlbmNlLCBzZWxmLmJlZ2luLCBzZWxmLmVuZCwgc3RlcCwgZXhjbHVkZV9lbmQ/XS5oYXNoXHJcbiAgICBlbmRcclxuXHJcbiAgICBkZWYgaW5zcGVjdFxyXG4gICAgICBpZiBAcmVjZWl2ZXJfbnVtXHJcbiAgICAgICAgYXJncyA9IGlmIEBzdGVwX2FyZzJcclxuICAgICAgICAgICAgICAgICBcIigje0B0b3BmeH0je0BzdGVwX2FyZzEuaW5zcGVjdH0sICN7QGJ5cGZ4fSN7QHN0ZXBfYXJnMi5pbnNwZWN0fSlcIlxyXG4gICAgICAgICAgICAgICBlbHNpZiBAc3RlcF9hcmcxXHJcbiAgICAgICAgICAgICAgICAgXCIoI3tAdG9wZnh9I3tAc3RlcF9hcmcxLmluc3BlY3R9KVwiXHJcbiAgICAgICAgICAgICAgIGVuZFxyXG5cclxuICAgICAgICBcIigje0ByZWNlaXZlcl9udW0uaW5zcGVjdH0uI3tAY3JlYXRpb25fbWV0aG9kfSN7YXJnc30pXCJcclxuICAgICAgZWxzZVxyXG4gICAgICAgIGFyZ3MgPSB1bmxlc3MgQHNraXBwZWRfYXJnXHJcbiAgICAgICAgICAgICAgICAgXCIoI3tAc3RlcH0pXCJcclxuICAgICAgICAgICAgICAgZW5kXHJcbiAgICAgICAgXCIoKCN7QHJhbmdlLmluc3BlY3R9KS4je0BjcmVhdGlvbl9tZXRob2R9I3thcmdzfSlcIlxyXG4gICAgICBlbmRcclxuICAgIGVuZFxyXG5cclxuICAgIGFsaWFzID09PSA9PVxyXG4gICAgYWxpYXMgZXFsPyA9PVxyXG4gIGVuZFxyXG5lbmRcclxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6RW51bWVyYXRvcj4iLCI8Y2xhc3M6c2VsZjo6QXJpdGhtZXRpY1NlcXVlbmNlPiIsImluaXRpYWxpemUiLCJyYW5nZSIsInN0ZXAiLCJjcmVhdGlvbl9tZXRob2QiLCJAY3JlYXRpb25fbWV0aG9kIiwiaXNfYT8iLCJBcnJheSIsIkBzdGVwX2FyZzEiLCJAc3RlcF9hcmcyIiwiQHRvcGZ4IiwiQGJ5cGZ4IiwiQHJlY2VpdmVyX251bSIsIkBzdGVwIiwiMSIsIkByYW5nZSIsIkBza2lwcGVkX2FyZyIsIiRyZXRfb3JfMSIsIkBvYmplY3QiLCJzZWxmIiwiMCIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsInJlc3BvbmRfdG8/IiwiY2xhc3MiLCJhdHRyX3JlYWRlciIsImJlZ2luIiwiZW5kIiwiZXhjbHVkZV9lbmQ/IiwiX2xlc3Nlcl90aGFuX2VuZD8iLCJ2YWwiLCJlbmRfIiwiPiIsIjwiLCI8PSIsIj49IiwiX2dyZWF0ZXJfdGhhbl9iZWdpbj8iLCJiZWdpbl8iLCItQCIsImZpcnN0IiwiY291bnQiLCJpdGVyIiwib3V0IiwiPDwiLCIrIiwiLSIsImVhY2giLCJibG9ja19naXZlbj8iLCJUeXBlRXJyb3IiLCJsYXN0IiwiRmxvYXREb21haW5FcnJvciIsIlJhbmdlRXJyb3IiLCIlIiwicmV2ZXJzZSIsInNpemUiLCJzdGVwX3NpZ24iLCItMSIsImluY2x1ZGU/IiwiKiIsIi8iLCJhYnMiLCJ0b19pIiwiPT0iLCJvdGhlciIsIiRyZXRfb3JfMiIsIiRyZXRfb3JfMyIsIiRyZXRfb3JfNCIsImhhc2giLCJBcml0aG1ldGljU2VxdWVuY2UiLCJpbnNwZWN0IiwiYXJncyJdLCJtYXBwaW5ncyI6IkFBQUFBLHlEQUFBQSxnQkFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBO0VBR0FBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUM7SUFBQUE7O01BQUFBOztBQUFBQTs7TUFDR0E7TUFFQUE7O0FBR0RDLE1BQUFBLDBCQUFBQSxzQkFBZUMsS0FBRCxFQUFRQyxJQUFSLEVBQTBCQyxlQUF4Q0g7QUFBQUEsUUFBQUE7Ozs7UUFBd0MsK0NBQWtCO1FBQ3hESSx1QkFBbUJEO1FBQ25CLElBQUEsUUFBR0YsS0FBS0ksVUFBQUEsQ0FBT0MsWUFBUEQsQ0FBUixDQUFBOztVQUNFLEtBQXlDLFVBQUEsTUFBQ0osS0FBRCxDQUFBLENBQXpDLEVBQUFNLENBQUFBLGlCQUFBLDZCQUFBQSxDQUFBLEVBQVlDLENBQUFBLGlCQUFaLDZCQUFZQSxDQUFaLEVBQXdCQyxDQUFBQSxhQUF4Qiw2QkFBd0JBLENBQXhCLEVBQWdDQyxDQUFBQSxhQUFoQyw2QkFBZ0NBLENBQWhDO1VBQ0FDLG9CQUFnQlQ7VUFDaEJVLFlBQVFDO1VBRVJDLGFBQVMsQ0FBQSxRQUFHTixjQUFILENBQUEsR0FBQSxDQUNFUixDQUFBWSxDQUFBQSxZQUFRSixjQUFSSSxHQUNDLGdCQUFBRCxpQkFBQSxFQUFlSixjQUFmLFFBRERQLENBREYsSUFHQSxDQUFBLFFBQU1PLGNBQU4sQ0FBQSxHQUFBLENBQ0csZ0JBQUFJLGlCQUFBLEVBQWVKLGNBQWYsUUFESCxJQUFBLENBR0csZ0JBQUFJLGlCQUFBLEVBQWUsR0FBZixRQUhILENBQUEsQ0FIQTtRQUxYOztVQWNFLEtBQUEsUUFBMkJULElBQTNCLENBQUE7WUFBQWEsbUJBQWU7VUFBZjtVQUNBLEtBQWdCLENBQUFkLEtBQUEsRUFBTyxDQUFBLFFBQUFlLENBQUFBLFlBQUFkLElBQUFjLENBQUEsQ0FBQSxHQUFBLENBQUEsU0FBQSxJQUFBLENBQVFILENBQVIsQ0FBQSxDQUFQLENBQWhCLEVBQUFDLENBQUFBLGFBQUEsS0FBQUEsQ0FBQSxFQUFRRixDQUFBQSxZQUFSLEtBQVFBLENBQVI7UUFmRjtRQWtCQUssY0FBVUM7UUFFVixJQUFBLE1BQW1ETixTQUFuRCxFQUE0RE8sQ0FBNUQsQ0FBQTtVQUFBQyxPQUFRQyxPQUFBQSxDQUFPQyxtQkFBZixFQUE4QnRCLGlCQUF0QnFCO1FBQVI7UUFDQSxJQUFBLFFBQU9ULFNBQUtXLGdCQUFBQSxDQUFhLFFBQWJBLENBQVosQ0FBQTtVQWpDTnZCLE9BQUE7UUFpQ007VUFDRUEsT0FBQW9CLE9BQVFDLE9BQUFBLENBQU9DLG1CQUFmLEVBQThCLE1BQUN0Qiw0QkFBRCxHQUFBLE1BQTZCWSxTQUFLWSxPQUFBQSxDQUFBQSxDQUFsQyxDQUFBLEdBQXlDeEIsR0FBekMsQ0FBQSxHQUNBQSxjQUR0QnFCO1FBRFY7TUF2QkZyQixDQUFBQSxJQUFBQTtNQTZCQWtCLElBQUFPLGFBQUFBLENBQVksTUFBWkE7O0FBRUFDLE1BQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFaLFVBQU1ZLE9BQUFBLENBQUFBO01BRFJBLENBQUFBOztBQUlBQyxNQUFBQSxtQkFBQUEsZUFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFiLFVBQU1hLEtBQUFBLENBQUFBO01BRFJBLENBQUFBOztBQUlBQyxNQUFBQSw0QkFBQUEsZ0RBQUFBO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFBZCxVQUFNYyxpQkFBQUEsQ0FBQUE7TUFEUkEsQ0FBQUE7O0FBS0FDLE1BQUFBLGlDQUFBQSxxREFBc0JDLEdBQXRCRDtBQUFBQSxRQUFBQTs7O1FBQ0VFLE9BQU8sQ0FBQSxRQUFBZixDQUFBQSxZQUFBRSxJQUFJUyxLQUFBQSxDQUFBQSxDQUFKWCxDQUFBLENBQUEsR0FBQSxDQUFBLFNBQUEsSUFBQSxDQUFhYSxHQUFiLENBQUE7UUFDUCxJQUFBLFFBQVFHLE9BQUxkLElBQUFoQixNQUFBQSxDQUFBQSxDQUFLOEIsRUFBRWIsQ0FBRmEsQ0FBUixDQUFBO1VBQ0UsSUFBQSxRQUFBZCxJQUFBVSxpQkFBQUEsQ0FBQUEsQ0FBQSxDQUFBO1lBQWVDLE9BQUlJLE9BQUpILEdBQUlHLEVBQUVGLElBQUZFO1VBQW5CO1lBQTRCSixPQUFJSyxPQUFKSixHQUFJSSxFQUFHSCxJQUFIRztVQUFoQztRQURGLE9BR0UsSUFBQSxRQUFBaEIsSUFBQVUsaUJBQUFBLENBQUFBLENBQUEsQ0FBQTtVQUFlQyxPQUFJRyxPQUFKRixHQUFJRSxFQUFFRCxJQUFGQztRQUFuQjtVQUE0QkgsT0FBSU0sT0FBSkwsR0FBSUssRUFBR0osSUFBSEk7UUFBaEM7TUFMSk4sQ0FBQUE7O0FBVUFPLE1BQUFBLG9DQUFBQSx3REFBeUJOLEdBQXpCTTtBQUFBQSxRQUFBQTs7O1FBQ0VDLFNBQVMsQ0FBQSxRQUFBckIsQ0FBQUEsWUFBQUUsSUFBSVEsT0FBQUEsQ0FBQUEsQ0FBSlYsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxTQUFBLElBQUEsQ0FBZW9CLENBQUNBLEdBQURBLENBQURFLE9BQUFBLENBQUFBLENBQWQsQ0FBQTtRQUNULElBQUEsUUFBUU4sT0FBTGQsSUFBQWhCLE1BQUFBLENBQUFBLENBQUs4QixFQUFFYixDQUFGYSxDQUFSLENBQUE7VUFDRUksT0FBSUosT0FBSkYsR0FBSUUsRUFBRUssTUFBRkw7UUFETjtVQUdFSSxPQUFJSCxPQUFKSCxHQUFJRyxFQUFFSSxNQUFGSjtRQUhOO01BRkZHLENBQUFBOztBQVNBRyxNQUFBQSxxQkFBQUEsaUJBQVVDLEtBQVZEO0FBQUFBLFFBQUFBOzs7O1FBQ0VFLE9BQU8sQ0FBQSxRQUFBekIsQ0FBQUEsWUFBQUUsSUFBSVEsT0FBQUEsQ0FBQUEsQ0FBSlYsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxTQUFBLElBQUEsQ0FBZXVCLENBQUNBLEdBQURBLENBQURELE9BQUFBLENBQUFBLENBQWQsQ0FBQTtRQUVQLEtBQUEsUUFBbURFLEtBQW5ELENBQUE7VUFBQSxPQUFPLENBQUEsUUFBQXRCLElBQUFXLHNCQUFBQSxDQUFrQlksSUFBbEJaLENBQUEsQ0FBQSxHQUFBLENBQTBCWSxJQUExQixJQUFBLENBQWlDLEdBQWpDLENBQUE7UUFBUDtRQUVBQyxNQUFNO1FBRU4sT0FBQSxRQUFNLENBQUEsUUFBQTFCLENBQUFBLFlBQUFFLElBQUFXLHNCQUFBQSxDQUFrQlksSUFBbEJaLENBQUFiLENBQUEsQ0FBQSxHQUFBLENBQWlDZ0IsT0FBTlEsS0FBTVIsRUFBRWIsQ0FBRmEsQ0FBakMsSUFBQSxDQUFBLFNBQUEsQ0FBQSxDQUFOLENBQUE7O1VBQ0VVLEdBQUlDLE9BQUFBLENBQUdGLElBQUhFO1VBQ0pGLE9BQUtHLFNBQUxILElBQUtHLEVBQUcxQixJQUFBaEIsTUFBQUEsQ0FBQUEsQ0FBSDBDO1VBQ0xKLFFBQU1LLFVBQU5MLEtBQU1LLEVBQUdoQyxDQUFIZ0M7UUFIUjtRQU1BTixPQUFBRztNQWJGSCxDQUFBQSxJQUFBQTs7QUFnQkFPLE1BQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsUUFBQUE7O1FBQUFBOzs7UUFDRSxLQUFtQkMsZUFBbkI7VUFBQSxPQUFPN0I7UUFBUDtRQUdBLElBQUEsUUFBSyxHQUFMLEVBREFGLENBQUFBLFlBQUtFLElBQUlRLE9BQUFBLENBQUFBLENBQVRWLENBQ0EsQ0FBQTtVQUNFSSxPQUFRQyxPQUFBQSxDQUFPMkIsZUFBZixFQUEwQkYsbUNBQWxCekI7UUFEVjtVQURBO1FBQ0E7UUFJQW9CLE9BQU8sQ0FBQSxRQUFBekIsQ0FBQUEsWUFBQUUsSUFBSVEsT0FBQUEsQ0FBQUEsQ0FBSlYsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxTQUFBLElBQUEsQ0FBZThCLENBQUNBLEdBQURBLENBQURSLE9BQUFBLENBQUFBLENBQWQsQ0FBQTtRQUVQLE9BQUEsUUFBTXBCLElBQUFXLHNCQUFBQSxDQUFrQlksSUFBbEJaLENBQU4sQ0FBQTs7VUFDRSxtQkFBTVksSUFBTjtVQUNBQSxPQUFLRyxTQUFMSCxJQUFLRyxFQUFHMUIsSUFBQWhCLE1BQUFBLENBQUFBLENBQUgwQztRQUZQO1FBSUFFLE9BQUE1QjtNQWRGNEIsQ0FBQUE7O0FBaUJBRyxNQUFBQSxvQkFBQUEsZ0JBQVNULEtBQVRTO0FBQUFBLFFBQUFBOzs7O1FBRUUsSUE1R04sQ0FBQSxRQTRHWUEsR0E1R1osRUEyR01qQyxDQUFBQSxZQUFLRSxJQUFJUyxLQUFBQSxDQUFBQSxDQUFUWCxDQTNHTixDQUFBLElBQUEsQ0FBQSxRQTRHbUJpQyxDQUFDQSxHQUFEQSxDQUFEWCxPQUFBQSxDQUFBQSxDQTVHbEIsRUFBQSxTQUFBLENBQUEsQ0FBQSxDQTRHTTtVQUNFbEIsT0FBUUMsT0FBQUEsQ0FBTzZCLHVCQUFmLEVBQW1DaEMsSUFBSVMsS0FBQUEsQ0FBQUEsQ0FBL0JOO1FBRFYsT0FFQSxJQUFBLFFBQUssR0FBTCxFQTlHTixTQThHTSxDQUFBO1VBQ0VELE9BQVFDLE9BQUFBLENBQU84QixpQkFBZixFQUE2QkYsNERBQXJCNUI7UUFEVjtVQUhBO1FBR0E7UUFJQW9CLE9BQWdCSSxVQUFUM0IsSUFBSVMsS0FBQUEsQ0FBQUEsQ0FBS2tCLEVBQWFBLFVBQVQzQixJQUFJUyxLQUFBQSxDQUFBQSxDQUFLa0IsRUFBRTNCLElBQUlRLE9BQUFBLENBQUFBLENBQU5tQixDQUFjTyxNQUFBQSxDQUFFbEMsSUFBQWhCLE1BQUFBLENBQUFBLENBQUZrRCxDQUEzQlA7UUFDaEIsS0FBQSxRQUFvQjNCLElBQUFXLHNCQUFBQSxDQUFrQlksSUFBbEJaLENBQXBCLENBQUE7VUFBQVksT0FBS0ksVUFBTEosSUFBS0ksRUFBRzNCLElBQUFoQixNQUFBQSxDQUFBQSxDQUFIMkM7UUFBTDtRQUVBLEtBQUEsUUFBc0RMLEtBQXRELENBQUE7VUFBQSxPQUFPLENBQUEsUUFBQXRCLElBQUFrQix5QkFBQUEsQ0FBcUJLLElBQXJCTCxDQUFBLENBQUEsR0FBQSxDQUE2QkssSUFBN0IsSUFBQSxDQUFvQyxHQUFwQyxDQUFBO1FBQVA7UUFFQUMsTUFBTTtRQUVOLE9BQUEsUUFBTSxDQUFBLFFBQUExQixDQUFBQSxZQUFBRSxJQUFBa0IseUJBQUFBLENBQXFCSyxJQUFyQkwsQ0FBQXBCLENBQUEsQ0FBQSxHQUFBLENBQW9DZ0IsT0FBTlEsS0FBTVIsRUFBRWIsQ0FBRmEsQ0FBcEMsSUFBQSxDQUFBLFNBQUEsQ0FBQSxDQUFOLENBQUE7O1VBQ0VVLEdBQUlDLE9BQUFBLENBQUdGLElBQUhFO1VBQ0pGLE9BQUtJLFVBQUxKLElBQUtJLEVBQUczQixJQUFBaEIsTUFBQUEsQ0FBQUEsQ0FBSDJDO1VBQ0xMLFFBQU1LLFVBQU5MLEtBQU1LLEVBQUdoQyxDQUFIZ0M7UUFIUjtRQU1BSSxPQUFBUCxHQUFHVyxTQUFBQSxDQUFBQTtNQXJCTEosQ0FBQUEsSUFBQUE7O0FBd0JBSyxNQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLFFBQUFBOzs7UUFDRUMsWUFBWSxDQUFBLFFBQUt2QixPQUFMZCxJQUFBaEIsTUFBQUEsQ0FBQUEsQ0FBSzhCLEVBQUViLENBQUZhLENBQUwsQ0FBQSxHQUFBLENBQVduQixDQUFYLElBQUEsQ0FBZTJDLEVBQWYsQ0FBQTtRQUVaLElBQUEsS0FBSXRDLElBQUFXLHNCQUFBQSxDQUFrQlgsSUFBSVEsT0FBQUEsQ0FBQUEsQ0FBdEJHLENBQUosQ0FBQTtVQUNFeUIsT0FBQW5DO1FBREYsT0FFQSxJQUFBLFFBQU0sQ0FBRW1DLENBQUNBLEdBQURBLENBQURoQixPQUFBQSxDQUFBQSxDQUFELEVBQVVnQixHQUFWLENBQWVHLGFBQUFBLENBQVV2QyxJQUFBaEIsTUFBQUEsQ0FBQUEsQ0FBVnVELENBQXJCLENBQUE7VUFDRUgsT0FBQXpDO1FBREYsT0FFQSxJQUFNLENBQUEsUUFBQSxDQUFRNkMsVUFBTkosQ0FBQ0EsR0FBREEsQ0FBRGhCLE9BQUFBLENBQUFBLENBQU9vQixFQUFFSCxTQUFGRyxDQUFSLEVBQXFCLEdBQXJCLENBQXlCRCxhQUFBQSxDQUFVdkMsSUFBSVEsT0FBQUEsQ0FBQUEsQ0FBZCtCLENBQXpCLENBQUEsSUFBQSxDQUFBLFFBQ0EsQ0FBT0MsVUFBTEosR0FBS0ksRUFBRUgsU0FBRkcsQ0FBUCxFQUFvQixHQUFwQixDQUF3QkQsYUFBQUEsQ0FBVXZDLElBQUlTLEtBQUFBLENBQUFBLENBQWQ4QixDQUR4QixDQUFBLENBQUEsQ0FBTjtVQUVFSCxPQUFDQSxHQUFEQTtRQUZGOztVQUlFYixPQUFnQkksVUFBVDNCLElBQUlTLEtBQUFBLENBQUFBLENBQUtrQixFQUFhQSxVQUFUM0IsSUFBSVMsS0FBQUEsQ0FBQUEsQ0FBS2tCLEVBQUUzQixJQUFJUSxPQUFBQSxDQUFBQSxDQUFObUIsQ0FBY08sTUFBQUEsQ0FBRWxDLElBQUFoQixNQUFBQSxDQUFBQSxDQUFGa0QsQ0FBM0JQO1VBQ2hCLEtBQUEsUUFBb0IzQixJQUFBVyxzQkFBQUEsQ0FBa0JZLElBQWxCWixDQUFwQixDQUFBO1lBQUFZLE9BQUtJLFVBQUxKLElBQUtJLEVBQUczQixJQUFBaEIsTUFBQUEsQ0FBQUEsQ0FBSDJDO1VBQUw7VUFDQVMsT0FBc0NWLFNBQWpCZSxXQUFkZCxVQUFMSixJQUFLSSxFQUFFM0IsSUFBSVEsT0FBQUEsQ0FBQUEsQ0FBTm1CLENBQWNjLEVBQUV6QyxJQUFBaEIsTUFBQUEsQ0FBQUEsQ0FBRnlELENBQU9DLEtBQUFBLENBQUFBLENBQUlDLE1BQUFBLENBQUFBLENBQU1qQixFQUFFL0IsQ0FBRitCO1FBTnhDO01BUEZVLENBQUFBOztBQWlCQVEsTUFBQUEsa0JBQUFBLHNDQUFPQyxLQUFQRDtBQUFBQSxRQUFBQTs7UUFDRSxJQUFBLFFBQUE5QyxDQUFBQSxZQUFBLENBQUEsUUFBQWdELENBQUFBLFlBQUEsQ0FBQSxRQUFBQyxDQUFBQSxZQUFBLENBQUEsUUFBQUMsQ0FBQUEsWUFBQWhELElBQUlNLE9BQUFBLENBQUFBLENBQU9zQyxPQUFBQSxDQUFHQyxLQUFLdkMsT0FBQUEsQ0FBQUEsQ0FBUnNDLENBQVhJLENBQUEsQ0FBQSxHQUFBLENBQ0VoRCxJQUFJUSxPQUFBQSxDQUFBQSxDQUFPb0MsT0FBQUEsQ0FBR0MsS0FBS3JDLE9BQUFBLENBQUFBLENBQVJvQyxDQURiLElBQUEsQ0FBQSxTQUFBLENBQUEsQ0FBQUcsQ0FBQSxDQUFBLEdBQUEsQ0FFRS9DLElBQUlTLEtBQUFBLENBQUFBLENBQUttQyxPQUFBQSxDQUFHQyxLQUFLcEMsS0FBQUEsQ0FBQUEsQ0FBUm1DLENBRlgsSUFBQSxDQUFBLFNBQUEsQ0FBQSxDQUFBRSxDQUFBLENBQUEsR0FBQSxDQUdFOUMsSUFBQWhCLE1BQUFBLENBQUFBLENBQUs0RCxPQUFBQSxDQUFHQyxLQUFLN0QsTUFBQUEsQ0FBQUEsQ0FBUjRELENBSFAsSUFBQSxDQUFBLFNBQUEsQ0FBQSxDQUFBOUMsQ0FBQSxDQUFBO1VBSUU4QyxPQUFBNUMsSUFBQVUsaUJBQUFBLENBQUFBLENBQWFrQyxPQUFBQSxDQUFHQyxLQUFLbkMsaUJBQUFBLENBQUFBLENBQVJrQztRQUpmO1VBQUFBLE9BQUE7UUFBQTtNQURGQSxDQUFBQTs7QUFRQUssTUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQSxDQUFDQyx3QkFBRCxFQUFxQmxELElBQUlRLE9BQUFBLENBQUFBLENBQXpCLEVBQWlDUixJQUFJUyxLQUFBQSxDQUFBQSxDQUFyQyxFQUEyQ1QsSUFBQWhCLE1BQUFBLENBQUFBLENBQTNDLEVBQWlEZ0IsSUFBQVUsaUJBQUFBLENBQUFBLENBQWpELENBQThEdUMsTUFBQUEsQ0FBQUE7TUFEaEVBLENBQUFBOztBQUlBRSxNQUFBQSx1QkFBQUEsbUJBQUFBO0FBQUFBLFFBQUFBOztRQUNFLElBQUEsUUFBRzFELGlCQUFILENBQUE7O1VBQ0UyRCxPQUFPLENBQUEsUUFBRzlELGNBQUgsQ0FBQSxHQUFBLENBQ0c2RCxHQUFELEdBQUEsTUFBSTVELFVBQUosQ0FBQSxHQUFBLE1BQWFGLGNBQVU4RCxTQUFBQSxDQUFBQSxDQUF2QixDQUFBLEdBQWdDQSxJQUFoQyxHQUFBLE1BQW9DM0QsVUFBcEMsQ0FBQSxHQUFBLE1BQTZDRixjQUFVNkQsU0FBQUEsQ0FBQUEsQ0FBdkQsQ0FBQSxHQUFnRUEsR0FEbEUsSUFFQSxDQUFBLFFBQU05RCxjQUFOLENBQUEsR0FBQSxDQUNHOEQsR0FBRCxHQUFBLE1BQUk1RCxVQUFKLENBQUEsR0FBQSxNQUFhRixjQUFVOEQsU0FBQUEsQ0FBQUEsQ0FBdkIsQ0FBQSxHQUFnQ0EsR0FEbEMsSUFBQSxHQUFBLENBRkE7VUFNUEEsT0FBQ0EsR0FBRCxHQUFBLE1BQUkxRCxpQkFBYTBELFNBQUFBLENBQUFBLENBQWpCLENBQUEsR0FBMEJBLEdBQTFCLEdBQUEsTUFBNkJqRSxvQkFBN0IsQ0FBQSxHQUFBLE1BQWdEa0UsSUFBaEQsQ0FBQSxHQUFxREQ7UUFQdkQ7O1VBU0VDLE9BQU8sQ0FBQSxRQUFPdkQsZ0JBQVAsQ0FBQSxHQUFBLENBQUEsR0FBQSxJQUFBLENBQ0dzRCxHQUFELEdBQUEsTUFBSXpELFNBQUosQ0FBQSxHQUFVeUQsR0FEWixDQUFBO1VBR1BBLE9BQUNBLElBQUQsR0FBQSxNQUFLdkQsVUFBTXVELFNBQUFBLENBQUFBLENBQVgsQ0FBQSxHQUFvQkEsSUFBcEIsR0FBQSxNQUF3QmpFLG9CQUF4QixDQUFBLEdBQUEsTUFBMkNrRSxJQUEzQyxDQUFBLEdBQWdERDtRQVpsRDtNQURGQSxDQUFBQTtNQWlCQSxhQUFNLEtBQU4sRUFBVSxJQUFWO01BQ0F0RSxPQUFBLGFBQU0sTUFBTixFQUFXLElBQVg7SUE3S0ZBLEdBQU1tQixJQUFObkIsRUFBaUNtQixJQUFqQ25CO0VBREZELEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUFIQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjEyNjA5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9lbnVtZXJhdG9yL2NoYWluLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogZGVueV9mcm96ZW5fYWNjZXNzXHJcbiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxyXG4jIHVzZV9zdHJpY3Q6IHRydWVcclxuXHJcbmNsYXNzIDo6RW51bWVyYXRvclxyXG4gIGNsYXNzIHNlbGY6OkNoYWluIDwgc2VsZlxyXG4gICAgZGVmIGluaXRpYWxpemUoKmVudW1zKVxyXG4gICAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcclxuXHJcbiAgICAgIEBlbnVtcyA9IGVudW1zXHJcbiAgICAgIEBpdGVyYXRlZCA9IFtdXHJcbiAgICAgIEBvYmplY3QgPSBzZWxmXHJcbiAgICBlbmRcclxuXHJcbiAgICBkZWYgZWFjaCgqYXJncywgJmJsb2NrKVxyXG4gICAgICByZXR1cm4gdG9fZW51bSg6ZWFjaCwgKmFyZ3MpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cclxuXHJcbiAgICAgIEBlbnVtcy5lYWNoIGRvIHxlbnVtfFxyXG4gICAgICAgIEBpdGVyYXRlZCA8PCBlbnVtXHJcbiAgICAgICAgZW51bS5lYWNoKCphcmdzLCAmYmxvY2spXHJcbiAgICAgIGVuZFxyXG5cclxuICAgICAgc2VsZlxyXG4gICAgZW5kXHJcblxyXG4gICAgZGVmIHNpemUoKmFyZ3MpXHJcbiAgICAgIGFjY3VtID0gMFxyXG4gICAgICBAZW51bXMuZWFjaCBkbyB8ZW51bXxcclxuICAgICAgICBzaXplID0gZW51bS5zaXplKCphcmdzKVxyXG4gICAgICAgIHJldHVybiBzaXplIGlmIFtuaWwsIDo6RmxvYXQ6OklORklOSVRZXS5pbmNsdWRlPyBzaXplXHJcbiAgICAgICAgYWNjdW0gKz0gc2l6ZVxyXG4gICAgICBlbmRcclxuICAgICAgYWNjdW1cclxuICAgIGVuZFxyXG5cclxuICAgIGRlZiByZXdpbmRcclxuICAgICAgQGl0ZXJhdGVkLnJldmVyc2VfZWFjaCBkbyB8ZW51bXxcclxuICAgICAgICBlbnVtLnJld2luZCBpZiBlbnVtLnJlc3BvbmRfdG8/IDpyZXdpbmRcclxuICAgICAgZW5kXHJcbiAgICAgIEBpdGVyYXRlZCA9IFtdXHJcbiAgICAgIHNlbGZcclxuICAgIGVuZFxyXG5cclxuICAgIGRlZiBpbnNwZWN0XHJcbiAgICAgIFwiIzxFbnVtZXJhdG9yOjpDaGFpbjogI3tAZW51bXMuaW5zcGVjdH0+XCJcclxuICAgIGVuZFxyXG4gIGVuZFxyXG5lbmRcclxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6RW51bWVyYXRvcj4iLCI8Y2xhc3M6c2VsZjo6Q2hhaW4+IiwiaW5pdGlhbGl6ZSIsIkBlbnVtcyIsImVudW1zIiwiQGl0ZXJhdGVkIiwiQG9iamVjdCIsInNlbGYiLCJlYWNoIiwiYmxvY2tfZ2l2ZW4/IiwidG9fZW51bSIsImFyZ3MiLCJibG9jayBpbiBlYWNoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoIiwic2l6ZSIsImVudW0kIiwiPDwiLCJibG9jayIsInRvX3Byb2MiLCJhY2N1bSIsIjAiLCJibG9jayBpbiBzaXplIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzaXplIiwiRmxvYXQ6OklORklOSVRZIiwiRmxvYXQiLCJpbmNsdWRlPyIsIisiLCJyZXdpbmQiLCJyZXZlcnNlX2VhY2giLCJibG9jayBpbiByZXdpbmQiLCJyZXNwb25kX3RvPyIsImJsb2NrICgyIGxldmVscykgaW4gcmV3aW5kIiwiaW5zcGVjdCJdLCJtYXBwaW5ncyI6IkFBQUFBLDJDQUFBQSxnQkFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBO0VBSUFBLE9BQUFDO0VBQUFBOzs7SUFDRUEsT0FBQUM7SUFBQUE7O01BQUFBOztBQUFBQTs7O0FBQ0VDLE1BQUFBLDBCQUFBQSxzQkFOSixFQU1JQTtBQUFBQSxRQUFBQTs7O1FBTko7UUFNbUI7UUFDWkE7UUFFREMsYUFBU0M7UUFDVEMsZ0JBQVk7UUFDWkgsT0FBQUksQ0FBQUEsY0FBVUMsSUFBVkQ7TUFMRkosQ0FBQUEsSUFBQUE7O0FBUUFNLE1BQUFBLG9CQUFBQSxnQkFkSixFQWNJQTtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQWRKO1FBY2E7UUFDUCxLQUE2Q0MsZUFBN0M7VUFBQSxPQUFPQyxNQUFBSCxJQUFBRyxXQUFBQSxFQUFBLENBQVEsTUFBUixDQUFBLFFBQWUsTUFBQ0MsSUFBRCxDQUFmLENBQUFELEVBQUFFLGFBQUFBLEVBQUFDOztZQUF3QkEsT0FBQU4sSUFBQU8sTUFBQUEsQ0FBQUEsQ0FBeEJGLENBQUFBLEdBQUFBLFNBQUFBLENBQUFGO1FBQVA7UUFFTUYsTUFBTkwsVUFBTUssUUFBQUEsRUFBQUEsRUFBQUEsRUFBTkksYUFBZ0JHLEtBQWhCSCxFQUFBQztBQUFBQTs7O1VBQWdCO1VBQ2RSLGFBQVVXLE9BQUFBLENBQUdELEtBQUhDO1VBQ1ZILE9BQUlMLE1BQUpPLEtBQUlQLFFBQUFBLEVBQU0sTUFBQ0csSUFBRCxDQUFOSCxFQUFjUyxLQUFEQyxTQUFBQSxDQUFBQSxDQUFiVixFQUZOSSxDQUFBQSxHQUFBQSxTQUFBQSxDQUFNSjtRQUtOQSxPQUFBRDtNQVJGQyxDQUFBQSxJQUFBQTs7QUFXQU0sTUFBQUEsb0JBQUFBLGdCQXpCSixFQXlCSUEsR0FBQUEsTUFBQUEsSUFBQUEsOEJBQUFBO0FBQUFBLFFBQUFBOzs7UUF6Qko7UUF5QmE7UUFDUEssUUFBUUM7UUFDRlosTUFBTkwsVUFBTUssUUFBQUEsRUFBQUEsRUFBQUEsRUFBTmEsYUFBZ0JOLEtBQWhCTSxFQUFBQzs7O1VBQWdCO1VBQ2RSLE9BQVdBLE1BQUpDLEtBQUlELFFBQUFBLEVBQU0sTUFBQ0gsSUFBRCxDQUFORztVQUNYLElBQUEsUUFBZSxDQUFDLEdBQUQsRUFBTVMsSUFBQUMsWUFBQUQsYUFBTixDQUF3QkUsYUFBQUEsQ0FBVVgsSUFBVlcsQ0FBdkMsQ0FBQTtZQUFBLFNBQUEsUUFBT1gsSUFBUCxFQUFBLEdBQUE7VUFBQTtVQUNBUSxPQUFBSCxDQUFBQSxRQUFNTyxTQUFOUCxLQUFNTyxFQUFHWixJQUFIWSxDQUFOUCxFQUhGRSxDQUFBQSxHQUFBQSxnQkFBQUEsQ0FBTWI7UUFLTk0sT0FBQUssTUFQRkw7VUFBQUE7VUFBQUE7UUFBQUEsQ0FBQUEsVUFBQUEsMkJBQUFBO01BQUFBLENBQUFBLElBQUFBOztBQVVBYSxNQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLFFBQUFBOzs7UUFDV0MsTUFBVHZCLGFBQVN1QixnQkFBQUEsRUFBQUEsRUFBQUEsRUFBVEMsYUFBMkJkLEtBQTNCYzs7VUFBMkI7VUFDekIsSUFBQSxRQUFlZCxLQUFJZSxnQkFBQUEsQ0FBYSxRQUFiQSxDQUFuQixDQUFBO1lBQUFDLE9BQUFoQixLQUFJWSxRQUFBQSxDQUFBQTtVQUFKO1lBckNSSSxPQUFBO1VBcUNRLEVBREZGLENBQVNEO1FBR1R2QixnQkFBWTtRQUNac0IsT0FBQXBCO01BTEZvQixDQUFBQTtNQVFBMUIsT0FBQStCLHVCQUFBQSxtQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUNBLHVCQUFELEdBQUEsTUFBd0I3QixVQUFNNkIsU0FBQUEsQ0FBQUEsQ0FBOUIsQ0FBQSxHQUF1Q0E7TUFEekNBLENBQUFBO0lBdENGL0IsR0FBTU0sSUFBTk4sRUFBb0JNLElBQXBCTjtFQURGRCxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBSkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxMjcwNywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZW51bWVyYXRvci9nZW5lcmF0b3IucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBkZW55X2Zyb3plbl9hY2Nlc3NcclxuIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXHJcbiMgdXNlX3N0cmljdDogdHJ1ZVxyXG5cclxuY2xhc3MgRW51bWVyYXRvclxyXG4gIGNsYXNzIEdlbmVyYXRvclxyXG4gICAgaW5jbHVkZSA6OkVudW1lcmFibGVcclxuXHJcbiAgICBkZWYgaW5pdGlhbGl6ZSgmYmxvY2spXHJcbiAgICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxyXG5cclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpMb2NhbEp1bXBFcnJvciwgJ25vIGJsb2NrIGdpdmVuJyB1bmxlc3MgYmxvY2tcclxuXHJcbiAgICAgIEBibG9jayA9IGJsb2NrXHJcbiAgICBlbmRcclxuXHJcbiAgICBkZWYgZWFjaCgqYXJncywgJmJsb2NrKVxyXG4gICAgICB5aWVsZGVyID0gWWllbGRlci5uZXcoJmJsb2NrKVxyXG5cclxuICAgICAgJXh7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGFyZ3MudW5zaGlmdCgje3lpZWxkZXJ9KTtcclxuXHJcbiAgICAgICAgICBPcGFsLnlpZWxkWCgje0BibG9ja30sIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgaWYgKGUgJiYgZS4kdGhyb3dlcl90eXBlID09IFwiYnJlYWtlclwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlLiR2O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBzZWxmXHJcbiAgICBlbmRcclxuICBlbmRcclxuZW5kXHJcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkVudW1lcmF0b3I+IiwiPGNsYXNzOkdlbmVyYXRvcj4iLCJzZWxmIiwiaW5jbHVkZSIsIkVudW1lcmFibGUiLCJpbml0aWFsaXplIiwiYmxvY2siLCJLZXJuZWwiLCJyYWlzZSIsIkxvY2FsSnVtcEVycm9yIiwiQGJsb2NrIiwiZWFjaCIsInlpZWxkZXIiLCJuZXciLCJZaWVsZGVyIiwidG9fcHJvYyJdLCJtYXBwaW5ncyI6IkFBQUFBLCtDQUFBQSxnQkFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBO0VBSUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUM7SUFBQUE7O01BQUFBOztBQUFBQTs7TUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUMsaUJBQVJEOztBQUVBRSxNQUFBQSwwQkFBQUEsc0JBQUFBO0FBQUFBLFFBQUFBOztRQUFBQTs7O1FBQ0dBO1FBRUQsS0FBQSxRQUF5REMsS0FBekQsQ0FBQTtVQUFBQyxPQUFRQyxPQUFBQSxDQUFPQyxxQkFBZixFQUFpQ0osZ0JBQXpCRztRQUFSO1FBRUFILE9BQUFLLENBQUFBLGFBQVNKLEtBQVRJO01BTEZMLENBQUFBO01BUUFKLE9BQUFVLG9CQUFBQSxnQkFoQkosRUFnQklBO0FBQUFBLFFBQUFBOztRQUFBQTs7O1FBaEJKO1FBZ0JhO1FBQ1BDLFVBQWlCQyxNQUFQQyxhQUFPRCxPQUFBQSxFQUFBQSxFQUFBQSxFQUFNUCxLQUFEUyxTQUFBQSxDQUFBQSxDQUFMRjs7QUFHdkJGO0FBQ0FBLHVCQUF5QkMsT0FBUUQ7O0FBRWpDQSxzQkFBd0JELFVBQU9DO0FBQy9CQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtRQUVNQSxPQUFBVDtNQW5CRlMsQ0FBQUEsSUFBQUE7SUFYRlYsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFERkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFKQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjEyNzY4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9lbnVtZXJhdG9yL2xhenkucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0cnV0aHksIGNvZXJjZV90bywgeWllbGQxLCB5aWVsZFgsIGRlbnlfZnJvemVuX2FjY2Vzc1xyXG4jIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcclxuIyB1c2Vfc3RyaWN0OiB0cnVlXHJcblxyXG5jbGFzcyA6OkVudW1lcmF0b3JcclxuICBjbGFzcyBzZWxmOjpMYXp5IDwgc2VsZlxyXG4gICAgY2xhc3Mgc2VsZjo6U3RvcExhenlFcnJvciA8IDo6RXhjZXB0aW9uOyBlbmRcclxuXHJcbiAgICBkZWYgc2VsZi5mb3Iob2JqZWN0LCAqKVxyXG4gICAgICBsYXp5ID0gc3VwZXJcclxuICAgICAgYGxhenkuZW51bWVyYXRvciA9IG9iamVjdGBcclxuICAgICAgbGF6eVxyXG4gICAgZW5kXHJcblxyXG4gICAgZGVmIGluaXRpYWxpemUob2JqZWN0LCBzaXplID0gbmlsLCAmYmxvY2spXHJcbiAgICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxyXG5cclxuICAgICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSBuZXcgd2l0aG91dCBhIGJsb2NrJ1xyXG4gICAgICBlbmRcclxuXHJcbiAgICAgIEBlbnVtZXJhdG9yID0gb2JqZWN0XHJcblxyXG4gICAgICBzdXBlciBzaXplIGRvIHx5aWVsZGVyLCAqZWFjaF9hcmdzfFxyXG4gICAgICAgIG9iamVjdC5lYWNoKCplYWNoX2FyZ3MpIGRvIHwqYXJnc3xcclxuICAgICAgICAgICV4e1xyXG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQoI3t5aWVsZGVyfSk7XHJcblxyXG4gICAgICAgICAgICAkeWllbGRYKGJsb2NrLCBhcmdzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICBlbmRcclxuICAgICAgcmVzY3VlIFN0b3BMYXp5RXJyb3JcclxuICAgICAgICBuaWxcclxuICAgICAgZW5kXHJcbiAgICBlbmRcclxuXHJcbiAgICBkZWYgbGF6eVxyXG4gICAgICBzZWxmXHJcbiAgICBlbmRcclxuXHJcbiAgICBkZWYgY29sbGVjdCgmYmxvY2spXHJcbiAgICAgIHVubGVzcyBibG9ja1xyXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSBtYXAgd2l0aG91dCBhIGJsb2NrJ1xyXG4gICAgICBlbmRcclxuXHJcbiAgICAgIExhenkubmV3KHNlbGYsIGVudW1lcmF0b3Jfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxyXG4gICAgICAgICV4e1xyXG4gICAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkWChibG9jaywgYXJncyk7XHJcblxyXG4gICAgICAgICAgI3tlbnVtLnlpZWxkIGB2YWx1ZWB9O1xyXG4gICAgICAgIH1cclxuICAgICAgZW5kXHJcbiAgICBlbmRcclxuXHJcbiAgICBkZWYgY29sbGVjdF9jb25jYXQoJmJsb2NrKVxyXG4gICAgICB1bmxlc3MgYmxvY2tcclxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjYWxsIGxhenkgbWFwIHdpdGhvdXQgYSBibG9jaydcclxuICAgICAgZW5kXHJcblxyXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcclxuICAgICAgICAleHtcclxuICAgICAgICAgIHZhciB2YWx1ZSA9ICR5aWVsZFgoYmxvY2ssIGFyZ3MpO1xyXG5cclxuICAgICAgICAgIGlmICgje2B2YWx1ZWAucmVzcG9uZF90bz8gOmZvcmNlfSAmJiAje2B2YWx1ZWAucmVzcG9uZF90bz8gOmVhY2h9KSB7XHJcbiAgICAgICAgICAgICN7YHZhbHVlYC5lYWNoIHsgfHZ8IGVudW0ueWllbGQgdiB9fVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBhcnJheSA9ICN7OjpPcGFsLnRyeV9jb252ZXJ0IGB2YWx1ZWAsIDo6QXJyYXksIDp0b19hcnl9O1xyXG5cclxuICAgICAgICAgICAgaWYgKGFycmF5ID09PSBuaWwpIHtcclxuICAgICAgICAgICAgICAje2VudW0ueWllbGQgYHZhbHVlYH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgI3tgdmFsdWVgLmVhY2ggeyB8dnwgZW51bS55aWVsZCB2IH19O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICBlbmRcclxuICAgIGVuZFxyXG5cclxuICAgIGRlZiBkcm9wKG4pXHJcbiAgICAgIG4gPSBgJGNvZXJjZV90bygje259LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcclxuXHJcbiAgICAgIGlmIG4gPCAwXHJcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnYXR0ZW1wdCB0byBkcm9wIG5lZ2F0aXZlIHNpemUnXHJcbiAgICAgIGVuZFxyXG5cclxuICAgICAgY3VycmVudF9zaXplID0gZW51bWVyYXRvcl9zaXplXHJcbiAgICAgIHNldF9zaXplICAgICA9IGlmIDo6SW50ZWdlciA9PT0gY3VycmVudF9zaXplXHJcbiAgICAgICAgICAgICAgICAgICAgICAgbiA8IGN1cnJlbnRfc2l6ZSA/IG4gOiBjdXJyZW50X3NpemVcclxuICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfc2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgICBlbmRcclxuXHJcbiAgICAgIGRyb3BwZWQgPSAwXHJcbiAgICAgIExhenkubmV3KHNlbGYsIHNldF9zaXplKSBkbyB8ZW51bSwgKmFyZ3N8XHJcbiAgICAgICAgaWYgZHJvcHBlZCA8IG5cclxuICAgICAgICAgIGRyb3BwZWQgKz0gMVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIGVudW0ueWllbGQoKmFyZ3MpXHJcbiAgICAgICAgZW5kXHJcbiAgICAgIGVuZFxyXG4gICAgZW5kXHJcblxyXG4gICAgZGVmIGRyb3Bfd2hpbGUoJmJsb2NrKVxyXG4gICAgICB1bmxlc3MgYmxvY2tcclxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjYWxsIGxhenkgZHJvcF93aGlsZSB3aXRob3V0IGEgYmxvY2snXHJcbiAgICAgIGVuZFxyXG5cclxuICAgICAgc3VjY2VlZGluZyA9IHRydWVcclxuICAgICAgTGF6eS5uZXcoc2VsZiwgbmlsKSBkbyB8ZW51bSwgKmFyZ3N8XHJcbiAgICAgICAgaWYgc3VjY2VlZGluZ1xyXG4gICAgICAgICAgJXh7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR5aWVsZFgoYmxvY2ssIGFyZ3MpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCEkdHJ1dGh5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgIHN1Y2NlZWRpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgI3tlbnVtLnlpZWxkKCphcmdzKX07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBlbnVtLnlpZWxkKCphcmdzKVxyXG4gICAgICAgIGVuZFxyXG4gICAgICBlbmRcclxuICAgIGVuZFxyXG5cclxuICAgIGRlZiBlbnVtX2ZvcihtZXRob2QgPSA6ZWFjaCwgKmFyZ3MsICZibG9jaylcclxuICAgICAgc2VsZi5jbGFzcy5mb3Ioc2VsZiwgbWV0aG9kLCAqYXJncywgJmJsb2NrKVxyXG4gICAgZW5kXHJcblxyXG4gICAgZGVmIGZpbmRfYWxsKCZibG9jaylcclxuICAgICAgdW5sZXNzIGJsb2NrXHJcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IHNlbGVjdCB3aXRob3V0IGEgYmxvY2snXHJcbiAgICAgIGVuZFxyXG5cclxuICAgICAgTGF6eS5uZXcoc2VsZiwgbmlsKSBkbyB8ZW51bSwgKmFyZ3N8XHJcbiAgICAgICAgJXh7XHJcbiAgICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGRYKGJsb2NrLCBhcmdzKTtcclxuXHJcbiAgICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgI3tlbnVtLnlpZWxkKCphcmdzKX07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICBlbmRcclxuICAgIGVuZFxyXG5cclxuICAgIGRlZiBncmVwKHBhdHRlcm4sICZibG9jaylcclxuICAgICAgaWYgYmxvY2tcclxuICAgICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcclxuICAgICAgICAgICV4e1xyXG4gICAgICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShhcmdzKX0sXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICN7cGF0dGVybiA9PT0gYHBhcmFtYH07XHJcblxyXG4gICAgICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHBhcmFtKTtcclxuXHJcbiAgICAgICAgICAgICAgI3tlbnVtLnlpZWxkIGAkeWllbGQxKGJsb2NrLCBwYXJhbSlgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIGVuZFxyXG4gICAgICBlbHNlXHJcbiAgICAgICAgTGF6eS5uZXcoc2VsZiwgbmlsKSBkbyB8ZW51bSwgKmFyZ3N8XHJcbiAgICAgICAgICAleHtcclxuICAgICAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYXJncyl9LFxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAje3BhdHRlcm4gPT09IGBwYXJhbWB9O1xyXG5cclxuICAgICAgICAgICAgaWYgKCR0cnV0aHkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgI3tlbnVtLnlpZWxkIGBwYXJhbWB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgZW5kXHJcbiAgICAgIGVuZFxyXG4gICAgZW5kXHJcblxyXG4gICAgZGVmIHJlamVjdCgmYmxvY2spXHJcbiAgICAgIHVubGVzcyBibG9ja1xyXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSByZWplY3Qgd2l0aG91dCBhIGJsb2NrJ1xyXG4gICAgICBlbmRcclxuXHJcbiAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxyXG4gICAgICAgICV4e1xyXG4gICAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkWChibG9jaywgYXJncyk7XHJcblxyXG4gICAgICAgICAgaWYgKCEkdHJ1dGh5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAje2VudW0ueWllbGQoKmFyZ3MpfTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIGVuZFxyXG4gICAgZW5kXHJcblxyXG4gICAgZGVmIHRha2UobilcclxuICAgICAgbiA9IGAkY29lcmNlX3RvKCN7bn0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxyXG5cclxuICAgICAgaWYgbiA8IDBcclxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdhdHRlbXB0IHRvIHRha2UgbmVnYXRpdmUgc2l6ZSdcclxuICAgICAgZW5kXHJcblxyXG4gICAgICBjdXJyZW50X3NpemUgPSBlbnVtZXJhdG9yX3NpemVcclxuICAgICAgc2V0X3NpemUgICAgID0gaWYgOjpJbnRlZ2VyID09PSBjdXJyZW50X3NpemVcclxuICAgICAgICAgICAgICAgICAgICAgICBuIDwgY3VycmVudF9zaXplID8gbiA6IGN1cnJlbnRfc2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF9zaXplXHJcbiAgICAgICAgICAgICAgICAgICAgIGVuZFxyXG5cclxuICAgICAgdGFrZW4gPSAwXHJcbiAgICAgIExhenkubmV3KHNlbGYsIHNldF9zaXplKSBkbyB8ZW51bSwgKmFyZ3N8XHJcbiAgICAgICAgaWYgdGFrZW4gPCBuXHJcbiAgICAgICAgICBlbnVtLnlpZWxkKCphcmdzKVxyXG4gICAgICAgICAgdGFrZW4gKz0gMVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIDo6S2VybmVsLnJhaXNlIFN0b3BMYXp5RXJyb3JcclxuICAgICAgICBlbmRcclxuICAgICAgZW5kXHJcbiAgICBlbmRcclxuXHJcbiAgICBkZWYgdGFrZV93aGlsZSgmYmxvY2spXHJcbiAgICAgIHVubGVzcyBibG9ja1xyXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSB0YWtlX3doaWxlIHdpdGhvdXQgYSBibG9jaydcclxuICAgICAgZW5kXHJcblxyXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcclxuICAgICAgICAleHtcclxuICAgICAgICAgIHZhciB2YWx1ZSA9ICR5aWVsZFgoYmxvY2ssIGFyZ3MpO1xyXG5cclxuICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAje2VudW0ueWllbGQoKmFyZ3MpfTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIFN0b3BMYXp5RXJyb3J9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgZW5kXHJcbiAgICBlbmRcclxuXHJcbiAgICBkZWYgaW5zcGVjdFxyXG4gICAgICBcIiM8I3tzZWxmLmNsYXNzfTogI3tAZW51bWVyYXRvci5pbnNwZWN0fT5cIlxyXG4gICAgZW5kXHJcblxyXG4gICAgYWxpYXMgZm9yY2UgdG9fYVxyXG4gICAgYWxpYXMgZmlsdGVyIGZpbmRfYWxsXHJcbiAgICBhbGlhcyBmbGF0X21hcCBjb2xsZWN0X2NvbmNhdFxyXG4gICAgYWxpYXMgbWFwIGNvbGxlY3RcclxuICAgIGFsaWFzIHNlbGVjdCBmaW5kX2FsbFxyXG4gICAgYWxpYXMgdG9fZW51bSBlbnVtX2ZvclxyXG4gIGVuZFxyXG5lbmRcclxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6RW51bWVyYXRvcj4iLCI8Y2xhc3M6c2VsZjo6TGF6eT4iLCI8Y2xhc3M6c2VsZjo6U3RvcExhenlFcnJvcj4iLCJzZWxmIiwiRXhjZXB0aW9uIiwiZm9yIiwib2JqZWN0IiwibGF6eSIsIiRmd2RfcmVzdCIsImluaXRpYWxpemUiLCJzaXplIiwiYmxvY2tfZ2l2ZW4/IiwiS2VybmVsIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiQGVudW1lcmF0b3IiLCJibG9jayBpbiBpbml0aWFsaXplIiwieWllbGRlciIsImJsb2NrICgyIGxldmVscykgaW4gaW5pdGlhbGl6ZSIsImVhY2giLCJlYWNoX2FyZ3MiLCJibG9jayAoMyBsZXZlbHMpIGluIGluaXRpYWxpemUiLCJTdG9wTGF6eUVycm9yIiwiY29sbGVjdCIsImJsb2NrIiwibmV3IiwiTGF6eSIsImVudW1lcmF0b3Jfc2l6ZSIsImJsb2NrIGluIGNvbGxlY3QiLCJlbnVtJCIsImJsb2NrICgyIGxldmVscykgaW4gY29sbGVjdCIsInlpZWxkIiwiY29sbGVjdF9jb25jYXQiLCJibG9jayBpbiBjb2xsZWN0X2NvbmNhdCIsImJsb2NrICgyIGxldmVscykgaW4gY29sbGVjdF9jb25jYXQiLCJyZXNwb25kX3RvPyIsInYiLCJibG9jayAoMyBsZXZlbHMpIGluIGNvbGxlY3RfY29uY2F0IiwiT3BhbCIsInRyeV9jb252ZXJ0IiwiQXJyYXkiLCJkcm9wIiwibiIsIkludGVnZXIiLCI8IiwiMCIsImN1cnJlbnRfc2l6ZSIsInNldF9zaXplIiwiZHJvcHBlZCIsImJsb2NrIGluIGRyb3AiLCJibG9jayAoMiBsZXZlbHMpIGluIGRyb3AiLCIrIiwiMSIsImFyZ3MiLCJkcm9wX3doaWxlIiwic3VjY2VlZGluZyIsImJsb2NrIGluIGRyb3Bfd2hpbGUiLCJibG9jayAoMiBsZXZlbHMpIGluIGRyb3Bfd2hpbGUiLCJlbnVtX2ZvciIsImNsYXNzIiwibWV0aG9kIiwidG9fcHJvYyIsImZpbmRfYWxsIiwiYmxvY2sgaW4gZmluZF9hbGwiLCJibG9jayAoMiBsZXZlbHMpIGluIGZpbmRfYWxsIiwiZ3JlcCIsInBhdHRlcm4iLCJibG9jayBpbiBncmVwIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBncmVwIiwiZGVzdHJ1Y3R1cmUiLCI9PT0iLCJyZWplY3QiLCJibG9jayBpbiByZWplY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIHJlamVjdCIsInRha2UiLCJ0YWtlbiIsImJsb2NrIGluIHRha2UiLCJibG9jayAoMiBsZXZlbHMpIGluIHRha2UiLCJ0YWtlX3doaWxlIiwiYmxvY2sgaW4gdGFrZV93aGlsZSIsImJsb2NrICgyIGxldmVscykgaW4gdGFrZV93aGlsZSIsImluc3BlY3QiXSwibWFwcGluZ3MiOiJBQUFBQSwwQ0FBQUEsZ0JBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTtFQUlBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lB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QUFBLFFBQUFBOztRQUNFQSxPQUFDQSxJQUFELEdBQUEsTUFBSzlFLElBQUl3RCxPQUFBQSxDQUFBQSxDQUFULENBQUEsR0FBZ0JzQixJQUFoQixHQUFBLE1BQW9CbEUsZUFBV2tFLFNBQUFBLENBQUFBLENBQS9CLENBQUEsR0FBd0NBO01BRDFDQSxDQUFBQTtNQUlBLGFBQU0sT0FBTixFQUFZLE1BQVo7TUFDQSxhQUFNLFFBQU4sRUFBYSxVQUFiO01BQ0EsYUFBTSxVQUFOLEVBQWUsZ0JBQWY7TUFDQSxhQUFNLEtBQU4sRUFBVSxTQUFWO01BQ0EsYUFBTSxRQUFOLEVBQWEsVUFBYjtNQUNBaEYsT0FBQSxhQUFNLFNBQU4sRUFBYyxVQUFkO0lBL09GQSxHQUFNRSxJQUFORixFQUFtQkUsSUFBbkJGO0VBREZELEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUFKQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjEzMTI1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9lbnVtZXJhdG9yL3lpZWxkZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXHJcbiMgdXNlX3N0cmljdDogdHJ1ZVxyXG5cclxuY2xhc3MgRW51bWVyYXRvclxyXG4gIGNsYXNzIFlpZWxkZXJcclxuICAgIGRlZiBpbml0aWFsaXplKCZibG9jaylcclxuICAgICAgQGJsb2NrID0gYmxvY2tcclxuICAgICAgIyBydWJvY29wOmRpc2FibGUgTGludC9Wb2lkXHJcbiAgICAgIHNlbGZcclxuICAgICAgIyBydWJvY29wOmVuYWJsZSBMaW50L1ZvaWRcclxuICAgIGVuZFxyXG5cclxuICAgIGRlZiB5aWVsZCgqdmFsdWVzKVxyXG4gICAgICAleHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBPcGFsLnlpZWxkWCgje0BibG9ja30sIHZhbHVlcyk7XHJcblxyXG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS4kdGhyb3dlcl90eXBlID09IFwiYnJlYWtcIikge1xyXG4gICAgICAgICAgdGhyb3cgdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgIH1cclxuICAgIGVuZFxyXG5cclxuICAgIGRlZiA8PCh2YWx1ZSlcclxuICAgICAgc2VsZi55aWVsZCh2YWx1ZSlcclxuXHJcbiAgICAgIHNlbGZcclxuICAgIGVuZFxyXG5cclxuICAgIGRlZiB0b19wcm9jXHJcbiAgICAgIHByb2MgZG8gfCp2YWx1ZXN8XHJcbiAgICAgICAgc2VsZi55aWVsZCgqdmFsdWVzKVxyXG4gICAgICBlbmRcclxuICAgIGVuZFxyXG4gIGVuZFxyXG5lbmRcclxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6RW51bWVyYXRvcj4iLCI8Y2xhc3M6WWllbGRlcj4iLCJpbml0aWFsaXplIiwiQGJsb2NrIiwiYmxvY2siLCJzZWxmIiwieWllbGQiLCI8PCIsInZhbHVlIiwidG9fcHJvYyIsInByb2MiLCJibG9jayBpbiB0b19wcm9jIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0b19wcm9jIiwidmFsdWVzIl0sIm1hcHBpbmdzIjoiQUFBQUEsNkNBQUFBLGdCQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7RUFHQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQztJQUFBQTs7TUFBQUE7O0FBQUFBOzs7QUFDRUMsTUFBQUEsMEJBQUFBLHNCQUFBQTtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQUNFQyxhQUFTQztRQUVURixPQUFBRztNQUhGSCxDQUFBQTs7QUFPQUksTUFBQUEscUJBQUFBLDBCQVpKLEVBWUlBO0FBQUFBLFFBQUFBOzs7UUFaSjtRQVljOztBQUVkQSxnQ0FBa0NILFVBQU9HOztBQUV6Q0E7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO01BVElBLENBQUFBLElBQUFBOztBQVlBQyxNQUFBQSxrQkFBQUEsMkJBQU9DLEtBQVBEO0FBQUFBLFFBQUFBOzs7UUFDRUYsSUFBSUMsT0FBQUEsQ0FBT0UsS0FBUEY7UUFFSkMsT0FBQUY7TUFIRkUsQ0FBQUE7TUFNQU4sT0FBQVEsdUJBQUFBLG1CQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQUMsTUFBQUwsSUFBQUssUUFBQUEsRUFBQUEsRUFBQUEsRUFBQUMsYUEvQk4sRUErQk1BLEVBQUFDOzs7VUEvQk47VUErQmU7VUFDUEEsT0FBSU4sTUFBSkQsSUFBSUMsU0FBQUEsRUFBTyxNQUFDTyxNQUFELENBQVBQLEVBRE5LLENBQUFBLEdBQUFBLHNCQUFBQSxDQUFBRDtNQURGRCxDQUFBQTtJQTFCRlIsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFERkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFIQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjEzMTkxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9lbnVtZXJhdG9yLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogc2xpY2UsIGNvZXJjZV90bywgZGVueV9mcm96ZW5fYWNjZXNzXHJcbiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxyXG4jIHVzZV9zdHJpY3Q6IHRydWVcclxuXHJcbnJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYWJsZSdcclxuXHJcbmNsYXNzIDo6RW51bWVyYXRvclxyXG4gIGluY2x1ZGUgOjpFbnVtZXJhYmxlXHJcblxyXG4gIGBzZWxmLiQkcHJvdG90eXBlLiQkaXNfZW51bWVyYXRvciA9IHRydWVgXHJcblxyXG4gIGRlZiBzZWxmLmZvcihvYmplY3QsIG1ldGhvZCA9IDplYWNoLCAqYXJncywgJmJsb2NrKVxyXG4gICAgJXh7XHJcbiAgICAgIHZhciBvYmogPSAje2FsbG9jYXRlfTtcclxuXHJcbiAgICAgIG9iai5vYmplY3QgPSBvYmplY3Q7XHJcbiAgICAgIG9iai5zaXplICAgPSBibG9jaztcclxuICAgICAgb2JqLm1ldGhvZCA9IG1ldGhvZDtcclxuICAgICAgb2JqLmFyZ3MgICA9IGFyZ3M7XHJcbiAgICAgIG9iai5jdXJzb3IgPSAwO1xyXG5cclxuICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGluaXRpYWxpemUoKiwgJmJsb2NrKVxyXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXHJcblxyXG4gICAgQGN1cnNvciA9IDBcclxuICAgIGlmIGJsb2NrXHJcbiAgICAgIEBvYmplY3QgPSBHZW5lcmF0b3IubmV3KCZibG9jaylcclxuICAgICAgQG1ldGhvZCA9IDplYWNoXHJcbiAgICAgIEBhcmdzICAgPSBbXVxyXG4gICAgICBAc2l6ZSAgID0gYGFyZ3VtZW50c1swXSB8fCBuaWxgXHJcblxyXG4gICAgICBpZiBAc2l6ZSAmJiAhQHNpemUucmVzcG9uZF90bz8oOmNhbGwpXHJcbiAgICAgICAgQHNpemUgPSBgJGNvZXJjZV90bygje0BzaXplfSwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXHJcbiAgICAgIGVuZFxyXG4gICAgZWxzZVxyXG4gICAgICBAb2JqZWN0ID0gYGFyZ3VtZW50c1swXWBcclxuICAgICAgQG1ldGhvZCA9IGBhcmd1bWVudHNbMV0gfHwgXCJlYWNoXCJgXHJcbiAgICAgIEBhcmdzICAgPSBgJHNsaWNlKGFyZ3VtZW50cywgMilgXHJcbiAgICAgIEBzaXplICAgPSBuaWxcclxuICAgIGVuZFxyXG4gIGVuZFxyXG5cclxuICBkZWYgZWFjaCgqYXJncywgJmJsb2NrKVxyXG4gICAgcmV0dXJuIHNlbGYgaWYgYmxvY2submlsPyAmJiBhcmdzLmVtcHR5P1xyXG5cclxuICAgIGFyZ3MgPSBAYXJncyArIGFyZ3NcclxuXHJcbiAgICByZXR1cm4gc2VsZi5jbGFzcy5uZXcoQG9iamVjdCwgQG1ldGhvZCwgKmFyZ3MpIGlmIGJsb2NrLm5pbD9cclxuXHJcbiAgICBAb2JqZWN0Ll9fc2VuZF9fKEBtZXRob2QsICphcmdzLCAmYmxvY2spXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzaXplXHJcbiAgICBAc2l6ZS5yZXNwb25kX3RvPyg6Y2FsbCkgPyBAc2l6ZS5jYWxsKCpAYXJncykgOiBAc2l6ZVxyXG4gIGVuZFxyXG5cclxuICBkZWYgd2l0aF9pbmRleChvZmZzZXQgPSAwLCAmYmxvY2spXHJcbiAgICBvZmZzZXQgPSBpZiBvZmZzZXRcclxuICAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ob2Zmc2V0LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcclxuICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgMFxyXG4gICAgICAgICAgICAgZW5kXHJcblxyXG4gICAgcmV0dXJuIGVudW1fZm9yKDp3aXRoX2luZGV4LCBvZmZzZXQpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xyXG5cclxuICAgICV4e1xyXG4gICAgICB2YXIgcmVzdWx0LCBpbmRleCA9IG9mZnNldDtcclxuXHJcbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcclxuICAgICAgICAgICAgdmFsdWUgPSBibG9jayhwYXJhbSwgaW5kZXgpO1xyXG5cclxuICAgICAgICBpbmRleCsrO1xyXG5cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzZWxmLiRlYWNoKCk7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBlYWNoX3dpdGhfaW5kZXgoJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3dpdGhfaW5kZXgpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cclxuXHJcbiAgICBzdXBlclxyXG4gICAgQG9iamVjdFxyXG4gIGVuZFxyXG5cclxuICBkZWYgcmV3aW5kXHJcbiAgICBAY3Vyc29yID0gMFxyXG5cclxuICAgIHNlbGZcclxuICBlbmRcclxuXHJcbiAgZGVmIHBlZWtfdmFsdWVzXHJcbiAgICBAdmFsdWVzIHx8PSBtYXAgeyB8Kml8IGkgfVxyXG4gICAgOjpLZXJuZWwucmFpc2UgOjpTdG9wSXRlcmF0aW9uLCAnaXRlcmF0aW9uIHJlYWNoZWQgYW4gZW5kJyBpZiBAY3Vyc29yID49IEB2YWx1ZXMubGVuZ3RoXHJcbiAgICBAdmFsdWVzW0BjdXJzb3JdXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBwZWVrXHJcbiAgICB2YWx1ZXMgPSBwZWVrX3ZhbHVlc1xyXG4gICAgdmFsdWVzLmxlbmd0aCA8PSAxID8gdmFsdWVzWzBdIDogdmFsdWVzXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBuZXh0X3ZhbHVlc1xyXG4gICAgb3V0ID0gcGVla192YWx1ZXNcclxuICAgIEBjdXJzb3IgKz0gMVxyXG4gICAgb3V0XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBuZXh0XHJcbiAgICB2YWx1ZXMgPSBuZXh0X3ZhbHVlc1xyXG4gICAgdmFsdWVzLmxlbmd0aCA8PSAxID8gdmFsdWVzWzBdIDogdmFsdWVzXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBmZWVkKGFyZylcclxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIFwiT3BhbCBkb2Vzbid0IHN1cHBvcnQgRW51bWVyYXRvciNmZWVkXCJcclxuICBlbmRcclxuXHJcbiAgZGVmICsob3RoZXIpXHJcbiAgICA6OkVudW1lcmF0b3I6OkNoYWluLm5ldyhzZWxmLCBvdGhlcilcclxuICBlbmRcclxuXHJcbiAgZGVmIGluc3BlY3RcclxuICAgIHJlc3VsdCA9IFwiIzwje3NlbGYuY2xhc3N9OiAje0BvYmplY3QuaW5zcGVjdH06I3tAbWV0aG9kfVwiXHJcblxyXG4gICAgaWYgQGFyZ3MuYW55P1xyXG4gICAgICByZXN1bHQgKz0gXCIoI3tAYXJncy5pbnNwZWN0Wzo6UmFuZ2UubmV3KDEsIC0yKV19KVwiXHJcbiAgICBlbmRcclxuXHJcbiAgICByZXN1bHQgKyAnPidcclxuICBlbmRcclxuXHJcbiAgYWxpYXMgd2l0aF9vYmplY3QgZWFjaF93aXRoX29iamVjdFxyXG5cclxuICBhdXRvbG9hZCA6QXJpdGhtZXRpY1NlcXVlbmNlLCAnY29yZWxpYi9lbnVtZXJhdG9yL2FyaXRobWV0aWNfc2VxdWVuY2UnXHJcbiAgYXV0b2xvYWQgOkNoYWluLCAnY29yZWxpYi9lbnVtZXJhdG9yL2NoYWluJ1xyXG4gIGF1dG9sb2FkIDpHZW5lcmF0b3IsICdjb3JlbGliL2VudW1lcmF0b3IvZ2VuZXJhdG9yJ1xyXG4gIGF1dG9sb2FkIDpMYXp5LCAnY29yZWxpYi9lbnVtZXJhdG9yL2xhenknXHJcbiAgYXV0b2xvYWQgOllpZWxkZXIsICdjb3JlbGliL2VudW1lcmF0b3IveWllbGRlcidcclxuZW5kXHJcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6RW51bWVyYXRvcj4iLCJpbmNsdWRlIiwiRW51bWVyYWJsZSIsImZvciIsIm9iamVjdCIsImFsbG9jYXRlIiwiaW5pdGlhbGl6ZSIsIkBjdXJzb3IiLCIwIiwiYmxvY2siLCJAb2JqZWN0IiwibmV3IiwiR2VuZXJhdG9yIiwidG9fcHJvYyIsIkBtZXRob2QiLCJAYXJncyIsIkBzaXplIiwicmVzcG9uZF90bz8iLCJJbnRlZ2VyIiwiZWFjaCIsIm5pbD8iLCJhcmdzIiwiZW1wdHk/IiwiKyIsImNsYXNzIiwiX19zZW5kX18iLCJzaXplIiwiY2FsbCIsIndpdGhfaW5kZXgiLCJvZmZzZXQiLCJlbnVtX2ZvciIsImJsb2NrIGluIHdpdGhfaW5kZXgiLCJibG9jayAoMiBsZXZlbHMpIGluIHdpdGhfaW5kZXgiLCJPcGFsIiwiZGVzdHJ1Y3R1cmUiLCJlYWNoX3dpdGhfaW5kZXgiLCJibG9ja19naXZlbj8iLCJibG9jayBpbiBlYWNoX3dpdGhfaW5kZXgiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfd2l0aF9pbmRleCIsInJld2luZCIsInBlZWtfdmFsdWVzIiwiQHZhbHVlcyIsIiRyZXRfb3JfMSIsIm1hcCIsImJsb2NrIGluIHBlZWtfdmFsdWVzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwZWVrX3ZhbHVlcyIsImkiLCI+PSIsImxlbmd0aCIsIktlcm5lbCIsInJhaXNlIiwiU3RvcEl0ZXJhdGlvbiIsIltdIiwicGVlayIsInZhbHVlcyIsIjw9IiwiMSIsIm5leHRfdmFsdWVzIiwib3V0IiwibmV4dCIsImZlZWQiLCJhcmciLCJOb3RJbXBsZW1lbnRlZEVycm9yIiwib3RoZXIiLCJFbnVtZXJhdG9yOjpDaGFpbiIsIkVudW1lcmF0b3IiLCJpbnNwZWN0IiwicmVzdWx0IiwiYW55PyIsIlJhbmdlIiwiLTIiLCJhdXRvbG9hZCJdLCJtYXBwaW5ncyI6IkFBQUFBLHFDQUFBQSxnQkFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBOztFQUlBQyxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDRUYsSUFBQUcsU0FBQUEsQ0FBUUMsaUJBQVJEO0lBRUNEO0lBRURHLE1BQUlMLElBQUpLLFVBQUFBLDJCQUFhQyxNQUFELEVBWGQsRUFXYyxFQVhkLEVBV0VEO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BWEY7O01BV3VCLHVEQUFBLDZCQUFTO01BQU87O0FBRXZDQSxnQkFBa0JMLElBQUFPLFVBQUFBLENBQUFBLENBQVNGOztBQUUzQkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0lBWEVBLENBQUFBLElBQUFBOztBQWNBRyxJQUFBQSwwQkFBQUEsc0JBekJGLEVBeUJFQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQXpCRjtNQXlCaUI7TUFDWkE7TUFFREMsY0FBVUM7TUFDVixJQUFBLFFBQUdDLEtBQUgsQ0FBQTs7UUFDRUMsY0FBbUJDLE1BQVRDLGVBQVNELE9BQUFBLEVBQUFBLEVBQUFBLEVBQU1GLEtBQURJLFNBQUFBLENBQUFBLENBQUxGO1FBQ25CRyxjQUFVO1FBQ1ZDLFlBQVU7UUFDVkMsWUFBV1Y7UUFFWCxJQUFHLENBQUEsUUFBQVUsU0FBQSxDQUFBLElBQUEsQ0FBQSxLQUFVQSxTQUFLQyxnQkFBQUEsQ0FBYSxNQUFiQSxDQUFmLENBQUEsQ0FB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QUFoQnVFO0lBQ0F2RSxPQUFBRixJQUFBeUUsVUFBQUEsQ0FBUyxTQUFULEVBQW1CdkUsNEJBQW5CdUU7RUExSUZ2RSxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBTkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxMzQyMCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbnVtZXJpYy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcclxuIyB1c2Vfc3RyaWN0OiB0cnVlXHJcblxyXG5yZXF1aXJlICdjb3JlbGliL2NvbXBhcmFibGUnXHJcblxyXG5jbGFzcyA6Ok51bWVyaWNcclxuICBpbmNsdWRlIDo6Q29tcGFyYWJsZVxyXG5cclxuICBkZWYgY29lcmNlKG90aGVyKVxyXG4gICAgaWYgb3RoZXIuaW5zdGFuY2Vfb2Y/IHNlbGYuY2xhc3NcclxuICAgICAgcmV0dXJuIFtvdGhlciwgc2VsZl1cclxuICAgIGVuZFxyXG5cclxuICAgIFs6Oktlcm5lbC5GbG9hdChvdGhlciksIDo6S2VybmVsLkZsb2F0KHNlbGYpXVxyXG4gIGVuZFxyXG5cclxuICBkZWYgX19jb2VyY2VkX18obWV0aG9kLCBvdGhlcilcclxuICAgIGlmIG90aGVyLnJlc3BvbmRfdG8/KDpjb2VyY2UpXHJcbiAgICAgIGEsIGIgPSBvdGhlci5jb2VyY2Uoc2VsZilcclxuICAgICAgYS5fX3NlbmRfXyBtZXRob2QsIGJcclxuICAgIGVsc2VcclxuICAgICAgY2FzZSBtZXRob2RcclxuICAgICAgd2hlbiA6KywgOi0sIDoqLCA6LywgOiUsIDomLCA6fCwgOl4sIDoqKlxyXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIiN7b3RoZXIuY2xhc3N9IGNhbid0IGJlIGNvZXJjZWQgaW50byBOdW1lcmljXCJcclxuICAgICAgd2hlbiA6PiwgOj49LCA6PCwgOjw9LCA6PD0+XHJcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tzZWxmLmNsYXNzfSB3aXRoICN7b3RoZXIuY2xhc3N9IGZhaWxlZFwiXHJcbiAgICAgIGVuZFxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiA8PT4ob3RoZXIpXHJcbiAgICBpZiBlcXVhbD8gb3RoZXJcclxuICAgICAgcmV0dXJuIDBcclxuICAgIGVuZFxyXG5cclxuICAgIG5pbFxyXG4gIGVuZFxyXG5cclxuICBkZWYgK0BcclxuICAgIHNlbGZcclxuICBlbmRcclxuXHJcbiAgZGVmIC1AXHJcbiAgICAwIC0gc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgJShvdGhlcilcclxuICAgIHNlbGYgLSBvdGhlciAqIGRpdihvdGhlcilcclxuICBlbmRcclxuXHJcbiAgZGVmIGFic1xyXG4gICAgc2VsZiA8IDAgPyAtc2VsZiA6IHNlbGZcclxuICBlbmRcclxuXHJcbiAgZGVmIGFiczJcclxuICAgIHNlbGYgKiBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBhbmdsZVxyXG4gICAgc2VsZiA8IDAgPyA6Ok1hdGg6OlBJIDogMFxyXG4gIGVuZFxyXG5cclxuICBkZWYgY2VpbChuZGlnaXRzID0gMClcclxuICAgIHRvX2YuY2VpbChuZGlnaXRzKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgY29ualxyXG4gICAgc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgZGVub21pbmF0b3JcclxuICAgIHRvX3IuZGVub21pbmF0b3JcclxuICBlbmRcclxuXHJcbiAgZGVmIGRpdihvdGhlcilcclxuICAgIDo6S2VybmVsLnJhaXNlIDo6WmVyb0RpdmlzaW9uRXJyb3IsICdkaXZpZGVkIGJ5IG8nIGlmIG90aGVyID09IDBcclxuXHJcbiAgICAoc2VsZiAvIG90aGVyKS5mbG9vclxyXG4gIGVuZFxyXG5cclxuICBkZWYgZGl2bW9kKG90aGVyKVxyXG4gICAgW2RpdihvdGhlciksIHNlbGYgJSBvdGhlcl1cclxuICBlbmRcclxuXHJcbiAgZGVmIGZkaXYob3RoZXIpXHJcbiAgICB0b19mIC8gb3RoZXJcclxuICBlbmRcclxuXHJcbiAgZGVmIGZsb29yKG5kaWdpdHMgPSAwKVxyXG4gICAgdG9fZi5mbG9vcihuZGlnaXRzKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgaVxyXG4gICAgOjpLZXJuZWwuQ29tcGxleCgwLCBzZWxmKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgaW1hZ1xyXG4gICAgMFxyXG4gIGVuZFxyXG5cclxuICBkZWYgaW50ZWdlcj9cclxuICAgIGZhbHNlXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBub256ZXJvP1xyXG4gICAgemVybz8gPyBuaWwgOiBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBudW1lcmF0b3JcclxuICAgIHRvX3IubnVtZXJhdG9yXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBwb2xhclxyXG4gICAgW2FicywgYXJnXVxyXG4gIGVuZFxyXG5cclxuICBkZWYgcXVvKG90aGVyKVxyXG4gICAgOjpPcGFsLmNvZXJjZV90byEoc2VsZiwgOjpSYXRpb25hbCwgOnRvX3IpIC8gb3RoZXJcclxuICBlbmRcclxuXHJcbiAgZGVmIHJlYWxcclxuICAgIHNlbGZcclxuICBlbmRcclxuXHJcbiAgZGVmIHJlYWw/XHJcbiAgICB0cnVlXHJcbiAgZW5kXHJcblxyXG4gIGRlZiByZWN0XHJcbiAgICBbc2VsZiwgMF1cclxuICBlbmRcclxuXHJcbiAgZGVmIHJvdW5kKGRpZ2l0cyA9IHVuZGVmaW5lZClcclxuICAgIHRvX2Yucm91bmQoZGlnaXRzKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc3RlcChsaW1pdCA9IHVuZGVmaW5lZCwgc3RlcCA9IHVuZGVmaW5lZCwgdG86IHVuZGVmaW5lZCwgYnk6IHVuZGVmaW5lZCwgJmJsb2NrKVxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkICYmIHRvICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RvIGlzIGdpdmVuIHR3aWNlJ31cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHN0ZXAgIT09IHVuZGVmaW5lZCAmJiBieSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdzdGVwIGlzIGdpdmVuIHR3aWNlJ31cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRvICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBsaW1pdCA9IHRvO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYnkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHN0ZXAgPSBieTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBsaW1pdCA9IG5pbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gdmFsaWRhdGVQYXJhbWV0ZXJzKCkge1xyXG4gICAgICAgIGlmIChzdGVwID09PSBuaWwpIHtcclxuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdzdGVwIG11c3QgYmUgbnVtZXJpYyd9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc3RlcCAhPSBudWxsICYmICN7c3RlcCA9PSAwfSkge1xyXG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwic3RlcCBjYW4ndCBiZSAwXCJ9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc3RlcCA9PT0gbmlsIHx8IHN0ZXAgPT0gbnVsbCkge1xyXG4gICAgICAgICAgc3RlcCA9IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc2lnbiA9ICN7c3RlcCA8PT4gMH07XHJcblxyXG4gICAgICAgIGlmIChzaWduID09PSBuaWwpIHtcclxuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIjAgY2FuJ3QgYmUgY29lcmNlZCBpbnRvICN7c3RlcC5jbGFzc31cIn1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChsaW1pdCA9PT0gbmlsIHx8IGxpbWl0ID09IG51bGwpIHtcclxuICAgICAgICAgIGxpbWl0ID0gc2lnbiA+IDAgPyAjezo6RmxvYXQ6OklORklOSVRZfSA6ICN7LTo6RmxvYXQ6OklORklOSVRZfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICN7OjpPcGFsLmNvbXBhcmUoc2VsZiwgbGltaXQpfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBzdGVwRmxvYXRTaXplKCkge1xyXG4gICAgICAgIGlmICgoc3RlcCA+IDAgJiYgc2VsZiA+IGxpbWl0KSB8fCAoc3RlcCA8IDAgJiYgc2VsZiA8IGxpbWl0KSkge1xyXG4gICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzdGVwID09PSBJbmZpbml0eSB8fCBzdGVwID09PSAtSW5maW5pdHkpIHtcclxuICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2YXIgYWJzID0gTWF0aC5hYnMsIGZsb29yID0gTWF0aC5mbG9vcixcclxuICAgICAgICAgICAgICBlcnIgPSAoYWJzKHNlbGYpICsgYWJzKGxpbWl0KSArIGFicyhsaW1pdCAtIHNlbGYpKSAvIGFicyhzdGVwKSAqICN7OjpGbG9hdDo6RVBTSUxPTn07XHJcblxyXG4gICAgICAgICAgaWYgKGVyciA9PT0gSW5maW5pdHkgfHwgZXJyID09PSAtSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZXJyID4gMC41KSB7XHJcbiAgICAgICAgICAgICAgZXJyID0gMC41O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmxvb3IoKGxpbWl0IC0gc2VsZikgLyBzdGVwICsgZXJyKSArIDFcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHN0ZXBTaXplKCkge1xyXG4gICAgICAgIHZhbGlkYXRlUGFyYW1ldGVycygpO1xyXG5cclxuICAgICAgICBpZiAoc3RlcCA9PT0gMCkge1xyXG4gICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHN0ZXAgJSAxICE9PSAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gc3RlcEZsb2F0U2l6ZSgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoKHN0ZXAgPiAwICYmIHNlbGYgPiBsaW1pdCkgfHwgKHN0ZXAgPCAwICYmIHNlbGYgPCBsaW1pdCkpIHtcclxuICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2YXIgY2VpbCA9IE1hdGguY2VpbCwgYWJzID0gTWF0aC5hYnMsXHJcbiAgICAgICAgICAgICAgbGhzID0gYWJzKHNlbGYgLSBsaW1pdCkgKyAxLFxyXG4gICAgICAgICAgICAgIHJocyA9IGFicyhzdGVwKTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gY2VpbChsaHMgLyByaHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XHJcbiAgICAgIGlmICghbGltaXQgfHwgbGltaXQuaXNfYT8oOjpOdW1lcmljKSkgJiZcclxuICAgICAgICAgKCFzdGVwIHx8IHN0ZXAuaXNfYT8oOjpOdW1lcmljKSlcclxuXHJcbiAgICAgICAgcmV0dXJuIDo6RW51bWVyYXRvcjo6QXJpdGhtZXRpY1NlcXVlbmNlLm5ldyhcclxuICAgICAgICAgIFtsaW1pdCwgc3RlcCwgKCd0bzogJyBpZiB0byksICgnYnk6ICcgaWYgYnkpXSwgc2VsZlxyXG4gICAgICAgIClcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBlbnVtX2Zvcig6c3RlcCwgbGltaXQsIHN0ZXAsICZgc3RlcFNpemVgKVxyXG4gICAgICBlbmRcclxuICAgIGVuZFxyXG5cclxuICAgICV4e1xyXG4gICAgICB2YWxpZGF0ZVBhcmFtZXRlcnMoKTtcclxuXHJcbiAgICAgIHZhciBpc0Rlc2MgPSAje3N0ZXAubmVnYXRpdmU/fSxcclxuICAgICAgICAgIGlzSW5mID0gI3tzdGVwID09IDB9IHx8XHJcbiAgICAgICAgICAgICAgICAgIChsaW1pdCA9PT0gSW5maW5pdHkgJiYgIWlzRGVzYykgfHxcclxuICAgICAgICAgICAgICAgICAgKGxpbWl0ID09PSAtSW5maW5pdHkgJiYgaXNEZXNjKTtcclxuXHJcbiAgICAgIGlmIChzZWxmLiQkaXNfbnVtYmVyICYmIHN0ZXAuJCRpc19udW1iZXIgJiYgbGltaXQuJCRpc19udW1iZXIpIHtcclxuICAgICAgICBpZiAoc2VsZiAlIDEgPT09IDAgJiYgKGlzSW5mIHx8IGxpbWl0ICUgMSA9PT0gMCkgJiYgc3RlcCAlIDEgPT09IDApIHtcclxuICAgICAgICAgIHZhciB2YWx1ZSA9IHNlbGY7XHJcblxyXG4gICAgICAgICAgaWYgKGlzSW5mKSB7XHJcbiAgICAgICAgICAgIGZvciAoOzsgdmFsdWUgKz0gc3RlcCkge1xyXG4gICAgICAgICAgICAgIGJsb2NrKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIGlmIChpc0Rlc2MpIHtcclxuICAgICAgICAgICAgZm9yICg7IHZhbHVlID49IGxpbWl0OyB2YWx1ZSArPSBzdGVwKSB7XHJcbiAgICAgICAgICAgICAgYmxvY2sodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKDsgdmFsdWUgPD0gbGltaXQ7IHZhbHVlICs9IHN0ZXApIHtcclxuICAgICAgICAgICAgICBibG9jayh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFyIGJlZ2luID0gI3t0b19mfS52YWx1ZU9mKCk7XHJcbiAgICAgICAgICBzdGVwID0gI3tzdGVwLnRvX2Z9LnZhbHVlT2YoKTtcclxuICAgICAgICAgIGxpbWl0ID0gI3tsaW1pdC50b19mfS52YWx1ZU9mKCk7XHJcblxyXG4gICAgICAgICAgdmFyIG4gPSBzdGVwRmxvYXRTaXplKCk7XHJcblxyXG4gICAgICAgICAgaWYgKCFpc0Zpbml0ZShzdGVwKSkge1xyXG4gICAgICAgICAgICBpZiAobiAhPT0gMCkgYmxvY2soYmVnaW4pO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChzdGVwID09PSAwKSB7XHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgYmxvY2soYmVnaW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgIHZhciBkID0gaSAqIHN0ZXAgKyBzZWxmO1xyXG4gICAgICAgICAgICAgIGlmIChzdGVwID49IDAgPyBsaW1pdCA8IGQgOiBsaW1pdCA+IGQpIHtcclxuICAgICAgICAgICAgICAgIGQgPSBsaW1pdDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgYmxvY2soZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb3VudGVyID0gc2VsZlxyXG5cclxuICAgIHdoaWxlIGBpc0Rlc2MgPyAje2NvdW50ZXIgPj0gbGltaXR9IDogI3tjb3VudGVyIDw9IGxpbWl0fWBcclxuICAgICAgeWllbGQgY291bnRlclxyXG4gICAgICBjb3VudGVyICs9IHN0ZXBcclxuICAgIGVuZFxyXG4gIGVuZFxyXG5cclxuICBkZWYgdG9fY1xyXG4gICAgOjpLZXJuZWwuQ29tcGxleChzZWxmLCAwKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgdG9faW50XHJcbiAgICB0b19pXHJcbiAgZW5kXHJcblxyXG4gIGRlZiB0cnVuY2F0ZShuZGlnaXRzID0gMClcclxuICAgIHRvX2YudHJ1bmNhdGUobmRpZ2l0cylcclxuICBlbmRcclxuXHJcbiAgZGVmIHplcm8/XHJcbiAgICBzZWxmID09IDBcclxuICBlbmRcclxuXHJcbiAgZGVmIHBvc2l0aXZlP1xyXG4gICAgc2VsZiA+IDBcclxuICBlbmRcclxuXHJcbiAgZGVmIG5lZ2F0aXZlP1xyXG4gICAgc2VsZiA8IDBcclxuICBlbmRcclxuXHJcbiAgZGVmIGR1cFxyXG4gICAgc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgY2xvbmUoZnJlZXplOiB0cnVlKVxyXG4gICAgc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgZmluaXRlP1xyXG4gICAgdHJ1ZVxyXG4gIGVuZFxyXG5cclxuICBkZWYgaW5maW5pdGU/XHJcbiAgICBuaWxcclxuICBlbmRcclxuXHJcbiAgYWxpYXMgYXJnIGFuZ2xlXHJcbiAgYWxpYXMgY29uanVnYXRlIGNvbmpcclxuICBhbGlhcyBpbWFnaW5hcnkgaW1hZ1xyXG4gIGFsaWFzIG1hZ25pdHVkZSBhYnNcclxuICBhbGlhcyBtb2R1bG8gJVxyXG4gIGFsaWFzIHBoYXNlIGFyZ1xyXG4gIGFsaWFzIHJlY3Rhbmd1bGFyIHJlY3RcclxuZW5kXHJcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6TnVtZXJpYz4iLCJpbmNsdWRlIiwiQ29tcGFyYWJsZSIsImNvZXJjZSIsIm90aGVyIiwiaW5zdGFuY2Vfb2Y/IiwiY2xhc3MiLCJLZXJuZWwiLCJGbG9hdCIsIl9fY29lcmNlZF9fIiwibWV0aG9kIiwicmVzcG9uZF90bz8iLCJhIiwiYiIsIl9fc2VuZF9fIiwicmFpc2UiLCJUeXBlRXJyb3IiLCJBcmd1bWVudEVycm9yIiwiPD0+IiwiZXF1YWw/IiwiMCIsIitAIiwiLUAiLCItIiwiJSIsIioiLCJkaXYiLCJhYnMiLCI8IiwiYWJzMiIsImFuZ2xlIiwiTWF0aDo6UEkiLCJNYXRoIiwiY2VpbCIsIm5kaWdpdHMiLCJ0b19mIiwiY29uaiIsImRlbm9taW5hdG9yIiwidG9fciIsIlplcm9EaXZpc2lvbkVycm9yIiwiLyIsImZsb29yIiwiZGl2bW9kIiwiZmRpdiIsImkiLCJDb21wbGV4IiwiaW1hZyIsImludGVnZXI/Iiwibm9uemVybz8iLCJ6ZXJvPyIsIm51bWVyYXRvciIsInBvbGFyIiwiYXJnIiwicXVvIiwiT3BhbCIsImNvZXJjZV90byEiLCJSYXRpb25hbCIsInJlYWwiLCJyZWFsPyIsInJlY3QiLCJyb3VuZCIsImRpZ2l0cyIsInN0ZXAiLCI9PSIsIkZsb2F0OjpJTkZJTklUWSIsImNvbXBhcmUiLCJsaW1pdCIsIkZsb2F0OjpFUFNJTE9OIiwiYmxvY2tfZ2l2ZW4/IiwiaXNfYT8iLCJOdW1lcmljIiwiRW51bWVyYXRvcjo6QXJpdGhtZXRpY1NlcXVlbmNlIiwiRW51bWVyYXRvciIsIm5ldyIsInRvIiwiYnkiLCJlbnVtX2ZvciIsInRvX3Byb2MiLCJuZWdhdGl2ZT8iLCJjb3VudGVyIiwiPj0iLCI8PSIsIisiLCJ0b19jIiwidG9faW50IiwidG9faSIsInRydW5jYXRlIiwicG9zaXRpdmU/IiwiPiIsImR1cCIsImNsb25lIiwiJGt3YXJncyIsImZpbml0ZT8iLCJpbmZpbml0ZT8iXSwibWFwcGluZ3MiOiJBQUFBQSxrQ0FBQUEsZ0JBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTs7RUFHQUMsSUFBQUMsU0FBQUEsQ0FBUUYsb0JBQVJFO0VBRUFGLE9BQUFHO0VBQUFBOzs7O0lBQ0VGLElBQUFHLFNBQUFBLENBQVFDLGlCQUFSRDs7QUFFQUUsSUFBQUEsc0JBQUFBLGtCQUFXQyxLQUFYRDtBQUFBQSxNQUFBQTs7O01BQ0UsSUFBQSxRQUFHQyxLQUFLQyxpQkFBQUEsQ0FBY1AsSUFBSVEsT0FBQUEsQ0FB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Q0FBRzNDLENBQUgyQztJQURQZCxDQUFBQTs7QUFJQXNDLElBQUFBLHlCQUFBQSxrQ0FBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUtDLE9BQUwxRixJQUFLMEYsRUFBRXBFLENBQUZvRTtJQURQRCxDQUFBQTs7QUFJQVQsSUFBQUEseUJBQUFBLGtDQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBS2xELE9BQUw5QixJQUFLOEIsRUFBRVIsQ0FBRlE7SUFEUGtELENBQUFBOztBQUlBVyxJQUFBQSxtQkFBQUEsWUFBQUE7O0FBSUFDLElBQUFBLHFCQUFBQSxpQkExVUZDLE9BMFVFRDtBQUFBQSxNQUFBQTs7O01BMVVGOztNQTBVWSxzQ0FBQSw2QkFBUTtNQUNoQkEsT0FBQTVGO0lBREY0RixDQUFBQSxJQUFBQTs7QUFJQUUsSUFBQUEsdUJBQUFBLFlBQ0UsSUFERkEsQ0FBQUE7O0FBSUFDLElBQUFBLHlCQUFBQSxZQUNFLEdBREZBLENBQUFBO0lBSUEsYUFBTSxLQUFOLEVBQVUsT0FBVjtJQUNBLGFBQU0sV0FBTixFQUFnQixNQUFoQjtJQUNBLGFBQU0sV0FBTixFQUFnQixNQUFoQjtJQUNBLGFBQU0sV0FBTixFQUFnQixLQUFoQjtJQUNBLGFBQU0sUUFBTixFQUFhLEdBQWI7SUFDQSxhQUFNLE9BQU4sRUFBWSxLQUFaO0lBQ0E3RixPQUFBLGFBQU0sYUFBTixFQUFrQixNQUFsQjtFQXZWRkEsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQUxBSDsifX0seyJvZmZzZXQiOnsibGluZSI6MTM4NjQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2FycmF5LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHJ1dGh5LCBmYWxzeSwgeWllbGQxLCBoYXNoX2dldCwgaGFzaF9wdXQsIGhhc2hfZGVsZXRlLCBjb2VyY2VfdG8sIHJlc3BvbmRfdG8sIGRlbnlfZnJvemVuX2FjY2VzcywgZnJlZXplLCBvcGFsMzJfaW5pdCwgb3BhbDMyX2FkZFxyXG4jIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcclxuXHJcbnJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYWJsZSdcclxucmVxdWlyZSAnY29yZWxpYi9udW1lcmljJ1xyXG5cclxuY2xhc3MgOjpBcnJheSA8IGBBcnJheWBcclxuICBpbmNsdWRlIDo6RW51bWVyYWJsZVxyXG5cclxuICAjIE1hcmsgYWxsIGphdmFzY3JpcHQgYXJyYXlzIGFzIGJlaW5nIHZhbGlkIHJ1YnkgYXJyYXlzXHJcbiAgYE9wYWwucHJvcChzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19hcnJheScsIHRydWUpYFxyXG5cclxuICAleHtcclxuICAgIC8vIFJlY2VudCB2ZXJzaW9ucyBvZiBWOCAoPiA3LjEpIG9ubHkgdXNlIGFuIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiB3aGVuIEFycmF5LnByb3RvdHlwZSBpcyB1bm1vZGlmaWVkLlxyXG4gICAgLy8gRm9yIGluc3RhbmNlLCBcImFycmF5LXNwbGljZS50cVwiIGhhcyBhIFwiZmFzdCBwYXRoXCIgKEV4dHJhY3RGYXN0SlNBcnJheSwgZGVmaW5lZCBpbiBcInNyYy9jb2RlZ2VuL2NvZGUtc3R1Yi1hc3NlbWJsZXIuY2NcIilcclxuICAgIC8vIGJ1dCBpdCdzIG9ubHkgZW5hYmxlZCB3aGVuIFwiSXNQcm90b3R5cGVJbml0aWFsQXJyYXlQcm90b3R5cGUoKVwiIGlzIHRydWUuXHJcbiAgICAvL1xyXG4gICAgLy8gT2xkZXIgdmVyc2lvbnMgb2YgVjggd2VyZSB1c2luZyByZWxhdGl2ZWx5IGZhc3QgSlMtd2l0aC1leHRlbnNpb25zIGNvZGUgZXZlbiB3aGVuIEFycmF5LnByb3RvdHlwZSBpcyBtb2RpZmllZDpcclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92OC92OC9ibG9iLzcuMC4xL3NyYy9qcy9hcnJheS5qcyNMNTk5LUw2NDJcclxuICAgIC8vXHJcbiAgICAvLyBJbiBzaG9ydCwgQXJyYXkgb3BlcmF0aW9ucyBhcmUgc2xvdyBpbiByZWNlbnQgdmVyc2lvbnMgb2YgVjggd2hlbiB0aGUgQXJyYXkucHJvdG90eXBlIGhhcyBiZWVuIHRhbXBlcmVkLlxyXG4gICAgLy8gU28sIHdoZW4gcG9zc2libGUsIHdlIGFyZSB1c2luZyBmYXN0ZXIgb3Blbi1jb2RlZCB2ZXJzaW9uIHRvIGJvb3N0IHRoZSBwZXJmb3JtYW5jZS5cclxuXHJcbiAgICAvLyBBcyBvZiBWOCA4LjQsIGRlcGVuZGluZyBvbiB0aGUgc2l6ZSBvZiB0aGUgYXJyYXksIHRoaXMgaXMgdXAgdG8gfjI1eCB0aW1lcyBmYXN0ZXIgdGhhbiBBcnJheSNzaGlmdCgpXHJcbiAgICAvLyBJbXBsZW1lbnRhdGlvbiBpcyBoZWF2aWx5IGluc3BpcmVkIGJ5OiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9iYTY4NDgwNWI2YzBlZGVkNzZlNWNkODllZTAwMzI4YWM3YTU5MzY1L2xpYi9pbnRlcm5hbC91dGlsLmpzI0wzNDEtTDM0N1xyXG4gICAgZnVuY3Rpb24gc2hpZnROb0FyZyhsaXN0KSB7XHJcbiAgICAgIHZhciByID0gbGlzdFswXTtcclxuICAgICAgdmFyIGluZGV4ID0gMTtcclxuICAgICAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xyXG4gICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICBsaXN0W2luZGV4IC0gMV0gPSBsaXN0W2luZGV4XTtcclxuICAgICAgfVxyXG4gICAgICBsaXN0LnBvcCgpO1xyXG4gICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0b0FycmF5U3ViY2xhc3Mob2JqLCBrbGFzcykge1xyXG4gICAgICBpZiAoa2xhc3MuJCRuYW1lID09PSBPcGFsLkFycmF5KSB7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4ga2xhc3MuJGFsbG9jYXRlKCkuJHJlcGxhY2UoI3tgb2JqYC50b19hfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBBIGhlbHBlciBmb3Iga2VlcF9pZiBhbmQgZGVsZXRlX2lmLCBmaWx0ZXIgaXMgZWl0aGVyIE9wYWwudHJ1dGh5XHJcbiAgICAvLyBvciBPcGFsLmZhbHN5LlxyXG4gICAgZnVuY3Rpb24gZmlsdGVySWYoc2VsZiwgZmlsdGVyLCBibG9jaykge1xyXG4gICAgICB2YXIgdmFsdWUsIHJhaXNlZCA9IG51bGwsIHVwZGF0ZWQgPSBuZXcgQXJyYXkoc2VsZi5sZW5ndGgpO1xyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGkyID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoIXJhaXNlZCkge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBzZWxmW2ldKVxyXG4gICAgICAgICAgfSBjYXRjaChlcnJvcikge1xyXG4gICAgICAgICAgICByYWlzZWQgPSBlcnJvcjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChyYWlzZWQgfHwgZmlsdGVyKHZhbHVlKSkge1xyXG4gICAgICAgICAgdXBkYXRlZFtpMl0gPSBzZWxmW2ldXHJcbiAgICAgICAgICBpMiArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGkyICE9PSBpKSB7XHJcbiAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgWzAsIHVwZGF0ZWQubGVuZ3RoXS5jb25jYXQodXBkYXRlZCkpO1xyXG4gICAgICAgIHNlbGYuc3BsaWNlKGkyLCB1cGRhdGVkLmxlbmd0aCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChyYWlzZWQpIHRocm93IHJhaXNlZDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb252ZXJ0VG9BcnJheShhcnJheSkge1xyXG4gICAgICBpZiAoIWFycmF5LiQkaXNfYXJyYXkpIHtcclxuICAgICAgICBhcnJheSA9ICRjb2VyY2VfdG8oYXJyYXksICN7OjpBcnJheX0sICd0b19hcnknKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gI3tgYXJyYXlgLnRvX2F9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGZhc3RfcHVzaChhcnIsIG9iamVjdHMpIHtcclxuICAgICAgLy8gcHVzaC5hcHBseSgpIGZvciBhcnJheXMgbG9uZ2VyIHRoYW4gMzI3NjcgbWF5IGNhdXNlIHZhcmlvdXMgYXJndW1lbnQgZXJyb3JzIGluIGJyb3dzZXJzXHJcbiAgICAgIC8vIGJ1dCBpdCBpcyBzaWduaWZpY2FudGx5IGZhc3RlciB0aGFuIGEgZm9yIGxvb3AsIHdoaWNoIHB1c2hlcyBlYWNoIGVsZW1lbnQgc2VwYXJhdGVseVxyXG4gICAgICAvLyBidXQgYXBwbHkoKSBoYXMgYSBvdmVyaGVhZCBieSBpdHNlbGYsIGZvciBhIHNtYWxsIG51bWJlciBvZiBlbGVtZW50c1xyXG4gICAgICAvLyB0aGUgZm9yIGxvb3AgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXJcclxuICAgICAgLy8gdGhpcyBpcyB1c2luZyB0aGUgYmVzdCBvcHRpb24gZGVwZW5kaW5nIG9uIG9iamVjdHMubGVuZ3RoXHJcbiAgICAgIHZhciBsZW5ndGggPSBvYmplY3RzLmxlbmd0aDtcclxuICAgICAgaWYgKGxlbmd0aCA+IDYgJiYgbGVuZ3RoIDwgMzI3NjcpIHtcclxuICAgICAgICBhcnIucHVzaC5hcHBseShhcnIsIG9iamVjdHMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGFyci5wdXNoKG9iamVjdHNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVmIHNlbGYuW10oKm9iamVjdHMpXHJcbiAgICBgdG9BcnJheVN1YmNsYXNzKG9iamVjdHMsIHNlbGYpYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgaW5pdGlhbGl6ZShzaXplID0gbmlsLCBvYmogPSBuaWwsICZibG9jaylcclxuICAgICV4e1xyXG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xyXG5cclxuICAgICAgaWYgKG9iaiAhPT0gbmlsICYmIGJsb2NrICE9PSBuaWwpIHtcclxuICAgICAgICAjezo6S2VybmVsLndhcm4oJ3dhcm5pbmc6IGJsb2NrIHN1cGVyc2VkZXMgZGVmYXVsdCB2YWx1ZSBhcmd1bWVudCcpfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2l6ZSA+ICN7OjpJbnRlZ2VyOjpNQVh9KSB7XHJcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdhcnJheSBzaXplIHRvbyBiaWcnfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcmd1bWVudHMubGVuZ3RoYH0gZm9yIDAuLjIpXCJ9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgaWYgKHNlbGYubGVuZ3RoID4gMCkgc2VsZi5zcGxpY2UoMCwgc2VsZi5sZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIGlmIChzaXplLiQkaXNfYXJyYXkpIHtcclxuICAgICAgICAgICN7cmVwbGFjZShzaXplLnRvX2EpfVxyXG4gICAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICAgICAgfSBlbHNlIGlmICgje3NpemUucmVzcG9uZF90bz8gOnRvX2FyeX0pIHtcclxuICAgICAgICAgICN7cmVwbGFjZShzaXplLnRvX2FyeSl9XHJcbiAgICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNpemUgPSAkY29lcmNlX3RvKHNpemUsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xyXG5cclxuICAgICAgaWYgKHNpemUgPCAwKSB7XHJcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBhcnJheSBzaXplJ31cclxuICAgICAgfVxyXG5cclxuICAgICAgc2VsZi5zcGxpY2UoMCwgc2VsZi5sZW5ndGgpO1xyXG4gICAgICB2YXIgaSwgdmFsdWU7XHJcblxyXG4gICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcclxuICAgICAgICAgIHNlbGYucHVzaChvYmopO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBmb3IgKGkgPSAwLCB2YWx1ZTsgaSA8IHNpemU7IGkrKykge1xyXG4gICAgICAgICAgdmFsdWUgPSBibG9jayhpKTtcclxuICAgICAgICAgIHNlbGZbaV0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc2VsZi50cnlfY29udmVydChvYmopXHJcbiAgICA6Ok9wYWwuY29lcmNlX3RvPyBvYmosIDo6QXJyYXksIDp0b19hcnlcclxuICBlbmRcclxuXHJcbiAgZGVmICYob3RoZXIpXHJcbiAgICAleHtcclxuICAgICAgb3RoZXIgPSBjb252ZXJ0VG9BcnJheShvdGhlcilcclxuXHJcbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMCB8fCBvdGhlci5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciByZXN1bHQgPSBbXSwgaGFzaCA9ICN7e319LCBpLCBsZW5ndGgsIGl0ZW07XHJcblxyXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBvdGhlci5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICRoYXNoX3B1dChoYXNoLCBvdGhlcltpXSwgdHJ1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpdGVtID0gc2VsZltpXTtcclxuICAgICAgICBpZiAoJGhhc2hfZGVsZXRlKGhhc2gsIGl0ZW0pICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHwob3RoZXIpXHJcbiAgICBvdGhlciA9IGBjb252ZXJ0VG9BcnJheShvdGhlcilgXHJcblxyXG4gICAgJXh7XHJcbiAgICAgIHZhciBoYXNoID0gI3t7fX0sIGksIGxlbmd0aCwgaXRlbTtcclxuXHJcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAkaGFzaF9wdXQoaGFzaCwgc2VsZltpXSwgdHJ1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG90aGVyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgJGhhc2hfcHV0KGhhc2gsIG90aGVyW2ldLCB0cnVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGhhc2guJGtleXMoKTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmICoob3RoZXIpXHJcbiAgICByZXR1cm4gam9pbihvdGhlci50b19zdHIpIGlmIG90aGVyLnJlc3BvbmRfdG8/IDp0b19zdHJcclxuXHJcbiAgICBvdGhlciA9IGAkY29lcmNlX3RvKG90aGVyLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcclxuXHJcbiAgICBpZiBgb3RoZXIgPCAwYFxyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBhcmd1bWVudCdcclxuICAgIGVuZFxyXG5cclxuICAgICV4e1xyXG4gICAgICB2YXIgcmVzdWx0ID0gW10sXHJcbiAgICAgICAgICBjb252ZXJ0ZWQgPSAje3RvX2F9O1xyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdGhlcjsgaSsrKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChjb252ZXJ0ZWQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgKyhvdGhlcilcclxuICAgIG90aGVyID0gYGNvbnZlcnRUb0FycmF5KG90aGVyKWBcclxuXHJcbiAgICBgc2VsZi5jb25jYXQob3RoZXIpYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgLShvdGhlcilcclxuICAgIG90aGVyID0gYGNvbnZlcnRUb0FycmF5KG90aGVyKWBcclxuXHJcbiAgICByZXR1cm4gW10gaWYgYHNlbGYubGVuZ3RoID09PSAwYFxyXG4gICAgcmV0dXJuIGBzZWxmLnNsaWNlKClgIGlmIGBvdGhlci5sZW5ndGggPT09IDBgXHJcblxyXG4gICAgJXh7XHJcbiAgICAgIHZhciByZXN1bHQgPSBbXSwgaGFzaCA9ICN7e319LCBpLCBsZW5ndGgsIGl0ZW07XHJcblxyXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBvdGhlci5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICRoYXNoX3B1dChoYXNoLCBvdGhlcltpXSwgdHJ1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpdGVtID0gc2VsZltpXTtcclxuICAgICAgICBpZiAoJGhhc2hfZ2V0KGhhc2gsIGl0ZW0pID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIDw8KG9iamVjdClcclxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxyXG4gICAgYHNlbGYucHVzaChvYmplY3QpYFxyXG5cclxuICAgIHNlbGZcclxuICBlbmRcclxuXHJcbiAgZGVmIDw9PihvdGhlcilcclxuICAgIGlmIDo6QXJyYXkgPT09IG90aGVyXHJcbiAgICAgIG90aGVyID0gb3RoZXIudG9fYVxyXG4gICAgZWxzaWYgb3RoZXIucmVzcG9uZF90bz8gOnRvX2FyeVxyXG4gICAgICBvdGhlciA9IG90aGVyLnRvX2FyeS50b19hXHJcbiAgICBlbHNlXHJcbiAgICAgIHJldHVyblxyXG4gICAgZW5kXHJcblxyXG4gICAgJXh7XHJcbiAgICAgIGlmICgje3NlbGZ9ID09PSAje290aGVyfSkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgY291bnQgPSBNYXRoLm1pbihzZWxmLmxlbmd0aCwgb3RoZXIubGVuZ3RoKTtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgIHZhciB0bXAgPSAje2BzZWxmW2ldYCA8PT4gYG90aGVyW2ldYH07XHJcblxyXG4gICAgICAgIGlmICh0bXAgIT09IDApIHtcclxuICAgICAgICAgIHJldHVybiB0bXA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gI3tgc2VsZi5sZW5ndGhgIDw9PiBgb3RoZXIubGVuZ3RoYH07XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiA9PShvdGhlcilcclxuICAgICV4e1xyXG4gICAgICB2YXIgcmVjdXJzZWQgPSB7fTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIF9lcWVxKGFycmF5LCBvdGhlcikge1xyXG4gICAgICAgIHZhciBpLCBsZW5ndGgsIGEsIGI7XHJcblxyXG4gICAgICAgIGlmIChhcnJheSA9PT0gb3RoZXIpXHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYgKCFvdGhlci4kJGlzX2FycmF5KSB7XHJcbiAgICAgICAgICBpZiAoJHJlc3BvbmRfdG8ob3RoZXIsICckdG9fYXJ5JykpIHtcclxuICAgICAgICAgICAgcmV0dXJuICN7YG90aGVyYCA9PSBgYXJyYXlgfTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChhcnJheS4kJGNvbnN0cnVjdG9yICE9PSBBcnJheSlcclxuICAgICAgICAgIGFycmF5ID0gI3tgYXJyYXlgLnRvX2F9O1xyXG4gICAgICAgIGlmIChvdGhlci4kJGNvbnN0cnVjdG9yICE9PSBBcnJheSlcclxuICAgICAgICAgIG90aGVyID0gI3tgb3RoZXJgLnRvX2F9O1xyXG5cclxuICAgICAgICBpZiAoYXJyYXkubGVuZ3RoICE9PSBvdGhlci5sZW5ndGgpIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlY3Vyc2VkWyN7YGFycmF5YC5vYmplY3RfaWR9XSA9IHRydWU7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBhID0gYXJyYXlbaV07XHJcbiAgICAgICAgICBiID0gb3RoZXJbaV07XHJcbiAgICAgICAgICBpZiAoYS4kJGlzX2FycmF5KSB7XHJcbiAgICAgICAgICAgIGlmIChiLiQkaXNfYXJyYXkgJiYgYi5sZW5ndGggIT09IGEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghcmVjdXJzZWQuaGFzT3duUHJvcGVydHkoI3tgYWAub2JqZWN0X2lkfSkpIHtcclxuICAgICAgICAgICAgICBpZiAoIV9lcWVxKGEsIGIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoISN7YGFgID09IGBiYH0pIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gX2VxZXEoc2VsZiwgb3RoZXIpO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICAleHtcclxuICAgIGZ1bmN0aW9uICRhcnJheV9zbGljZV9yYW5nZShzZWxmLCBpbmRleCkge1xyXG4gICAgICB2YXIgc2l6ZSA9IHNlbGYubGVuZ3RoLFxyXG4gICAgICAgICAgZXhjbHVkZSwgZnJvbSwgdG8sIHJlc3VsdDtcclxuXHJcbiAgICAgIGV4Y2x1ZGUgPSBpbmRleC5leGNsO1xyXG4gICAgICBmcm9tICAgID0gaW5kZXguYmVnaW4gPT09IG5pbCA/IDAgOiAkY29lcmNlX3RvKGluZGV4LmJlZ2luLCBPcGFsLkludGVnZXIsICd0b19pbnQnKTtcclxuICAgICAgdG8gICAgICA9IGluZGV4LmVuZCA9PT0gbmlsID8gLTEgOiAkY29lcmNlX3RvKGluZGV4LmVuZCwgT3BhbC5JbnRlZ2VyLCAndG9faW50Jyk7XHJcblxyXG4gICAgICBpZiAoZnJvbSA8IDApIHtcclxuICAgICAgICBmcm9tICs9IHNpemU7XHJcblxyXG4gICAgICAgIGlmIChmcm9tIDwgMCkge1xyXG4gICAgICAgICAgcmV0dXJuIG5pbDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpbmRleC5leGNsX3JldiAmJiBpbmRleC5iZWdpbiAhPT0gbmlsKSB7XHJcbiAgICAgICAgZnJvbSArPSAxO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZnJvbSA+IHNpemUpIHtcclxuICAgICAgICByZXR1cm4gbmlsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodG8gPCAwKSB7XHJcbiAgICAgICAgdG8gKz0gc2l6ZTtcclxuXHJcbiAgICAgICAgaWYgKHRvIDwgMCkge1xyXG4gICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFleGNsdWRlIHx8IGluZGV4LmVuZCA9PT0gbmlsKSB7XHJcbiAgICAgICAgdG8gKz0gMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZShmcm9tLCB0byk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gJGFycmF5X3NsaWNlX2FyaXRobWV0aWNfc2VxKHNlbGYsIGluZGV4KSB7XHJcbiAgICAgIHZhciBhcnJheSwgb3V0ID0gW10sIGkgPSAwLCBwc2V1ZG9yYW5nZTtcclxuXHJcbiAgICAgIGlmIChpbmRleC5zdGVwIDwgMCkge1xyXG4gICAgICAgIHBzZXVkb3JhbmdlID0ge1xyXG4gICAgICAgICAgYmVnaW46IGluZGV4LnJhbmdlLmVuZCxcclxuICAgICAgICAgIGVuZDogaW5kZXgucmFuZ2UuYmVnaW4sXHJcbiAgICAgICAgICBleGNsOiBmYWxzZSxcclxuICAgICAgICAgIGV4Y2xfcmV2OiBpbmRleC5yYW5nZS5leGNsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBhcnJheSA9ICRhcnJheV9zbGljZV9yYW5nZShzZWxmLCBwc2V1ZG9yYW5nZSkuJHJldmVyc2UoKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBhcnJheSA9ICRhcnJheV9zbGljZV9yYW5nZShzZWxmLCBpbmRleC5yYW5nZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHdoaWxlIChpIDwgYXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgICAgb3V0LnB1c2goYXJyYXlbaV0pO1xyXG4gICAgICAgIGkgKz0gTWF0aC5hYnMoaW5kZXguc3RlcCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gJGFycmF5X3NsaWNlX2luZGV4X2xlbmd0aChzZWxmLCBpbmRleCwgbGVuZ3RoKSB7XHJcbiAgICAgIHZhciBzaXplID0gc2VsZi5sZW5ndGgsXHJcbiAgICAgICAgICBleGNsdWRlLCBmcm9tLCB0bywgcmVzdWx0O1xyXG5cclxuICAgICAgaW5kZXggPSAkY29lcmNlX3RvKGluZGV4LCBPcGFsLkludGVnZXIsICd0b19pbnQnKTtcclxuXHJcbiAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICBpbmRleCArPSBzaXplO1xyXG5cclxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gbmlsO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaWYgKGluZGV4ID49IHNpemUgfHwgaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gbmlsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNlbGZbaW5kZXhdO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGxlbmd0aCA9ICRjb2VyY2VfdG8obGVuZ3RoLCBPcGFsLkludGVnZXIsICd0b19pbnQnKTtcclxuXHJcbiAgICAgICAgaWYgKGxlbmd0aCA8IDAgfHwgaW5kZXggPiBzaXplIHx8IGluZGV4IDwgMCkge1xyXG4gICAgICAgICAgcmV0dXJuIG5pbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoaW5kZXgsIGluZGV4ICsgbGVuZ3RoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVmIFtdKGluZGV4LCBsZW5ndGggPSB1bmRlZmluZWQpXHJcbiAgICAleHtcclxuICAgICAgaWYgKGluZGV4LiQkaXNfcmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gJGFycmF5X3NsaWNlX3JhbmdlKHNlbGYsIGluZGV4KTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmIChpbmRleC4kJGlzX2FyaXRobWV0aWNfc2VxKSB7XHJcbiAgICAgICAgcmV0dXJuICRhcnJheV9zbGljZV9hcml0aG1ldGljX3NlcShzZWxmLCBpbmRleCk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuICRhcnJheV9zbGljZV9pbmRleF9sZW5ndGgoc2VsZiwgaW5kZXgsIGxlbmd0aCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIFtdPShpbmRleCwgdmFsdWUsIGV4dHJhID0gdW5kZWZpbmVkKVxyXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXHJcblxyXG4gICAgZGF0YSA9IG5pbFxyXG4gICAgJXh7XHJcbiAgICAgIHZhciBpLCBzaXplID0gc2VsZi5sZW5ndGg7XHJcblxyXG4gICAgICBpZiAoaW5kZXguJCRpc19yYW5nZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZS4kJGlzX2FycmF5KVxyXG4gICAgICAgICAgZGF0YSA9ICN7dmFsdWUudG9fYX07XHJcbiAgICAgICAgZWxzZSBpZiAoI3t2YWx1ZS5yZXNwb25kX3RvPyA6dG9fYXJ5fSlcclxuICAgICAgICAgIGRhdGEgPSAje3ZhbHVlLnRvX2FyeS50b19hfTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBkYXRhID0gW3ZhbHVlXTtcclxuXHJcbiAgICAgICAgdmFyIGV4Y2x1ZGUgPSBpbmRleC5leGNsLFxyXG4gICAgICAgICAgICBmcm9tICAgID0gaW5kZXguYmVnaW4gPT09IG5pbCA/IDAgOiAkY29lcmNlX3RvKGluZGV4LmJlZ2luLCBPcGFsLkludGVnZXIsICd0b19pbnQnKSxcclxuICAgICAgICAgICAgdG8gICAgICA9IGluZGV4LmVuZCA9PT0gbmlsID8gLTEgOiAkY29lcmNlX3RvKGluZGV4LmVuZCwgT3BhbC5JbnRlZ2VyLCAndG9faW50Jyk7XHJcblxyXG4gICAgICAgIGlmIChmcm9tIDwgMCkge1xyXG4gICAgICAgICAgZnJvbSArPSBzaXplO1xyXG5cclxuICAgICAgICAgIGlmIChmcm9tIDwgMCkge1xyXG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgXCIje2luZGV4Lmluc3BlY3R9IG91dCBvZiByYW5nZVwifTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0byA8IDApIHtcclxuICAgICAgICAgIHRvICs9IHNpemU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWV4Y2x1ZGUgfHwgaW5kZXguZW5kID09PSBuaWwpIHtcclxuICAgICAgICAgIHRvICs9IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZnJvbSA+IHNpemUpIHtcclxuICAgICAgICAgIGZvciAoaSA9IHNpemU7IGkgPCBmcm9tOyBpKyspIHtcclxuICAgICAgICAgICAgc2VsZltpXSA9IG5pbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0byA8IDApIHtcclxuICAgICAgICAgIHNlbGYuc3BsaWNlLmFwcGx5KHNlbGYsIFtmcm9tLCAwXS5jb25jYXQoZGF0YSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHNlbGYuc3BsaWNlLmFwcGx5KHNlbGYsIFtmcm9tLCB0byAtIGZyb21dLmNvbmNhdChkYXRhKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGV4dHJhID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICN7bGVuZ3RoID0gMX1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbGVuZ3RoID0gdmFsdWU7XHJcbiAgICAgICAgICB2YWx1ZSAgPSBleHRyYTtcclxuXHJcbiAgICAgICAgICBpZiAodmFsdWUuJCRpc19hcnJheSlcclxuICAgICAgICAgICAgZGF0YSA9ICN7dmFsdWUudG9fYX07XHJcbiAgICAgICAgICBlbHNlIGlmICgje3ZhbHVlLnJlc3BvbmRfdG8/IDp0b19hcnl9KVxyXG4gICAgICAgICAgICBkYXRhID0gI3t2YWx1ZS50b19hcnkudG9fYX07XHJcbiAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGRhdGEgPSBbdmFsdWVdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG9sZDtcclxuXHJcbiAgICAgICAgaW5kZXggID0gJGNvZXJjZV90byhpbmRleCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XHJcbiAgICAgICAgbGVuZ3RoID0gJGNvZXJjZV90byhsZW5ndGgsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xyXG5cclxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICBvbGQgICAgPSBpbmRleDtcclxuICAgICAgICAgIGluZGV4ICs9IHNpemU7XHJcblxyXG4gICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCJpbmRleCAje2BvbGRgfSB0b28gc21hbGwgZm9yIGFycmF5OyBtaW5pbXVtICN7YC1zZWxmLmxlbmd0aGB9XCJ9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcclxuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpJbmRleEVycm9yLCBcIm5lZ2F0aXZlIGxlbmd0aCAoI3tsZW5ndGh9KVwifVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGluZGV4ID4gc2l6ZSkge1xyXG4gICAgICAgICAgZm9yIChpID0gc2l6ZTsgaSA8IGluZGV4OyBpKyspIHtcclxuICAgICAgICAgICAgc2VsZltpXSA9IG5pbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChleHRyYSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBzZWxmW2luZGV4XSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHNlbGYuc3BsaWNlLmFwcGx5KHNlbGYsIFtpbmRleCwgbGVuZ3RoXS5jb25jYXQoZGF0YSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBhbnk/KHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcclxuICAgIGBpZiAoc2VsZi5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZWBcclxuICAgIHN1cGVyXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBhc3NvYyhvYmplY3QpXHJcbiAgICAleHtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCBpdGVtOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoaXRlbSA9IHNlbGZbaV0sIGl0ZW0ubGVuZ3RoICYmICN7YGl0ZW1bMF1gID09IG9iamVjdH0pIHtcclxuICAgICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG5pbDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGF0KGluZGV4KVxyXG4gICAgJXh7XHJcbiAgICAgIGluZGV4ID0gJGNvZXJjZV90byhpbmRleCwgI3s6OkludGVnZXJ9LCAndG9faW50JylcclxuXHJcbiAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICBpbmRleCArPSBzZWxmLmxlbmd0aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzZWxmLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBuaWw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzZWxmW2luZGV4XTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGJzZWFyY2hfaW5kZXgoJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVudW1fZm9yIDpic2VhcmNoX2luZGV4IHVubGVzcyBibG9ja19naXZlbj9cclxuXHJcbiAgICAleHtcclxuICAgICAgdmFyIG1pbiA9IDAsXHJcbiAgICAgICAgICBtYXggPSBzZWxmLmxlbmd0aCxcclxuICAgICAgICAgIG1pZCxcclxuICAgICAgICAgIHZhbCxcclxuICAgICAgICAgIHJldCxcclxuICAgICAgICAgIHNtYWxsZXIgPSBmYWxzZSxcclxuICAgICAgICAgIHNhdGlzZmllZCA9IG5pbDtcclxuXHJcbiAgICAgIHdoaWxlIChtaW4gPCBtYXgpIHtcclxuICAgICAgICBtaWQgPSBtaW4gKyBNYXRoLmZsb29yKChtYXggLSBtaW4pIC8gMik7XHJcbiAgICAgICAgdmFsID0gc2VsZlttaWRdO1xyXG4gICAgICAgIHJldCA9ICR5aWVsZDEoYmxvY2ssIHZhbCk7XHJcblxyXG4gICAgICAgIGlmIChyZXQgPT09IHRydWUpIHtcclxuICAgICAgICAgIHNhdGlzZmllZCA9IG1pZDtcclxuICAgICAgICAgIHNtYWxsZXIgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyZXQgPT09IGZhbHNlIHx8IHJldCA9PT0gbmlsKSB7XHJcbiAgICAgICAgICBzbWFsbGVyID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJldC4kJGlzX251bWJlcikge1xyXG4gICAgICAgICAgaWYgKHJldCA9PT0gMCkgeyByZXR1cm4gbWlkOyB9XHJcbiAgICAgICAgICBzbWFsbGVyID0gKHJldCA8IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2ByZXRgLmNsYXNzfSAobXVzdCBiZSBudW1lcmljLCB0cnVlLCBmYWxzZSBvciBuaWwpXCJ9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc21hbGxlcikgeyBtYXggPSBtaWQ7IH0gZWxzZSB7IG1pbiA9IG1pZCArIDE7IH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHNhdGlzZmllZDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGJzZWFyY2goJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVudW1fZm9yIDpic2VhcmNoIHVubGVzcyBibG9ja19naXZlbj9cclxuXHJcbiAgICBpbmRleCA9IGJzZWFyY2hfaW5kZXgoJmJsb2NrKVxyXG5cclxuICAgICV4e1xyXG4gICAgICBpZiAoaW5kZXggIT0gbnVsbCAmJiBpbmRleC4kJGlzX251bWJlcikge1xyXG4gICAgICAgIHJldHVybiBzZWxmW2luZGV4XTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGN5Y2xlKG4gPSBuaWwsICZibG9jaylcclxuICAgIHVubGVzcyBibG9ja19naXZlbj9cclxuICAgICAgcmV0dXJuIGVudW1fZm9yKDpjeWNsZSwgbikgZG9cclxuICAgICAgICBpZiBuLm5pbD9cclxuICAgICAgICAgIDo6RmxvYXQ6OklORklOSVRZXHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgbiA9IDo6T3BhbC5jb2VyY2VfdG8hKG4sIDo6SW50ZWdlciwgOnRvX2ludClcclxuICAgICAgICAgIG4gPiAwID8gZW51bWVyYXRvcl9zaXplICogbiA6IDBcclxuICAgICAgICBlbmRcclxuICAgICAgZW5kXHJcbiAgICBlbmRcclxuXHJcbiAgICByZXR1cm4gaWYgZW1wdHk/IHx8IG4gPT0gMFxyXG5cclxuICAgICV4e1xyXG4gICAgICB2YXIgaSwgbGVuZ3RoLCB2YWx1ZTtcclxuXHJcbiAgICAgIGlmIChuID09PSBuaWwpIHtcclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBuID0gI3s6Ok9wYWwuY29lcmNlX3RvIShuLCA6OkludGVnZXIsIDp0b19pbnQpfTtcclxuICAgICAgICBpZiAobiA8PSAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdoaWxlIChuID4gMCkge1xyXG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIG4tLTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBjbGVhclxyXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXHJcblxyXG4gICAgYHNlbGYuc3BsaWNlKDAsIHNlbGYubGVuZ3RoKWBcclxuXHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBjb3VudChvYmplY3QgPSB1bmRlZmluZWQsICZibG9jaylcclxuICAgIGlmIGBvYmplY3QgIT09IHVuZGVmaW5lZGAgfHwgYmxvY2tcclxuICAgICAgc3VwZXJcclxuICAgIGVsc2VcclxuICAgICAgc2l6ZVxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBpbml0aWFsaXplX2NvcHkob3RoZXIpXHJcbiAgICByZXBsYWNlIG90aGVyXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBjb2xsZWN0KCZibG9jaylcclxuICAgIHJldHVybiBlbnVtX2Zvcig6Y29sbGVjdCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG5cclxuICAgICV4e1xyXG4gICAgICB2YXIgcmVzdWx0ID0gW107XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBzZWxmW2ldKTtcclxuICAgICAgICByZXN1bHRbaV0gPSB2YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGNvbGxlY3QhKCZibG9jaylcclxuICAgIHJldHVybiBlbnVtX2Zvcig6Y29sbGVjdCEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cclxuXHJcbiAgICAleHtcclxuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xyXG4gICAgICAgIHNlbGZbaV0gPSB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNlbGZcclxuICBlbmRcclxuXHJcbiAgJXh7XHJcbiAgICBmdW5jdGlvbiBiaW5vbWlhbF9jb2VmZmljaWVudChuLCBrKSB7XHJcbiAgICAgIGlmIChuID09PSBrIHx8IGsgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGsgPiAwICYmIG4gPiBrKSB7XHJcbiAgICAgICAgcmV0dXJuIGJpbm9taWFsX2NvZWZmaWNpZW50KG4gLSAxLCBrIC0gMSkgKyBiaW5vbWlhbF9jb2VmZmljaWVudChuIC0gMSwgayk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVmIGNvbWJpbmF0aW9uKG4pXHJcbiAgICBudW0gPSA6Ok9wYWwuY29lcmNlX3RvISBuLCA6OkludGVnZXIsIDp0b19pbnRcclxuICAgIHJldHVybiBlbnVtX2Zvcig6Y29tYmluYXRpb24sIG51bSkgeyBgYmlub21pYWxfY29lZmZpY2llbnQoI3tzZWxmfS5sZW5ndGgsIG51bSlgIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG5cclxuICAgICV4e1xyXG4gICAgICB2YXIgaSwgbGVuZ3RoLCBzdGFjaywgY2hvc2VuLCBsZXYsIGRvbmUsIG5leHQ7XHJcblxyXG4gICAgICBpZiAobnVtID09PSAwKSB7XHJcbiAgICAgICAgI3t5aWVsZCBbXX1cclxuICAgICAgfSBlbHNlIGlmIChudW0gPT09IDEpIHtcclxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAje3lpZWxkIGBbc2VsZltpXV1gfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmIChudW0gPT09IHNlbGYubGVuZ3RoKSB7XHJcbiAgICAgICAgI3t5aWVsZCBgc2VsZi5zbGljZSgpYH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmIChudW0gPj0gMCAmJiBudW0gPCBzZWxmLmxlbmd0aCkge1xyXG4gICAgICAgIHN0YWNrID0gW107XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8PSBudW0gKyAxOyBpKyspIHtcclxuICAgICAgICAgIHN0YWNrLnB1c2goMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjaG9zZW4gPSBbXTtcclxuICAgICAgICBsZXYgPSAwO1xyXG4gICAgICAgIGRvbmUgPSBmYWxzZTtcclxuICAgICAgICBzdGFja1swXSA9IC0xO1xyXG5cclxuICAgICAgICB3aGlsZSAoIWRvbmUpIHtcclxuICAgICAgICAgIGNob3NlbltsZXZdID0gc2VsZltzdGFja1tsZXYrMV1dO1xyXG4gICAgICAgICAgd2hpbGUgKGxldiA8IG51bSAtIDEpIHtcclxuICAgICAgICAgICAgbGV2Kys7XHJcbiAgICAgICAgICAgIG5leHQgPSBzdGFja1tsZXYrMV0gPSBzdGFja1tsZXZdICsgMTtcclxuICAgICAgICAgICAgY2hvc2VuW2xldl0gPSBzZWxmW25leHRdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgI3sgeWllbGQgYGNob3Nlbi5zbGljZSgpYCB9XHJcbiAgICAgICAgICBsZXYrKztcclxuICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgZG9uZSA9IChsZXYgPT09IDApO1xyXG4gICAgICAgICAgICBzdGFja1tsZXZdKys7XHJcbiAgICAgICAgICAgIGxldi0tO1xyXG4gICAgICAgICAgfSB3aGlsZSAoIHN0YWNrW2xldisxXSArIG51bSA9PT0gc2VsZi5sZW5ndGggKyBsZXYgKyAxICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiByZXBlYXRlZF9jb21iaW5hdGlvbihuKVxyXG4gICAgbnVtID0gOjpPcGFsLmNvZXJjZV90byEgbiwgOjpJbnRlZ2VyLCA6dG9faW50XHJcblxyXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG4gICAgICByZXR1cm4gZW51bV9mb3IoOnJlcGVhdGVkX2NvbWJpbmF0aW9uLCBudW0pIHsgYGJpbm9taWFsX2NvZWZmaWNpZW50KHNlbGYubGVuZ3RoICsgbnVtIC0gMSwgbnVtKWAgfVxyXG4gICAgZW5kXHJcblxyXG4gICAgJXh7XHJcbiAgICAgIGZ1bmN0aW9uIGl0ZXJhdGUobWF4LCBmcm9tLCBidWZmZXIsIHNlbGYpIHtcclxuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PSBtYXgpIHtcclxuICAgICAgICAgIHZhciBjb3B5ID0gYnVmZmVyLnNsaWNlKCk7XHJcbiAgICAgICAgICAje3lpZWxkIGBjb3B5YH1cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGZyb207IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBidWZmZXIucHVzaChzZWxmW2ldKTtcclxuICAgICAgICAgIGl0ZXJhdGUobWF4LCBpLCBidWZmZXIsIHNlbGYpO1xyXG4gICAgICAgICAgYnVmZmVyLnBvcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG51bSA+PSAwKSB7XHJcbiAgICAgICAgaXRlcmF0ZShudW0sIDAsIFtdLCBzZWxmKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgY29tcGFjdFxyXG4gICAgJXh7XHJcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aCwgaXRlbTsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XHJcbiAgICAgICAgaWYgKGl0ZW0gIT09IG5pbCAmJiBpdGVtICE9IG51bGwpIHtcclxuICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGNvbXBhY3QhXHJcbiAgICAleHtcclxuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcclxuXHJcbiAgICAgIHZhciBvcmlnaW5hbCA9IHNlbGYubGVuZ3RoO1xyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCBpdGVtOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpdGVtID0gc2VsZltpXTtcclxuICAgICAgICBpZiAoaXRlbSA9PT0gbmlsIHx8IGl0ZW0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgc2VsZi5zcGxpY2UoaSwgMSk7XHJcblxyXG4gICAgICAgICAgbGVuZ3RoLS07XHJcbiAgICAgICAgICBpLS07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc2VsZi5sZW5ndGggPT09IG9yaWdpbmFsID8gbmlsIDogc2VsZjtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGNvbmNhdCgqb3RoZXJzKVxyXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXHJcblxyXG4gICAgb3RoZXJzID0gb3RoZXJzLm1hcCBkbyB8b3RoZXJ8XHJcbiAgICAgIGBvdGhlciA9IGNvbnZlcnRUb0FycmF5KG90aGVyKWBcclxuXHJcbiAgICAgIGlmIG90aGVyLmVxdWFsPyhzZWxmKVxyXG4gICAgICAgIG90aGVyID0gb3RoZXIuZHVwXHJcbiAgICAgIGVuZFxyXG5cclxuICAgICAgb3RoZXJcclxuICAgIGVuZFxyXG5cclxuICAgIG90aGVycy5lYWNoIGRvIHxvdGhlcnxcclxuICAgICAgJXh7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG90aGVyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBzZWxmLnB1c2gob3RoZXJbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgZW5kXHJcblxyXG4gICAgc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgZGVsZXRlKG9iamVjdClcclxuICAgICV4e1xyXG4gICAgICB2YXIgb3JpZ2luYWwgPSBzZWxmLmxlbmd0aDtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvcmlnaW5hbDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKCN7YHNlbGZbaV1gID09IG9iamVjdH0pIHtcclxuICAgICAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XHJcblxyXG4gICAgICAgICAgc2VsZi5zcGxpY2UoaSwgMSk7XHJcblxyXG4gICAgICAgICAgbGVuZ3RoLS07XHJcbiAgICAgICAgICBpLS07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IG9yaWdpbmFsKSB7XHJcbiAgICAgICAgaWYgKCN7YmxvY2tfZ2l2ZW4/fSkge1xyXG4gICAgICAgICAgcmV0dXJuICN7eWllbGR9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmlsO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBkZWxldGVfYXQoaW5kZXgpXHJcbiAgICAleHtcclxuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcclxuXHJcbiAgICAgIGluZGV4ID0gJGNvZXJjZV90byhpbmRleCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XHJcblxyXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgaW5kZXggKz0gc2VsZi5sZW5ndGg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gc2VsZi5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbmlsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgcmVzdWx0ID0gc2VsZltpbmRleF07XHJcblxyXG4gICAgICBzZWxmLnNwbGljZShpbmRleCwgMSk7XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZGVsZXRlX2lmKCZibG9jaylcclxuICAgIHJldHVybiBlbnVtX2Zvcig6ZGVsZXRlX2lmKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XHJcbiAgICAleHtcclxuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcclxuXHJcbiAgICAgIGZpbHRlcklmKHNlbGYsICRmYWxzeSwgYmxvY2spXHJcbiAgICB9XHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBkaWZmZXJlbmNlKCphcnJheXMpXHJcbiAgICBhcnJheXMucmVkdWNlKHRvX2EuZHVwKSB7IHxhLCBifCBhIC0gYiB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBkaWcoaWR4LCAqaWR4cylcclxuICAgIGl0ZW0gPSBzZWxmW2lkeF1cclxuXHJcbiAgICAleHtcclxuICAgICAgaWYgKGl0ZW0gPT09IG5pbCB8fCBpZHhzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdW5sZXNzIGl0ZW0ucmVzcG9uZF90bz8oOmRpZylcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiI3tpdGVtLmNsYXNzfSBkb2VzIG5vdCBoYXZlICNkaWcgbWV0aG9kXCJcclxuICAgIGVuZFxyXG5cclxuICAgIGl0ZW0uZGlnKCppZHhzKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZHJvcChudW1iZXIpXHJcbiAgICAleHtcclxuICAgICAgbnVtYmVyID0gJGNvZXJjZV90byhudW1iZXIsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xyXG5cclxuICAgICAgaWYgKG51bWJlciA8IDApIHtcclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvcn1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2UobnVtYmVyKTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGR1cFxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChzZWxmLiQkY2xhc3MgPT09IE9wYWwuQXJyYXkgJiZcclxuICAgICAgICAgIHNlbGYuJCRjbGFzcy4kYWxsb2NhdGUuJCRwcmlzdGluZSAmJlxyXG4gICAgICAgICAgc2VsZi4kY29weV9pbnN0YW5jZV92YXJpYWJsZXMuJCRwcmlzdGluZSAmJlxyXG4gICAgICAgICAgc2VsZi4kaW5pdGlhbGl6ZV9kdXAuJCRwcmlzdGluZSkge1xyXG4gICAgICAgIHJldHVybiBzZWxmLnNsaWNlKDApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3VwZXJcclxuICBlbmRcclxuXHJcbiAgZGVmIGVhY2goJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XHJcblxyXG4gICAgJXh7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICR5aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgZWFjaF9pbmRleCgmYmxvY2spXHJcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfaW5kZXgpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cclxuXHJcbiAgICAleHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgJHlpZWxkMShibG9jaywgaSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBlbXB0eT9cclxuICAgIGBzZWxmLmxlbmd0aCA9PT0gMGBcclxuICBlbmRcclxuXHJcbiAgZGVmIGVxbD8ob3RoZXIpXHJcbiAgICAleHtcclxuICAgICAgdmFyIHJlY3Vyc2VkID0ge307XHJcblxyXG4gICAgICBmdW5jdGlvbiBfZXFsKGFycmF5LCBvdGhlcikge1xyXG4gICAgICAgIHZhciBpLCBsZW5ndGgsIGEsIGI7XHJcblxyXG4gICAgICAgIGlmICghb3RoZXIuJCRpc19hcnJheSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3RoZXIgPSAje290aGVyLnRvX2F9O1xyXG5cclxuICAgICAgICBpZiAoYXJyYXkubGVuZ3RoICE9PSBvdGhlci5sZW5ndGgpIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlY3Vyc2VkWyN7YGFycmF5YC5vYmplY3RfaWR9XSA9IHRydWU7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBhID0gYXJyYXlbaV07XHJcbiAgICAgICAgICBiID0gb3RoZXJbaV07XHJcbiAgICAgICAgICBpZiAoYS4kJGlzX2FycmF5KSB7XHJcbiAgICAgICAgICAgIGlmIChiLiQkaXNfYXJyYXkgJiYgYi5sZW5ndGggIT09IGEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghcmVjdXJzZWQuaGFzT3duUHJvcGVydHkoI3tgYWAub2JqZWN0X2lkfSkpIHtcclxuICAgICAgICAgICAgICBpZiAoIV9lcWwoYSwgYikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghI3tgYWAuZXFsPyhgYmApfSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBfZXFsKHNlbGYsIG90aGVyKTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGZldGNoKGluZGV4LCBkZWZhdWx0cyA9IHVuZGVmaW5lZCwgJmJsb2NrKVxyXG4gICAgJXh7XHJcbiAgICAgIHZhciBvcmlnaW5hbCA9IGluZGV4O1xyXG5cclxuICAgICAgaW5kZXggPSAkY29lcmNlX3RvKGluZGV4LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcclxuXHJcbiAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICBpbmRleCArPSBzZWxmLmxlbmd0aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBzZWxmLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBzZWxmW2luZGV4XTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwgJiYgZGVmYXVsdHMgIT0gbnVsbCkge1xyXG4gICAgICAgICN7d2Fybignd2FybmluZzogYmxvY2sgc3VwZXJzZWRlcyBkZWZhdWx0IHZhbHVlIGFyZ3VtZW50Jyl9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XHJcbiAgICAgICAgcmV0dXJuIGJsb2NrKG9yaWdpbmFsKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGRlZmF1bHRzICE9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdHM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpJbmRleEVycm9yLCBcImluZGV4ICN7YG9yaWdpbmFsYH0gb3V0c2lkZSBvZiBhcnJheSBib3VuZHM6IDAuLi4wXCJ9XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkluZGV4RXJyb3IsIFwiaW5kZXggI3tgb3JpZ2luYWxgfSBvdXRzaWRlIG9mIGFycmF5IGJvdW5kczogLSN7YHNlbGYubGVuZ3RoYH0uLi4je2BzZWxmLmxlbmd0aGB9XCJ9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBmaWxsKCphcmdzLCAmYmxvY2spXHJcbiAgICAleHtcclxuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcclxuXHJcbiAgICAgIHZhciBpLCBsZW5ndGgsIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIGJsb2NrXHJcbiAgICAgIGlmIGBhcmdzLmxlbmd0aCA+IDJgXHJcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YXJncy5sZW5ndGh9IGZvciAwLi4yKVwiXHJcbiAgICAgIGVuZFxyXG5cclxuICAgICAgb25lLCB0d28gPSBhcmdzXHJcbiAgICBlbHNlXHJcbiAgICAgIGlmIGBhcmdzLmxlbmd0aCA9PSAwYFxyXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDAgZm9yIDEuLjMpJ1xyXG4gICAgICBlbHNpZiBgYXJncy5sZW5ndGggPiAzYFxyXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2FyZ3MubGVuZ3RofSBmb3IgMS4uMylcIlxyXG4gICAgICBlbmRcclxuXHJcbiAgICAgIG9iaiwgb25lLCB0d28gPSBhcmdzXHJcbiAgICBlbmRcclxuXHJcbiAgICBpZiA6OlJhbmdlID09PSBvbmVcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdsZW5ndGggaW52YWxpZCB3aXRoIHJhbmdlJyBpZiB0d29cclxuXHJcbiAgICAgIGxlZnQgICA9IGBvbmUuYmVnaW4gPT09IG5pbCA/IDAgOiAkY29lcmNlX3RvKG9uZS5iZWdpbiwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXHJcbiAgICAgIGBsZWZ0ICs9IHRoaXMubGVuZ3RoYCBpZiBgbGVmdCA8IDBgXHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgXCIje29uZS5pbnNwZWN0fSBvdXQgb2YgcmFuZ2VcIiBpZiBgbGVmdCA8IDBgXHJcblxyXG4gICAgICByaWdodCA9IGBvbmUuZW5kID09PSBuaWwgPyAtMSA6ICRjb2VyY2VfdG8ob25lLmVuZCwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXHJcbiAgICAgIGByaWdodCArPSB0aGlzLmxlbmd0aGAgaWYgYHJpZ2h0IDwgMGBcclxuICAgICAgYHJpZ2h0ICs9IDFgIHVubGVzcyBvbmUuZXhjbHVkZV9lbmQ/XHJcblxyXG4gICAgICByZXR1cm4gc2VsZiBpZiBgcmlnaHQgPD0gbGVmdGBcclxuICAgIGVsc2lmIG9uZVxyXG4gICAgICBsZWZ0ICAgPSBgJGNvZXJjZV90byhvbmUsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxyXG4gICAgICBgbGVmdCArPSB0aGlzLmxlbmd0aGAgaWYgYGxlZnQgPCAwYFxyXG4gICAgICBsZWZ0ICAgPSAwIGlmIGBsZWZ0IDwgMGBcclxuXHJcbiAgICAgIGlmIHR3b1xyXG4gICAgICAgIHJpZ2h0ID0gYCRjb2VyY2VfdG8odHdvLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcclxuXHJcbiAgICAgICAgcmV0dXJuIHNlbGYgaWYgYHJpZ2h0ID09IDBgXHJcblxyXG4gICAgICAgIGByaWdodCArPSBsZWZ0YFxyXG4gICAgICBlbHNlXHJcbiAgICAgICAgcmlnaHQgPSBgdGhpcy5sZW5ndGhgXHJcbiAgICAgIGVuZFxyXG4gICAgZWxzZVxyXG4gICAgICBsZWZ0ICA9IDBcclxuICAgICAgcmlnaHQgPSBgdGhpcy5sZW5ndGhgXHJcbiAgICBlbmRcclxuXHJcbiAgICBpZiBgbGVmdCA+IHRoaXMubGVuZ3RoYFxyXG4gICAgICAleHtcclxuICAgICAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aDsgaSA8IHJpZ2h0OyBpKyspIHtcclxuICAgICAgICAgIHNlbGZbaV0gPSBuaWw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICBlbmRcclxuXHJcbiAgICBpZiBgcmlnaHQgPiB0aGlzLmxlbmd0aGBcclxuICAgICAgYHRoaXMubGVuZ3RoID0gcmlnaHRgXHJcbiAgICBlbmRcclxuXHJcbiAgICBpZiBibG9ja1xyXG4gICAgICAleHtcclxuICAgICAgICBmb3IgKGxlbmd0aCA9IHRoaXMubGVuZ3RoOyBsZWZ0IDwgcmlnaHQ7IGxlZnQrKykge1xyXG4gICAgICAgICAgdmFsdWUgPSBibG9jayhsZWZ0KTtcclxuICAgICAgICAgIHNlbGZbbGVmdF0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIGVsc2VcclxuICAgICAgJXh7XHJcbiAgICAgICAgZm9yIChsZW5ndGggPSB0aGlzLmxlbmd0aDsgbGVmdCA8IHJpZ2h0OyBsZWZ0KyspIHtcclxuICAgICAgICAgIHNlbGZbbGVmdF0gPSAje29ian07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICBlbmRcclxuXHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBmaXJzdChjb3VudCA9IHVuZGVmaW5lZClcclxuICAgICV4e1xyXG4gICAgICBpZiAoY291bnQgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBzZWxmLmxlbmd0aCA9PT0gMCA/IG5pbCA6IHNlbGZbMF07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvdW50ID0gJGNvZXJjZV90byhjb3VudCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XHJcblxyXG4gICAgICBpZiAoY291bnQgPCAwKSB7XHJcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBhcnJheSBzaXplJ307XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzZWxmLnNsaWNlKDAsIGNvdW50KTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGZsYXR0ZW4obGV2ZWwgPSB1bmRlZmluZWQpXHJcbiAgICAleHtcclxuICAgICAgZnVuY3Rpb24gX2ZsYXR0ZW4oYXJyYXksIGxldmVsKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLFxyXG4gICAgICAgICAgICBpLCBsZW5ndGgsXHJcbiAgICAgICAgICAgIGl0ZW0sIGFyeTtcclxuXHJcbiAgICAgICAgYXJyYXkgPSAje2BhcnJheWAudG9fYX07XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBpdGVtID0gYXJyYXlbaV07XHJcblxyXG4gICAgICAgICAgaWYgKCEkcmVzcG9uZF90byhpdGVtLCAnJHRvX2FyeScsIHRydWUpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBhcnkgPSAje2BpdGVtYC50b19hcnl9O1xyXG5cclxuICAgICAgICAgIGlmIChhcnkgPT09IG5pbCkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKCFhcnkuJCRpc19hcnJheSkge1xyXG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yfTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoYXJ5ID09PSBzZWxmKSB7XHJcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yfTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBzd2l0Y2ggKGxldmVsKSB7XHJcbiAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChfZmxhdHRlbihhcnkpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFyeSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgZmFzdF9wdXNoKHJlc3VsdCwgX2ZsYXR0ZW4oYXJ5LCBsZXZlbCAtIDEpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGxldmVsICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBsZXZlbCA9ICRjb2VyY2VfdG8obGV2ZWwsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gX2ZsYXR0ZW4oc2VsZiwgbGV2ZWwpO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZmxhdHRlbiEobGV2ZWwgPSB1bmRlZmluZWQpXHJcbiAgICAleHtcclxuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcclxuXHJcbiAgICAgIHZhciBmbGF0dGVuZWQgPSAje2ZsYXR0ZW4gbGV2ZWx9O1xyXG5cclxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09IGZsYXR0ZW5lZC5sZW5ndGgpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgaWYgKHNlbGZbaV0gIT09IGZsYXR0ZW5lZFtpXSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpID09IGxlbmd0aCkge1xyXG4gICAgICAgICAgcmV0dXJuIG5pbDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgICN7cmVwbGFjZSBgZmxhdHRlbmVkYH07XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgZnJlZXplXHJcbiAgICByZXR1cm4gc2VsZiBpZiBmcm96ZW4/XHJcblxyXG4gICAgYCRmcmVlemUoc2VsZilgXHJcbiAgZW5kXHJcblxyXG4gIGB2YXIgJGhhc2hfaWRzYFxyXG5cclxuICBkZWYgaGFzaFxyXG4gICAgJXh7XHJcbiAgICAgIHZhciB0b3AgPSAoJGhhc2hfaWRzID09PSB1bmRlZmluZWQpLFxyXG4gICAgICAgICAgcmVzdWx0ID0gJG9wYWwzMl9pbml0KCksXHJcbiAgICAgICAgICBoYXNoX2lkID0gc2VsZi4kb2JqZWN0X2lkKCksXHJcbiAgICAgICAgICBpdGVtLCBpLCBrZXksIHZhbHVlcztcclxuXHJcbiAgICAgIHJlc3VsdCA9ICRvcGFsMzJfYWRkKHJlc3VsdCwgMHhBKTtcclxuICAgICAgcmVzdWx0ID0gJG9wYWwzMl9hZGQocmVzdWx0LCBzZWxmLmxlbmd0aCk7XHJcblxyXG4gICAgICBpZiAodG9wKSB7XHJcbiAgICAgICAgJGhhc2hfaWRzID0gbmV3IE1hcCgpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHJldHVybiBlYXJseSBmb3IgcmVjdXJzaXZlIHN0cnVjdHVyZXNcclxuICAgICAgZWxzZSBpZiAoJGhhc2hfaWRzLmhhcyhoYXNoX2lkKSkge1xyXG4gICAgICAgIHJldHVybiAkb3BhbDMyX2FkZChyZXN1bHQsIDB4MDEwMTAxMDEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmICghdG9wKSB7XHJcbiAgICAgICAgICB2YWx1ZXMgPSAkaGFzaF9pZHMudmFsdWVzKCk7XHJcbiAgICAgICAgICBmb3IgKGl0ZW0gb2YgdmFsdWVzKSB7XHJcbiAgICAgICAgICAgIGlmICgje2VxbD8oYGl0ZW1gKX0pIHtcclxuICAgICAgICAgICAgICByZXR1cm4gJG9wYWwzMl9hZGQocmVzdWx0LCAweDAxMDEwMTAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgJGhhc2hfaWRzLnNldChoYXNoX2lkLCBzZWxmKTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xyXG4gICAgICAgICAgcmVzdWx0ID0gJG9wYWwzMl9hZGQocmVzdWx0LCBpdGVtLiRoYXNoKCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICBpZiAodG9wKSB7XHJcbiAgICAgICAgICAkaGFzaF9pZHMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBpbmNsdWRlPyhtZW1iZXIpXHJcbiAgICAleHtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoJGVxZXEoc2VsZltpXSwgbWVtYmVyKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBpbmRleChvYmplY3QgPSB1bmRlZmluZWQsICZibG9jaylcclxuICAgICV4e1xyXG4gICAgICB2YXIgaSwgbGVuZ3RoLCB2YWx1ZTtcclxuXHJcbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiBibG9jayAhPT0gbmlsKSB7XHJcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBnaXZlbiBibG9jayBub3QgdXNlZCcpfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwpIHtcclxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAoI3tgc2VsZltpXWAgPT0gb2JqZWN0fSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoYmxvY2sgIT09IG5pbCkge1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICB2YWx1ZSA9IGJsb2NrKHNlbGZbaV0pO1xyXG5cclxuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gZmFsc2UgJiYgdmFsdWUgIT09IG5pbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuICN7ZW51bV9mb3IgOmluZGV4fTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG5pbDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGluc2VydChpbmRleCwgKm9iamVjdHMpXHJcbiAgICAleHtcclxuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcclxuXHJcbiAgICAgIGluZGV4ID0gJGNvZXJjZV90byhpbmRleCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XHJcblxyXG4gICAgICBpZiAob2JqZWN0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgICAgaW5kZXggKz0gc2VsZi5sZW5ndGggKyAxO1xyXG5cclxuICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICAgICAgI3sgOjpLZXJuZWwucmFpc2UgOjpJbmRleEVycm9yLCBcIiN7aW5kZXh9IGlzIG91dCBvZiBib3VuZHNcIiB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5kZXggPiBzZWxmLmxlbmd0aCkge1xyXG4gICAgICAgICAgZm9yICh2YXIgaSA9IHNlbGYubGVuZ3RoOyBpIDwgaW5kZXg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWxmLnB1c2gobmlsKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNlbGYuc3BsaWNlLmFwcGx5KHNlbGYsIFtpbmRleCwgMF0uY29uY2F0KG9iamVjdHMpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNlbGZcclxuICBlbmRcclxuXHJcbiAgYHZhciBpbnNwZWN0X3N0YWNrID0gW11gXHJcblxyXG4gIGRlZiBpbnNwZWN0XHJcbiAgICAleHtcclxuICAgICAgdmFyIHJlc3VsdCA9IFtdLFxyXG4gICAgICBpZCA9ICN7X19pZF9ffSxcclxuICAgICAgcHVzaGVkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBiZWdpblxyXG4gICAgICAleHtcclxuICAgICAgICBpZiAoaW5zcGVjdF9zdGFjay5pbmRleE9mKGlkKSAhPT0gLTEpIHtcclxuICAgICAgICAgIHB1c2hlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgcmV0dXJuICdbLi4uXSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3BlY3Rfc3RhY2sucHVzaChpZClcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIHZhciBpdGVtID0gI3tzZWxmW2BpYF19O1xyXG5cclxuICAgICAgICAgIHJlc3VsdC5wdXNoKCN7T3BhbC5pbnNwZWN0KGBpdGVtYCl9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAnWycgKyByZXN1bHQuam9pbignLCAnKSArICddJztcclxuICAgICAgfVxyXG4gICAgICBuaWxcclxuICAgIGVuc3VyZVxyXG4gICAgICBgaWYgKHB1c2hlZCkgaW5zcGVjdF9zdGFjay5wb3AoKWBcclxuICAgIGVuZFxyXG4gIGVuZFxyXG5cclxuICBkZWYgaW50ZXJzZWN0aW9uKCphcnJheXMpXHJcbiAgICAleHtcclxuICAgICAgaWYgKGFycmF5cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gI3t0b19hLmR1cH07XHJcbiAgICAgIH1cclxuICAgICAgYXJyYXlzID0gYXJyYXlzLm1hcChjb252ZXJ0VG9BcnJheSk7XHJcbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFycmF5cyA9IGFycmF5cy5zb3J0X2J5KCY6bGVuZ3RoKVxyXG4gICAgIyBXaGVuIHNlbGYgaXMgdGhlIHNtYWxsZXN0IGFtb25nIHRoZSBhcnJheXNcclxuICAgIGlmIGBzZWxmLmxlbmd0aCA8IGFycmF5c1swXS5sZW5ndGhgXHJcbiAgICAgIHJldHVybiBhcnJheXMucmVkdWNlKHNlbGYsICY6JilcclxuICAgIGVuZFxyXG5cclxuICAgICMgRmlyc3QsIGNhbGN1bGF0ZSBpbnRlcnNlY3Rpb24gb2YgYXJndW1lbnQgYXJyYXlzLlxyXG4gICAgIyBBcnJheSMmIGlzIGZhc3RlciB3aGVuIHRoZSBhcmd1bWVudCBzaXplIGlzIHNtYWxsLlxyXG4gICAgIyBTbyBgbGFyZ2VzdCAmIHNob3J0ZXN0ICYgc2Vjb25kX3Nob3J0ZXN0ICYgLi4uYCB3b3VsZCBiZSB0aGUgZmFzdGVzdC5cclxuICAgIGxhcmdlc3QgPSBgYXJyYXlzLnBvcCgpYFxyXG4gICAgaW50ZXJzZWN0aW9uX29mX2FyZ3MgPSBhcnJheXMucmVkdWNlKGxhcmdlc3QsICY6JilcclxuXHJcbiAgICAjIHNlbGYgYXJyYXkgbXVzdCBjb21lIGxhc3QgdG8gbWFpbnRhaW4gdGhlIG9yZGVyXHJcbiAgICBzZWxmICYgaW50ZXJzZWN0aW9uX29mX2FyZ3NcclxuICBlbmRcclxuXHJcbiAgZGVmIGludGVyc2VjdD8ob3RoZXIpXHJcbiAgICAleHtcclxuICAgICAgdmFyIHNtYWxsLCBsYXJnZSwgaGFzaCA9ICN7e319LCBpLCBsZW5ndGg7XHJcbiAgICAgIGlmIChzZWxmLmxlbmd0aCA8IG90aGVyLmxlbmd0aCkge1xyXG4gICAgICAgIHNtYWxsID0gc2VsZjtcclxuICAgICAgICBsYXJnZSA9IG90aGVyO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNtYWxsID0gb3RoZXI7XHJcbiAgICAgICAgbGFyZ2UgPSBzZWxmO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzbWFsbC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICRoYXNoX3B1dChoYXNoLCBzbWFsbFtpXSwgdHJ1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGxhcmdlLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKCRoYXNoX2dldChoYXNoLCBsYXJnZVtpXSkpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBqb2luKHNlcCA9IG5pbClcclxuICAgIHJldHVybiAnJyBpZiBgc2VsZi5sZW5ndGggPT09IDBgXHJcblxyXG4gICAgaWYgYHNlcCA9PT0gbmlsYFxyXG4gICAgICBzZXAgPSAkLFxyXG4gICAgZW5kXHJcblxyXG4gICAgJXh7XHJcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgdmFyIGksIGxlbmd0aCwgaXRlbSwgdG1wO1xyXG5cclxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xyXG5cclxuICAgICAgICBpZiAoJHJlc3BvbmRfdG8oaXRlbSwgJyR0b19zdHInKSkge1xyXG4gICAgICAgICAgdG1wID0gI3tgaXRlbWAudG9fc3RyfTtcclxuXHJcbiAgICAgICAgICBpZiAodG1wICE9PSBuaWwpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goI3tgdG1wYC50b19zfSk7XHJcblxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgkcmVzcG9uZF90byhpdGVtLCAnJHRvX2FyeScpKSB7XHJcbiAgICAgICAgICB0bXAgPSAje2BpdGVtYC50b19hcnl9O1xyXG5cclxuICAgICAgICAgIGlmICh0bXAgPT09IHNlbGYpIHtcclxuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3J9O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmICh0bXAgIT09IG5pbCkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCgje2B0bXBgLmpvaW4oc2VwKX0pO1xyXG5cclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoJHJlc3BvbmRfdG8oaXRlbSwgJyR0b19zJykpIHtcclxuICAgICAgICAgIHRtcCA9ICN7YGl0ZW1gLnRvX3N9O1xyXG5cclxuICAgICAgICAgIGlmICh0bXAgIT09IG5pbCkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCh0bXApO1xyXG5cclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6Tm9NZXRob2RFcnJvci5uZXcoXCIje09wYWwuaW5zcGVjdChpdGVtKX0gZG9lc24ndCByZXNwb25kIHRvICN0b19zdHIsICN0b19hcnkgb3IgI3RvX3NcIiwgJ3RvX3N0cicpfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHNlcCA9PT0gbmlsKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oI3s6Ok9wYWwuY29lcmNlX3RvIShzZXAsIDo6U3RyaW5nLCA6dG9fc3RyKS50b19zfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGtlZXBfaWYoJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVudW1fZm9yKDprZWVwX2lmKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XHJcbiAgICAleHtcclxuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcclxuXHJcbiAgICAgIGZpbHRlcklmKHNlbGYsICR0cnV0aHksIGJsb2NrKVxyXG4gICAgfVxyXG4gICAgc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgbGFzdChjb3VudCA9IHVuZGVmaW5lZClcclxuICAgICV4e1xyXG4gICAgICBpZiAoY291bnQgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBzZWxmLmxlbmd0aCA9PT0gMCA/IG5pbCA6IHNlbGZbc2VsZi5sZW5ndGggLSAxXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY291bnQgPSAkY29lcmNlX3RvKGNvdW50LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcclxuXHJcbiAgICAgIGlmIChjb3VudCA8IDApIHtcclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFycmF5IHNpemUnfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNvdW50ID4gc2VsZi5sZW5ndGgpIHtcclxuICAgICAgICBjb3VudCA9IHNlbGYubGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc2VsZi5zbGljZShzZWxmLmxlbmd0aCAtIGNvdW50LCBzZWxmLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBsZW5ndGhcclxuICAgIGBzZWxmLmxlbmd0aGBcclxuICBlbmRcclxuXHJcbiAgZGVmIG1heChuID0gdW5kZWZpbmVkLCAmYmxvY2spXHJcbiAgICBlYWNoLm1heChuLCAmYmxvY2spXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBtaW4oJmJsb2NrKVxyXG4gICAgZWFjaC5taW4oJmJsb2NrKVxyXG4gIGVuZFxyXG5cclxuICAleHtcclxuICAgIC8vIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgZnJvbSwgZnJvbS0xLCAuLi4sIGZyb20gLSBob3dfbWFueSArIDEuXHJcbiAgICBmdW5jdGlvbiBkZXNjZW5kaW5nX2ZhY3RvcmlhbChmcm9tLCBob3dfbWFueSkge1xyXG4gICAgICB2YXIgY291bnQgPSBob3dfbWFueSA+PSAwID8gMSA6IDA7XHJcbiAgICAgIHdoaWxlIChob3dfbWFueSkge1xyXG4gICAgICAgIGNvdW50ICo9IGZyb207XHJcbiAgICAgICAgZnJvbS0tO1xyXG4gICAgICAgIGhvd19tYW55LS07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNvdW50O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVmIHBlcm11dGF0aW9uKG51bSA9IHVuZGVmaW5lZCwgJmJsb2NrKVxyXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG4gICAgICByZXR1cm4gZW51bV9mb3IoOnBlcm11dGF0aW9uLCBudW0pIGRvXHJcbiAgICAgICAgYGRlc2NlbmRpbmdfZmFjdG9yaWFsKHNlbGYubGVuZ3RoLCBudW0gPT09IHVuZGVmaW5lZCA/IHNlbGYubGVuZ3RoIDogbnVtKWBcclxuICAgICAgZW5kXHJcbiAgICBlbmRcclxuXHJcbiAgICAleHtcclxuICAgICAgdmFyIHBlcm11dGUsIG9mZmVuc2l2ZSwgb3V0cHV0O1xyXG5cclxuICAgICAgaWYgKG51bSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgbnVtID0gc2VsZi5sZW5ndGg7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgbnVtID0gJGNvZXJjZV90byhudW0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobnVtIDwgMCB8fCBzZWxmLmxlbmd0aCA8IG51bSkge1xyXG4gICAgICAgIC8vIG5vIHBlcm11dGF0aW9ucywgeWllbGQgbm90aGluZ1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKG51bSA9PT0gMCkge1xyXG4gICAgICAgIC8vIGV4YWN0bHkgb25lIHBlcm11dGF0aW9uOiB0aGUgemVyby1sZW5ndGggYXJyYXlcclxuICAgICAgICAjeyB5aWVsZCBbXSB9XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAobnVtID09PSAxKSB7XHJcbiAgICAgICAgLy8gdGhpcyBpcyBhIHNwZWNpYWwsIGVhc3kgY2FzZVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgI3sgeWllbGQgYFtzZWxmW2ldXWAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAvLyB0aGlzIGlzIHRoZSBnZW5lcmFsIGNhc2VcclxuICAgICAgICAjeyBwZXJtID0gQXJyYXkubmV3KG51bSkgfTtcclxuICAgICAgICAjeyB1c2VkID0gQXJyYXkubmV3KGBzZWxmLmxlbmd0aGAsIGZhbHNlKSB9O1xyXG5cclxuICAgICAgICBwZXJtdXRlID0gZnVuY3Rpb24obnVtLCBwZXJtLCBpbmRleCwgdXNlZCwgYmxrKSB7XHJcbiAgICAgICAgICBzZWxmID0gdGhpcztcclxuICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgaWYoI3sgIXVzZWRbYGlgXSB9KSB7XHJcbiAgICAgICAgICAgICAgcGVybVtpbmRleF0gPSBpO1xyXG4gICAgICAgICAgICAgIGlmKGluZGV4IDwgbnVtIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgdXNlZFtpXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBwZXJtdXRlLmNhbGwoc2VsZiwgbnVtLCBwZXJtLCBpbmRleCArIDEsIHVzZWQsIGJsayk7XHJcbiAgICAgICAgICAgICAgICB1c2VkW2ldID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBlcm0ubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc2VsZltwZXJtW2pdXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAkeWllbGQxKGJsaywgb3V0cHV0KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgje2Jsb2NrX2dpdmVuP30pIHtcclxuICAgICAgICAgIC8vIG9mZmVuc2l2ZSAoYm90aCBkZWZpbml0aW9ucykgY29weS5cclxuICAgICAgICAgIG9mZmVuc2l2ZSA9IHNlbGYuc2xpY2UoKTtcclxuICAgICAgICAgIHBlcm11dGUuY2FsbChvZmZlbnNpdmUsIG51bSwgcGVybSwgMCwgdXNlZCwgYmxvY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHBlcm11dGUuY2FsbChzZWxmLCBudW0sIHBlcm0sIDAsIHVzZWQsIGJsb2NrKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiByZXBlYXRlZF9wZXJtdXRhdGlvbihuKVxyXG4gICAgbnVtID0gOjpPcGFsLmNvZXJjZV90byEgbiwgOjpJbnRlZ2VyLCA6dG9faW50XHJcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlcGVhdGVkX3Blcm11dGF0aW9uLCBudW0pIHsgbnVtID49IDAgPyBzaXplKipudW0gOiAwIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG5cclxuICAgICV4e1xyXG4gICAgICBmdW5jdGlvbiBpdGVyYXRlKG1heCwgYnVmZmVyLCBzZWxmKSB7XHJcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT0gbWF4KSB7XHJcbiAgICAgICAgICB2YXIgY29weSA9IGJ1ZmZlci5zbGljZSgpO1xyXG4gICAgICAgICAgI3t5aWVsZCBgY29weWB9XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgYnVmZmVyLnB1c2goc2VsZltpXSk7XHJcbiAgICAgICAgICBpdGVyYXRlKG1heCwgYnVmZmVyLCBzZWxmKTtcclxuICAgICAgICAgIGJ1ZmZlci5wb3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGl0ZXJhdGUobnVtLCBbXSwgc2VsZi5zbGljZSgpKTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBwb3AoY291bnQgPSB1bmRlZmluZWQpXHJcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcclxuXHJcbiAgICBpZiBgY291bnQgPT09IHVuZGVmaW5lZGBcclxuICAgICAgcmV0dXJuIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcclxuICAgICAgcmV0dXJuIGBzZWxmLnBvcCgpYFxyXG4gICAgZW5kXHJcblxyXG4gICAgY291bnQgPSBgJGNvZXJjZV90byhjb3VudCwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXHJcblxyXG4gICAgaWYgYGNvdW50IDwgMGBcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJyYXkgc2l6ZSdcclxuICAgIGVuZFxyXG5cclxuICAgIHJldHVybiBbXSBpZiBgc2VsZi5sZW5ndGggPT09IDBgXHJcblxyXG4gICAgaWYgYGNvdW50ID09PSAxYFxyXG4gICAgICBgW3NlbGYucG9wKCldYFxyXG4gICAgZWxzaWYgYGNvdW50ID4gc2VsZi5sZW5ndGhgXHJcbiAgICAgIGBzZWxmLnNwbGljZSgwLCBzZWxmLmxlbmd0aClgXHJcbiAgICBlbHNlXHJcbiAgICAgIGBzZWxmLnNwbGljZShzZWxmLmxlbmd0aCAtIGNvdW50LCBzZWxmLmxlbmd0aClgXHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmIHByb2R1Y3QoKmFyZ3MsICZibG9jaylcclxuICAgICV4e1xyXG4gICAgICB2YXIgcmVzdWx0ID0gI3tibG9ja19naXZlbj99ID8gbnVsbCA6IFtdLFxyXG4gICAgICAgICAgbiA9IGFyZ3MubGVuZ3RoICsgMSxcclxuICAgICAgICAgIGNvdW50ZXJzID0gbmV3IEFycmF5KG4pLFxyXG4gICAgICAgICAgbGVuZ3RocyAgPSBuZXcgQXJyYXkobiksXHJcbiAgICAgICAgICBhcnJheXMgICA9IG5ldyBBcnJheShuKSxcclxuICAgICAgICAgIGksIG0sIHN1YmFycmF5LCBsZW4sIHJlc3VsdGxlbiA9IDE7XHJcblxyXG4gICAgICBhcnJheXNbMF0gPSBzZWxmO1xyXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgYXJyYXlzW2ldID0gJGNvZXJjZV90byhhcmdzW2kgLSAxXSwgI3s6OkFycmF5fSwgJ3RvX2FyeScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgbGVuID0gYXJyYXlzW2ldLmxlbmd0aDtcclxuICAgICAgICBpZiAobGVuID09PSAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gcmVzdWx0IHx8IHNlbGY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdGxlbiAqPSBsZW47XHJcbiAgICAgICAgaWYgKHJlc3VsdGxlbiA+IDIxNDc0ODM2NDcpIHtcclxuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCAndG9vIGJpZyB0byBwcm9kdWN0J31cclxuICAgICAgICB9XHJcbiAgICAgICAgbGVuZ3Roc1tpXSA9IGxlbjtcclxuICAgICAgICBjb3VudGVyc1tpXSA9IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG91dGVyX2xvb3A6IGZvciAoOzspIHtcclxuICAgICAgICBzdWJhcnJheSA9IFtdO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgIHN1YmFycmF5LnB1c2goYXJyYXlzW2ldW2NvdW50ZXJzW2ldXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgIHJlc3VsdC5wdXNoKHN1YmFycmF5KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgI3t5aWVsZCBgc3ViYXJyYXlgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBtID0gbiAtIDE7XHJcbiAgICAgICAgY291bnRlcnNbbV0rKztcclxuICAgICAgICB3aGlsZSAoY291bnRlcnNbbV0gPT09IGxlbmd0aHNbbV0pIHtcclxuICAgICAgICAgIGNvdW50ZXJzW21dID0gMDtcclxuICAgICAgICAgIGlmICgtLW0gPCAwKSBicmVhayBvdXRlcl9sb29wO1xyXG4gICAgICAgICAgY291bnRlcnNbbV0rKztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQgfHwgc2VsZjtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHB1c2goKm9iamVjdHMpXHJcbiAgICAleHtcclxuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcclxuXHJcbiAgICAgIGZhc3RfcHVzaChzZWxmLCBvYmplY3RzKTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiByYXNzb2Mob2JqZWN0KVxyXG4gICAgJXh7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aCwgaXRlbTsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XHJcblxyXG4gICAgICAgIGlmIChpdGVtLmxlbmd0aCAmJiBpdGVtWzFdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGlmICgje2BpdGVtWzFdYCA9PSBvYmplY3R9KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG5pbDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHJlamVjdCgmYmxvY2spXHJcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG5cclxuICAgICV4e1xyXG4gICAgICB2YXIgcmVzdWx0ID0gW107XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMCwgdmFsdWU7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFsdWUgPSBibG9jayhzZWxmW2ldKTtcclxuXHJcbiAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gbmlsKSB7XHJcbiAgICAgICAgICByZXN1bHQucHVzaChzZWxmW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHJlamVjdCEoJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZWplY3QhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XHJcblxyXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXHJcblxyXG4gICAgb3JpZ2luYWwgPSBsZW5ndGhcclxuICAgIGRlbGV0ZV9pZigmYmxvY2spXHJcblxyXG4gICAgdW5sZXNzIGxlbmd0aCA9PSBvcmlnaW5hbFxyXG4gICAgICBzZWxmXHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmIHJlcGxhY2Uob3RoZXIpXHJcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcclxuXHJcbiAgICBvdGhlciA9IGBjb252ZXJ0VG9BcnJheShvdGhlcilgXHJcblxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChzZWxmLmxlbmd0aCA+IDApIHNlbGYuc3BsaWNlKDAsIHNlbGYubGVuZ3RoKTtcclxuICAgICAgZmFzdF9wdXNoKHNlbGYsIG90aGVyKTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiByZXZlcnNlXHJcbiAgICBgc2VsZi5zbGljZSgwKS5yZXZlcnNlKClgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiByZXZlcnNlIVxyXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXHJcblxyXG4gICAgYHNlbGYucmV2ZXJzZSgpYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgcmV2ZXJzZV9lYWNoKCZibG9jaylcclxuICAgIHJldHVybiBlbnVtX2Zvcig6cmV2ZXJzZV9lYWNoKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XHJcblxyXG4gICAgJXh7XHJcbiAgICAgIGZvciAodmFyIGkgPSBzZWxmLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgJHlpZWxkMShibG9jaywgc2VsZltpXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHNlbGZcclxuICBlbmRcclxuXHJcbiAgZGVmIHJpbmRleChvYmplY3QgPSB1bmRlZmluZWQsICZibG9jaylcclxuICAgICV4e1xyXG4gICAgICB2YXIgaSwgdmFsdWU7XHJcblxyXG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwgJiYgYmxvY2sgIT09IG5pbCkge1xyXG4gICAgICAgICN7d2Fybignd2FybmluZzogZ2l2ZW4gYmxvY2sgbm90IHVzZWQnKX1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XHJcbiAgICAgICAgZm9yIChpID0gc2VsZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgaWYgKGkgPj0gc2VsZi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoI3tgc2VsZltpXWAgPT0gYG9iamVjdGB9KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmIChibG9jayAhPT0gbmlsKSB7XHJcbiAgICAgICAgZm9yIChpID0gc2VsZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgaWYgKGkgPj0gc2VsZi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFsdWUgPSBibG9jayhzZWxmW2ldKTtcclxuXHJcbiAgICAgICAgICBpZiAodmFsdWUgIT09IGZhbHNlICYmIHZhbHVlICE9PSBuaWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKG9iamVjdCA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuICN7ZW51bV9mb3IgOnJpbmRleH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuaWw7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiByb3RhdGUobiA9IDEpXHJcbiAgICAleHtcclxuICAgICAgdmFyIGFyeSwgaWR4LCBmaXJzdFBhcnQsIGxhc3RQYXJ0O1xyXG5cclxuICAgICAgbiA9ICRjb2VyY2VfdG8obiwgI3s6OkludGVnZXJ9LCAndG9faW50JylcclxuXHJcbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiBzZWxmLnNsaWNlKCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhcnkgPSBzZWxmLnNsaWNlKCk7XHJcbiAgICAgIGlkeCA9IG4gJSBhcnkubGVuZ3RoO1xyXG5cclxuICAgICAgZmlyc3RQYXJ0ID0gYXJ5LnNsaWNlKGlkeCk7XHJcbiAgICAgIGxhc3RQYXJ0ID0gYXJ5LnNsaWNlKDAsIGlkeCk7XHJcbiAgICAgIHJldHVybiBmaXJzdFBhcnQuY29uY2F0KGxhc3RQYXJ0KTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHJvdGF0ZSEoY250ID0gMSlcclxuICAgICV4e1xyXG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xyXG5cclxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAwIHx8IHNlbGYubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICAgIH1cclxuICAgICAgY250ID0gJGNvZXJjZV90byhjbnQsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xyXG4gICAgfVxyXG4gICAgYXJ5ID0gcm90YXRlKGNudClcclxuICAgIHJlcGxhY2UgYXJ5XHJcbiAgZW5kXHJcblxyXG4gIGNsYXNzIHNlbGY6OlNhbXBsZVJhbmRvbVxyXG4gICAgZGVmIGluaXRpYWxpemUocm5nKVxyXG4gICAgICBAcm5nID0gcm5nXHJcbiAgICBlbmRcclxuXHJcbiAgICBkZWYgcmFuZChzaXplKVxyXG4gICAgICByYW5kb20gPSBgJGNvZXJjZV90bygje0BybmcucmFuZChzaXplKX0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsICdyYW5kb20gdmFsdWUgbXVzdCBiZSA+PSAwJyBpZiBgcmFuZG9tIDwgMGBcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCAncmFuZG9tIHZhbHVlIG11c3QgYmUgbGVzcyB0aGFuIEFycmF5IHNpemUnIHVubGVzcyBgcmFuZG9tIDwgc2l6ZWBcclxuXHJcbiAgICAgIHJhbmRvbVxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzYW1wbGUoY291bnQgPSB1bmRlZmluZWQsIG9wdGlvbnMgPSB1bmRlZmluZWQpXHJcbiAgICByZXR1cm4gYXQgOjpLZXJuZWwucmFuZChgc2VsZi5sZW5ndGhgKSBpZiBgY291bnQgPT09IHVuZGVmaW5lZGBcclxuXHJcbiAgICBpZiBgb3B0aW9ucyA9PT0gdW5kZWZpbmVkYFxyXG4gICAgICBpZiAobyA9IDo6T3BhbC5jb2VyY2VfdG8/IGNvdW50LCA6Okhhc2gsIDp0b19oYXNoKVxyXG4gICAgICAgIG9wdGlvbnMgPSBvXHJcbiAgICAgICAgY291bnQgPSBuaWxcclxuICAgICAgZWxzZVxyXG4gICAgICAgIG9wdGlvbnMgPSBuaWxcclxuICAgICAgICBjb3VudCA9IGAkY29lcmNlX3RvKGNvdW50LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcclxuICAgICAgZW5kXHJcbiAgICBlbHNlXHJcbiAgICAgIGNvdW50ID0gYCRjb2VyY2VfdG8oY291bnQsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxyXG4gICAgICBvcHRpb25zID0gYCRjb2VyY2VfdG8ob3B0aW9ucywgI3s6Okhhc2h9LCAndG9faGFzaCcpYFxyXG4gICAgZW5kXHJcblxyXG4gICAgaWYgY291bnQgJiYgYGNvdW50IDwgMGBcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnY291bnQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCdcclxuICAgIGVuZFxyXG5cclxuICAgIHJuZyA9IG9wdGlvbnNbOnJhbmRvbV0gaWYgb3B0aW9uc1xyXG4gICAgcm5nID0gaWYgcm5nICYmIHJuZy5yZXNwb25kX3RvPyg6cmFuZClcclxuICAgICAgICAgICAgU2FtcGxlUmFuZG9tLm5ldyBybmdcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgOjpLZXJuZWxcclxuICAgICAgICAgIGVuZFxyXG5cclxuICAgIHJldHVybiBgc2VsZlsje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfV1gIHVubGVzcyBjb3VudFxyXG5cclxuICAgICV4e1xyXG5cclxuICAgICAgdmFyIGFiYW5kb24sIHNwaW4sIHJlc3VsdCwgaSwgaiwgaywgdGFyZ2V0SW5kZXgsIG9sZFZhbHVlO1xyXG5cclxuICAgICAgaWYgKGNvdW50ID4gc2VsZi5sZW5ndGgpIHtcclxuICAgICAgICBjb3VudCA9IHNlbGYubGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzd2l0Y2ggKGNvdW50KSB7XHJcbiAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgcmV0dXJuIFtzZWxmWyN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9XV07XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICBpID0gI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX07XHJcbiAgICAgICAgICBqID0gI3tybmcucmFuZChgc2VsZi5sZW5ndGggLSAxYCl9O1xyXG4gICAgICAgICAgaWYgKGkgPD0gaikge1xyXG4gICAgICAgICAgICBqKys7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gW3NlbGZbaV0sIHNlbGZbal1dO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGlmIChzZWxmLmxlbmd0aCAvIGNvdW50ID4gMykge1xyXG4gICAgICAgICAgICBhYmFuZG9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHNwaW4gPSAwO1xyXG5cclxuICAgICAgICAgICAgcmVzdWx0ID0gI3sgQXJyYXkubmV3KGNvdW50KSB9O1xyXG4gICAgICAgICAgICBpID0gMTtcclxuXHJcbiAgICAgICAgICAgIHJlc3VsdFswXSA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9O1xyXG4gICAgICAgICAgICB3aGlsZSAoaSA8IGNvdW50KSB7XHJcbiAgICAgICAgICAgICAgayA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9O1xyXG4gICAgICAgICAgICAgIGogPSAwO1xyXG5cclxuICAgICAgICAgICAgICB3aGlsZSAoaiA8IGkpIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChrID09PSByZXN1bHRbal0pIHtcclxuICAgICAgICAgICAgICAgICAgc3BpbisrO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoc3BpbiA+IDEwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFiYW5kb24gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGsgPSAje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhYmFuZG9uKSB7IGJyZWFrOyB9XHJcblxyXG4gICAgICAgICAgICAgICAgaisrO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgaWYgKGFiYW5kb24pIHsgYnJlYWs7IH1cclxuXHJcbiAgICAgICAgICAgICAgcmVzdWx0W2ldID0gaztcclxuXHJcbiAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWFiYW5kb24pIHtcclxuICAgICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgICB3aGlsZSAoaSA8IGNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBzZWxmW3Jlc3VsdFtpXV07XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZSgpO1xyXG5cclxuICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY291bnQ7IGMrKykge1xyXG4gICAgICAgICAgICB0YXJnZXRJbmRleCA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoIC0gY2ApfSArIGM7XHJcbiAgICAgICAgICAgIG9sZFZhbHVlID0gcmVzdWx0W2NdO1xyXG4gICAgICAgICAgICByZXN1bHRbY10gPSByZXN1bHRbdGFyZ2V0SW5kZXhdO1xyXG4gICAgICAgICAgICByZXN1bHRbdGFyZ2V0SW5kZXhdID0gb2xkVmFsdWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGNvdW50ID09PSBzZWxmLmxlbmd0aCA/IHJlc3VsdCA6ICN7YHJlc3VsdGBbMCwgY291bnRdfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc2VsZWN0KCZibG9jaylcclxuICAgIHJldHVybiBlbnVtX2Zvcig6c2VsZWN0KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XHJcblxyXG4gICAgJXh7XHJcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpdGVtLCB2YWx1ZTsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpdGVtID0gc2VsZltpXTtcclxuXHJcbiAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBpdGVtKTtcclxuXHJcbiAgICAgICAgaWYgKCR0cnV0aHkodmFsdWUpKSB7XHJcbiAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzZWxlY3QhKCZibG9jaylcclxuICAgIHJldHVybiBlbnVtX2Zvcig6c2VsZWN0ISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG5cclxuICAgICV4e1xyXG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpXHJcblxyXG4gICAgICB2YXIgb3JpZ2luYWwgPSBzZWxmLmxlbmd0aDtcclxuICAgICAgI3sga2VlcF9pZigmYmxvY2spIH07XHJcbiAgICAgIHJldHVybiBzZWxmLmxlbmd0aCA9PT0gb3JpZ2luYWwgPyBuaWwgOiBzZWxmO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc2hpZnQoY291bnQgPSB1bmRlZmluZWQpXHJcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcclxuXHJcbiAgICBpZiBgY291bnQgPT09IHVuZGVmaW5lZGBcclxuICAgICAgcmV0dXJuIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcclxuICAgICAgcmV0dXJuIGBzaGlmdE5vQXJnKHNlbGYpYFxyXG4gICAgZW5kXHJcblxyXG4gICAgY291bnQgPSBgJGNvZXJjZV90byhjb3VudCwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXHJcblxyXG4gICAgaWYgYGNvdW50IDwgMGBcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJyYXkgc2l6ZSdcclxuICAgIGVuZFxyXG5cclxuICAgIHJldHVybiBbXSBpZiBgc2VsZi5sZW5ndGggPT09IDBgXHJcblxyXG4gICAgYHNlbGYuc3BsaWNlKDAsIGNvdW50KWBcclxuICBlbmRcclxuXHJcbiAgZGVmIHNodWZmbGUocm5nID0gdW5kZWZpbmVkKVxyXG4gICAgZHVwLnRvX2Euc2h1ZmZsZSEocm5nKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc2h1ZmZsZSEocm5nID0gdW5kZWZpbmVkKVxyXG4gICAgJXh7XHJcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XHJcblxyXG4gICAgICB2YXIgcmFuZGdlbiwgaSA9IHNlbGYubGVuZ3RoLCBqLCB0bXA7XHJcblxyXG4gICAgICBpZiAocm5nICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBybmcgPSAjezo6T3BhbC5jb2VyY2VfdG8/KHJuZywgOjpIYXNoLCA6dG9faGFzaCl9O1xyXG5cclxuICAgICAgICBpZiAocm5nICE9PSBuaWwpIHtcclxuICAgICAgICAgIHJuZyA9ICN7cm5nWzpyYW5kb21dfTtcclxuXHJcbiAgICAgICAgICBpZiAocm5nICE9PSBuaWwgJiYgI3tybmcucmVzcG9uZF90bz8oOnJhbmQpfSkge1xyXG4gICAgICAgICAgICByYW5kZ2VuID0gcm5nO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgd2hpbGUgKGkpIHtcclxuICAgICAgICBpZiAocmFuZGdlbikge1xyXG4gICAgICAgICAgaiA9IHJhbmRnZW4uJHJhbmQoaSkuJHRvX2ludCgpO1xyXG5cclxuICAgICAgICAgIGlmIChqIDwgMCkge1xyXG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgXCJyYW5kb20gbnVtYmVyIHRvbyBzbWFsbCAje2BqYH1cIn1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoaiA+PSBpKSB7XHJcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCBcInJhbmRvbSBudW1iZXIgdG9vIGJpZyAje2BqYH1cIn1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBqID0gI3tyYW5kKGBpYCl9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdG1wID0gc2VsZlstLWldO1xyXG4gICAgICAgIHNlbGZbaV0gPSBzZWxmW2pdO1xyXG4gICAgICAgIHNlbGZbal0gPSB0bXA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc2xpY2UhKGluZGV4LCBsZW5ndGggPSB1bmRlZmluZWQpXHJcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcclxuXHJcbiAgICByZXN1bHQgPSBuaWxcclxuXHJcbiAgICBpZiBgbGVuZ3RoID09PSB1bmRlZmluZWRgXHJcbiAgICAgIGlmIDo6UmFuZ2UgPT09IGluZGV4XHJcbiAgICAgICAgcmFuZ2UgPSBpbmRleFxyXG4gICAgICAgIHJlc3VsdCA9IHNlbGZbcmFuZ2VdXHJcblxyXG4gICAgICAgIHJhbmdlX3N0YXJ0ID0gYHJhbmdlLmJlZ2luID09PSBuaWwgPyAwIDogJGNvZXJjZV90byhyYW5nZS5iZWdpbiwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXHJcbiAgICAgICAgcmFuZ2VfZW5kID0gYHJhbmdlLmVuZCA9PT0gbmlsID8gLTEgOiAkY29lcmNlX3RvKHJhbmdlLmVuZCwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXHJcblxyXG4gICAgICAgICV4e1xyXG4gICAgICAgICAgaWYgKHJhbmdlX3N0YXJ0IDwgMCkge1xyXG4gICAgICAgICAgICByYW5nZV9zdGFydCArPSBzZWxmLmxlbmd0aDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAocmFuZ2VfZW5kIDwgMCkge1xyXG4gICAgICAgICAgICByYW5nZV9lbmQgKz0gc2VsZi5sZW5ndGg7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHJhbmdlX2VuZCA+PSBzZWxmLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByYW5nZV9lbmQgPSBzZWxmLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIGlmIChyYW5nZS5leGNsKSB7XHJcbiAgICAgICAgICAgICAgcmFuZ2VfZW5kICs9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgcmFuZ2VfbGVuZ3RoID0gcmFuZ2VfZW5kIC0gcmFuZ2Vfc3RhcnQ7XHJcbiAgICAgICAgICBpZiAocmFuZ2UuZXhjbCAmJiByYW5nZS5lbmQgIT09IG5pbCkge1xyXG4gICAgICAgICAgICByYW5nZV9lbmQgLT0gMTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJhbmdlX2xlbmd0aCArPSAxO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChyYW5nZV9zdGFydCA8IHNlbGYubGVuZ3RoICYmIHJhbmdlX3N0YXJ0ID49IDAgJiYgcmFuZ2VfZW5kIDwgc2VsZi5sZW5ndGggJiYgcmFuZ2VfZW5kID49IDAgJiYgcmFuZ2VfbGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBzZWxmLnNwbGljZShyYW5nZV9zdGFydCwgcmFuZ2VfbGVuZ3RoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBzdGFydCA9IGAkY29lcmNlX3RvKGluZGV4LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcclxuICAgICAgICAleHtcclxuICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcclxuICAgICAgICAgICAgc3RhcnQgKz0gc2VsZi5sZW5ndGg7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSBzZWxmLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmlsO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJlc3VsdCA9IHNlbGZbc3RhcnRdO1xyXG5cclxuICAgICAgICAgIGlmIChzdGFydCA9PT0gMCkge1xyXG4gICAgICAgICAgICBzZWxmLnNoaWZ0KCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzZWxmLnNwbGljZShzdGFydCwgMSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICBlbmRcclxuICAgIGVsc2VcclxuICAgICAgc3RhcnQgPSBgJGNvZXJjZV90byhpbmRleCwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXHJcbiAgICAgIGxlbmd0aCA9IGAkY29lcmNlX3RvKGxlbmd0aCwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXHJcblxyXG4gICAgICAleHtcclxuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xyXG4gICAgICAgICAgcmV0dXJuIG5pbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBlbmQgPSBzdGFydCArIGxlbmd0aDtcclxuXHJcbiAgICAgICAgcmVzdWx0ID0gI3tzZWxmW3N0YXJ0LCBsZW5ndGhdfTtcclxuXHJcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xyXG4gICAgICAgICAgc3RhcnQgKz0gc2VsZi5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc3RhcnQgKyBsZW5ndGggPiBzZWxmLmxlbmd0aCkge1xyXG4gICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggLSBzdGFydDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzdGFydCA8IHNlbGYubGVuZ3RoICYmIHN0YXJ0ID49IDApIHtcclxuICAgICAgICAgIHNlbGYuc3BsaWNlKHN0YXJ0LCBsZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgZW5kXHJcbiAgICByZXN1bHRcclxuICBlbmRcclxuXHJcbiAgZGVmIHNvcnQoJmJsb2NrKVxyXG4gICAgcmV0dXJuIHNlbGYgdW5sZXNzIGBzZWxmLmxlbmd0aCA+IDFgXHJcblxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XHJcbiAgICAgICAgYmxvY2sgPSBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICByZXR1cm4gI3tgYWAgPD0+IGBiYH07XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgICB2YXIgcmV0ID0gYmxvY2soeCwgeSk7XHJcblxyXG4gICAgICAgIGlmIChyZXQgPT09IG5pbCkge1xyXG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje2B4YC5pbnNwZWN0fSB3aXRoICN7YHlgLmluc3BlY3R9IGZhaWxlZFwifTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAje2ByZXRgID4gMH0gPyAxIDogKCN7YHJldGAgPCAwfSA/IC0xIDogMCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc29ydCEoJmJsb2NrKVxyXG4gICAgJXh7XHJcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilcclxuXHJcbiAgICAgIHZhciByZXN1bHQ7XHJcblxyXG4gICAgICBpZiAoI3tibG9ja19naXZlbj99KSB7XHJcbiAgICAgICAgcmVzdWx0ID0gI3tgc2VsZi5zbGljZSgpYC5zb3J0KCZibG9jayl9O1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdCA9ICN7YHNlbGYuc2xpY2UoKWAuc29ydH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNlbGYubGVuZ3RoID0gMDtcclxuICAgICAgZm9yKHZhciBpID0gMCwgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgc2VsZi5wdXNoKHJlc3VsdFtpXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc29ydF9ieSEoJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzb3J0X2J5ISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG5cclxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxyXG5cclxuICAgIHJlcGxhY2Ugc29ydF9ieSgmYmxvY2spXHJcbiAgZW5kXHJcblxyXG4gIGRlZiB0YWtlKGNvdW50KVxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChjb3VudCA8IDApIHtcclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvcn07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzZWxmLnNsaWNlKDAsIGNvdW50KTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHRha2Vfd2hpbGUoJmJsb2NrKVxyXG4gICAgJXh7XHJcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpdGVtLCB2YWx1ZTsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpdGVtID0gc2VsZltpXTtcclxuXHJcbiAgICAgICAgdmFsdWUgPSBibG9jayhpdGVtKTtcclxuXHJcbiAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gbmlsKSB7XHJcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiB0b19hXHJcbiAgICAleHtcclxuICAgICAgaWYgKHNlbGYuJCRjbGFzcyA9PT0gT3BhbC5BcnJheSkge1xyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBPcGFsLkFycmF5LiRuZXcoc2VsZik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHRvX2FyeVxyXG4gICAgc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgdG9faCgmYmxvY2spXHJcbiAgICBhcnJheSA9IHNlbGZcclxuICAgIGFycmF5ID0gYXJyYXkubWFwKCZibG9jaykgaWYgYmxvY2tfZ2l2ZW4/XHJcblxyXG4gICAgJXh7XHJcbiAgICAgIHZhciBpLCBsZW4gPSBhcnJheS5sZW5ndGgsIGFyeSwga2V5LCB2YWwsIGhhc2ggPSAje3t9fTtcclxuXHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGFyeSA9ICN7OjpPcGFsLmNvZXJjZV90bz8oYGFycmF5W2ldYCwgOjpBcnJheSwgOnRvX2FyeSl9O1xyXG4gICAgICAgIGlmICghYXJ5LiQkaXNfYXJyYXkpIHtcclxuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgZWxlbWVudCB0eXBlICN7YGFycmF5W2ldYC5jbGFzc30gYXQgI3tgaWB9IChleHBlY3RlZCBhcnJheSlcIn1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFyeS5sZW5ndGggIT09IDIpIHtcclxuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImVsZW1lbnQgaGFzIHdyb25nIGFycmF5IGxlbmd0aCBhdCAje2BpYH0gKGV4cGVjdGVkIDIsIHdhcyAje2BhcnlgLmxlbmd0aH0pXCJ9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGtleSA9IGFyeVswXTtcclxuICAgICAgICB2YWwgPSBhcnlbMV07XHJcbiAgICAgICAgJGhhc2hfcHV0KGhhc2gsIGtleSwgdmFsKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGhhc2g7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiB0cmFuc3Bvc2VcclxuICAgIHJldHVybiBbXSBpZiBlbXB0eT9cclxuXHJcbiAgICByZXN1bHQgPSBbXVxyXG4gICAgbWF4ICAgID0gbmlsXHJcblxyXG4gICAgZWFjaCBkbyB8cm93fFxyXG4gICAgICBgcm93ID0gY29udmVydFRvQXJyYXkocm93KWBcclxuXHJcbiAgICAgIG1heCB8fD0gYHJvdy5sZW5ndGhgXHJcblxyXG4gICAgICBpZiBgcm93Lmxlbmd0aGAgIT0gbWF4XHJcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpJbmRleEVycm9yLCBcImVsZW1lbnQgc2l6ZSBkaWZmZXJzICgje2Byb3cubGVuZ3RoYH0gc2hvdWxkIGJlICN7bWF4fSlcIlxyXG4gICAgICBlbmRcclxuXHJcbiAgICAgIGByb3cubGVuZ3RoYC50aW1lcyBkbyB8aXxcclxuICAgICAgICBlbnRyeSA9IChyZXN1bHRbaV0gfHw9IFtdKVxyXG4gICAgICAgIGVudHJ5IDw8IHJvdy5hdChpKVxyXG4gICAgICBlbmRcclxuICAgIGVuZFxyXG5cclxuICAgIHJlc3VsdFxyXG4gIGVuZFxyXG5cclxuICBkZWYgdW5pb24oKmFycmF5cylcclxuICAgIGFycmF5cy5yZWR1Y2UodW5pcSkgeyB8YSwgYnwgYSB8IGIgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgdW5pcSgmYmxvY2spXHJcbiAgICAleHtcclxuICAgICAgdmFyIGhhc2ggPSAje3t9fSwgaSwgbGVuZ3RoLCBpdGVtLCBrZXk7XHJcblxyXG4gICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xyXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xyXG4gICAgICAgICAgaWYgKCRoYXNoX2dldChoYXNoLCBpdGVtKSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICRoYXNoX3B1dChoYXNoLCBpdGVtLCBpdGVtKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xyXG4gICAgICAgICAga2V5ID0gJHlpZWxkMShibG9jaywgaXRlbSk7XHJcbiAgICAgICAgICBpZiAoJGhhc2hfZ2V0KGhhc2gsIGtleSkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAkaGFzaF9wdXQoaGFzaCwga2V5LCBpdGVtKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiAje2BoYXNoYC52YWx1ZXN9O1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgdW5pcSEoJmJsb2NrKVxyXG4gICAgJXh7XHJcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XHJcblxyXG4gICAgICB2YXIgaGFzaCA9ICN7e319LCBpLCBpdGVtLCBrZXksIGRlbGV0ZV9pbmRleGVzID0gW107XHJcblxyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xyXG4gICAgICAgIGtleSA9IChibG9jayA9PT0gbmlsID8gaXRlbSA6ICR5aWVsZDEoYmxvY2ssIGl0ZW0pKTtcclxuXHJcbiAgICAgICAgaWYgKCRoYXNoX2dldChoYXNoLCBrZXkpID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICRoYXNoX3B1dChoYXNoLCBrZXksIGl0ZW0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBkZWxldGVfaW5kZXhlcy5wdXNoKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChpID0gZGVsZXRlX2luZGV4ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBzZWxmLnNwbGljZShkZWxldGVfaW5kZXhlc1tpXSwgMSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBkZWxldGVfaW5kZXhlcy5sZW5ndGggPT09IDAgPyBuaWwgOiBzZWxmO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgdW5zaGlmdCgqb2JqZWN0cylcclxuICAgICV4e1xyXG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xyXG5cclxuICAgICAgdmFyIHNlbGZMZW5ndGggPSBzZWxmLmxlbmd0aFxyXG4gICAgICB2YXIgb2JqZWN0c0xlbmd0aCA9IG9iamVjdHMubGVuZ3RoXHJcbiAgICAgIGlmIChvYmplY3RzTGVuZ3RoID09IDApIHJldHVybiBzZWxmO1xyXG4gICAgICB2YXIgaW5kZXggPSBzZWxmTGVuZ3RoIC0gb2JqZWN0c0xlbmd0aFxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdHNMZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHNlbGYucHVzaChzZWxmW2luZGV4ICsgaV0pXHJcbiAgICAgIH1cclxuICAgICAgdmFyIGxlbiA9IHNlbGZMZW5ndGggLSAxXHJcbiAgICAgIHdoaWxlIChsZW4gLSBvYmplY3RzTGVuZ3RoID49IDApIHtcclxuICAgICAgICBzZWxmW2xlbl0gPSBzZWxmW2xlbiAtIG9iamVjdHNMZW5ndGhdXHJcbiAgICAgICAgbGVuLS1cclxuICAgICAgfVxyXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9iamVjdHNMZW5ndGg7IGorKykge1xyXG4gICAgICAgIHNlbGZbal0gPSBvYmplY3RzW2pdXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiB2YWx1ZXNfYXQoKmFyZ3MpXHJcbiAgICBvdXQgPSBbXVxyXG5cclxuICAgIGFyZ3MuZWFjaCBkbyB8ZWxlbXxcclxuICAgICAgaWYgZWxlbS5pc19hPyA6OlJhbmdlXHJcbiAgICAgICAgZmluaXNoID0gYCN7ZWxlbS5lbmR9ID09PSBuaWwgPyAtMSA6ICRjb2VyY2VfdG8oI3tlbGVtLmVuZH0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxyXG4gICAgICAgIHN0YXJ0ID0gYCN7ZWxlbS5iZWdpbn0gPT09IG5pbCA/IDAgOiAkY29lcmNlX3RvKCN7ZWxlbS5iZWdpbn0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxyXG5cclxuICAgICAgICAleHtcclxuICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcclxuICAgICAgICAgICAgc3RhcnQgPSBzdGFydCArIHNlbGYubGVuZ3RoO1xyXG4gICAgICAgICAgICAje25leHR9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgJXh7XHJcbiAgICAgICAgICBpZiAoZmluaXNoIDwgMCkge1xyXG4gICAgICAgICAgICBmaW5pc2ggPSBmaW5pc2ggKyBzZWxmLmxlbmd0aDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICgje2VsZW0uZXhjbHVkZV9lbmQ/fSAmJiAje2VsZW0uZW5kfSAhPT0gbmlsKSB7XHJcbiAgICAgICAgICAgIGZpbmlzaC0tO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGZpbmlzaCA8IHN0YXJ0KSB7XHJcbiAgICAgICAgICAgICN7bmV4dH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGFydC51cHRvKGZpbmlzaCkgeyB8aXwgb3V0IDw8IGF0KGkpIH1cclxuICAgICAgZWxzZVxyXG4gICAgICAgIGkgPSBgJGNvZXJjZV90byhlbGVtLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcclxuICAgICAgICBvdXQgPDwgYXQoaSlcclxuICAgICAgZW5kXHJcbiAgICBlbmRcclxuXHJcbiAgICBvdXRcclxuICBlbmRcclxuXHJcbiAgZGVmIHppcCgqb3RoZXJzLCAmYmxvY2spXHJcbiAgICAleHtcclxuICAgICAgdmFyIHJlc3VsdCA9IFtdLCBzaXplID0gc2VsZi5sZW5ndGgsIHBhcnQsIG8sIGksIGosIGpqO1xyXG5cclxuICAgICAgZm9yIChqID0gMCwgamogPSBvdGhlcnMubGVuZ3RoOyBqIDwgamo7IGorKykge1xyXG4gICAgICAgIG8gPSBvdGhlcnNbal07XHJcbiAgICAgICAgaWYgKG8uJCRpc19hcnJheSkge1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvLiQkaXNfcmFuZ2UgfHwgby4kJGlzX2VudW1lcmF0b3IpIHtcclxuICAgICAgICAgIG90aGVyc1tqXSA9IG8uJHRha2Uoc2l6ZSk7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3RoZXJzW2pdID0gI3soXHJcbiAgICAgICAgICA6Ok9wYWwuY29lcmNlX3RvPyhgb2AsIDo6QXJyYXksIDp0b19hcnkpIHx8XHJcbiAgICAgICAgICA6Ok9wYWwuY29lcmNlX3RvIShgb2AsIDo6RW51bWVyYXRvciwgOnRvX2VudW0sIDplYWNoKVxyXG4gICAgICAgICkudG9fYX07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcclxuICAgICAgICBwYXJ0ID0gW3NlbGZbaV1dO1xyXG5cclxuICAgICAgICBmb3IgKGogPSAwLCBqaiA9IG90aGVycy5sZW5ndGg7IGogPCBqajsgaisrKSB7XHJcbiAgICAgICAgICBvID0gb3RoZXJzW2pdW2ldO1xyXG5cclxuICAgICAgICAgIGlmIChvID09IG51bGwpIHtcclxuICAgICAgICAgICAgbyA9IG5pbDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBwYXJ0W2ogKyAxXSA9IG87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXN1bHRbaV0gPSBwYXJ0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcclxuICAgICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCByZXN1bHRbaV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5pbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHNlbGYuaW5oZXJpdGVkKGtsYXNzKVxyXG4gICAgJXh7XHJcbiAgICAgIGtsYXNzLiQkcHJvdG90eXBlLiR0b19hID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoMCwgdGhpcy5sZW5ndGgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZXNcclxuICAgIHN1cGVyLnJlamVjdCB7IHxpdmFyfCBgL15AXFxkKyQvLnRlc3QoI3tpdmFyfSlgIHx8IGl2YXIgPT0gJ0BsZW5ndGgnIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHBhY2soKmFyZ3MpXHJcbiAgICA6Oktlcm5lbC5yYWlzZSBcIlRvIHVzZSBBcnJheSNwYWNrLCB5b3UgbXVzdCBmaXJzdCByZXF1aXJlICdjb3JlbGliL2FycmF5L3BhY2snLlwiXHJcbiAgZW5kXHJcblxyXG4gIGFsaWFzIGFwcGVuZCBwdXNoXHJcbiAgYWxpYXMgZmlsdGVyIHNlbGVjdFxyXG4gIGFsaWFzIGZpbHRlciEgc2VsZWN0IVxyXG4gIGFsaWFzIG1hcCBjb2xsZWN0XHJcbiAgYWxpYXMgbWFwISBjb2xsZWN0IVxyXG4gIGFsaWFzIHByZXBlbmQgdW5zaGlmdFxyXG4gIGFsaWFzIHNpemUgbGVuZ3RoXHJcbiAgYWxpYXMgc2xpY2UgW11cclxuICBhbGlhcyB0b19zIGluc3BlY3RcclxuXHJcbiAgOjpPcGFsLnByaXN0aW5lIHNpbmdsZXRvbl9jbGFzcywgOmFsbG9jYXRlXHJcbiAgOjpPcGFsLnByaXN0aW5lIHNlbGYsIDpjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcywgOmluaXRpYWxpemVfZHVwXHJcbmVuZFxyXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOkFycmF5PiIsImluY2x1ZGUiLCJFbnVtZXJhYmxlIiwidG9fYSIsIkFycmF5IiwiW10iLCJpbml0aWFsaXplIiwic2l6ZSIsIm9iaiIsIktlcm5lbCIsIndhcm4iLCJJbnRlZ2VyOjpNQVgiLCJJbnRlZ2VyIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwicmVwbGFjZSIsInJlc3BvbmRfdG8/IiwidG9fYXJ5IiwidHJ5X2NvbnZlcnQiLCJPcGFsIiwiY29lcmNlX3RvPyIsIiYiLCJvdGhlciIsInwiLCIqIiwiam9pbiIsInRvX3N0ciIsIisiLCItIiwiPDwiLCJvYmplY3QiLCI8PT4iLCI9PSIsIm9iamVjdF9pZCIsImluZGV4IiwibGVuZ3RoIiwiW109IiwidmFsdWUiLCJleHRyYSIsImRhdGEiLCJSYW5nZUVycm9yIiwiaW5zcGVjdCIsIjEiLCJJbmRleEVycm9yIiwiYW55PyIsInBhdHRlcm4iLCJhc3NvYyIsImF0IiwiYnNlYXJjaF9pbmRleCIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwiVHlwZUVycm9yIiwiY2xhc3MiLCJic2VhcmNoIiwiYmxvY2siLCJ0b19wcm9jIiwiY3ljbGUiLCJuIiwiYmxvY2sgaW4gY3ljbGUiLCJibG9jayAoMiBsZXZlbHMpIGluIGN5Y2xlIiwibmlsPyIsIkZsb2F0OjpJTkZJTklUWSIsIkZsb2F0IiwiY29lcmNlX3RvISIsIj4iLCIwIiwiZW51bWVyYXRvcl9zaXplIiwiZW1wdHk/IiwiY2xlYXIiLCJjb3VudCIsImluaXRpYWxpemVfY29weSIsImNvbGxlY3QiLCJibG9jayBpbiBjb2xsZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb2xsZWN0IiwiY29sbGVjdCEiLCJibG9jayBpbiBjb2xsZWN0ISIsImJsb2NrICgyIGxldmVscykgaW4gY29sbGVjdCEiLCJjb21iaW5hdGlvbiIsIm51bSIsImJsb2NrIGluIGNvbWJpbmF0aW9uIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb21iaW5hdGlvbiIsInJlcGVhdGVkX2NvbWJpbmF0aW9uIiwiYmxvY2sgaW4gcmVwZWF0ZWRfY29tYmluYXRpb24iLCJibG9jayAoMiBsZXZlbHMpIGluIHJlcGVhdGVkX2NvbWJpbmF0aW9uIiwiY29tcGFjdCIsImNvbXBhY3QhIiwiY29uY2F0Iiwib3RoZXJzIiwibWFwIiwiYmxvY2sgaW4gY29uY2F0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb25jYXQiLCJlcXVhbD8iLCJkdXAiLCJlYWNoIiwiZGVsZXRlIiwiZGVsZXRlX2F0IiwiZGVsZXRlX2lmIiwiYmxvY2sgaW4gZGVsZXRlX2lmIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkZWxldGVfaWYiLCJkaWZmZXJlbmNlIiwicmVkdWNlIiwiYXJyYXlzIiwiYmxvY2sgaW4gZGlmZmVyZW5jZSIsImEiLCJiIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkaWZmZXJlbmNlIiwiZGlnIiwiaWR4IiwiaXRlbSIsImlkeHMiLCJkcm9wIiwibnVtYmVyIiwiYmxvY2sgaW4gZWFjaCIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaCIsImVhY2hfaW5kZXgiLCJibG9jayBpbiBlYWNoX2luZGV4IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX2luZGV4IiwiZXFsPyIsImZldGNoIiwiZGVmYXVsdHMiLCJmaWxsIiwiYXJncyIsIm9uZSIsInR3byIsIlJhbmdlIiwibGVmdCIsInJpZ2h0IiwiZXhjbHVkZV9lbmQ/IiwiZmlyc3QiLCJmbGF0dGVuIiwibGV2ZWwiLCJmbGF0dGVuISIsImZyZWV6ZSIsImZyb3plbj8iLCJoYXNoIiwiaW5jbHVkZT8iLCJtZW1iZXIiLCJpbnNlcnQiLCJfX2lkX18iLCJpbnRlcnNlY3Rpb24iLCJzb3J0X2J5IiwibGFyZ2VzdCIsImludGVyc2VjdGlvbl9vZl9hcmdzIiwiaW50ZXJzZWN0PyIsInNlcCIsIiQsIiwidG9fcyIsIk5vTWV0aG9kRXJyb3IiLCJuZXciLCJTdHJpbmciLCJrZWVwX2lmIiwiYmxvY2sgaW4ga2VlcF9pZiIsImJsb2NrICgyIGxldmVscykgaW4ga2VlcF9pZiIsImxhc3QiLCJtYXgiLCJtaW4iLCJwZXJtdXRhdGlvbiIsImJsb2NrIGluIHBlcm11dGF0aW9uIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwZXJtdXRhdGlvbiIsInBlcm0iLCJ1c2VkIiwiISIsInJlcGVhdGVkX3Blcm11dGF0aW9uIiwiYmxvY2sgaW4gcmVwZWF0ZWRfcGVybXV0YXRpb24iLCJibG9jayAoMiBsZXZlbHMpIGluIHJlcGVhdGVkX3Blcm11dGF0aW9uIiwiPj0iLCIqKiIsInBvcCIsInByb2R1Y3QiLCJwdXNoIiwicmFzc29jIiwicmVqZWN0IiwiYmxvY2sgaW4gcmVqZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWplY3QiLCJyZWplY3QhIiwiYmxvY2sgaW4gcmVqZWN0ISIsImJsb2NrICgyIGxldmVscykgaW4gcmVqZWN0ISIsIm9yaWdpbmFsIiwicmV2ZXJzZSIsInJldmVyc2UhIiwicmV2ZXJzZV9lYWNoIiwiYmxvY2sgaW4gcmV2ZXJzZV9lYWNoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZXZlcnNlX2VhY2giLCJyaW5kZXgiLCJyb3RhdGUiLCJyb3RhdGUhIiwiY250IiwiYXJ5IiwiPGNsYXNzOnNlbGY6OlNhbXBsZVJhbmRvbT4iLCJyYW5kIiwicmFuZG9tIiwiQHJuZyIsInNhbXBsZSIsIm9wdGlvbnMiLCJvIiwiSGFzaCIsInJuZyIsIlNhbXBsZVJhbmRvbSIsInNlbGVjdCIsImJsb2NrIGluIHNlbGVjdCIsImJsb2NrICgyIGxldmVscykgaW4gc2VsZWN0Iiwic2VsZWN0ISIsImJsb2NrIGluIHNlbGVjdCEiLCJibG9jayAoMiBsZXZlbHMpIGluIHNlbGVjdCEiLCJzaGlmdCIsInNodWZmbGUiLCJzaHVmZmxlISIsInNsaWNlISIsInJlc3VsdCIsInJhbmdlIiwicmFuZ2Vfc3RhcnQiLCJyYW5nZV9lbmQiLCJzdGFydCIsInNvcnQiLCI8Iiwic29ydCEiLCJzb3J0X2J5ISIsImJsb2NrIGluIHNvcnRfYnkhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzb3J0X2J5ISIsInRha2UiLCJ0YWtlX3doaWxlIiwidG9faCIsImFycmF5IiwidHJhbnNwb3NlIiwiYmxvY2sgaW4gdHJhbnNwb3NlIiwicm93IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0cmFuc3Bvc2UiLCIkcmV0X29yXzEiLCJ0aW1lcyIsImkiLCJibG9jayAoMyBsZXZlbHMpIGluIHRyYW5zcG9zZSIsImVudHJ5IiwidW5pb24iLCJ1bmlxIiwiYmxvY2sgaW4gdW5pb24iLCJibG9jayAoMiBsZXZlbHMpIGluIHVuaW9uIiwidmFsdWVzIiwidW5pcSEiLCJ1bnNoaWZ0IiwidmFsdWVzX2F0Iiwib3V0IiwiYmxvY2sgaW4gdmFsdWVzX2F0IiwiZWxlbSIsImJsb2NrICgyIGxldmVscykgaW4gdmFsdWVzX2F0IiwiaXNfYT8iLCJmaW5pc2giLCJlbmQiLCJiZWdpbiIsInVwdG8iLCJibG9jayAoMyBsZXZlbHMpIGluIHZhbHVlc19hdCIsInppcCIsIkVudW1lcmF0b3IiLCJpbmhlcml0ZWQiLCJrbGFzcyIsImluc3RhbmNlX3ZhcmlhYmxlcyIsImJsb2NrIGluIGluc3RhbmNlX3ZhcmlhYmxlcyIsIml2YXIiLCJibG9jayAoMiBsZXZlbHMpIGluIGluc3RhbmNlX3ZhcmlhYmxlcyIsInBhY2siLCJwcmlzdGluZSIsInNpbmdsZXRvbl9jbGFzcyJdLCJtYXBwaW5ncyI6IkFBQUFBLGdDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUdBQyxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsaUJBQVJFO0VBRUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7O0lBQ0VGLElBQUFHLFNBQUFBLENBQVFDLGlCQUFSRDtJQUdDRDs7QUFHSEE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSwwQ0FBNENBLENBQUNBLEdBQURBLENBQUtHLE1BQUFBLENBQUFBLENBQU1IO0FBQ3ZEQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtB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O0lBQ0EsYUFBTSxNQUFOLEVBQVcsVUFBWDtJQUNBLGFBQU0sU0FBTixFQUFjLFNBQWQ7SUFDQSxhQUFNLE1BQU4sRUFBVyxRQUFYO0lBQ0EsYUFBTSxPQUFOLEVBQVksSUFBWjtJQUNBLGFBQU0sTUFBTixFQUFXLFNBQVg7SUFFQS9PLEtBQU1nUCxVQUFBQSxDQUFVclEsSUFBQXNRLGlCQUFBQSxDQUFBQSxDQUFoQixFQUFpQyxVQUEzQkQ7SUFDTm5RLE9BQUFtQixLQUFNZ1AsVUFBQUEsQ0FBVXJRLElBQWhCLEVBQXNCLHlCQUF0QixFQUFnRCxnQkFBMUNxUTtFQXBnRlJuUSxHQUFNLElBQU5BLEVBQWlCSCxLQUFqQkc7QUFOQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE2ODgyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9oYXNoLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogeWllbGQxLCBoYXNoX2Nsb25lLCBoYXNoX2RlbGV0ZSwgaGFzaF9lYWNoLCBoYXNoX2dldCwgaGFzaF9wdXQsIGRlbnlfZnJvemVuX2FjY2VzcywgZnJlZXplLCBvcGFsMzJfaW5pdCwgb3BhbDMyX2FkZFxyXG4jIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcclxuIyB1c2Vfc3RyaWN0OiB0cnVlXHJcblxyXG5yZXF1aXJlICdjb3JlbGliL2VudW1lcmFibGUnXHJcblxyXG4jIC0tLVxyXG4jIEludGVybmFsIHByb3BlcnRpZXM6XHJcbiNcclxuIyAtICQka2V5cyAgICAgW01hcDxrZXktYXJyYXk+XSBvcHRpb25hbCBNYXAgb2Yga2V5IGFycmF5cywgdXNlZCB3aGVuIG9iamVjdHMgYXJlIHVzZWQgYXMga2V5c1xyXG4jIC0gJCRwcm9jICAgICAgICBbUHJvYyxudWxsLG5pbF0gdGhlIGRlZmF1bHQgcHJvYyB1c2VkIGZvciBtaXNzaW5nIGtleXNcclxuIyAtIGtleS1hcnJheSAgIFtKUzo6TWFwXSBhbiBlbGVtZW50IG9mIGEgYXJyYXkgdGhhdCBob2xkcyBvYmplY3RzIHVzZWQgYXMga2V5cywgYHsga2V5X2hhc2ggPT4gW29iamVjdHMuLi5dIH1gXHJcbmNsYXNzIDo6SGFzaCA8IGBNYXBgXHJcbiAgaW5jbHVkZSA6OkVudW1lcmFibGVcclxuXHJcbiAgIyBNYXJrIGFsbCBoYXNoIGluc3RhbmNlcyBhcyB2YWxpZCBoYXNoZXMgKHVzZWQgdG8gY2hlY2sga2V5d29yZCBhcmdzLCBldGMpXHJcbiAgYHNlbGYuJCRwcm90b3R5cGUuJCRpc19oYXNoID0gdHJ1ZWBcclxuXHJcbiAgZGVmIHNlbGYuW10oKmFyZ3YpXHJcbiAgICAleHtcclxuICAgICAgdmFyIGhhc2gsIGFyZ2MgPSBhcmd2Lmxlbmd0aCwgYXJnLCBpO1xyXG5cclxuICAgICAgaWYgKGFyZ2MgPT09IDEpIHtcclxuICAgICAgICBoYXNoID0gI3s6Ok9wYWwuY29lcmNlX3RvPyhhcmd2WzBdLCA6Okhhc2gsIDp0b19oYXNoKX07XHJcbiAgICAgICAgaWYgKGhhc2ggIT09IG5pbCkge1xyXG4gICAgICAgICAgcmV0dXJuICN7YWxsb2NhdGUubWVyZ2UhKGBoYXNoYCl9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYXJndiA9ICN7OjpPcGFsLmNvZXJjZV90bz8oYXJndlswXSwgOjpBcnJheSwgOnRvX2FyeSl9O1xyXG4gICAgICAgIGlmIChhcmd2ID09PSBuaWwpIHtcclxuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnb2RkIG51bWJlciBvZiBhcmd1bWVudHMgZm9yIEhhc2gnfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGFyZ2MgPSBhcmd2Lmxlbmd0aDtcclxuICAgICAgICBoYXNoID0gI3thbGxvY2F0ZX07XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdjOyBpKyspIHtcclxuICAgICAgICAgIGFyZyA9IGFyZ3ZbaV07XHJcbiAgICAgICAgICBpZiAoIWFyZy4kJGlzX2FycmF5KVxyXG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIGVsZW1lbnQgI3tgYXJnYC5pbnNwZWN0fSBmb3IgSGFzaFwifTtcclxuICAgICAgICAgIGlmIChhcmcubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIGhhc2guJHN0b3JlKGFyZ1swXSwgbmlsKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoYXJnLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICBoYXNoLiRzdG9yZShhcmdbMF0sIGFyZ1sxXSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIG51bWJlciBvZiBlbGVtZW50cyAoI3tgYXJnLmxlbmd0aGB9IGZvciAje2BhcmdgLmluc3BlY3R9KSwgbXVzdCBiZSAxLi4yXCJ9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGhhc2g7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChhcmdjICUgMiAhPT0gMCkge1xyXG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnb2RkIG51bWJlciBvZiBhcmd1bWVudHMgZm9yIEhhc2gnfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBoYXNoID0gI3thbGxvY2F0ZX07XHJcblxyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnYzsgaSArPSAyKSB7XHJcbiAgICAgICAgaGFzaC4kc3RvcmUoYXJndltpXSwgYXJndltpICsgMV0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gaGFzaDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHNlbGYuYWxsb2NhdGVcclxuICAgICV4e1xyXG4gICAgICB2YXIgaGFzaCA9IG5ldyBzZWxmLiQkY29uc3RydWN0b3IoKTtcclxuXHJcbiAgICAgIGhhc2guJCRub25lID0gbmlsO1xyXG4gICAgICBoYXNoLiQkcHJvYyA9IG5pbDtcclxuXHJcbiAgICAgIHJldHVybiBoYXNoO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc2VsZi50cnlfY29udmVydChvYmopXHJcbiAgICA6Ok9wYWwuY29lcmNlX3RvPyhvYmosIDo6SGFzaCwgOnRvX2hhc2gpXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBpbml0aWFsaXplKGRlZmF1bHRzID0gdW5kZWZpbmVkLCAmYmxvY2spXHJcbiAgICAleHtcclxuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcclxuXHJcbiAgICAgIGlmIChkZWZhdWx0cyAhPT0gdW5kZWZpbmVkICYmIGJsb2NrICE9PSBuaWwpIHtcclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDEgZm9yIDApJ31cclxuICAgICAgfVxyXG4gICAgICBzZWxmLiQkbm9uZSA9IChkZWZhdWx0cyA9PT0gdW5kZWZpbmVkID8gbmlsIDogZGVmYXVsdHMpO1xyXG4gICAgICBzZWxmLiQkcHJvYyA9IGJsb2NrO1xyXG5cclxuICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiA9PShvdGhlcilcclxuICAgICV4e1xyXG4gICAgICBpZiAoc2VsZiA9PT0gb3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFvdGhlci4kJGlzX2hhc2gpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzZWxmLnNpemUgIT09IG90aGVyLnNpemUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBlbnRyeSwgb3RoZXJfdmFsdWU7XHJcbiAgICAgIGZvciAoZW50cnkgb2Ygc2VsZikge1xyXG4gICAgICAgIG90aGVyX3ZhbHVlID0gJGhhc2hfZ2V0KG90aGVyLCBlbnRyeVswXSk7XHJcbiAgICAgICAgaWYgKG90aGVyX3ZhbHVlID09PSB1bmRlZmluZWQgfHwgIWVudHJ5WzFdWyckZXFsPyddKG90aGVyX3ZhbHVlKSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmID49KG90aGVyKVxyXG4gICAgb3RoZXIgPSA6Ok9wYWwuY29lcmNlX3RvIShvdGhlciwgOjpIYXNoLCA6dG9faGFzaClcclxuXHJcbiAgICAleHtcclxuICAgICAgaWYgKHNlbGYuc2l6ZSA8IG90aGVyLnNpemUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXN1bHQgPSB0cnVlXHJcblxyXG4gICAgb3RoZXIuZWFjaCBkbyB8b3RoZXJfa2V5LCBvdGhlcl92YWx8ICMgcnVib2NvcDpkaXNhYmxlIFN0eWxlL0hhc2hFYWNoTWV0aG9kc1xyXG4gICAgICB2YWwgPSBmZXRjaChvdGhlcl9rZXksIGBudWxsYClcclxuXHJcbiAgICAgICV4e1xyXG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCB8fCB2YWwgIT09IG90aGVyX3ZhbCkge1xyXG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICBlbmRcclxuXHJcbiAgICByZXN1bHRcclxuICBlbmRcclxuXHJcbiAgZGVmID4ob3RoZXIpXHJcbiAgICBvdGhlciA9IDo6T3BhbC5jb2VyY2VfdG8hKG90aGVyLCA6Okhhc2gsIDp0b19oYXNoKVxyXG5cclxuICAgICV4e1xyXG4gICAgICBpZiAoc2VsZi5zaXplIDw9IG90aGVyLnNpemUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZWxmID49IG90aGVyXHJcbiAgZW5kXHJcblxyXG4gIGRlZiA8KG90aGVyKVxyXG4gICAgb3RoZXIgPSA6Ok9wYWwuY29lcmNlX3RvIShvdGhlciwgOjpIYXNoLCA6dG9faGFzaClcclxuICAgIG90aGVyID4gc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgPD0ob3RoZXIpXHJcbiAgICBvdGhlciA9IDo6T3BhbC5jb2VyY2VfdG8hKG90aGVyLCA6Okhhc2gsIDp0b19oYXNoKVxyXG4gICAgb3RoZXIgPj0gc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgW10oa2V5KVxyXG4gICAgJXh7XHJcbiAgICAgIHZhciB2YWx1ZSA9ICRoYXNoX2dldChzZWxmLCBrZXkpO1xyXG5cclxuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzZWxmLiRkZWZhdWx0KGtleSk7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBbXT0oa2V5LCB2YWx1ZSlcclxuICAgICV4e1xyXG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xyXG5cclxuICAgICAgJGhhc2hfcHV0KHNlbGYsIGtleSwgdmFsdWUpO1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBhc3NvYyhvYmplY3QpXHJcbiAgICAleHtcclxuICAgICAgdmFyIGVudHJ5O1xyXG4gICAgICBmb3IgKGVudHJ5IG9mIHNlbGYpIHtcclxuICAgICAgICBpZiAoI3tgZW50cnlbMF1gID09IG9iamVjdH0pIHtcclxuICAgICAgICAgIHJldHVybiBbZW50cnlbMF0sIGVudHJ5WzFdXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5pbDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGNsZWFyXHJcbiAgICAleHtcclxuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcclxuXHJcbiAgICAgIHNlbGYuY2xlYXIoKTtcclxuICAgICAgaWYgKHNlbGYuJCRrZXlzKVxyXG4gICAgICAgIHNlbGYuJCRrZXlzLmNsZWFyKCk7XHJcblxyXG4gICAgICByZXR1cm4gc2VsZjtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGNsb25lXHJcbiAgICAleHtcclxuICAgICAgdmFyIGhhc2ggPSBzZWxmLiRjbGFzcygpLiRuZXcoKTtcclxuICAgICAgJGhhc2hfY2xvbmUoc2VsZiwgaGFzaCk7XHJcbiAgICAgIHJldHVybiBzZWxmW1wiJGZyb3plbj9cIl0oKSA/IGhhc2guJGZyZWV6ZSgpIDogaGFzaDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGNvbXBhY3RcclxuICAgICV4e1xyXG4gICAgICB2YXIgaGFzaCA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgIHNlbGYuZm9yRWFjaCgodmFsdWUsIGtleSwgcykgPT4ge1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbmlsICYmIHZhbHVlICE9IG51bGwpXHJcbiAgICAgICAgICAkaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIGhhc2g7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBjb21wYWN0IVxyXG4gICAgJXh7XHJcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XHJcblxyXG4gICAgICB2YXIgcmVzdWx0ID0gbmlsO1xyXG5cclxuICAgICAgcmV0dXJuICRoYXNoX2VhY2goc2VsZiwgcmVzdWx0LCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlID09PSBuaWwgfHwgdmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgJGhhc2hfZGVsZXRlKHNlbGYsIGtleSk7XHJcbiAgICAgICAgICByZXN1bHQgPSBzZWxmO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW2ZhbHNlLCByZXN1bHRdO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGNvbXBhcmVfYnlfaWRlbnRpdHlcclxuICAgICV4e1xyXG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xyXG5cclxuICAgICAgaWYgKCFzZWxmLiQkYnlfaWRlbnRpdHkpIHtcclxuICAgICAgICBzZWxmLiQkYnlfaWRlbnRpdHkgPSB0cnVlO1xyXG5cclxuICAgICAgICBpZiAoc2VsZi5zaXplICE9PSAwKVxyXG4gICAgICAgICAgT3BhbC5oYXNoX3JlaGFzaChzZWxmKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBjb21wYXJlX2J5X2lkZW50aXR5P1xyXG4gICAgYHNlbGYuJCRieV9pZGVudGl0eSA9PT0gdHJ1ZWBcclxuICBlbmRcclxuXHJcbiAgZGVmIGRlZmF1bHQoa2V5ID0gdW5kZWZpbmVkKVxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCAmJiBzZWxmLiQkcHJvYyAhPT0gbmlsICYmIHNlbGYuJCRwcm9jICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gc2VsZi4kJHByb2MuJGNhbGwoc2VsZiwga2V5KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2VsZi4kJG5vbmUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBuaWw7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNlbGYuJCRub25lO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZGVmYXVsdD0ob2JqZWN0KVxyXG4gICAgJXh7XHJcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XHJcblxyXG4gICAgICBzZWxmLiQkcHJvYyA9IG5pbDtcclxuICAgICAgc2VsZi4kJG5vbmUgPSBvYmplY3Q7XHJcblxyXG4gICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZGVmYXVsdF9wcm9jXHJcbiAgICAleHtcclxuICAgICAgaWYgKHNlbGYuJCRwcm9jICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gc2VsZi4kJHByb2M7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5pbDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGRlZmF1bHRfcHJvYz0oZGVmYXVsdF9wcm9jKVxyXG4gICAgJXh7XHJcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XHJcblxyXG4gICAgICB2YXIgcHJvYyA9IGRlZmF1bHRfcHJvYztcclxuXHJcbiAgICAgIGlmIChwcm9jICE9PSBuaWwpIHtcclxuICAgICAgICBwcm9jID0gI3s6Ok9wYWwuY29lcmNlX3RvIShgcHJvY2AsIDo6UHJvYywgOnRvX3Byb2MpfTtcclxuXHJcbiAgICAgICAgaWYgKCN7YHByb2NgLmxhbWJkYT99ICYmICN7YHByb2NgLmFyaXR5LmFic30gIT09IDIpIHtcclxuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdkZWZhdWx0X3Byb2MgdGFrZXMgdHdvIGFyZ3VtZW50cyd9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgc2VsZi4kJG5vbmUgPSBuaWw7XHJcbiAgICAgIHNlbGYuJCRwcm9jID0gcHJvYztcclxuXHJcbiAgICAgIHJldHVybiBkZWZhdWx0X3Byb2M7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBkZWxldGUoa2V5LCAmYmxvY2spXHJcbiAgICAleHtcclxuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcclxuICAgICAgdmFyIHZhbHVlID0gJGhhc2hfZGVsZXRlKHNlbGYsIGtleSk7XHJcblxyXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcclxuICAgICAgICByZXR1cm4gI3t5aWVsZCBrZXl9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbmlsO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZGVsZXRlX2lmKCZibG9jaylcclxuICAgIHJldHVybiBlbnVtX2Zvcig6ZGVsZXRlX2lmKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcclxuXHJcbiAgICAleHtcclxuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcclxuXHJcbiAgICAgIHJldHVybiAkaGFzaF9lYWNoKHNlbGYsIHNlbGYsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgb2JqID0gYmxvY2soa2V5LCB2YWx1ZSk7XHJcblxyXG4gICAgICAgIGlmIChvYmogIT09IGZhbHNlICYmIG9iaiAhPT0gbmlsKSB7XHJcbiAgICAgICAgICAkaGFzaF9kZWxldGUoc2VsZiwga2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtmYWxzZSwgc2VsZl07XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZGlnKGtleSwgKmtleXMpXHJcbiAgICBpdGVtID0gc2VsZltrZXldXHJcblxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChpdGVtID09PSBuaWwgfHwga2V5cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHVubGVzcyBpdGVtLnJlc3BvbmRfdG8/KDpkaWcpXHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIiN7aXRlbS5jbGFzc30gZG9lcyBub3QgaGF2ZSAjZGlnIG1ldGhvZFwiXHJcbiAgICBlbmRcclxuXHJcbiAgICBpdGVtLmRpZygqa2V5cylcclxuICBlbmRcclxuXHJcbiAgZGVmIGR1cFxyXG4gICAgYCRoYXNoX2Nsb25lKHNlbGYsIHNlbGYuJGNsYXNzKCkuJG5ldygpKWBcclxuICBlbmRcclxuXHJcbiAgZGVmIGVhY2goJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcclxuXHJcbiAgICAleHtcclxuICAgICAgcmV0dXJuICRoYXNoX2VhY2goc2VsZiwgc2VsZiwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICR5aWVsZDEoYmxvY2ssIFtrZXksIHZhbHVlXSk7XHJcbiAgICAgICAgcmV0dXJuIFtmYWxzZSwgc2VsZl07XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZWFjaF9rZXkoJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX2tleSkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXHJcblxyXG4gICAgJXh7XHJcbiAgICAgIHJldHVybiAkaGFzaF9lYWNoKHNlbGYsIHNlbGYsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgICAgICBibG9jayhrZXkpO1xyXG4gICAgICAgIHJldHVybiBbZmFsc2UsIHNlbGZdO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGVhY2hfdmFsdWUoJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3ZhbHVlKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcclxuXHJcbiAgICAleHtcclxuICAgICAgcmV0dXJuICRoYXNoX2VhY2goc2VsZiwgc2VsZiwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGJsb2NrKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gW2ZhbHNlLCBzZWxmXTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBlbXB0eT9cclxuICAgIGBzZWxmLnNpemUgPT09IDBgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBleGNlcHQoKmtleXMpXHJcbiAgICBkdXAuZXhjZXB0ISgqa2V5cylcclxuICBlbmRcclxuXHJcbiAgZGVmIGV4Y2VwdCEoKmtleXMpXHJcbiAgICBrZXlzLmVhY2ggeyB8a2V5fCBkZWxldGUoa2V5KSB9XHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBmZXRjaChrZXksIGRlZmF1bHRzID0gdW5kZWZpbmVkLCAmYmxvY2spXHJcbiAgICAleHtcclxuICAgICAgdmFyIHZhbHVlID0gJGhhc2hfZ2V0KHNlbGYsIGtleSk7XHJcblxyXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcclxuICAgICAgICByZXR1cm4gYmxvY2soa2V5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGRlZmF1bHRzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdHM7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICA6Oktlcm5lbC5yYWlzZSA6OktleUVycm9yLm5ldyhcImtleSBub3QgZm91bmQ6ICN7a2V5Lmluc3BlY3R9XCIsIGtleToga2V5LCByZWNlaXZlcjogc2VsZilcclxuICBlbmRcclxuXHJcbiAgZGVmIGZldGNoX3ZhbHVlcygqa2V5cywgJmJsb2NrKVxyXG4gICAga2V5cy5tYXAgeyB8a2V5fCBmZXRjaChrZXksICZibG9jaykgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZmxhdHRlbihsZXZlbCA9IDEpXHJcbiAgICBsZXZlbCA9IDo6T3BhbC5jb2VyY2VfdG8hKGxldmVsLCA6OkludGVnZXIsIDp0b19pbnQpXHJcblxyXG4gICAgJXh7XHJcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuXHJcbiAgICAgIHJldHVybiAkaGFzaF9lYWNoKHNlbGYsIHJlc3VsdCwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XHJcblxyXG4gICAgICAgIGlmICh2YWx1ZS4kJGlzX2FycmF5KSB7XHJcbiAgICAgICAgICBpZiAobGV2ZWwgPT09IDEpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gW2ZhbHNlLCByZXN1bHRdO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoI3tgdmFsdWVgLmZsYXR0ZW4oYGxldmVsIC0gMmApfSk7XHJcbiAgICAgICAgICByZXR1cm4gW2ZhbHNlLCByZXN1bHRdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBbZmFsc2UsIHJlc3VsdF07XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZnJlZXplXHJcbiAgICByZXR1cm4gc2VsZiBpZiBmcm96ZW4/XHJcblxyXG4gICAgYCRmcmVlemUoc2VsZilgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBoYXNfa2V5PyhrZXkpXHJcbiAgICBgJGhhc2hfZ2V0KHNlbGYsIGtleSkgIT09IHVuZGVmaW5lZGBcclxuICBlbmRcclxuXHJcbiAgZGVmIGhhc192YWx1ZT8odmFsdWUpXHJcbiAgICAleHtcclxuICAgICAgdmFyIHZhbCwgdmFsdWVzID0gc2VsZi52YWx1ZXMoKTtcclxuICAgICAgZm9yICh2YWwgb2YgdmFsdWVzKSB7XHJcbiAgICAgICAgaWYgKCN7YHZhbGAgPT0gdmFsdWV9KSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBgdmFyICRoYXNoX2lkc2BcclxuXHJcbiAgZGVmIGhhc2hcclxuICAgICV4e1xyXG4gICAgICB2YXIgdG9wID0gKCRoYXNoX2lkcyA9PT0gdW5kZWZpbmVkKSxcclxuICAgICAgICAgIGhhc2hfaWQgPSBzZWxmLiRvYmplY3RfaWQoKSxcclxuICAgICAgICAgIHJlc3VsdCA9ICRvcGFsMzJfaW5pdCgpLFxyXG4gICAgICAgICAga2V5LCBpdGVtLCBpLCB2YWx1ZXMsIGVudHJ5LFxyXG4gICAgICAgICAgc2l6ZSA9IHNlbGYuc2l6ZSwgYXJ5ID0gbmV3IEludDMyQXJyYXkoc2l6ZSk7XHJcblxyXG4gICAgICByZXN1bHQgPSAkb3BhbDMyX2FkZChyZXN1bHQsIDB4NCk7XHJcbiAgICAgIHJlc3VsdCA9ICRvcGFsMzJfYWRkKHJlc3VsdCwgc2l6ZSk7XHJcblxyXG4gICAgICBpZiAodG9wKSB7XHJcbiAgICAgICAgJGhhc2hfaWRzID0gbmV3IE1hcCgpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKCRoYXNoX2lkcy5oYXMoaGFzaF9pZCkpIHtcclxuICAgICAgICByZXR1cm4gJG9wYWwzMl9hZGQocmVzdWx0LCAweDAxMDEwMTAxKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAoIXRvcCkge1xyXG4gICAgICAgICAgdmFsdWVzID0gJGhhc2hfaWRzLnZhbHVlcygpO1xyXG4gICAgICAgICAgZm9yIChpdGVtIG9mIHZhbHVlcykge1xyXG4gICAgICAgICAgICBpZiAoI3tlcWw/KGBpdGVtYCl9KSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICRvcGFsMzJfYWRkKHJlc3VsdCwgMHgwMTAxMDEwMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICRoYXNoX2lkcy5zZXQoaGFzaF9pZCwgc2VsZik7XHJcbiAgICAgICAgaSA9IDA7XHJcblxyXG4gICAgICAgIGZvciAoZW50cnkgb2Ygc2VsZikge1xyXG4gICAgICAgICAgYXJ5W2ldID0gWzB4NzA0MTQ5NTIsIGVudHJ5WzBdLCBlbnRyeVsxXV0uJGhhc2goKTtcclxuICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGFyeSA9IGFyeS5zb3J0KCk7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIHJlc3VsdCA9ICRvcGFsMzJfYWRkKHJlc3VsdCwgYXJ5W2ldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgaWYgKHRvcCkge1xyXG4gICAgICAgICAgJGhhc2hfaWRzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgaW5kZXgob2JqZWN0KVxyXG4gICAgJXh7XHJcbiAgICAgIHZhciBlbnRyeTtcclxuICAgICAgZm9yIChlbnRyeSBvZiBzZWxmKSB7XHJcbiAgICAgICAgaWYgKCN7YGVudHJ5WzFdYCA9PSBvYmplY3R9KSB7XHJcbiAgICAgICAgICByZXR1cm4gZW50cnlbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuaWw7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBpbmRleGVzKCphcmdzKVxyXG4gICAgJXh7XHJcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcmdzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAga2V5ID0gYXJnc1tpXTtcclxuICAgICAgICB2YWx1ZSA9ICRoYXNoX2dldChzZWxmLCBrZXkpO1xyXG5cclxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgcmVzdWx0LnB1c2goI3tkZWZhdWx0fSk7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgYHZhciBpbnNwZWN0X2lkc2BcclxuXHJcbiAgZGVmIGluc3BlY3RcclxuICAgICV4e1xyXG4gICAgICB2YXIgdG9wID0gKGluc3BlY3RfaWRzID09PSB1bmRlZmluZWQpLFxyXG4gICAgICAgICAgaGFzaF9pZCA9IHNlbGYuJG9iamVjdF9pZCgpLFxyXG4gICAgICAgICAgcmVzdWx0ID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgYmVnaW5cclxuICAgICAgJXh7XHJcbiAgICAgICAgaWYgKHRvcCkge1xyXG4gICAgICAgICAgaW5zcGVjdF9pZHMgPSB7fTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpbnNwZWN0X2lkcy5oYXNPd25Qcm9wZXJ0eShoYXNoX2lkKSkge1xyXG4gICAgICAgICAgcmV0dXJuICd7Li4ufSc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnNwZWN0X2lkc1toYXNoX2lkXSA9IHRydWU7XHJcblxyXG4gICAgICAgICRoYXNoX2VhY2goc2VsZiwgZmFsc2UsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgIHZhbHVlID0gI3tPcGFsLmluc3BlY3QoYHZhbHVlYCl9XHJcbiAgICAgICAgICBrZXkgPSAje09wYWwuaW5zcGVjdChga2V5YCl9XHJcblxyXG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5ICsgJz0+JyArIHZhbHVlKTtcclxuICAgICAgICAgIHJldHVybiBbZmFsc2UsIGZhbHNlXTtcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICByZXR1cm4gJ3snICsgcmVzdWx0LmpvaW4oJywgJykgKyAnfSc7XHJcbiAgICAgIH1cclxuICAgICAgbmlsXHJcbiAgICBlbnN1cmVcclxuICAgICAgYGlmICh0b3ApIGluc3BlY3RfaWRzID0gdW5kZWZpbmVkYFxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBpbnZlcnRcclxuICAgICV4e1xyXG4gICAgICB2YXIgaGFzaCA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgIHJldHVybiAkaGFzaF9lYWNoKHNlbGYsIGhhc2gsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAkaGFzaF9wdXQoaGFzaCwgdmFsdWUsIGtleSk7XHJcbiAgICAgICAgcmV0dXJuIFtmYWxzZSwgaGFzaF07XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYga2VlcF9pZigmYmxvY2spXHJcbiAgICByZXR1cm4gZW51bV9mb3IoOmtlZXBfaWYpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xyXG5cclxuICAgICV4e1xyXG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xyXG5cclxuICAgICAgcmV0dXJuICRoYXNoX2VhY2goc2VsZiwgc2VsZiwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcclxuXHJcbiAgICAgICAgaWYgKG9iaiA9PT0gZmFsc2UgfHwgb2JqID09PSBuaWwpIHtcclxuICAgICAgICAgICRoYXNoX2RlbGV0ZShzZWxmLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW2ZhbHNlLCBzZWxmXTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBrZXlzXHJcbiAgICBgQXJyYXkuZnJvbShzZWxmLmtleXMoKSlgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBsZW5ndGhcclxuICAgIGBzZWxmLnNpemVgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBtZXJnZSgqb3RoZXJzLCAmYmxvY2spXHJcbiAgICBkdXAubWVyZ2UhKCpvdGhlcnMsICZibG9jaylcclxuICBlbmRcclxuXHJcbiAgZGVmIG1lcmdlISgqb3RoZXJzLCAmYmxvY2spXHJcbiAgICAleHtcclxuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcclxuXHJcbiAgICAgIHZhciBpLCBqLCBvdGhlcjtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IG90aGVycy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIG90aGVyID0gI3s6Ok9wYWwuY29lcmNlX3RvIShgb3RoZXJzW2ldYCwgOjpIYXNoLCA6dG9faGFzaCl9O1xyXG5cclxuICAgICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xyXG4gICAgICAgICAgJGhhc2hfZWFjaChvdGhlciwgZmFsc2UsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgJGhhc2hfcHV0KHNlbGYsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gW2ZhbHNlLCBmYWxzZV07XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgJGhhc2hfZWFjaChvdGhlciwgZmFsc2UsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHZhbCA9ICRoYXNoX2dldChzZWxmLCBrZXkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgJGhhc2hfcHV0KHNlbGYsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgIHJldHVybiBbZmFsc2UsIGZhbHNlXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgJGhhc2hfcHV0KHNlbGYsIGtleSwgYmxvY2soa2V5LCB2YWwsIHZhbHVlKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBbZmFsc2UsIGZhbHNlXTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiByYXNzb2Mob2JqZWN0KVxyXG4gICAgJXh7XHJcbiAgICAgIHZhciBlbnRyeTtcclxuICAgICAgZm9yIChlbnRyeSBvZiBzZWxmKSB7XHJcbiAgICAgICAgaWYgKCN7YGVudHJ5WzFdYCA9PSBvYmplY3R9KSB7XHJcbiAgICAgICAgICByZXR1cm4gW2VudHJ5WzBdLCBlbnRyeVsxXV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuaWw7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiByZWhhc2hcclxuICAgICV4e1xyXG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xyXG4gICAgICByZXR1cm4gT3BhbC5oYXNoX3JlaGFzaChzZWxmKTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHJlamVjdCgmYmxvY2spXHJcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXHJcblxyXG4gICAgJXh7XHJcbiAgICAgIHZhciBoYXNoID0gbmV3IE1hcCgpO1xyXG5cclxuICAgICAgc2VsZi5mb3JFYWNoKCh2YWx1ZSwga2V5LCBzKSA9PiB7XHJcbiAgICAgICAgdmFyIG9iaiA9IGJsb2NrKGtleSwgdmFsdWUpO1xyXG5cclxuICAgICAgICBpZiAob2JqID09PSBmYWxzZSB8fCBvYmogPT09IG5pbCkge1xyXG4gICAgICAgICAgJGhhc2hfcHV0KGhhc2gsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gaGFzaDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHJlamVjdCEoJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZWplY3QhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcclxuXHJcbiAgICAleHtcclxuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcclxuXHJcbiAgICAgIHZhciByZXN1bHQgPSBuaWw7XHJcblxyXG4gICAgICByZXR1cm4gJGhhc2hfZWFjaChzZWxmLCByZXN1bHQsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgb2JqID0gYmxvY2soa2V5LCB2YWx1ZSk7XHJcblxyXG4gICAgICAgIGlmIChvYmogIT09IGZhbHNlICYmIG9iaiAhPT0gbmlsKSB7XHJcbiAgICAgICAgICAkaGFzaF9kZWxldGUoc2VsZiwga2V5KTtcclxuICAgICAgICAgIHJlc3VsdCA9IHNlbGY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbZmFsc2UsIHJlc3VsdF07XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgcmVwbGFjZShvdGhlcilcclxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO2BcclxuXHJcbiAgICBvdGhlciA9IDo6T3BhbC5jb2VyY2VfdG8hKG90aGVyLCA6Okhhc2gsIDp0b19oYXNoKVxyXG5cclxuICAgICV4e1xyXG4gICAgICBzZWxmLiRjbGVhcigpO1xyXG5cclxuICAgICAgJGhhc2hfZWFjaChvdGhlciwgZmFsc2UsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAkaGFzaF9wdXQoc2VsZiwga2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIFtmYWxzZSwgZmFsc2VdO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiBvdGhlci5kZWZhdWx0X3Byb2NcclxuICAgICAgc2VsZi5kZWZhdWx0X3Byb2MgPSBvdGhlci5kZWZhdWx0X3Byb2NcclxuICAgIGVsc2VcclxuICAgICAgc2VsZi5kZWZhdWx0ID0gb3RoZXIuZGVmYXVsdFxyXG4gICAgZW5kXHJcblxyXG4gICAgc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgc2VsZWN0KCZibG9jaylcclxuICAgIHJldHVybiBlbnVtX2Zvcig6c2VsZWN0KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcclxuXHJcbiAgICAleHtcclxuICAgICAgdmFyIGhhc2ggPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgICBzZWxmLmZvckVhY2goKHZhbHVlLCBrZXksIHMpID0+IHtcclxuICAgICAgICB2YXIgb2JqID0gYmxvY2soa2V5LCB2YWx1ZSk7XHJcblxyXG4gICAgICAgIGlmIChvYmogIT09IGZhbHNlICYmIG9iaiAhPT0gbmlsKSB7XHJcbiAgICAgICAgICAkaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiBoYXNoO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc2VsZWN0ISgmYmxvY2spXHJcbiAgICByZXR1cm4gZW51bV9mb3IoOnNlbGVjdCEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xyXG5cclxuICAgICV4e1xyXG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xyXG5cclxuICAgICAgdmFyIHJlc3VsdCA9IG5pbDtcclxuXHJcbiAgICAgIHJldHVybiAkaGFzaF9lYWNoKHNlbGYsIHJlc3VsdCwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcclxuXHJcbiAgICAgICAgaWYgKG9iaiA9PT0gZmFsc2UgfHwgb2JqID09PSBuaWwpIHtcclxuICAgICAgICAgICRoYXNoX2RlbGV0ZShzZWxmLCBrZXkpO1xyXG4gICAgICAgICAgcmVzdWx0ID0gc2VsZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtmYWxzZSwgcmVzdWx0XTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzaGlmdFxyXG4gICAgJXh7XHJcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XHJcblxyXG4gICAgICByZXR1cm4gJGhhc2hfZWFjaChzZWxmLCBuaWwsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gW3RydWUsIFtrZXksICRoYXNoX2RlbGV0ZShzZWxmLCBrZXkpXV07XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc2xpY2UoKmtleXMpXHJcbiAgICAleHtcclxuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV0sIHZhbHVlID0gJGhhc2hfZ2V0KHNlbGYsIGtleSk7XHJcblxyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAkaGFzaF9wdXQocmVzdWx0LCBrZXksIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiB0b19hXHJcbiAgICBgQXJyYXkuZnJvbShzZWxmKWBcclxuICBlbmRcclxuXHJcbiAgZGVmIHRvX2goJmJsb2NrKVxyXG4gICAgcmV0dXJuIG1hcCgmYmxvY2spLnRvX2ggaWYgYmxvY2tfZ2l2ZW4/XHJcblxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChzZWxmLiQkY2xhc3MgPT09IE9wYWwuSGFzaCkge1xyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgaGFzaCA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgICRoYXNoX2Nsb25lKHNlbGYsIGhhc2gpO1xyXG5cclxuICAgICAgcmV0dXJuIGhhc2g7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiB0b19oYXNoXHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiB0b19wcm9jXHJcbiAgICBwcm9jIGRvIHxrZXkgPSB1bmRlZmluZWR8XHJcbiAgICAgICV4e1xyXG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdubyBrZXkgZ2l2ZW4nfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgc2VsZltrZXldXHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmIHRyYW5zZm9ybV9rZXlzKGtleXNfaGFzaCA9IG5pbCwgJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVudW1fZm9yKDp0cmFuc2Zvcm1fa2V5cykgeyBzaXplIH0gaWYgIWJsb2NrICYmICFrZXlzX2hhc2hcclxuXHJcbiAgICAleHtcclxuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgIHNlbGYuZm9yRWFjaCgodmFsdWUsIGtleSwgcykgPT4ge1xyXG4gICAgICAgIHZhciBuZXdfa2V5O1xyXG4gICAgICAgIGlmIChrZXlzX2hhc2ggIT09IG5pbClcclxuICAgICAgICAgIG5ld19rZXkgPSAkaGFzaF9nZXQoa2V5c19oYXNoLCBrZXkpO1xyXG4gICAgICAgIGlmIChuZXdfa2V5ID09PSB1bmRlZmluZWQgJiYgYmxvY2sgJiYgYmxvY2sgIT09IG5pbClcclxuICAgICAgICAgIG5ld19rZXkgPSBibG9jayhrZXkpO1xyXG4gICAgICAgIGlmIChuZXdfa2V5ID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICBuZXdfa2V5ID0ga2V5IC8vIGtleSBub3QgbW9kaWZpZWRcclxuICAgICAgICAkaGFzaF9wdXQocmVzdWx0LCBuZXdfa2V5LCB2YWx1ZSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHRyYW5zZm9ybV9rZXlzIShrZXlzX2hhc2ggPSBuaWwsICZibG9jaylcclxuICAgIHJldHVybiBlbnVtX2Zvcig6dHJhbnNmb3JtX2tleXMhKSB7IHNpemUgfSBpZiAhYmxvY2sgJiYgIWtleXNfaGFzaFxyXG5cclxuICAgICV4e1xyXG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xyXG5cclxuICAgICAgdmFyIG1vZGlmaWVkX2tleXMgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgICByZXR1cm4gJGhhc2hfZWFjaChzZWxmLCBzZWxmLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIG5ld19rZXk7XHJcbiAgICAgICAgaWYgKGtleXNfaGFzaCAhPT0gbmlsKVxyXG4gICAgICAgICAgbmV3X2tleSA9ICRoYXNoX2dldChrZXlzX2hhc2gsIGtleSk7XHJcbiAgICAgICAgaWYgKG5ld19rZXkgPT09IHVuZGVmaW5lZCAmJiBibG9jayAmJiBibG9jayAhPT0gbmlsKVxyXG4gICAgICAgICAgbmV3X2tleSA9IGJsb2NrKGtleSk7XHJcbiAgICAgICAgaWYgKG5ld19rZXkgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgIHJldHVybiBbZmFsc2UsIHNlbGZdOyAvLyBrZXkgbm90IG1vZGlmaWVkXHJcbiAgICAgICAgaWYgKCEkaGFzaF9nZXQobW9kaWZpZWRfa2V5cywga2V5KSlcclxuICAgICAgICAgICRoYXNoX2RlbGV0ZShzZWxmLCBrZXkpO1xyXG4gICAgICAgICRoYXNoX3B1dChzZWxmLCBuZXdfa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgJGhhc2hfcHV0KG1vZGlmaWVkX2tleXMsIG5ld19rZXksIHRydWUpXHJcbiAgICAgICAgcmV0dXJuIFtmYWxzZSwgc2VsZl07XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgdHJhbnNmb3JtX3ZhbHVlcygmYmxvY2spXHJcbiAgICByZXR1cm4gZW51bV9mb3IoOnRyYW5zZm9ybV92YWx1ZXMpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xyXG5cclxuICAgICV4e1xyXG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IE1hcCgpO1xyXG5cclxuICAgICAgc2VsZi5mb3JFYWNoKCh2YWx1ZSwga2V5LCBzKSA9PiAkaGFzaF9wdXQocmVzdWx0LCBrZXksIGJsb2NrKHZhbHVlKSkpO1xyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHRyYW5zZm9ybV92YWx1ZXMhKCZibG9jaylcclxuICAgIHJldHVybiBlbnVtX2Zvcig6dHJhbnNmb3JtX3ZhbHVlcyEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xyXG5cclxuICAgICV4e1xyXG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xyXG5cclxuICAgICAgcmV0dXJuICRoYXNoX2VhY2goc2VsZiwgc2VsZiwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICRoYXNoX3B1dChzZWxmLCBrZXksIGJsb2NrKHZhbHVlKSk7XHJcbiAgICAgICAgcmV0dXJuIFtmYWxzZSwgc2VsZl07XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgdmFsdWVzXHJcbiAgICBgQXJyYXkuZnJvbShzZWxmLnZhbHVlcygpKWBcclxuICBlbmRcclxuXHJcbiAgYWxpYXMgZWFjaF9wYWlyIGVhY2hcclxuICBhbGlhcyBlcWw/ID09XHJcbiAgYWxpYXMgZmlsdGVyIHNlbGVjdFxyXG4gIGFsaWFzIGZpbHRlciEgc2VsZWN0IVxyXG4gIGFsaWFzIGluY2x1ZGU/IGhhc19rZXk/XHJcbiAgYWxpYXMgaW5kaWNlcyBpbmRleGVzXHJcbiAgYWxpYXMga2V5IGluZGV4XHJcbiAgYWxpYXMga2V5PyBoYXNfa2V5P1xyXG4gIGFsaWFzIG1lbWJlcj8gaGFzX2tleT9cclxuICBhbGlhcyBzaXplIGxlbmd0aFxyXG4gIGFsaWFzIHN0b3JlIFtdPVxyXG4gIGFsaWFzIHRvX3MgaW5zcGVjdFxyXG4gIGFsaWFzIHVwZGF0ZSBtZXJnZSFcclxuICBhbGlhcyB2YWx1ZT8gaGFzX3ZhbHVlP1xyXG4gIGFsaWFzIHZhbHVlc19hdCBpbmRleGVzXHJcbmVuZFxyXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOkhhc2g+IiwiaW5jbHVkZSIsIkVudW1lcmFibGUiLCJbXSIsIk9wYWwiLCJjb2VyY2VfdG8/IiwiYXJndiIsIjAiLCJIYXNoIiwiYWxsb2NhdGUiLCJtZXJnZSEiLCJBcnJheSIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsImluc3BlY3QiLCJ0cnlfY29udmVydCIsIm9iaiIsImluaXRpYWxpemUiLCJkZWZhdWx0cyIsIj09Iiwib3RoZXIiLCI+PSIsImNvZXJjZV90byEiLCJyZXN1bHQiLCJlYWNoIiwiYmxvY2sgaW4gPj0iLCJvdGhlcl9rZXkiLCJvdGhlcl92YWwiLCJibG9jayAoMiBsZXZlbHMpIGluID49IiwidmFsIiwiZmV0Y2giLCI+IiwiPCIsIjw9Iiwia2V5IiwiW109IiwidmFsdWUiLCJhc3NvYyIsIm9iamVjdCIsImNsZWFyIiwiY2xvbmUiLCJjb21wYWN0IiwiY29tcGFjdCEiLCJjb21wYXJlX2J5X2lkZW50aXR5IiwiY29tcGFyZV9ieV9pZGVudGl0eT8iLCJkZWZhdWx0IiwiZGVmYXVsdD0iLCJkZWZhdWx0X3Byb2MiLCJkZWZhdWx0X3Byb2M9IiwiUHJvYyIsImxhbWJkYT8iLCJhcml0eSIsImFicyIsIlR5cGVFcnJvciIsImRlbGV0ZSIsImRlbGV0ZV9pZiIsImJsb2NrIiwiZW51bV9mb3IiLCJibG9jayBpbiBkZWxldGVfaWYiLCJibG9jayAoMiBsZXZlbHMpIGluIGRlbGV0ZV9pZiIsInNpemUiLCJkaWciLCJpdGVtIiwicmVzcG9uZF90bz8iLCJjbGFzcyIsImtleXMiLCJkdXAiLCJibG9jayBpbiBlYWNoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoIiwiZWFjaF9rZXkiLCJibG9jayBpbiBlYWNoX2tleSIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF9rZXkiLCJlYWNoX3ZhbHVlIiwiYmxvY2sgaW4gZWFjaF92YWx1ZSIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF92YWx1ZSIsImVtcHR5PyIsImV4Y2VwdCIsImV4Y2VwdCEiLCJibG9jayBpbiBleGNlcHQhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBleGNlcHQhIiwiS2V5RXJyb3IiLCJuZXciLCJmZXRjaF92YWx1ZXMiLCJtYXAiLCJibG9jayBpbiBmZXRjaF92YWx1ZXMiLCJibG9jayAoMiBsZXZlbHMpIGluIGZldGNoX3ZhbHVlcyIsInRvX3Byb2MiLCJmbGF0dGVuIiwibGV2ZWwiLCIxIiwiSW50ZWdlciIsImZyZWV6ZSIsImZyb3plbj8iLCJoYXNfa2V5PyIsImhhc192YWx1ZT8iLCJoYXNoIiwiZXFsPyIsImluZGV4IiwiaW5kZXhlcyIsImludmVydCIsImtlZXBfaWYiLCJibG9jayBpbiBrZWVwX2lmIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBrZWVwX2lmIiwibGVuZ3RoIiwibWVyZ2UiLCJvdGhlcnMiLCJyYXNzb2MiLCJyZWhhc2giLCJyZWplY3QiLCJibG9jayBpbiByZWplY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIHJlamVjdCIsInJlamVjdCEiLCJibG9jayBpbiByZWplY3QhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWplY3QhIiwicmVwbGFjZSIsInNlbGVjdCIsImJsb2NrIGluIHNlbGVjdCIsImJsb2NrICgyIGxldmVscykgaW4gc2VsZWN0Iiwic2VsZWN0ISIsImJsb2NrIGluIHNlbGVjdCEiLCJibG9jayAoMiBsZXZlbHMpIGluIHNlbGVjdCEiLCJzaGlmdCIsInNsaWNlIiwidG9fYSIsInRvX2giLCJibG9ja19naXZlbj8iLCJ0b19oYXNoIiwicHJvYyIsImJsb2NrIGluIHRvX3Byb2MiLCJibG9jayAoMiBsZXZlbHMpIGluIHRvX3Byb2MiLCJ0cmFuc2Zvcm1fa2V5cyIsImtleXNfaGFzaCIsImJsb2NrIGluIHRyYW5zZm9ybV9rZXlzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0cmFuc2Zvcm1fa2V5cyIsInRyYW5zZm9ybV9rZXlzISIsImJsb2NrIGluIHRyYW5zZm9ybV9rZXlzISIsImJsb2NrICgyIGxldmVscykgaW4gdHJhbnNmb3JtX2tleXMhIiwidHJhbnNmb3JtX3ZhbHVlcyIsImJsb2NrIGluIHRyYW5zZm9ybV92YWx1ZXMiLCJibG9jayAoMiBsZXZlbHMpIGluIHRyYW5zZm9ybV92YWx1ZXMiLCJ0cmFuc2Zvcm1fdmFsdWVzISIsImJsb2NrIGluIHRyYW5zZm9ybV92YWx1ZXMhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0cmFuc2Zvcm1fdmFsdWVzISIsInZhbHVlcyJdLCJtYXBwaW5ncyI6IkFBQUFBLCtCQUFBQSxnQkFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBOztFQUlBQyxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFRQUYsT0FBQUc7RUFBQUE7O0lBQUFBOzs7SUFDRUYsSUFBQUcsU0FBQUEsQ0FBUUMsaUJBQVJEO0lBR0NEO0lBRURHLE1BQUlMLElBQUpLLFNBQUFBLG9CQWxCRixFQWtCRUE7QUFBQUEsTUFBQUE7OztNQWxCRjtNQWtCYzs7QUFFZEE7O0FBRUFBO0FBQ0FBLGVBQWlCQyxLQUFNQyxlQUFBQSxDQUFZQyxJQUFJSCxPQUFBQSxDQUFDSSxDQUFESixDQUF0QixFQUEyQkssV0FBM0IsRUFBbUMsU0FBN0JILENBQXVDRjtBQUM5REE7QUFDQUEsaUJBQW1CTCxJQUFBVyxVQUFBQSxDQUFBQSxDQUFRQyxXQUFBQSxDQUFTUCxJQUFUTyxDQUFnQlA7QUFDM0NBOztBQUVBQSxlQUFpQkMsS0FBTUMsZUFBQUEsQ0FBWUMsSUFBSUgsT0FBQUEsQ0FBQ0ksQ0FBREosQ0FBdEIsRUFBMkJRLFlBQTNCLEVBQW9DLFFBQTlCTixDQUF1Q0Y7QUFDOURBO0FBQ0FBLFVBQVlTLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWdDWCxrQ0FBeEJVLENBQTJEVjtBQUMvRUE7O0FBRUFBO0FBQ0FBLGVBQWlCTCxJQUFBVyxVQUFBQSxDQUFBQSxDQUFTTjs7QUFFMUJBO0FBQ0FBO0FBQ0FBO0FBQ0FBLFlBQWNTLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWlDWCxrQkFBRCxHQUFBLE1BQW1CQSxDQUFDQSxHQUFEQSxDQUFLWSxTQUFBQSxDQUFBQSxDQUF4QixDQUFBLEdBQWlDWixXQUF6RFUsQ0FBb0VWO0FBQzFGQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSxZQUFjUyxPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFpQ1gsOEJBQUQsR0FBQSxNQUFn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QUFBQSxTQUFBQSxDQUFBcEY7TUFBUDs7QUFHSm1GOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQVZFQSxDQUFBQTs7QUFhQUcsSUFBQUEsc0JBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EseUJBQURBO0lBREZBLENBQUFBO0lBSUEsYUFBTSxXQUFOLEVBQWdCLE1BQWhCO0lBQ0EsYUFBTSxNQUFOLEVBQVcsSUFBWDtJQUNBLGFBQU0sUUFBTixFQUFhLFFBQWI7SUFDQSxhQUFNLFNBQU4sRUFBYyxTQUFkO0lBQ0EsYUFBTSxVQUFOLEVBQWUsVUFBZjtJQUNBLGFBQU0sU0FBTixFQUFjLFNBQWQ7SUFDQSxhQUFNLEtBQU4sRUFBVSxPQUFWO0lBQ0EsYUFBTSxNQUFOLEVBQVcsVUFBWDtJQUNBLGFBQU0sU0FBTixFQUFjLFVBQWQ7SUFDQSxhQUFNLE1BQU4sRUFBVyxRQUFYO0lBQ0EsYUFBTSxPQUFOLEVBQVksS0FBWjtJQUNBLGFBQU0sTUFBTixFQUFXLFNBQVg7SUFDQSxhQUFNLFFBQU4sRUFBYSxRQUFiO0lBQ0EsYUFBTSxRQUFOLEVBQWEsWUFBYjtJQUNBaEosT0FBQSxhQUFNLFdBQU4sRUFBZ0IsU0FBaEI7RUEvNkJGQSxHQUFNLElBQU5BLEVBQWdCSCxHQUFoQkc7QUFaQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE4MDk3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9udW1iZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXHJcbiMgdXNlX3N0cmljdDogdHJ1ZVxyXG5cclxucmVxdWlyZSAnY29yZWxpYi9udW1lcmljJ1xyXG5cclxuY2xhc3MgOjpOdW1iZXIgPCA6Ok51bWVyaWNcclxuICA6Ok9wYWwuYnJpZGdlKGBOdW1iZXJgLCBzZWxmKVxyXG4gIGBPcGFsLnByb3Aoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfbnVtYmVyJywgdHJ1ZSlgXHJcbiAgYHNlbGYuJCRpc19udW1iZXJfY2xhc3MgPSB0cnVlYFxyXG4gIGB2YXIgbnVtYmVyX2lkX21hcCA9IG5ldyBNYXAoKWBcclxuXHJcbiAgY2xhc3MgPDwgc2VsZlxyXG4gICAgZGVmIGFsbG9jYXRlXHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxyXG4gICAgZW5kXHJcblxyXG4gICAgdW5kZWYgOm5ld1xyXG4gIGVuZFxyXG5cclxuICBkZWYgY29lcmNlKG90aGVyKVxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChvdGhlciA9PT0gbmlsKSB7XHJcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7b3RoZXIuY2xhc3N9IGludG8gRmxvYXRcIn07XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAob3RoZXIuJCRpc19zdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gWyN7OjpLZXJuZWwuRmxvYXQob3RoZXIpfSwgc2VsZl07XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoI3tvdGhlci5yZXNwb25kX3RvPyg6dG9fZil9KSB7XHJcbiAgICAgICAgcmV0dXJuIFsjezo6T3BhbC5jb2VyY2VfdG8hKG90aGVyLCA6OkZsb2F0LCA6dG9fZil9LCBzZWxmXTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmIChvdGhlci4kJGlzX251bWJlcikge1xyXG4gICAgICAgIHJldHVybiBbb3RoZXIsIHNlbGZdO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCAje290aGVyLmNsYXNzfSBpbnRvIEZsb2F0XCJ9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBfX2lkX19cclxuICAgICV4e1xyXG4gICAgICAvLyBCaW5hcnktc2FmZSBpbnRlZ2Vyc1xyXG4gICAgICBpZiAoc2VsZnwwID09PSBzZWxmKSB7XHJcbiAgICAgICAgcmV0dXJuIChzZWxmICogMikgKyAxO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChudW1iZXJfaWRfbWFwLmhhcyhzZWxmKSkge1xyXG4gICAgICAgICAgcmV0dXJuIG51bWJlcl9pZF9tYXAuZ2V0KHNlbGYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaWQgPSBPcGFsLnVpZCgpO1xyXG4gICAgICAgIG51bWJlcl9pZF9tYXAuc2V0KHNlbGYsIGlkKTtcclxuICAgICAgICByZXR1cm4gaWQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGhhc2hcclxuICAgICV4e1xyXG4gICAgICAvLyBCaW5hcnktc2FmZSBpbnRlZ2Vyc1xyXG4gICAgICBpZiAoc2VsZnwwID09PSBzZWxmKSB7XHJcbiAgICAgICAgcmV0dXJuICN7X19pZF9ffVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBzZWxmLnRvU3RyaW5nKCkuJGhhc2goKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgKyhvdGhlcilcclxuICAgICV4e1xyXG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gc2VsZiArIG90aGVyO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDorLCBvdGhlcn07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIC0ob3RoZXIpXHJcbiAgICAleHtcclxuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGYgLSBvdGhlcjtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6LSwgb3RoZXJ9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiAqKG90aGVyKVxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xyXG4gICAgICAgIHJldHVybiBzZWxmICogb3RoZXI7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOiosIG90aGVyfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgLyhvdGhlcilcclxuICAgICV4e1xyXG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gc2VsZiAvIG90aGVyO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDovLCBvdGhlcn07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmICUob3RoZXIpXHJcbiAgICAleHtcclxuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XHJcbiAgICAgICAgaWYgKG90aGVyID09IC1JbmZpbml0eSkge1xyXG4gICAgICAgICAgcmV0dXJuIG90aGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvdGhlciA9PSAwKSB7XHJcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6WmVyb0RpdmlzaW9uRXJyb3IsICdkaXZpZGVkIGJ5IDAnfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3RoZXIgPCAwIHx8IHNlbGYgPCAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gKHNlbGYgJSBvdGhlciArIG90aGVyKSAlIG90aGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiBzZWxmICUgb3RoZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDolLCBvdGhlcn07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmICYob3RoZXIpXHJcbiAgICAleHtcclxuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGYgJiBvdGhlcjtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Jiwgb3RoZXJ9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiB8KG90aGVyKVxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xyXG4gICAgICAgIHJldHVybiBzZWxmIHwgb3RoZXI7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOnwsIG90aGVyfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgXihvdGhlcilcclxuICAgICV4e1xyXG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gc2VsZiBeIG90aGVyO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDpeLCBvdGhlcn07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIDwob3RoZXIpXHJcbiAgICAleHtcclxuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGYgPCBvdGhlcjtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6PCwgb3RoZXJ9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiA8PShvdGhlcilcclxuICAgICV4e1xyXG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gc2VsZiA8PSBvdGhlcjtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6PD0sIG90aGVyfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgPihvdGhlcilcclxuICAgICV4e1xyXG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gc2VsZiA+IG90aGVyO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDo+LCBvdGhlcn07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmID49KG90aGVyKVxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xyXG4gICAgICAgIHJldHVybiBzZWxmID49IG90aGVyO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDo+PSwgb3RoZXJ9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gICMgQ29tcHV0ZSB0aGUgcmVzdWx0IG9mIHRoZSBzcGFjZXNoaXAgb3BlcmF0b3IgaW5zaWRlIGl0cyBvd24gZnVuY3Rpb24gc28gaXRcclxuICAjIGNhbiBiZSBvcHRpbWl6ZWQgZGVzcGl0ZSBhIHRyeS9maW5hbGx5IGNvbnN0cnVjdC5cclxuICAleHtcclxuICAgIHZhciBzcGFjZXNoaXBfb3BlcmF0b3IgPSBmdW5jdGlvbihzZWxmLCBvdGhlcikge1xyXG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcclxuICAgICAgICBpZiAoaXNOYU4oc2VsZikgfHwgaXNOYU4ob3RoZXIpKSB7XHJcbiAgICAgICAgICByZXR1cm4gbmlsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNlbGYgPiBvdGhlcikge1xyXG4gICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzZWxmIDwgb3RoZXIpIHtcclxuICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDo8PT4sIGBvdGhlcmB9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkZWYgPD0+KG90aGVyKVxyXG4gICAgYHNwYWNlc2hpcF9vcGVyYXRvcihzZWxmLCBvdGhlcilgXHJcbiAgcmVzY3VlIDo6QXJndW1lbnRFcnJvclxyXG4gICAgbmlsXHJcbiAgZW5kXHJcblxyXG4gIGRlZiA8PChjb3VudClcclxuICAgIGNvdW50ID0gOjpPcGFsLmNvZXJjZV90byEgY291bnQsIDo6SW50ZWdlciwgOnRvX2ludFxyXG5cclxuICAgIGAje2NvdW50fSA+IDAgPyBzZWxmIDw8ICN7Y291bnR9IDogc2VsZiA+PiAtI3tjb3VudH1gXHJcbiAgZW5kXHJcblxyXG4gIGRlZiA+Pihjb3VudClcclxuICAgIGNvdW50ID0gOjpPcGFsLmNvZXJjZV90byEgY291bnQsIDo6SW50ZWdlciwgOnRvX2ludFxyXG5cclxuICAgIGAje2NvdW50fSA+IDAgPyBzZWxmID4+ICN7Y291bnR9IDogc2VsZiA8PCAtI3tjb3VudH1gXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBbXShiaXQpXHJcbiAgICBiaXQgPSA6Ok9wYWwuY29lcmNlX3RvISBiaXQsIDo6SW50ZWdlciwgOnRvX2ludFxyXG5cclxuICAgICV4e1xyXG4gICAgICBpZiAoI3tiaXR9IDwgMCkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICgje2JpdH0gPj0gMzIpIHtcclxuICAgICAgICByZXR1cm4gI3sgc2VsZiB9IDwgMCA/IDEgOiAwO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAoc2VsZiA+PiAje2JpdH0pICYgMTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmICtAXHJcbiAgICBgK3NlbGZgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiAtQFxyXG4gICAgYC1zZWxmYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgflxyXG4gICAgYH5zZWxmYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgKioob3RoZXIpXHJcbiAgICBpZiA6OkludGVnZXIgPT09IG90aGVyXHJcbiAgICAgIGlmICEoOjpJbnRlZ2VyID09PSBzZWxmKSB8fCBvdGhlciA+IDBcclxuICAgICAgICBgTWF0aC5wb3coc2VsZiwgb3RoZXIpYFxyXG4gICAgICBlbHNlXHJcbiAgICAgICAgOjpSYXRpb25hbC5uZXcoc2VsZiwgMSkqKm90aGVyXHJcbiAgICAgIGVuZFxyXG4gICAgZWxzaWYgc2VsZiA8IDAgJiYgKDo6RmxvYXQgPT09IG90aGVyIHx8IDo6UmF0aW9uYWwgPT09IG90aGVyKVxyXG4gICAgICA6OkNvbXBsZXgubmV3KHNlbGYsIDApKipvdGhlci50b19mXHJcbiAgICBlbHNpZiBgb3RoZXIuJCRpc19udW1iZXIgIT0gbnVsbGBcclxuICAgICAgYE1hdGgucG93KHNlbGYsIG90aGVyKWBcclxuICAgIGVsc2VcclxuICAgICAgX19jb2VyY2VkX18gOioqLCBvdGhlclxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiA9PShvdGhlcilcclxuICAgICV4e1xyXG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gc2VsZi52YWx1ZU9mKCkgPT09IG90aGVyLnZhbHVlT2YoKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICgje290aGVyLnJlc3BvbmRfdG8/IDo9PX0pIHtcclxuICAgICAgICByZXR1cm4gI3tvdGhlciA9PSBzZWxmfTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgYWxpYXMgPT09ID09XHJcblxyXG4gIGRlZiBhYnNcclxuICAgIGBNYXRoLmFicyhzZWxmKWBcclxuICBlbmRcclxuXHJcbiAgZGVmIGFiczJcclxuICAgIGBNYXRoLmFicyhzZWxmICogc2VsZilgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBhbGxiaXRzPyhtYXNrKVxyXG4gICAgbWFzayA9IDo6T3BhbC5jb2VyY2VfdG8hIG1hc2ssIDo6SW50ZWdlciwgOnRvX2ludFxyXG4gICAgYChzZWxmICYgbWFzaykgPT0gbWFza2BcclxuICBlbmRcclxuXHJcbiAgZGVmIGFueWJpdHM/KG1hc2spXHJcbiAgICBtYXNrID0gOjpPcGFsLmNvZXJjZV90byEgbWFzaywgOjpJbnRlZ2VyLCA6dG9faW50XHJcbiAgICBgKHNlbGYgJiBtYXNrKSAhPT0gMGBcclxuICBlbmRcclxuXHJcbiAgZGVmIGFuZ2xlXHJcbiAgICByZXR1cm4gc2VsZiBpZiBuYW4/XHJcblxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChzZWxmID09IDApIHtcclxuICAgICAgICBpZiAoMSAvIHNlbGYgPiAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gTWF0aC5QSTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoc2VsZiA8IDApIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5QSTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgYml0X2xlbmd0aFxyXG4gICAgdW5sZXNzIDo6SW50ZWdlciA9PT0gc2VsZlxyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6Ok5vTWV0aG9kRXJyb3IubmV3KFwidW5kZWZpbmVkIG1ldGhvZCBgYml0X2xlbmd0aGAgZm9yICN7c2VsZn06RmxvYXRcIiwgJ2JpdF9sZW5ndGgnKVxyXG4gICAgZW5kXHJcblxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChzZWxmID09PSAwIHx8IHNlbGYgPT09IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciByZXN1bHQgPSAwLFxyXG4gICAgICAgICAgdmFsdWUgID0gc2VsZiA8IDAgPyB+c2VsZiA6IHNlbGY7XHJcblxyXG4gICAgICB3aGlsZSAodmFsdWUgIT0gMCkge1xyXG4gICAgICAgIHJlc3VsdCAgICs9IDE7XHJcbiAgICAgICAgdmFsdWUgID4+Pj0gMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGNlaWwobmRpZ2l0cyA9IDApXHJcbiAgICAleHtcclxuICAgICAgdmFyIGYgPSAje3RvX2Z9O1xyXG5cclxuICAgICAgaWYgKGYgJSAxID09PSAwICYmIG5kaWdpdHMgPj0gMCkge1xyXG4gICAgICAgIHJldHVybiBmO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgZmFjdG9yID0gTWF0aC5wb3coMTAsIG5kaWdpdHMpLFxyXG4gICAgICAgICAgcmVzdWx0ID0gTWF0aC5jZWlsKGYgKiBmYWN0b3IpIC8gZmFjdG9yO1xyXG5cclxuICAgICAgaWYgKGYgJSAxID09PSAwKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gTWF0aC5yb3VuZChyZXN1bHQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgY2hyKGVuY29kaW5nID0gdW5kZWZpbmVkKVxyXG4gICAgYE9wYWwuZW5jKFN0cmluZy5mcm9tQ29kZVBvaW50KHNlbGYpLCBlbmNvZGluZyB8fCBcIkJJTkFSWVwiKWBcclxuICBlbmRcclxuXHJcbiAgZGVmIGRlbm9taW5hdG9yXHJcbiAgICBpZiBuYW4/IHx8IGluZmluaXRlP1xyXG4gICAgICAxXHJcbiAgICBlbHNlXHJcbiAgICAgIHN1cGVyXHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmIGRvd250byhzdG9wLCAmYmxvY2spXHJcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XHJcbiAgICAgIHJldHVybiBlbnVtX2Zvcig6ZG93bnRvLCBzdG9wKSBkb1xyXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7c2VsZi5jbGFzc30gd2l0aCAje3N0b3AuY2xhc3N9IGZhaWxlZFwiIHVubGVzcyA6Ok51bWVyaWMgPT09IHN0b3BcclxuICAgICAgICBzdG9wID4gc2VsZiA/IDAgOiBzZWxmIC0gc3RvcCArIDFcclxuICAgICAgZW5kXHJcbiAgICBlbmRcclxuXHJcbiAgICAleHtcclxuICAgICAgaWYgKCFzdG9wLiQkaXNfbnVtYmVyKSB7XHJcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje3NlbGYuY2xhc3N9IHdpdGggI3tzdG9wLmNsYXNzfSBmYWlsZWRcIn1cclxuICAgICAgfVxyXG4gICAgICBmb3IgKHZhciBpID0gc2VsZjsgaSA+PSBzdG9wOyBpLS0pIHtcclxuICAgICAgICBibG9jayhpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNlbGZcclxuICBlbmRcclxuXHJcbiAgZGVmIGVxdWFsPyhvdGhlcilcclxuICAgIHNlbGYgPT0gb3RoZXIgfHwgYGlzTmFOKHNlbGYpICYmIGlzTmFOKG90aGVyKWBcclxuICBlbmRcclxuXHJcbiAgZGVmIGV2ZW4/XHJcbiAgICBgc2VsZiAlIDIgPT09IDBgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBmbG9vcihuZGlnaXRzID0gMClcclxuICAgICV4e1xyXG4gICAgICB2YXIgZiA9ICN7dG9fZn07XHJcblxyXG4gICAgICBpZiAoZiAlIDEgPT09IDAgJiYgbmRpZ2l0cyA+PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGY7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBmYWN0b3IgPSBNYXRoLnBvdygxMCwgbmRpZ2l0cyksXHJcbiAgICAgICAgICByZXN1bHQgPSBNYXRoLmZsb29yKGYgKiBmYWN0b3IpIC8gZmFjdG9yO1xyXG5cclxuICAgICAgaWYgKGYgJSAxID09PSAwKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gTWF0aC5yb3VuZChyZXN1bHQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZ2NkKG90aGVyKVxyXG4gICAgdW5sZXNzIDo6SW50ZWdlciA9PT0gb3RoZXJcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdub3QgYW4gaW50ZWdlcidcclxuICAgIGVuZFxyXG5cclxuICAgICV4e1xyXG4gICAgICB2YXIgbWluID0gTWF0aC5hYnMoc2VsZiksXHJcbiAgICAgICAgICBtYXggPSBNYXRoLmFicyhvdGhlcik7XHJcblxyXG4gICAgICB3aGlsZSAobWluID4gMCkge1xyXG4gICAgICAgIHZhciB0bXAgPSBtaW47XHJcblxyXG4gICAgICAgIG1pbiA9IG1heCAlIG1pbjtcclxuICAgICAgICBtYXggPSB0bXA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtYXg7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBnY2RsY20ob3RoZXIpXHJcbiAgICBbZ2NkKG90aGVyKSwgbGNtKG90aGVyKV1cclxuICBlbmRcclxuXHJcbiAgZGVmIGludGVnZXI/XHJcbiAgICBgc2VsZiAlIDEgPT09IDBgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBpc19hPyhrbGFzcylcclxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IDo6SW50ZWdlciAmJiA6OkludGVnZXIgPT09IHNlbGZcclxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IDo6SW50ZWdlciAmJiA6OkludGVnZXIgPT09IHNlbGZcclxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IDo6RmxvYXQgJiYgOjpGbG9hdCA9PT0gc2VsZlxyXG5cclxuICAgIHN1cGVyXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBpbnN0YW5jZV9vZj8oa2xhc3MpXHJcbiAgICByZXR1cm4gdHJ1ZSBpZiBrbGFzcyA9PSA6OkludGVnZXIgJiYgOjpJbnRlZ2VyID09PSBzZWxmXHJcbiAgICByZXR1cm4gdHJ1ZSBpZiBrbGFzcyA9PSA6OkludGVnZXIgJiYgOjpJbnRlZ2VyID09PSBzZWxmXHJcbiAgICByZXR1cm4gdHJ1ZSBpZiBrbGFzcyA9PSA6OkZsb2F0ICYmIDo6RmxvYXQgPT09IHNlbGZcclxuXHJcbiAgICBzdXBlclxyXG4gIGVuZFxyXG5cclxuICBkZWYgbGNtKG90aGVyKVxyXG4gICAgdW5sZXNzIDo6SW50ZWdlciA9PT0gb3RoZXJcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdub3QgYW4gaW50ZWdlcidcclxuICAgIGVuZFxyXG5cclxuICAgICV4e1xyXG4gICAgICBpZiAoc2VsZiA9PSAwIHx8IG90aGVyID09IDApIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5hYnMoc2VsZiAqIG90aGVyIC8gI3tnY2Qob3RoZXIpfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIG5leHRcclxuICAgIGBzZWxmICsgMWBcclxuICBlbmRcclxuXHJcbiAgZGVmIG5vYml0cz8obWFzaylcclxuICAgIG1hc2sgPSA6Ok9wYWwuY29lcmNlX3RvISBtYXNrLCA6OkludGVnZXIsIDp0b19pbnRcclxuICAgIGAoc2VsZiAmIG1hc2spID09IDBgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBub256ZXJvP1xyXG4gICAgYHNlbGYgPT0gMCA/IG5pbCA6IHNlbGZgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBudW1lcmF0b3JcclxuICAgIGlmIG5hbj8gfHwgaW5maW5pdGU/XHJcbiAgICAgIHNlbGZcclxuICAgIGVsc2VcclxuICAgICAgc3VwZXJcclxuICAgIGVuZFxyXG4gIGVuZFxyXG5cclxuICBkZWYgb2RkP1xyXG4gICAgYHNlbGYgJSAyICE9PSAwYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgb3JkXHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBwb3coYiwgbSA9IHVuZGVmaW5lZClcclxuICAgICV4e1xyXG4gICAgICBpZiAoc2VsZiA9PSAwKSB7XHJcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6Olplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSAwJ31cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiAje3NlbGYqKmJ9O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICghKCN7OjpJbnRlZ2VyID09PSBifSkpIHtcclxuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdJbnRlZ2VyI3BvdygpIDJuZCBhcmd1bWVudCBub3QgYWxsb3dlZCB1bmxlc3MgYSAxc3QgYXJndW1lbnQgaXMgaW50ZWdlcid9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYiA8IDApIHtcclxuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdJbnRlZ2VyI3BvdygpIDFzdCBhcmd1bWVudCBjYW5ub3QgYmUgbmVnYXRpdmUgd2hlbiAybmQgYXJndW1lbnQgc3BlY2lmaWVkJ31cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghKCN7OjpJbnRlZ2VyID09PSBtfSkpIHtcclxuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdJbnRlZ2VyI3BvdygpIDJuZCBhcmd1bWVudCBub3QgYWxsb3dlZCB1bmxlc3MgYWxsIGFyZ3VtZW50cyBhcmUgaW50ZWdlcnMnfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG0gPT09IDApIHtcclxuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpaZXJvRGl2aXNpb25FcnJvciwgJ2RpdmlkZWQgYnkgMCd9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gI3soc2VsZioqYikgJSBtfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBwcmVkXHJcbiAgICBgc2VsZiAtIDFgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBxdW8ob3RoZXIpXHJcbiAgICBpZiA6OkludGVnZXIgPT09IHNlbGZcclxuICAgICAgc3VwZXJcclxuICAgIGVsc2VcclxuICAgICAgc2VsZiAvIG90aGVyXHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmIHJhdGlvbmFsaXplKGVwcyA9IHVuZGVmaW5lZClcclxuICAgICV4e1xyXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcmd1bWVudHMubGVuZ3RoYH0gZm9yIDAuLjEpXCJ9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgOjpJbnRlZ2VyID09PSBzZWxmXHJcbiAgICAgIDo6UmF0aW9uYWwubmV3KHNlbGYsIDEpXHJcbiAgICBlbHNpZiBpbmZpbml0ZT9cclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpGbG9hdERvbWFpbkVycm9yLCAnSW5maW5pdHknXHJcbiAgICBlbHNpZiBuYW4/XHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6RmxvYXREb21haW5FcnJvciwgJ05hTidcclxuICAgIGVsc2lmIGBlcHMgPT0gbnVsbGBcclxuICAgICAgZiwgbiAgPSA6Ok1hdGguZnJleHAgc2VsZlxyXG4gICAgICBmICAgICA9IDo6TWF0aC5sZGV4cChmLCA6OkZsb2F0OjpNQU5UX0RJRykudG9faVxyXG4gICAgICBuICAgIC09IDo6RmxvYXQ6Ok1BTlRfRElHXHJcblxyXG4gICAgICA6OlJhdGlvbmFsLm5ldygyICogZiwgMSA8PCAoMSAtIG4pKS5yYXRpb25hbGl6ZSg6OlJhdGlvbmFsLm5ldygxLCAxIDw8ICgxIC0gbikpKVxyXG4gICAgZWxzZVxyXG4gICAgICB0b19yLnJhdGlvbmFsaXplKGVwcylcclxuICAgIGVuZFxyXG4gIGVuZFxyXG5cclxuICBkZWYgcmVtYWluZGVyKHkpXHJcbiAgICBzZWxmIC0geSAqIChzZWxmIC8geSkudHJ1bmNhdGVcclxuICBlbmRcclxuXHJcbiAgZGVmIHJvdW5kKG5kaWdpdHMgPSB1bmRlZmluZWQpXHJcbiAgICBpZiA6OkludGVnZXIgPT09IHNlbGZcclxuICAgICAgaWYgYG5kaWdpdHMgPT0gbnVsbGBcclxuICAgICAgICByZXR1cm4gc2VsZlxyXG4gICAgICBlbmRcclxuXHJcbiAgICAgIGlmIDo6RmxvYXQgPT09IG5kaWdpdHMgJiYgbmRpZ2l0cy5pbmZpbml0ZT9cclxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsICdJbmZpbml0eSdcclxuICAgICAgZW5kXHJcblxyXG4gICAgICBuZGlnaXRzID0gOjpPcGFsLmNvZXJjZV90byEobmRpZ2l0cywgOjpJbnRlZ2VyLCA6dG9faW50KVxyXG5cclxuICAgICAgaWYgbmRpZ2l0cyA8IDo6SW50ZWdlcjo6TUlOXHJcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCAnb3V0IG9mIGJvdW5kcydcclxuICAgICAgZW5kXHJcblxyXG4gICAgICBpZiBgbmRpZ2l0cyA+PSAwYFxyXG4gICAgICAgIHJldHVybiBzZWxmXHJcbiAgICAgIGVuZFxyXG5cclxuICAgICAgbmRpZ2l0cyA9IC1uZGlnaXRzXHJcblxyXG4gICAgICAleHtcclxuICAgICAgICBpZiAoMC40MTUyNDEgKiBuZGlnaXRzIC0gMC4xMjUgPiAje3NpemV9KSB7XHJcbiAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBmID0gTWF0aC5wb3coMTAsIG5kaWdpdHMpLFxyXG4gICAgICAgICAgICB4ID0gTWF0aC5mbG9vcigoTWF0aC5hYnMoc2VsZikgKyBmIC8gMikgLyBmKSAqIGY7XHJcblxyXG4gICAgICAgIHJldHVybiBzZWxmIDwgMCA/IC14IDogeDtcclxuICAgICAgfVxyXG4gICAgZWxzZVxyXG4gICAgICBpZiBuYW4/ICYmIGBuZGlnaXRzID09IG51bGxgXHJcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpGbG9hdERvbWFpbkVycm9yLCAnTmFOJ1xyXG4gICAgICBlbmRcclxuXHJcbiAgICAgIG5kaWdpdHMgPSA6Ok9wYWwuY29lcmNlX3RvIShgbmRpZ2l0cyB8fCAwYCwgOjpJbnRlZ2VyLCA6dG9faW50KVxyXG5cclxuICAgICAgaWYgbmRpZ2l0cyA8PSAwXHJcbiAgICAgICAgaWYgbmFuP1xyXG4gICAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCAnTmFOJ1xyXG4gICAgICAgIGVsc2lmIGluZmluaXRlP1xyXG4gICAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpGbG9hdERvbWFpbkVycm9yLCAnSW5maW5pdHknXHJcbiAgICAgICAgZW5kXHJcbiAgICAgIGVsc2lmIG5kaWdpdHMgPT0gMFxyXG4gICAgICAgIHJldHVybiBgTWF0aC5yb3VuZChzZWxmKWBcclxuICAgICAgZWxzaWYgbmFuPyB8fCBpbmZpbml0ZT9cclxuICAgICAgICByZXR1cm4gc2VsZlxyXG4gICAgICBlbmRcclxuXHJcbiAgICAgIF8sIGV4cCA9IDo6TWF0aC5mcmV4cChzZWxmKVxyXG5cclxuICAgICAgaWYgbmRpZ2l0cyA+PSAoOjpGbG9hdDo6RElHICsgMikgLSAoZXhwID4gMCA/IGV4cCAvIDQgOiBleHAgLyAzIC0gMSlcclxuICAgICAgICByZXR1cm4gc2VsZlxyXG4gICAgICBlbmRcclxuXHJcbiAgICAgIGlmIG5kaWdpdHMgPCAtKGV4cCA+IDAgPyBleHAgLyAzICsgMSA6IGV4cCAvIDQpXHJcbiAgICAgICAgcmV0dXJuIDBcclxuICAgICAgZW5kXHJcblxyXG4gICAgICBgTWF0aC5yb3VuZChzZWxmICogTWF0aC5wb3coMTAsIG5kaWdpdHMpKSAvIE1hdGgucG93KDEwLCBuZGlnaXRzKWBcclxuICAgIGVuZFxyXG4gIGVuZFxyXG5cclxuICBkZWYgdGltZXMoJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVudW1fZm9yKDp0aW1lcykgeyBzZWxmIH0gdW5sZXNzIGJsb2NrXHJcblxyXG4gICAgJXh7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZjsgaSsrKSB7XHJcbiAgICAgICAgYmxvY2soaSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiB0b19mXHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiB0b19pXHJcbiAgICBgc2VsZiA8IDAgPyBNYXRoLmNlaWwoc2VsZikgOiBNYXRoLmZsb29yKHNlbGYpYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgdG9fclxyXG4gICAgaWYgOjpJbnRlZ2VyID09PSBzZWxmXHJcbiAgICAgIDo6UmF0aW9uYWwubmV3KHNlbGYsIDEpXHJcbiAgICBlbHNlXHJcbiAgICAgIGYsIGUgID0gOjpNYXRoLmZyZXhwKHNlbGYpXHJcbiAgICAgIGYgICAgID0gOjpNYXRoLmxkZXhwKGYsIDo6RmxvYXQ6Ok1BTlRfRElHKS50b19pXHJcbiAgICAgIGUgICAgLT0gOjpGbG9hdDo6TUFOVF9ESUdcclxuXHJcbiAgICAgIChmICogKDo6RmxvYXQ6OlJBRElYKiplKSkudG9fclxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiB0b19zKGJhc2UgPSAxMClcclxuICAgIGJhc2UgPSA6Ok9wYWwuY29lcmNlX3RvISBiYXNlLCA6OkludGVnZXIsIDp0b19pbnRcclxuXHJcbiAgICBpZiBiYXNlIDwgMiB8fCBiYXNlID4gMzZcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFkaXggI3tiYXNlfVwiXHJcbiAgICBlbmRcclxuXHJcbiAgICAjIERvbid0IGxvc2UgdGhlIG5lZ2F0aXZlIHplcm9cclxuICAgIGlmIHNlbGYgPT0gMCAmJiBgMS9zZWxmID09PSAtSW5maW5pdHlgXHJcbiAgICAgIHJldHVybiAnLTAuMCdcclxuICAgIGVuZFxyXG5cclxuICAgIGBzZWxmLnRvU3RyaW5nKGJhc2UpYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgdHJ1bmNhdGUobmRpZ2l0cyA9IDApXHJcbiAgICAleHtcclxuICAgICAgdmFyIGYgPSAje3RvX2Z9O1xyXG5cclxuICAgICAgaWYgKGYgJSAxID09PSAwICYmIG5kaWdpdHMgPj0gMCkge1xyXG4gICAgICAgIHJldHVybiBmO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgZmFjdG9yID0gTWF0aC5wb3coMTAsIG5kaWdpdHMpLFxyXG4gICAgICAgICAgcmVzdWx0ID0gcGFyc2VJbnQoZiAqIGZhY3RvciwgMTApIC8gZmFjdG9yO1xyXG5cclxuICAgICAgaWYgKGYgJSAxID09PSAwKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gTWF0aC5yb3VuZChyZXN1bHQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZGlnaXRzKGJhc2UgPSAxMClcclxuICAgIGlmIHNlbGYgPCAwXHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6TWF0aDo6RG9tYWluRXJyb3IsICdvdXQgb2YgZG9tYWluJ1xyXG4gICAgZW5kXHJcblxyXG4gICAgYmFzZSA9IDo6T3BhbC5jb2VyY2VfdG8hIGJhc2UsIDo6SW50ZWdlciwgOnRvX2ludFxyXG5cclxuICAgIGlmIGJhc2UgPCAyXHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhZGl4ICN7YmFzZX1cIlxyXG4gICAgZW5kXHJcblxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChzZWxmICE9IHBhcnNlSW50KHNlbGYpKSAjezo6S2VybmVsLnJhaXNlIDo6Tm9NZXRob2RFcnJvciwgXCJ1bmRlZmluZWQgbWV0aG9kIGBkaWdpdHMnIGZvciAje2luc3BlY3R9XCJ9XHJcblxyXG4gICAgICB2YXIgdmFsdWUgPSBzZWxmLCByZXN1bHQgPSBbXTtcclxuXHJcbiAgICAgIGlmIChzZWxmID09IDApIHtcclxuICAgICAgICByZXR1cm4gWzBdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB3aGlsZSAodmFsdWUgIT0gMCkge1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlICUgYmFzZSk7XHJcbiAgICAgICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSAvIGJhc2UsIDEwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGRpdm1vZChvdGhlcilcclxuICAgIGlmIG5hbj8gfHwgb3RoZXIubmFuP1xyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkZsb2F0RG9tYWluRXJyb3IsICdOYU4nXHJcbiAgICBlbHNpZiBpbmZpbml0ZT9cclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpGbG9hdERvbWFpbkVycm9yLCAnSW5maW5pdHknXHJcbiAgICBlbHNlXHJcbiAgICAgIHN1cGVyXHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmIHVwdG8oc3RvcCwgJmJsb2NrKVxyXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG4gICAgICByZXR1cm4gZW51bV9mb3IoOnVwdG8sIHN0b3ApIGRvXHJcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tzZWxmLmNsYXNzfSB3aXRoICN7c3RvcC5jbGFzc30gZmFpbGVkXCIgdW5sZXNzIDo6TnVtZXJpYyA9PT0gc3RvcFxyXG4gICAgICAgIHN0b3AgPCBzZWxmID8gMCA6IHN0b3AgLSBzZWxmICsgMVxyXG4gICAgICBlbmRcclxuICAgIGVuZFxyXG5cclxuICAgICV4e1xyXG4gICAgICBpZiAoIXN0b3AuJCRpc19udW1iZXIpIHtcclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7c2VsZi5jbGFzc30gd2l0aCAje3N0b3AuY2xhc3N9IGZhaWxlZFwifVxyXG4gICAgICB9XHJcbiAgICAgIGZvciAodmFyIGkgPSBzZWxmOyBpIDw9IHN0b3A7IGkrKykge1xyXG4gICAgICAgIGJsb2NrKGkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgemVybz9cclxuICAgIGBzZWxmID09IDBgXHJcbiAgZW5kXHJcblxyXG4gICMgU2luY2UgYml0d2lzZSBvcGVyYXRpb25zIGFyZSAzMiBiaXQsIGRlY2xhcmUgaXQgdG8gYmUgc28uXHJcbiAgZGVmIHNpemVcclxuICAgIDRcclxuICBlbmRcclxuXHJcbiAgZGVmIG5hbj9cclxuICAgIGBpc05hTihzZWxmKWBcclxuICBlbmRcclxuXHJcbiAgZGVmIGZpbml0ZT9cclxuICAgIGBzZWxmICE9IEluZmluaXR5ICYmIHNlbGYgIT0gLUluZmluaXR5ICYmICFpc05hTihzZWxmKWBcclxuICBlbmRcclxuXHJcbiAgZGVmIGluZmluaXRlP1xyXG4gICAgJXh7XHJcbiAgICAgIGlmIChzZWxmID09IEluZmluaXR5KSB7XHJcbiAgICAgICAgcmV0dXJuICsxO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKHNlbGYgPT0gLUluZmluaXR5KSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBuaWw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHBvc2l0aXZlP1xyXG4gICAgYHNlbGYgIT0gMCAmJiAoc2VsZiA9PSBJbmZpbml0eSB8fCAxIC8gc2VsZiA+IDApYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgbmVnYXRpdmU/XHJcbiAgICBgc2VsZiA9PSAtSW5maW5pdHkgfHwgMSAvIHNlbGYgPCAwYFxyXG4gIGVuZFxyXG5cclxuICAleHtcclxuICAgIGZ1bmN0aW9uIG51bWJlclRvVWludDhBcnJheShudW0pIHtcclxuICAgICAgdmFyIHVpbnQ4YXJyYXkgPSBuZXcgVWludDhBcnJheSg4KTtcclxuICAgICAgbmV3IERhdGFWaWV3KHVpbnQ4YXJyYXkuYnVmZmVyKS5zZXRGbG9hdDY0KDAsIG51bSwgdHJ1ZSk7XHJcbiAgICAgIHJldHVybiB1aW50OGFycmF5O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVpbnQ4QXJyYXlUb051bWJlcihhcnIpIHtcclxuICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyKS5nZXRGbG9hdDY0KDAsIHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGluY3JlbWVudE51bWJlckJpdChudW0pIHtcclxuICAgICAgdmFyIGFyciA9IG51bWJlclRvVWludDhBcnJheShudW0pO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChhcnJbaV0gPT09IDB4ZmYpIHtcclxuICAgICAgICAgIGFycltpXSA9IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGFycltpXSsrO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB1aW50OEFycmF5VG9OdW1iZXIoYXJyKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkZWNyZW1lbnROdW1iZXJCaXQobnVtKSB7XHJcbiAgICAgIHZhciBhcnIgPSBudW1iZXJUb1VpbnQ4QXJyYXkobnVtKTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoYXJyW2ldID09PSAwKSB7XHJcbiAgICAgICAgICBhcnJbaV0gPSAweGZmO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhcnJbaV0tLTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdWludDhBcnJheVRvTnVtYmVyKGFycik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkZWYgbmV4dF9mbG9hdFxyXG4gICAgcmV0dXJuIDo6RmxvYXQ6OklORklOSVRZIGlmIHNlbGYgPT0gOjpGbG9hdDo6SU5GSU5JVFlcclxuICAgIHJldHVybiA6OkZsb2F0OjpOQU4gaWYgbmFuP1xyXG5cclxuICAgIGlmIHNlbGYgPj0gMFxyXG4gICAgICAjIE1hdGguYWJzKCkgaXMgbmVlZGVkIHRvIGhhbmRsZSAtMC4wXHJcbiAgICAgIGBpbmNyZW1lbnROdW1iZXJCaXQoTWF0aC5hYnMoc2VsZikpYFxyXG4gICAgZWxzZVxyXG4gICAgICBgZGVjcmVtZW50TnVtYmVyQml0KHNlbGYpYFxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBwcmV2X2Zsb2F0XHJcbiAgICByZXR1cm4gLTo6RmxvYXQ6OklORklOSVRZIGlmIHNlbGYgPT0gLTo6RmxvYXQ6OklORklOSVRZXHJcbiAgICByZXR1cm4gOjpGbG9hdDo6TkFOIGlmIG5hbj9cclxuXHJcbiAgICBpZiBzZWxmID4gMFxyXG4gICAgICBgZGVjcmVtZW50TnVtYmVyQml0KHNlbGYpYFxyXG4gICAgZWxzZVxyXG4gICAgICBgLWluY3JlbWVudE51bWJlckJpdChNYXRoLmFicyhzZWxmKSlgXHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgYWxpYXMgYXJnIGFuZ2xlXHJcbiAgYWxpYXMgZXFsPyA9PVxyXG4gIGFsaWFzIGZkaXYgL1xyXG4gIGFsaWFzIGluc3BlY3QgdG9fc1xyXG4gIGFsaWFzIGtpbmRfb2Y/IGlzX2E/XHJcbiAgYWxpYXMgbWFnbml0dWRlIGFic1xyXG4gIGFsaWFzIG1vZHVsbyAlXHJcbiAgYWxpYXMgb2JqZWN0X2lkIF9faWRfX1xyXG4gIGFsaWFzIHBoYXNlIGFuZ2xlXHJcbiAgYWxpYXMgc3VjYyBuZXh0XHJcbiAgYWxpYXMgdG9faW50IHRvX2lcclxuZW5kXHJcblxyXG46OkZpeG51bSA9IDo6TnVtYmVyXHJcblxyXG5jbGFzcyA6OkludGVnZXIgPCA6Ok51bWVyaWNcclxuICBgc2VsZi4kJGlzX251bWJlcl9jbGFzcyA9IHRydWVgXHJcbiAgYHNlbGYuJCRpc19pbnRlZ2VyX2NsYXNzID0gdHJ1ZWBcclxuXHJcbiAgY2xhc3MgPDwgc2VsZlxyXG4gICAgZGVmIGFsbG9jYXRlXHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxyXG4gICAgZW5kXHJcblxyXG4gICAgdW5kZWYgOm5ld1xyXG5cclxuICAgIGRlZiBzcXJ0KG4pXHJcbiAgICAgIG4gPSA6Ok9wYWwuY29lcmNlX3RvIShuLCA6OkludGVnZXIsIDp0b19pbnQpXHJcbiAgICAgICV4e1xyXG4gICAgICAgIGlmIChuIDwgMCkge1xyXG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6Ok1hdGg6OkRvbWFpbkVycm9yLCAnTnVtZXJpY2FsIGFyZ3VtZW50IGlzIG91dCBvZiBkb21haW4gLSBcImlzcXJ0XCInfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KE1hdGguc3FydChuKSwgMTApO1xyXG4gICAgICB9XHJcbiAgICBlbmRcclxuXHJcbiAgICBkZWYgdHJ5X2NvbnZlcnQob2JqZWN0KVxyXG4gICAgICBPcGFsLmNvZXJjZV90bz8ob2JqZWN0LCBzZWxmLCA6dG9faW50KVxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIHNlbGY6Ok1BWCA9IGBNYXRoLnBvdygyLCAzMCkgLSAxYFxyXG4gIHNlbGY6Ok1JTiA9IGAtTWF0aC5wb3coMiwgMzApYFxyXG5lbmRcclxuXHJcbmNsYXNzIDo6RmxvYXQgPCA6Ok51bWVyaWNcclxuICBgc2VsZi4kJGlzX251bWJlcl9jbGFzcyA9IHRydWVgXHJcblxyXG4gIGNsYXNzIDw8IHNlbGZcclxuICAgIGRlZiBhbGxvY2F0ZVxyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJhbGxvY2F0b3IgdW5kZWZpbmVkIGZvciAje25hbWV9XCJcclxuICAgIGVuZFxyXG5cclxuICAgIHVuZGVmIDpuZXdcclxuXHJcbiAgICBkZWYgPT09KG90aGVyKVxyXG4gICAgICBgISFvdGhlci4kJGlzX251bWJlcmBcclxuICAgIGVuZFxyXG4gIGVuZFxyXG5cclxuICBzZWxmOjpJTkZJTklUWSA9IGBJbmZpbml0eWBcclxuICBzZWxmOjpNQVggICAgICA9IGBOdW1iZXIuTUFYX1ZBTFVFYFxyXG4gIHNlbGY6Ok1JTiAgICAgID0gYE51bWJlci5NSU5fVkFMVUVgXHJcbiAgc2VsZjo6TkFOICAgICAgPSBgTmFOYFxyXG5cclxuICBzZWxmOjpESUcgICAgICA9IDE1XHJcbiAgc2VsZjo6TUFOVF9ESUcgPSA1M1xyXG4gIHNlbGY6OlJBRElYICAgID0gMlxyXG5cclxuICBzZWxmOjpFUFNJTE9OID0gYE51bWJlci5FUFNJTE9OIHx8IDIuMjIwNDQ2MDQ5MjUwMzEzMDgwODQ3MjYzMzM2MTgxNkUtMTZgXHJcbmVuZFxyXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOk51bWJlcj4iLCJPcGFsIiwiYnJpZGdlIiwiYWxsb2NhdGUiLCJLZXJuZWwiLCJyYWlzZSIsIlR5cGVFcnJvciIsIm5hbWUiLCJjb2VyY2UiLCJvdGhlciIsImNsYXNzIiwiRmxvYXQiLCJyZXNwb25kX3RvPyIsImNvZXJjZV90byEiLCJfX2lkX18iLCJoYXNoIiwiKyIsIl9fY29lcmNlZF9fIiwiLSIsIioiLCIvIiwiJSIsIlplcm9EaXZpc2lvbkVycm9yIiwiJiIsInwiLCJeIiwiPCIsIjw9IiwiPiIsIj49IiwiPD0+IiwiQXJndW1lbnRFcnJvciIsIjw8IiwiY291bnQiLCJJbnRlZ2VyIiwiPj4iLCJbXSIsImJpdCIsIitAIiwiLUAiLCJ+IiwiKioiLCI9PT0iLCIwIiwiUmF0aW9uYWwiLCJuZXciLCIxIiwiQ29tcGxleCIsInRvX2YiLCI9PSIsImFicyIsImFiczIiLCJhbGxiaXRzPyIsIm1hc2siLCJhbnliaXRzPyIsImFuZ2xlIiwibmFuPyIsImJpdF9sZW5ndGgiLCJOb01ldGhvZEVycm9yIiwiY2VpbCIsIm5kaWdpdHMiLCJjaHIiLCJlbmNvZGluZyIsImRlbm9taW5hdG9yIiwiaW5maW5pdGU/IiwiZG93bnRvIiwic3RvcCIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwiYmxvY2sgaW4gZG93bnRvIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkb3dudG8iLCJOdW1lcmljIiwiZXF1YWw/IiwiJHJldF9vcl8xIiwiZXZlbj8iLCJmbG9vciIsImdjZCIsImdjZGxjbSIsImxjbSIsImludGVnZXI/IiwiaXNfYT8iLCJrbGFzcyIsImluc3RhbmNlX29mPyIsIm5leHQiLCJub2JpdHM/Iiwibm9uemVybz8iLCJudW1lcmF0b3IiLCJvZGQ/Iiwib3JkIiwicG93IiwiYiIsIm0iLCJwcmVkIiwicXVvIiwicmF0aW9uYWxpemUiLCJlcHMiLCJGbG9hdERvbWFpbkVycm9yIiwiTWF0aCIsImZyZXhwIiwiZiIsIm4iLCJsZGV4cCIsIkZsb2F0OjpNQU5UX0RJRyIsInRvX2kiLCIyIiwidG9fciIsInJlbWFpbmRlciIsInkiLCJ0cnVuY2F0ZSIsInJvdW5kIiwiUmFuZ2VFcnJvciIsIkludGVnZXI6Ok1JTiIsInNpemUiLCJfIiwiZXhwIiwiRmxvYXQ6OkRJRyIsIjQiLCIzIiwidGltZXMiLCJibG9jayIsImJsb2NrIGluIHRpbWVzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0aW1lcyIsImUiLCJGbG9hdDo6UkFESVgiLCJ0b19zIiwiYmFzZSIsIjEwIiwiMzYiLCJkaWdpdHMiLCJNYXRoOjpEb21haW5FcnJvciIsImluc3BlY3QiLCJkaXZtb2QiLCJ1cHRvIiwiYmxvY2sgaW4gdXB0byIsImJsb2NrICgyIGxldmVscykgaW4gdXB0byIsInplcm8/IiwiZmluaXRlPyIsInBvc2l0aXZlPyIsIm5lZ2F0aXZlPyIsIm5leHRfZmxvYXQiLCJGbG9hdDo6SU5GSU5JVFkiLCJGbG9hdDo6TkFOIiwicHJldl9mbG9hdCIsIk51bWJlciIsIjxjbGFzczpJbnRlZ2VyPiIsInNxcnQiLCJ0cnlfY29udmVydCIsIm9iamVjdCIsImNvZXJjZV90bz8iLCI8Y2xhc3M6RmxvYXQ+IiwiMTUiLCI1MyJdLCJtYXBwaW5ncyI6IkFBQUFBLGlDQUFBQSxnQkFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBOztFQUdBQyxJQUFBQyxTQUFBQSxDQUFRRixpQkFBUkU7RUFFQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUMsS0FBTUMsUUFBQUEsQ0FBU0YsTUFBZixFQUF3QkYsSUFBbEJJO0lBQ0xGO0lBQ0FBO0lBQ0FBO0lBRUQ7Ozs7QUFDRUcsTUFBQUEsd0JBQUFBLG9CQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQUMsT0FBUUMsT0FBQUEsQ0FBT0MsZ0JBQWYsRUFBNkJILDBCQUFELEdBQUEsTUFBMkJMLElBQUFTLE1BQUFBLENBQUFBLENBQTNCLENBQXBCRjtNQURWRixDQUFBQTs7O01BSUEsc0JBQU0sS0FBTjtNQWhCSixPQUFBO0lBV0UsNEJBQVNMLElBQVQ7O0FBUUFVLElBQUFBLHNCQUFBQSxrQkFBV0MsS0FBWEQ7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQSxRQUFVSixPQUFRQyxPQUFBQSxDQUFPQyxnQkFBZixFQUE2QkUsZ0JBQUQsR0FBQSxNQUFpQkMsS0FBS0MsT0FBQUEsQ0FBQUEsQ0FBdEIsQ0FBQSxHQUE2QkYsYUFBakRILENBQThERztBQUNoRkE7QUFDQUE7QUFDQUEsZ0JBQWtCSixPQUFRTyxPQUFBQSxDQUFPRixLQUFQRSxDQUFj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QUFrQnVKLEdBQWxCO0lBRUEsV0FBQXZKLElBQUEsU0FBaUJ3SixFQUFqQjtJQUNBLFdBQUF4SixJQUFBLGNBQWlCeUosRUFBakI7SUFDQSxXQUFBekosSUFBQSxXQUFpQjBHLENBQWpCO0lBRUE2QyxPQUFBLFdBQUF2SixJQUFBLGFBQWlCdUosdURBQWpCO0VBeEJGQSxHQUFNLElBQU5BLEVBQWdCOUUsY0FBaEI4RTtBQS82QkF4SjsifX0seyJvZmZzZXQiOnsibGluZSI6MTkyODQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3JhbmdlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxyXG4jIHVzZV9zdHJpY3Q6IHRydWVcclxuXHJcbnJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYWJsZSdcclxuXHJcbmNsYXNzIDo6UmFuZ2VcclxuICBpbmNsdWRlIDo6RW51bWVyYWJsZVxyXG5cclxuICBgc2VsZi4kJHByb3RvdHlwZS4kJGlzX3JhbmdlID0gdHJ1ZWBcclxuXHJcbiAgYXR0cl9yZWFkZXIgOmJlZ2luLCA6ZW5kXHJcblxyXG4gIGRlZiBpbml0aWFsaXplKGZpcnN0LCBsYXN0LCBleGNsdWRlID0gZmFsc2UpXHJcbiAgICA6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvciwgXCInaW5pdGlhbGl6ZScgY2FsbGVkIHR3aWNlXCIgaWYgQGJlZ2luXHJcbiAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdiYWQgdmFsdWUgZm9yIHJhbmdlJyB1bmxlc3MgZmlyc3QgPD0+IGxhc3QgfHwgZmlyc3QubmlsPyB8fCBsYXN0Lm5pbD9cclxuXHJcbiAgICBAYmVnaW4gPSBmaXJzdFxyXG4gICAgQGVuZCAgID0gbGFzdFxyXG4gICAgQGV4Y2wgID0gZXhjbHVkZVxyXG4gIGVuZFxyXG5cclxuICBkZWYgPT09KHZhbHVlKVxyXG4gICAgcmV0dXJuIGZhbHNlIGlmIGB2YWx1ZS4kJGlzX3JhbmdlYFxyXG4gICAgY292ZXI/IHZhbHVlXHJcbiAgZW5kXHJcblxyXG4gICV4e1xyXG4gICAgZnVuY3Rpb24gaXNfaW5maW5pdGUoc2VsZikge1xyXG4gICAgICBpZiAoc2VsZi5iZWdpbiA9PT0gbmlsIHx8IHNlbGYuZW5kID09PSBuaWwgfHxcclxuICAgICAgICAgIHNlbGYuYmVnaW4gPT09IC1JbmZpbml0eSB8fCBzZWxmLmVuZCA9PT0gSW5maW5pdHkgfHxcclxuICAgICAgICAgIHNlbGYuYmVnaW4gPT09IEluZmluaXR5IHx8IHNlbGYuZW5kID09PSAtSW5maW5pdHkpIHJldHVybiB0cnVlO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkZWYgY291bnQoJmJsb2NrKVxyXG4gICAgaWYgIWJsb2NrX2dpdmVuPyAmJiBgaXNfaW5maW5pdGUoc2VsZilgXHJcbiAgICAgIHJldHVybiA6OkZsb2F0OjpJTkZJTklUWVxyXG4gICAgZW5kXHJcbiAgICBzdXBlclxyXG4gIGVuZFxyXG5cclxuICBkZWYgdG9fYVxyXG4gICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdjYW5ub3QgY29udmVydCBlbmRsZXNzIHJhbmdlIHRvIGFuIGFycmF5JyBpZiBgaXNfaW5maW5pdGUoc2VsZilgXHJcbiAgICBzdXBlclxyXG4gIGVuZFxyXG5cclxuICBkZWYgY292ZXI/KHZhbHVlKVxyXG4gICAgY29tcGFyZSA9IC0+KGEsIGIpIHtcclxuICAgICAgYSA8PT4gYiB8fCAxXHJcbiAgICB9XHJcblxyXG4gICAgaWYgYHZhbHVlLiQkaXNfcmFuZ2VgXHJcbiAgICAgIHZhbF9iZWdpbiA9IHZhbHVlLmJlZ2luXHJcbiAgICAgIHZhbF9lbmQgPSB2YWx1ZS5lbmRcclxuICAgICAgdmFsX2V4Y2wgPSB2YWx1ZS5leGNsdWRlX2VuZD9cclxuICAgICAgaWYgKEBiZWdpbiAmJiB2YWxfYmVnaW4ubmlsPykgfHxcclxuICAgICAgICAgKEBlbmQgJiYgdmFsX2VuZC5uaWw/KSB8fFxyXG4gICAgICAgICAodmFsX2JlZ2luICYmIHZhbF9lbmQgJiYgY29tcGFyZS5jYWxsKHZhbF9iZWdpbiwgdmFsX2VuZCkudGhlbiB7IHxjfCB2YWxfZXhjbCA/IGMgPj0gMCA6IGMgPiAwIH0pIHx8XHJcbiAgICAgICAgICh2YWxfYmVnaW4gJiYgIWNvdmVyPyh2YWxfYmVnaW4pKVxyXG4gICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICBlbmRcclxuXHJcbiAgICAgIGNtcCA9IGNvbXBhcmUuY2FsbChAZW5kLCB2YWxfZW5kKVxyXG4gICAgICByZXR1cm4gY21wID49IDAgaWYgQGV4Y2wgPT0gdmFsX2V4Y2xcclxuICAgICAgcmV0dXJuIGNtcCA+IDAgaWYgQGV4Y2xcclxuICAgICAgcmV0dXJuIHRydWUgaWYgY21wID49IDBcclxuXHJcbiAgICAgIHZhbF9tYXggPSB2YWx1ZS5tYXhcclxuICAgICAgcmV0dXJuICF2YWxfbWF4Lm5pbD8gJiYgY29tcGFyZS5jYWxsKHZhbF9tYXgsIEBlbmQpIDw9IDBcclxuICAgIGVuZFxyXG5cclxuICAgIHJldHVybiBmYWxzZSBpZiBAYmVnaW4gJiYgY29tcGFyZS5jYWxsKEBiZWdpbiwgdmFsdWUpID4gMFxyXG4gICAgcmV0dXJuIHRydWUgaWYgQGVuZC5uaWw/XHJcbiAgICBlbmRfY21wID0gY29tcGFyZS5jYWxsKHZhbHVlLCBAZW5kKVxyXG4gICAgQGV4Y2wgPyBlbmRfY21wIDwgMCA6IGVuZF9jbXAgPD0gMFxyXG4gIGVuZFxyXG5cclxuICBkZWYgZWFjaCgmYmxvY2spXHJcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2gpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cclxuXHJcbiAgICAleHtcclxuICAgICAgdmFyIGksIGxpbWl0O1xyXG5cclxuICAgICAgaWYgKCN7QGJlZ2lufS4kJGlzX251bWJlciAmJiAje0BlbmR9LiQkaXNfbnVtYmVyKSB7XHJcbiAgICAgICAgaWYgKCN7QGJlZ2lufSAlIDEgIT09IDAgfHwgI3tAZW5kfSAlIDEgIT09IDApIHtcclxuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiY2FuJ3QgaXRlcmF0ZSBmcm9tIEZsb2F0XCJ9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGkgPSAje0BiZWdpbn0sIGxpbWl0ID0gI3tAZW5kfSArICN7QGV4Y2wgPyAwIDogMX07IGkgPCBsaW1pdDsgaSsrKSB7XHJcbiAgICAgICAgICBibG9jayhpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoI3tAYmVnaW59LiQkaXNfc3RyaW5nICYmICN7QGVuZH0uJCRpc19zdHJpbmcpIHtcclxuICAgICAgICAje0BiZWdpbi51cHRvKEBlbmQsIEBleGNsLCAmYmxvY2spfVxyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY3VycmVudCA9IEBiZWdpblxyXG4gICAgbGFzdCAgICA9IEBlbmRcclxuXHJcbiAgICB1bmxlc3MgY3VycmVudC5yZXNwb25kX3RvPyg6c3VjYylcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiY2FuJ3QgaXRlcmF0ZSBmcm9tICN7Y3VycmVudC5jbGFzc31cIlxyXG4gICAgZW5kXHJcblxyXG4gICAgd2hpbGUgQGVuZC5uaWw/IHx8IChjdXJyZW50IDw9PiBsYXN0KSA8IDBcclxuICAgICAgeWllbGQgY3VycmVudFxyXG5cclxuICAgICAgY3VycmVudCA9IGN1cnJlbnQuc3VjY1xyXG4gICAgZW5kXHJcblxyXG4gICAgeWllbGQgY3VycmVudCBpZiAhQGV4Y2wgJiYgY3VycmVudCA9PSBsYXN0XHJcblxyXG4gICAgc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgZXFsPyhvdGhlcilcclxuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgOjpSYW5nZSA9PT0gb3RoZXJcclxuXHJcbiAgICBAZXhjbCA9PT0gb3RoZXIuZXhjbHVkZV9lbmQ/ICYmXHJcbiAgICAgIEBiZWdpbi5lcWw/KG90aGVyLmJlZ2luKSAmJlxyXG4gICAgICBAZW5kLmVxbD8ob3RoZXIuZW5kKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZXhjbHVkZV9lbmQ/XHJcbiAgICBAZXhjbFxyXG4gIGVuZFxyXG5cclxuICBkZWYgZmlyc3QobiA9IHVuZGVmaW5lZClcclxuICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ2Nhbm5vdCBnZXQgdGhlIG1pbmltdW0gb2YgYmVnaW5sZXNzIHJhbmdlJyBpZiBAYmVnaW4ubmlsP1xyXG4gICAgcmV0dXJuIEBiZWdpbiBpZiBgbiA9PSBudWxsYFxyXG4gICAgc3VwZXJcclxuICBlbmRcclxuXHJcbiAgZGVmIGluY2x1ZGU/KHZhbClcclxuICAgIGlmIGBzZWxmLmJlZ2luLiQkaXNfbnVtYmVyIHx8IHNlbGYuZW5kLiQkaXNfbnVtYmVyYCB8fFxyXG4gICAgICAgQGJlZ2luLmlzX2E/KDo6VGltZSkgfHwgQGVuZC5pc19hPyg6OlRpbWUpIHx8XHJcbiAgICAgICA6OkludGVnZXIudHJ5X2NvbnZlcnQoQGJlZ2luKSB8fCA6OkludGVnZXIudHJ5X2NvbnZlcnQoQGVuZClcclxuICAgICAgcmV0dXJuIGNvdmVyPyh2YWwpXHJcbiAgICBlbmRcclxuXHJcbiAgICBpZiBgc2VsZi5iZWdpbi4kJGlzX3N0cmluZyB8fCBzZWxmLmVuZC4kJGlzX3N0cmluZ2BcclxuICAgICAgaWYgYHNlbGYuYmVnaW4uJCRpc19zdHJpbmcgJiYgc2VsZi5lbmQuJCRpc19zdHJpbmdgXHJcbiAgICAgICAgcmV0dXJuIEBiZWdpbi51cHRvKEBlbmQsIEBleGNsKS5hbnk/IHsgfHN8IHMgPT0gdmFsIH1cclxuICAgICAgZWxzaWYgQGJlZ2luLm5pbD9cclxuICAgICAgICBjbXAgPSB2YWwgPD0+IEBlbmRcclxuICAgICAgICByZXR1cm4gIWNtcC5uaWw/ICYmIChAZXhjbCA/IGNtcCA8IDAgOiBjbXAgPD0gMClcclxuICAgICAgZWxzaWYgQGVuZC5uaWw/XHJcbiAgICAgICAgY21wID0gQGJlZ2luIDw9PiB2YWxcclxuICAgICAgICByZXR1cm4gIWNtcC5uaWw/ICYmIGNtcCA8PSAwXHJcbiAgICAgIGVuZFxyXG4gICAgZW5kXHJcblxyXG4gICAgIyBpbnZva2UgRW51bWVyYWJsZSNpbmNsdWRlP1xyXG4gICAgc3VwZXJcclxuICBlbmRcclxuXHJcbiAgZGVmIGxhc3QobiA9IHVuZGVmaW5lZClcclxuICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ2Nhbm5vdCBnZXQgdGhlIG1heGltdW0gb2YgZW5kbGVzcyByYW5nZScgaWYgQGVuZC5uaWw/XHJcbiAgICByZXR1cm4gQGVuZCBpZiBgbiA9PSBudWxsYFxyXG4gICAgdG9fYS5sYXN0KG4pXHJcbiAgZW5kXHJcblxyXG4gICMgRklYTUU6IGN1cnJlbnRseSBoYXJkY29kZWQgdG8gYXNzdW1lIHJhbmdlIGhvbGRzIG51bWVyaWNzXHJcbiAgZGVmIG1heFxyXG4gICAgaWYgQGVuZC5uaWw/XHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ2Nhbm5vdCBnZXQgdGhlIG1heGltdW0gb2YgZW5kbGVzcyByYW5nZSdcclxuICAgIGVsc2lmIGJsb2NrX2dpdmVuP1xyXG4gICAgICBzdXBlclxyXG4gICAgZWxzaWYgIUBiZWdpbi5uaWw/ICYmIChAYmVnaW4gPiBAZW5kIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEBleGNsICYmIEBiZWdpbiA9PSBAZW5kKVxyXG4gICAgICBuaWxcclxuICAgIGVsc2VcclxuICAgICAgYCN7QGV4Y2x9ID8gI3tAZW5kfSAtIDEgOiAje0BlbmR9YFxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBtaW5cclxuICAgIGlmIEBiZWdpbi5uaWw/XHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ2Nhbm5vdCBnZXQgdGhlIG1pbmltdW0gb2YgYmVnaW5sZXNzIHJhbmdlJ1xyXG4gICAgZWxzaWYgYmxvY2tfZ2l2ZW4/XHJcbiAgICAgIHN1cGVyXHJcbiAgICBlbHNpZiAhQGVuZC5uaWw/ICYmIChAYmVnaW4gPiBAZW5kIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBAZXhjbCAmJiBAYmVnaW4gPT0gQGVuZClcclxuICAgICAgbmlsXHJcbiAgICBlbHNlXHJcbiAgICAgIEBiZWdpblxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzaXplXHJcbiAgICAleHtcclxuICAgICAgdmFyIGIgPSB0aGlzLmJlZ2luLCBlID0gdGhpcy5lbmQ7XHJcblxyXG4gICAgICAvLyBJZiBiZWdpbiBpcyBOdW1lcmljXHJcbiAgICAgIGlmICgjezo6TnVtZXJpYyA9PT0gYGJgfSkge1xyXG4gICAgICAgIC8vIElmIGVuZCBpcyBOdW1lcmljXHJcbiAgICAgICAgaWYgKCN7OjpOdW1lcmljID09PSBgZWB9KSB7XHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGluZyBzaXplIGJhc2VkIG9uIHdoZXRoZXIgcmFuZ2UgaXMgZXhjbHVzaXZlIG9yIGluY2x1c2l2ZVxyXG4gICAgICAgICAgdmFyIHNpemUgPSAje2BlYCAtIGBiYH07XHJcbiAgICAgICAgICBpZiAoc2l6ZSA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoIXRoaXMuZXhjbCkge1xyXG4gICAgICAgICAgICBzaXplICs9IDE7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gKCN7OjpGbG9hdCA9PT0gYGJgfSB8fCAjezo6RmxvYXQgPT09IGBlYH0pID8gTWF0aC5mbG9vcihzaXplKSA6IHNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIGVuZCBpcyBuaWxcclxuICAgICAgICBlbHNlIGlmIChlID09PSBuaWwpIHtcclxuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy8gSWYgYmVnaW4gaXMgbmlsXHJcbiAgICAgIGVsc2UgaWYgKGIgPT09IG5pbCkge1xyXG4gICAgICAgIC8vIElmIGVuZCBpcyBOdW1lcmljXHJcbiAgICAgICAgaWYgKCN7OjpOdW1lcmljID09PSBgZWB9KSB7XHJcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiBuZWl0aGVyIGJlZ2luIG5vciBlbmQgaXMgTnVtZXJpY1xyXG4gICAgICByZXR1cm4gbmlsO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc3RlcChuID0gdW5kZWZpbmVkKVxyXG4gICAgJXh7XHJcbiAgICAgIGZ1bmN0aW9uIGNvZXJjZVN0ZXBTaXplKCkge1xyXG4gICAgICAgIGlmIChuID09IG51bGwpIHtcclxuICAgICAgICAgIG4gPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghbi4kJGlzX251bWJlcikge1xyXG4gICAgICAgICAgbiA9ICN7OjpPcGFsLmNvZXJjZV90byEobiwgOjpJbnRlZ2VyLCA6dG9faW50KX1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChuIDwgMCkge1xyXG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwic3RlcCBjYW4ndCBiZSBuZWdhdGl2ZVwifVxyXG4gICAgICAgIH0gZWxzZSBpZiAobiA9PT0gMCkge1xyXG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwic3RlcCBjYW4ndCBiZSAwXCJ9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBlbnVtZXJhdG9yU2l6ZSgpIHtcclxuICAgICAgICBpZiAoISN7QGJlZ2luLnJlc3BvbmRfdG8/KDpzdWNjKX0pIHtcclxuICAgICAgICAgIHJldHVybiBuaWw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoI3tAYmVnaW59LiQkaXNfc3RyaW5nICYmICN7QGVuZH0uJCRpc19zdHJpbmcpIHtcclxuICAgICAgICAgIHJldHVybiBuaWw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobiAlIDEgPT09IDApIHtcclxuICAgICAgICAgIHJldHVybiAjeyhzaXplIC8gbikuY2VpbH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIG4gaXMgYSBmbG9hdFxyXG4gICAgICAgICAgdmFyIGJlZ2luID0gc2VsZi5iZWdpbiwgZW5kID0gc2VsZi5lbmQsXHJcbiAgICAgICAgICAgICAgYWJzID0gTWF0aC5hYnMsIGZsb29yID0gTWF0aC5mbG9vcixcclxuICAgICAgICAgICAgICBlcnIgPSAoYWJzKGJlZ2luKSArIGFicyhlbmQpICsgYWJzKGVuZCAtIGJlZ2luKSkgLyBhYnMobikgKiAjezo6RmxvYXQ6OkVQU0lMT059LFxyXG4gICAgICAgICAgICAgIHNpemU7XHJcblxyXG4gICAgICAgICAgaWYgKGVyciA+IDAuNSkge1xyXG4gICAgICAgICAgICBlcnIgPSAwLjU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHNlbGYuZXhjbCkge1xyXG4gICAgICAgICAgICBzaXplID0gZmxvb3IoKGVuZCAtIGJlZ2luKSAvIG4gLSBlcnIpO1xyXG4gICAgICAgICAgICBpZiAoc2l6ZSAqIG4gKyBiZWdpbiA8IGVuZCkge1xyXG4gICAgICAgICAgICAgIHNpemUrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2l6ZSA9IGZsb29yKChlbmQgLSBiZWdpbikgLyBuICsgZXJyKSArIDFcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gc2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XHJcbiAgICAgIGlmIChAYmVnaW4uaXNfYT8oTnVtZXJpYykgfHwgQGJlZ2luLm5pbD8pICYmXHJcbiAgICAgICAgIChAZW5kLmlzX2E/KE51bWVyaWMpIHx8IEBlbmQubmlsPykgJiZcclxuICAgICAgICAgIShAYmVnaW4ubmlsPyAmJiBAZW5kLm5pbD8pXHJcblxyXG4gICAgICAgIHJldHVybiA6OkVudW1lcmF0b3I6OkFyaXRobWV0aWNTZXF1ZW5jZS5uZXcoc2VsZiwgbiwgOnN0ZXApXHJcbiAgICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gZW51bV9mb3IoOnN0ZXAsIG4pIGRvXHJcbiAgICAgICAgICAleHtcclxuICAgICAgICAgICAgY29lcmNlU3RlcFNpemUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGVudW1lcmF0b3JTaXplKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgZW5kXHJcbiAgICAgIGVuZFxyXG4gICAgZW5kXHJcblxyXG4gICAgYGNvZXJjZVN0ZXBTaXplKClgXHJcblxyXG4gICAgaWYgYHNlbGYuYmVnaW4uJCRpc19udW1iZXIgJiYgc2VsZi5lbmQuJCRpc19udW1iZXJgXHJcbiAgICAgIGkgPSAwXHJcbiAgICAgIGxvb3AgZG9cclxuICAgICAgICBjdXJyZW50ID0gQGJlZ2luICsgaSAqIG5cclxuICAgICAgICBpZiBAZXhjbFxyXG4gICAgICAgICAgYnJlYWsgaWYgY3VycmVudCA+PSBAZW5kXHJcbiAgICAgICAgZWxzaWYgY3VycmVudCA+IEBlbmRcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgZW5kXHJcbiAgICAgICAgeWllbGQoY3VycmVudClcclxuICAgICAgICBpICs9IDFcclxuICAgICAgZW5kXHJcbiAgICBlbHNlXHJcbiAgICAgICV4e1xyXG4gICAgICAgIGlmICgje0BiZWdpbn0uJCRpc19zdHJpbmcgJiYgI3tAZW5kfS4kJGlzX3N0cmluZyAmJiBuICUgMSAhPT0gMCkge1xyXG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ25vIGltcGxpY2l0IGNvbnZlcnNpb24gdG8gZmxvYXQgZnJvbSBzdHJpbmcnfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlYWNoX3dpdGhfaW5kZXggZG8gfHZhbHVlLCBpZHh8XHJcbiAgICAgICAgeWllbGQodmFsdWUpIGlmIGlkeCAlIG4gPT0gMFxyXG4gICAgICBlbmRcclxuICAgIGVuZFxyXG4gICAgc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgJShuKVxyXG4gICAgaWYgQGJlZ2luLmlzX2E/KE51bWVyaWMpICYmIEBlbmQuaXNfYT8oTnVtZXJpYylcclxuICAgICAgOjpFbnVtZXJhdG9yOjpBcml0aG1ldGljU2VxdWVuY2UubmV3KHNlbGYsIG4sIDolKVxyXG4gICAgZWxzZVxyXG4gICAgICBzdGVwKG4pXHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmIGJzZWFyY2goJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVudW1fZm9yKDpic2VhcmNoKSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XHJcblxyXG4gICAgaWYgYGlzX2luZmluaXRlKHNlbGYpICYmIChzZWxmLmJlZ2luLiQkaXNfbnVtYmVyIHx8IHNlbGYuZW5kLiQkaXNfbnVtYmVyKWBcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpOb3RJbXBsZW1lbnRlZEVycm9yLCBcIkNhbid0ICNic2VhcmNoIGFuIGluZmluaXRlIHJhbmdlXCJcclxuICAgIGVuZFxyXG5cclxuICAgIHVubGVzcyBgc2VsZi5iZWdpbi4kJGlzX251bWJlciAmJiBzZWxmLmVuZC4kJGlzX251bWJlcmBcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiY2FuJ3QgZG8gYmluYXJ5IHNlYXJjaCBmb3IgI3tAYmVnaW4uY2xhc3N9XCJcclxuICAgIGVuZFxyXG5cclxuICAgIHRvX2EuYnNlYXJjaCgmYmxvY2spXHJcbiAgZW5kXHJcblxyXG4gIGRlZiB0b19zXHJcbiAgICBcIiN7QGJlZ2luIHx8ICcnfSN7QGV4Y2wgPyAnLi4uJyA6ICcuLid9I3tAZW5kIHx8ICcnfVwiXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBpbnNwZWN0XHJcbiAgICBcIiN7QGJlZ2luICYmIEBiZWdpbi5pbnNwZWN0fSN7QGV4Y2wgPyAnLi4uJyA6ICcuLid9I3tAZW5kICYmIEBlbmQuaW5zcGVjdH1cIlxyXG4gIGVuZFxyXG5cclxuICBkZWYgbWFyc2hhbF9sb2FkKGFyZ3MpXHJcbiAgICBAYmVnaW4gPSBhcmdzWzpiZWdpbl1cclxuICAgIEBlbmQgPSBhcmdzWzplbmRdXHJcbiAgICBAZXhjbCA9IGFyZ3NbOmV4Y2xdXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBoYXNoXHJcbiAgICBbOjpSYW5nZSwgQGJlZ2luLCBAZW5kLCBAZXhjbF0uaGFzaFxyXG4gIGVuZFxyXG5cclxuICBhbGlhcyA9PSBlcWw/XHJcbiAgYWxpYXMgbWVtYmVyPyBpbmNsdWRlP1xyXG5lbmRcclxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpSYW5nZT4iLCJpbmNsdWRlIiwiRW51bWVyYWJsZSIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsImZpcnN0IiwibGFzdCIsImV4Y2x1ZGUiLCJAYmVnaW4iLCJLZXJuZWwiLCJyYWlzZSIsIk5hbWVFcnJvciIsIjw9PiIsIm5pbD8iLCJBcmd1bWVudEVycm9yIiwiQGVuZCIsIkBleGNsIiwiPT09IiwidmFsdWUiLCJjb3Zlcj8iLCJjb3VudCIsImJsb2NrX2dpdmVuPyIsIkZsb2F0OjpJTkZJTklUWSIsIkZsb2F0IiwidG9fYSIsIlR5cGVFcnJvciIsImNvbXBhcmUiLCJibG9jayBpbiBjb3Zlcj8iLCJhIiwiYiIsImJsb2NrICgyIGxldmVscykgaW4gY292ZXI/IiwiJHJldF9vcl8xIiwiMSIsInZhbF9iZWdpbiIsImJlZ2luIiwidmFsX2VuZCIsImVuZCIsInZhbF9leGNsIiwiZXhjbHVkZV9lbmQ/IiwidGhlbiIsImNhbGwiLCJjIiwiPj0iLCIwIiwiPiIsImNtcCIsInZhbF9tYXgiLCJtYXgiLCIhIiwiPD0iLCJlbmRfY21wIiwiPCIsImVhY2giLCJlbnVtX2ZvciIsImJsb2NrIGluIGVhY2giLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2giLCJzaXplIiwidXB0byIsImJsb2NrIiwidG9fcHJvYyIsImN1cnJlbnQiLCJyZXNwb25kX3RvPyIsImNsYXNzIiwic3VjYyIsImVxbD8iLCJvdGhlciIsIlJhbmdlIiwiJHJldF9vcl8yIiwibiIsIlJhbmdlRXJyb3IiLCJpbmNsdWRlPyIsInZhbCIsImlzX2E/IiwiVGltZSIsIkludGVnZXIiLCJ0cnlfY29udmVydCIsImFueT8iLCJibG9jayBpbiBpbmNsdWRlPyIsInMiLCJibG9jayAoMiBsZXZlbHMpIGluIGluY2x1ZGU/IiwiPT0iLCJtaW4iLCJOdW1lcmljIiwiLSIsInN0ZXAiLCJPcGFsIiwiY29lcmNlX3RvISIsIi8iLCJjZWlsIiwiRmxvYXQ6OkVQU0lMT04iLCJFbnVtZXJhdG9yOjpBcml0aG1ldGljU2VxdWVuY2UiLCJFbnVtZXJhdG9yIiwibmV3IiwiYmxvY2sgaW4gc3RlcCIsImJsb2NrICgyIGxldmVscykgaW4gc3RlcCIsImkiLCJsb29wIiwiKyIsIioiLCJlYWNoX3dpdGhfaW5kZXgiLCJpZHgiLCIlIiwiYnNlYXJjaCIsIk5vdEltcGxlbWVudGVkRXJyb3IiLCJ0b19zIiwiaW5zcGVjdCIsIm1hcnNoYWxfbG9hZCIsImFyZ3MiLCJbXSIsImhhc2giXSwibWFwcGluZ3MiOiJBQUFBQSxnQ0FBQUEsZ0JBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTs7RUFHQUMsSUFBQUMsU0FBQUEsQ0FBUUYsb0JBQVJFO0VBRUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7QUFBQUE7O0lBQ0VGLElBQUFHLFNBQUFBLENBQVFDLGlCQUFSRDtJQUVDRDtJQUVERixJQUFBSyxhQUFBQSxDQUFZLE9BQVosRUFBb0IsS0FBcEJBOztBQUVBQyxJQUFBQSwwQkFBQUEsc0JBQWVDLEtBQUQsRUFBUUMsSUFBUixFQUFjQyxPQUE1Qkg7QUFBQUEsTUFBQUE7OztNQUE0QiwrQkFBVTtNQUNwQyxJQUFB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QyxPQUFBQSxDQUFDLE1BQURBLENBQVo1RjtJQUhGMEYsQ0FBQUE7O0FBTUFHLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUEsQ0FBQzNDLFlBQUQsRUFBVTFELFVBQVYsRUFBa0JPLFFBQWxCLEVBQXdCQyxTQUF4QixDQUE4QjZGLE1BQUFBLENBQUFBO0lBRGhDQSxDQUFBQTtJQUlBLGFBQU0sSUFBTixFQUFTLE1BQVQ7SUFDQTdHLE9BQUEsYUFBTSxTQUFOLEVBQWMsVUFBZDtFQTFXRkEsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQUxBSDsifX0seyJvZmZzZXQiOnsibGluZSI6MTk3NzEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3Byb2MucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBzbGljZSwgZWFjaF9pdmFyXHJcbiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxyXG4jIHVzZV9zdHJpY3Q6IHRydWVcclxuXHJcbmNsYXNzIDo6UHJvYyA8IGBGdW5jdGlvbmBcclxuICBgT3BhbC5wcm9wKHNlbGYuJCRwcm90b3R5cGUsICckJGlzX3Byb2MnLCB0cnVlKWBcclxuICBgT3BhbC5wcm9wKHNlbGYuJCRwcm90b3R5cGUsICckJGlzX2xhbWJkYScsIGZhbHNlKWBcclxuXHJcbiAgZGVmIHNlbGYubmV3KCZibG9jaylcclxuICAgIHVubGVzcyBibG9ja1xyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjcmVhdGUgYSBQcm9jIG9iamVjdCB3aXRob3V0IGEgYmxvY2snXHJcbiAgICBlbmRcclxuXHJcbiAgICBibG9ja1xyXG4gIGVuZFxyXG5cclxuICAleHtcclxuICAgIGZ1bmN0aW9uICRjYWxsX2xhbWJkYShzZWxmLCBhcmdzKSB7XHJcbiAgICAgIGlmIChzZWxmLiQkcmV0KSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHJldHVybiBzZWxmLmFwcGx5KG51bGwsIGFyZ3MpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgaWYgKGVyciA9PT0gc2VsZi4kJHJldCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXJyLiR2O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gc2VsZi5hcHBseShudWxsLCBhcmdzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uICRjYWxsX3Byb2Moc2VsZiwgYXJncykge1xyXG4gICAgICBpZiAoc2VsZi4kJGJyaykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICByZXR1cm4gT3BhbC55aWVsZFgoc2VsZiwgYXJncyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICBpZiAoZXJyID09PSBzZWxmLiQkYnJrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlcnIuJHY7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBPcGFsLnlpZWxkWChzZWxmLCBhcmdzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVmIGNhbGwoKmFyZ3MsICZibG9jaylcclxuICAgICV4e1xyXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkgc2VsZi4kJHAgPSBibG9jaztcclxuICAgICAgaWYgKHNlbGYuJCRpc19sYW1iZGEpIHJldHVybiAkY2FsbF9sYW1iZGEoc2VsZiwgYXJncyk7XHJcbiAgICAgIHJldHVybiAkY2FsbF9wcm9jKHNlbGYsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgPj4ob3RoZXIpXHJcbiAgICA6Oktlcm5lbC5wcm9jIGRvIHwqYXJncywgJmJsb2NrfFxyXG4gICAgICBvdXQgPSBjYWxsKCphcmdzLCAmYmxvY2spXHJcbiAgICAgIG90aGVyLmNhbGwob3V0KVxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiA8PChvdGhlcilcclxuICAgIDo6S2VybmVsLnByb2MgZG8gfCphcmdzLCAmYmxvY2t8XHJcbiAgICAgIG91dCA9IG90aGVyLmNhbGwoKmFyZ3MsICZibG9jaylcclxuICAgICAgY2FsbChvdXQpXHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmIHRvX3Byb2NcclxuICAgIHNlbGZcclxuICBlbmRcclxuXHJcbiAgZGVmIGxhbWJkYT9cclxuICAgICMgVGhpcyBtZXRob2Qgc2hvdWxkIHRlbGwgdGhlIHVzZXIgaWYgdGhlIHByb2MgdHJpY2tzIGFyZSB1bmF2YWlsYWJsZSxcclxuICAgICMgKHNlZSBQcm9jI2xhbWJkYT8gb24gcnVieSBkb2NzIHRvIGZpbmQgb3V0IG1vcmUpLlxyXG4gICAgYCEhc2VsZi4kJGlzX2xhbWJkYWBcclxuICBlbmRcclxuXHJcbiAgZGVmIGFyaXR5XHJcbiAgICAleHtcclxuICAgICAgaWYgKHNlbGYuJCRpc19jdXJyaWVkKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICB9IGVsc2UgaWYgKHNlbGYuJCRhcml0eSAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRhcml0eTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gc2VsZi5sZW5ndGg7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHNvdXJjZV9sb2NhdGlvblxyXG4gICAgYGlmIChzZWxmLiQkaXNfY3VycmllZCkgeyByZXR1cm4gbmlsOyB9YFxyXG4gICAgYHNlbGYuJCRzb3VyY2VfbG9jYXRpb25gIHx8IG5pbFxyXG4gIGVuZFxyXG5cclxuICBkZWYgYmluZGluZ1xyXG4gICAgYGlmIChzZWxmLiQkaXNfY3VycmllZCkgeyAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJDYW4ndCBjcmVhdGUgQmluZGluZ1wifSB9YFxyXG5cclxuICAgIGlmIGRlZmluZWQ/IDo6QmluZGluZ1xyXG4gICAgICA6OkJpbmRpbmcubmV3KG5pbCwgW10sIGBzZWxmLiQkc2AsIHNvdXJjZV9sb2NhdGlvbilcclxuICAgIGVuZFxyXG4gIGVuZFxyXG5cclxuICBkZWYgcGFyYW1ldGVycyhsYW1iZGE6IHVuZGVmaW5lZClcclxuICAgICV4e1xyXG4gICAgICBpZiAoc2VsZi4kJGlzX2N1cnJpZWQpIHtcclxuICAgICAgICByZXR1cm4gI3tbWzpyZXN0XV19O1xyXG4gICAgICB9IGVsc2UgaWYgKHNlbGYuJCRwYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgaWYgKGxhbWJkYSA9PSBudWxsID8gc2VsZi4kJGlzX2xhbWJkYSA6IGxhbWJkYSkge1xyXG4gICAgICAgICAgcmV0dXJuIHNlbGYuJCRwYXJhbWV0ZXJzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gW10sIGksIGxlbmd0aDtcclxuXHJcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLiQkcGFyYW1ldGVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcGFyYW1ldGVyID0gc2VsZi4kJHBhcmFtZXRlcnNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAocGFyYW1ldGVyWzBdID09PSAncmVxJykge1xyXG4gICAgICAgICAgICAgIC8vIHJlcXVpcmVkIGFyZ3VtZW50cyBhbHdheXMgaGF2ZSBuYW1lXHJcbiAgICAgICAgICAgICAgcGFyYW1ldGVyID0gWydvcHQnLCBwYXJhbWV0ZXJbMV1dO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJhbWV0ZXIpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgY3VycnkoYXJpdHkgPSB1bmRlZmluZWQpXHJcbiAgICAleHtcclxuICAgICAgaWYgKGFyaXR5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBhcml0eSA9IHNlbGYubGVuZ3RoO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGFyaXR5ID0gI3s6Ok9wYWwuY29lcmNlX3RvIShhcml0eSwgOjpJbnRlZ2VyLCA6dG9faW50KX07XHJcbiAgICAgICAgaWYgKHNlbGYuJCRpc19sYW1iZGEgJiYgYXJpdHkgIT09IHNlbGYubGVuZ3RoKSB7XHJcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcml0eWB9IGZvciAje2BzZWxmLmxlbmd0aGB9KVwifVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gY3VycmllZCAoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSAkc2xpY2UoYXJndW1lbnRzKSxcclxuICAgICAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGgsXHJcbiAgICAgICAgICAgIHJlc3VsdDtcclxuXHJcbiAgICAgICAgaWYgKGxlbmd0aCA+IGFyaXR5ICYmIHNlbGYuJCRpc19sYW1iZGEgJiYgIXNlbGYuJCRpc19jdXJyaWVkKSB7XHJcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2BsZW5ndGhgfSBmb3IgI3tgYXJpdHlgfSlcIn1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChsZW5ndGggPj0gYXJpdHkpIHtcclxuICAgICAgICAgIHJldHVybiBzZWxmLiRjYWxsLmFwcGx5KHNlbGYsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzdWx0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcmV0dXJuIGN1cnJpZWQuYXBwbHkobnVsbCxcclxuICAgICAgICAgICAgYXJncy5jb25jYXQoJHNsaWNlKGFyZ3VtZW50cykpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LiQkaXNfbGFtYmRhID0gc2VsZi4kJGlzX2xhbWJkYTtcclxuICAgICAgICByZXN1bHQuJCRpc19jdXJyaWVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGN1cnJpZWQuJCRpc19sYW1iZGEgPSBzZWxmLiQkaXNfbGFtYmRhO1xyXG4gICAgICBjdXJyaWVkLiQkaXNfY3VycmllZCA9IHRydWU7XHJcbiAgICAgIHJldHVybiBjdXJyaWVkO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZHVwXHJcbiAgICAleHtcclxuICAgICAgdmFyIG9yaWdpbmFsX3Byb2MgPSBzZWxmLiQkb3JpZ2luYWxfcHJvYyB8fCBzZWxmLFxyXG4gICAgICAgICAgcHJvYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsX3Byb2MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAkZWFjaF9pdmFyKHNlbGYsIGZ1bmN0aW9uKHByb3ApIHtcclxuICAgICAgICBwcm9jW3Byb3BdID0gc2VsZltwcm9wXTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gcHJvYztcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgYWxpYXMgPT09IGNhbGxcclxuICBhbGlhcyBjbG9uZSBkdXBcclxuICBhbGlhcyB5aWVsZCBjYWxsXHJcbiAgYWxpYXMgW10gY2FsbFxyXG5lbmRcclxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6UHJvYz4iLCJuZXciLCJzZWxmIiwiYmxvY2siLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJjYWxsIiwiPj4iLCJvdGhlciIsInByb2MiLCJibG9jayBpbiA+PiIsImJsb2NrICgyIGxldmVscykgaW4gPj4iLCJvdXQiLCJhcmdzIiwidG9fcHJvYyIsIjw8IiwiYmxvY2sgaW4gPDwiLCJibG9jayAoMiBsZXZlbHMpIGluIDw8IiwibGFtYmRhPyIsImFyaXR5Iiwic291cmNlX2xvY2F0aW9uIiwiJHJldF9vcl8xIiwiYmluZGluZyIsIkJpbmRpbmciLCJwYXJhbWV0ZXJzIiwiJGt3YXJncyIsImN1cnJ5IiwiT3BhbCIsImNvZXJjZV90byEiLCJJbnRlZ2VyIiwiZHVwIl0sIm1hcHBpbmdzIjoiQUFBQUEsK0JBQUFBLGdCQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7RUFJQUEsT0FBQUM7RUFBQUE7Ozs7SUFDR0E7SUFDQUE7SUFFREMsTUFBSUMsSUFBSkQsVUFBQUEscUJBQUFBO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQ0UsS0FBQSxRQUFPRSxLQUFQLENBQUE7UUFDRUMsT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBZ0NMLCtDQUF4Qkk7TUFEVjtNQUlBSixPQUFBRTtJQUxGRixDQUFBQTs7QUFTRkQ7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVFTyxJQUFBQSxvQkFBQUEsZ0JBbERGLEVBa0RFQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQWxERjtNQWtEVzs7QUFFWEE7QUFDQUE7QUFDQUE7QUFDQUE7SUFMRUEsQ0FBQUEsSUFBQUE7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QixPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFpQ3FCLDZCQUFELEdBQUEsTUFBK0JBLE1BQS9CLENBQUEsR0FBdUNBLE9BQXZDLEdBQUEsTUFBK0NBLEtBQS9DLENBQUEsR0FBc0RBLEdBQTlFdEI7QUFDcEJzQjs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUF0Q0VBLENBQUFBLElBQUFBOztBQXlDQUksSUFBQUEsbUJBQUFBLGVBQUFBO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQVpFQSxDQUFBQTtJQWVBLGFBQU0sS0FBTixFQUFVLE1BQVY7SUFDQSxhQUFNLE9BQU4sRUFBWSxLQUFaO0lBQ0EsYUFBTSxPQUFOLEVBQVksTUFBWjtJQUNBL0IsT0FBQSxhQUFNLElBQU4sRUFBUyxNQUFUO0VBL0xGQSxHQUFNLElBQU5BLEVBQWdCRCxRQUFoQkM7QUFKQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIwMDIyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9tZXRob2QucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXHJcblxyXG5jbGFzcyA6Ok1ldGhvZFxyXG4gIGF0dHJfcmVhZGVyIDpvd25lciwgOnJlY2VpdmVyLCA6bmFtZVxyXG5cclxuICBkZWYgaW5pdGlhbGl6ZShyZWNlaXZlciwgb3duZXIsIG1ldGhvZCwgbmFtZSlcclxuICAgIEByZWNlaXZlciA9IHJlY2VpdmVyXHJcbiAgICBAb3duZXIgICAgPSBvd25lclxyXG4gICAgQG5hbWUgICAgID0gbmFtZVxyXG4gICAgQG1ldGhvZCAgID0gbWV0aG9kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBhcml0eVxyXG4gICAgQG1ldGhvZC5hcml0eVxyXG4gIGVuZFxyXG5cclxuICBkZWYgcGFyYW1ldGVyc1xyXG4gICAgYCN7QG1ldGhvZH0uJCRwYXJhbWV0ZXJzYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgc291cmNlX2xvY2F0aW9uXHJcbiAgICBgI3tAbWV0aG9kfS4kJHNvdXJjZV9sb2NhdGlvbmAgfHwgWycoZXZhbCknLCAwXVxyXG4gIGVuZFxyXG5cclxuICBkZWYgY29tbWVudHNcclxuICAgIGAje0BtZXRob2R9LiQkY29tbWVudHNgIHx8IFtdXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBjYWxsKCphcmdzLCAmYmxvY2spXHJcbiAgICAleHtcclxuICAgICAgI3tAbWV0aG9kfS4kJHAgPSBibG9jaztcclxuXHJcbiAgICAgIHJldHVybiAje0BtZXRob2R9LmFwcGx5KCN7QHJlY2VpdmVyfSwgYXJncyk7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBjdXJyeShhcml0eSA9IHVuZGVmaW5lZClcclxuICAgIEBtZXRob2QuY3VycnkoYXJpdHkpXHJcbiAgZW5kXHJcblxyXG4gIGRlZiA+PihvdGhlcilcclxuICAgIEBtZXRob2QgPj4gb3RoZXJcclxuICBlbmRcclxuXHJcbiAgZGVmIDw8KG90aGVyKVxyXG4gICAgQG1ldGhvZCA8PCBvdGhlclxyXG4gIGVuZFxyXG5cclxuICBkZWYgdW5iaW5kXHJcbiAgICA6OlVuYm91bmRNZXRob2QubmV3KEByZWNlaXZlci5jbGFzcywgQG93bmVyLCBAbWV0aG9kLCBAbmFtZSlcclxuICBlbmRcclxuXHJcbiAgZGVmIHRvX3Byb2NcclxuICAgICV4e1xyXG4gICAgICB2YXIgcHJvYyA9IHNlbGYuJGNhbGwuYmluZChzZWxmKTtcclxuICAgICAgcHJvYy4kJHVuYm91bmQgPSAje0BtZXRob2R9O1xyXG4gICAgICBwcm9jLiQkaXNfbGFtYmRhID0gdHJ1ZTtcclxuICAgICAgcHJvYy4kJGFyaXR5ID0gI3tAbWV0aG9kfS4kJGFyaXR5ID09IG51bGwgPyAje0BtZXRob2R9Lmxlbmd0aCA6ICN7QG1ldGhvZH0uJCRhcml0eTtcclxuICAgICAgcHJvYy4kJHBhcmFtZXRlcnMgPSAje0BtZXRob2R9LiQkcGFyYW1ldGVycztcclxuICAgICAgcmV0dXJuIHByb2M7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBpbnNwZWN0XHJcbiAgICBcIiM8I3tzZWxmLmNsYXNzfTogI3tAcmVjZWl2ZXIuY2xhc3N9IyN7QG5hbWV9IChkZWZpbmVkIGluICN7QG93bmVyfSBpbiAje3NvdXJjZV9sb2NhdGlvbi5qb2luKCc6Jyl9KT5cIlxyXG4gIGVuZFxyXG5cclxuICBhbGlhcyBbXSBjYWxsXHJcbiAgYWxpYXMgPT09IGNhbGxcclxuZW5kXHJcblxyXG5jbGFzcyA6OlVuYm91bmRNZXRob2RcclxuICBhdHRyX3JlYWRlciA6c291cmNlLCA6b3duZXIsIDpuYW1lXHJcblxyXG4gIGRlZiBpbml0aWFsaXplKHNvdXJjZSwgb3duZXIsIG1ldGhvZCwgbmFtZSlcclxuICAgIEBzb3VyY2UgPSBzb3VyY2VcclxuICAgIEBvd25lciAgPSBvd25lclxyXG4gICAgQG1ldGhvZCA9IG1ldGhvZFxyXG4gICAgQG5hbWUgICA9IG5hbWVcclxuICAgIGBzZWxmLiQkbWV0aG9kID0gbWV0aG9kYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgYXJpdHlcclxuICAgIEBtZXRob2QuYXJpdHlcclxuICBlbmRcclxuXHJcbiAgZGVmIHBhcmFtZXRlcnNcclxuICAgIGAje0BtZXRob2R9LiQkcGFyYW1ldGVyc2BcclxuICBlbmRcclxuXHJcbiAgZGVmIHNvdXJjZV9sb2NhdGlvblxyXG4gICAgYCN7QG1ldGhvZH0uJCRzb3VyY2VfbG9jYXRpb25gIHx8IFsnKGV2YWwpJywgMF1cclxuICBlbmRcclxuXHJcbiAgZGVmIGNvbW1lbnRzXHJcbiAgICBgI3tAbWV0aG9kfS4kJGNvbW1lbnRzYCB8fCBbXVxyXG4gIGVuZFxyXG5cclxuICBkZWYgYmluZChvYmplY3QpXHJcbiAgICAleHtcclxuICAgICAgaWYgKCN7QG93bmVyfS4kJGlzX21vZHVsZSB8fCBPcGFsLmlzX2EoI3tvYmplY3R9LCAje0Bvd25lcn0pKSB7XHJcbiAgICAgICAgcmV0dXJuICN7OjpNZXRob2QubmV3KG9iamVjdCwgQG93bmVyLCBAbWV0aG9kLCBAbmFtZSl9O1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiY2FuJ3QgYmluZCBzaW5nbGV0b24gbWV0aG9kIHRvIGEgZGlmZmVyZW50IGNsYXNzIChleHBlY3RlZCAje29iamVjdH0ua2luZF9vZj8oI3tAb3duZXJ9IHRvIGJlIHRydWUpXCJ9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBiaW5kX2NhbGwob2JqZWN0LCAqYXJncywgJmJsb2NrKVxyXG4gICAgYmluZChvYmplY3QpLmNhbGwoKmFyZ3MsICZibG9jaylcclxuICBlbmRcclxuXHJcbiAgZGVmIGluc3BlY3RcclxuICAgIFwiIzwje3NlbGYuY2xhc3N9OiAje0Bzb3VyY2V9IyN7QG5hbWV9IChkZWZpbmVkIGluICN7QG93bmVyfSBpbiAje3NvdXJjZV9sb2NhdGlvbi5qb2luKCc6Jyl9KT5cIlxyXG4gIGVuZFxyXG5lbmRcclxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6TWV0aG9kPiIsInNlbGYiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJyZWNlaXZlciIsIm93bmVyIiwibWV0aG9kIiwibmFtZSIsIkByZWNlaXZlciIsIkBvd25lciIsIkBuYW1lIiwiQG1ldGhvZCIsImFyaXR5IiwicGFyYW1ldGVycyIsInNvdXJjZV9sb2NhdGlvbiIsIiRyZXRfb3JfMSIsIjAiLCJjb21tZW50cyIsImNhbGwiLCJjdXJyeSIsIj4+Iiwib3RoZXIiLCI8PCIsInVuYmluZCIsIlVuYm91bmRNZXRob2QiLCJuZXciLCJjbGFzcyIsInRvX3Byb2MiLCJpbnNwZWN0Iiwiam9pbiIsIjxjbGFzczpVbmJvdW5kTWV0aG9kPiIsInNvdXJjZSIsIkBzb3VyY2UiLCJiaW5kIiwib2JqZWN0IiwiTWV0aG9kIiwiS2VybmVsIiwicmFpc2UiLCJUeXBlRXJyb3IiLCJiaW5kX2NhbGwiLCJhcmdzIiwiYmxvY2siXSwibWFwcGluZ3MiOiJBQUFBQSxpQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFFQUM7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDRUMsSUFBQUMsYUFBQUEsQ0FBWSxPQUFaLEVBQW9CLFVBQXBCLEVBQStCLE1BQS9CQTs7QUFFQUMsSUFBQUEsMEJBQUFBLHNCQUFlQyxRQUFELEVBQVdDLEtBQVgsRUFBa0JDLE1BQWxCLEVBQTBCQyxJQUF4Q0o7QUFBQUEsTUFBQUE7OztNQUNFSyxnQkFBWUo7TUFDWkssYUFBWUo7TUFDWkssWUFBWUg7TUFDWkosT0FBQVEsQ0FBQUEsY0FBWUwsTUFBWks7SUFKRlIsQ0FBQUE7O0FBT0FTLElBQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFELFdBQU9DLE9BQUFBLENBQUFBO0lBRFRBLENBQUFBOztBQUlBQyxJQUFBQSwwQkFBQUEsc0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFHRixXQUFRRTtJQURiQSxDQUFBQTs7QUFJQUMsSUFBQUEsK0JBQUFBLDJCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBQUFDLENBQUFBLFlBQUdKLFdBQVFHLGtCQUFYQyxDQUFBLENBQUE7UUFBQUQsT0FBQTtNQUFBO1FBQWtDQSxPQUFBLENBQUNBLFFBQUQsRUFBV0UsQ0FBWDtNQUFsQztJQURGRixDQUFBQTs7QUFJQUcsSUFBQUEsd0JBQUFBLG9CQUFBQTtBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBQUFGLENBQUFBLFlBQUdKLFdBQVFNLFdBQVhGLENBQUEsQ0FBQTtRQUFBRSxPQUFBO01BQUE7UUFBMkJBLE9BQUE7TUFBM0I7SUFERkEsQ0FBQUE7O0FBSUFDLElBQUFBLG9CQUFBQSxnQkE1QkYsRUE0QkVBO0FBQUFBLE1BQUFBOztNQUFBQTs7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RkUsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQXZFQS9COyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMDIyMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm9wYWwvcmVnZXhwX3RyYW5zcGlsZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBmcm96ZW5fc3RyaW5nX2xpdGVyYWw6IHRydWVcclxuXHJcbiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxyXG4jIHVzZV9zdHJpY3Q6IHRydWVcclxuXHJcbm1vZHVsZSBPcGFsXHJcbiAgbW9kdWxlIFJlZ2V4cFRyYW5zcGlsZXJcclxuICAgIG1vZHVsZV9mdW5jdGlvblxyXG5cclxuICAgICMgVHJhbnNmb3JtIGEgcmVndWxhciBleHByZXNzaW9uIGZyb20gUnVieSBzeW50YXggdG8gSlMgc3ludGF4LCBhcyBtdWNoXHJcbiAgICAjIGFzIHBvc3NpYmxlLlxyXG4gICAgZGVmIHRyYW5zZm9ybV9yZWdleHAob3JpZ2luYWxfcmVnZXhwLCBmbGFncylcclxuICAgICAgZmxhZ3MgfHw9ICcnXHJcblxyXG4gICAgICBpZiBpbmNsdWRlPyhmbGFncywgJ20nKVxyXG4gICAgICAgIHJ1YnlfbXVsdGlsaW5lID0gdHJ1ZVxyXG4gICAgICAgIGZsYWdzID0gcmVtb3ZlX2ZsYWcoZmxhZ3MsICdtJylcclxuICAgICAgZW5kXHJcblxyXG4gICAgICBmbGFncyA9IGFkZF9mbGFnKGZsYWdzLCAndScpICMgYWx3YXlzIGJlIHVuaWNvZGUgYXdhcmUgdG8gaGFuZGxlIHN1cnJvZ2F0ZXMgY29ycmVjdGx5XHJcblxyXG4gICAgICAjIEZpcnN0IHN0ZXAgLSBlYXN5IHJlcGxhY2VtZW50c1xyXG4gICAgICByZWdleHAgPSB0cmFuc2Zvcm1fcmVnZXhwX2J5X3JlX2FuZF9oYXNoKG9yaWdpbmFsX3JlZ2V4cCwgRVNDQVBFU19SRUdFWFAsIE9wYWw6OlJFR0VYUF9FUVVJVkFMRU5UUylcclxuXHJcbiAgICAgICMgVG9rZW5pemUgdGhlIHJlZ2V4cCBpbnRvIHRva2VucyBvZiBgW11gIGFuZCBhbnl0aGluZyBlbHNlLlxyXG4gICAgICBlc2NhcGluZyA9IGZhbHNlXHJcbiAgICAgIHN0ciA9ICcnXHJcbiAgICAgIGRlcHRoID0gMFxyXG4gICAgICBpbnNpZGUgPSBmYWxzZVxyXG4gICAgICBjdXJyX2luc2lkZSA9IGZhbHNlXHJcbiAgICAgIG5ld19yZWdleHAgPSAnJ1xyXG4gICAgICBsaW5lX2Jhc2VkX3JlZ2V4cCA9IGZhbHNlXHJcbiAgICAgIHN0cmluZ19iYXNlZF9yZWdleHAgPSBmYWxzZVxyXG4gICAgICB1bmljb2RlX2NoYXJhY3Rlcl9jbGFzcyA9IGZhbHNlXHJcbiAgICAgIHF1YW50aWZpZXIgPSBmYWxzZVxyXG5cclxuICAgICAgYXBwbHlfb3V0c2lkZV90cmFuc2Zvcm0gPSAtPiBkb1xyXG4gICAgICAgIHVubGVzcyBjdXJyX2luc2lkZVxyXG4gICAgICAgICAgc3RyID0gdHJhbnNmb3JtX3JlZ2V4cF9ieV9yZV9hbmRfaGFzaChzdHIsIE9VVFNJREVfRVNDQVBFU19SRUdFWFAsIE9wYWw6OlJFR0VYUF9FUVVJVkFMRU5UU19PVVRTSURFKVxyXG4gICAgICAgIGVuZFxyXG4gICAgICAgIG5ld19yZWdleHAgKz0gc3RyXHJcbiAgICAgIGVuZFxyXG5cclxuICAgICAgbGVuZ3RoID0gUlVCWV9FTkdJTkUgPT0gJ29wYWwnID8gYHJlZ2V4cC5sZW5ndGhgIDogcmVnZXhwLnNpemVcclxuICAgICAgaSA9IDBcclxuXHJcbiAgICAgIHdoaWxlIGkgPCBsZW5ndGhcclxuICAgICAgICBjaGFyID0gUlVCWV9FTkdJTkUgPT0gJ29wYWwnID8gYHJlZ2V4cFtpXWAgOiByZWdleHBbaV1cclxuICAgICAgICBjYXB0dXJlID0gdHJ1ZVxyXG5cclxuICAgICAgICBpZiBlc2NhcGluZ1xyXG4gICAgICAgICAgZXNjYXBpbmcgPSBmYWxzZVxyXG4gICAgICAgICAgaWYgY2hhciA9PSAnQScgfHwgY2hhciA9PSAneidcclxuICAgICAgICAgICAgc3RyaW5nX2Jhc2VkX3JlZ2V4cCA9IHRydWVcclxuICAgICAgICAgIGVsc2lmIGNoYXIgPT0gJ3AnIHx8IGNoYXIgPT0gJ1AnXHJcbiAgICAgICAgICAgIHVuaWNvZGVfY2hhcmFjdGVyX2NsYXNzID0gMVxyXG4gICAgICAgICAgZW5kXHJcbiAgICAgICAgZWxzaWYgY2hhciA9PSAnXFxcXCdcclxuICAgICAgICAgIGVzY2FwaW5nID0gdHJ1ZVxyXG4gICAgICAgIGVsc2lmIGRlcHRoID09IDAgJiYgY2hhciA9PSAnLicgJiYgcnVieV9tdWx0aWxpbmVcclxuICAgICAgICAgICMgSWYgdXNlciBoYXMgc3BlY2lmaWVkIC8vbSBtb2RpZmllciwgaXQgbWVhbnMgaXQncyBleHBlY3RlZCBmb3IgJy4nIHRvIG1hdGNoXHJcbiAgICAgICAgICAjIGFueSBjaGFyYWN0ZXIsIGluY2x1ZGluZyBuZXdsaW5lc1xyXG4gICAgICAgICAgY2hhciA9ICdbXFxzXFxTXSdcclxuICAgICAgICBlbHNpZiBkZXB0aCA9PSAwICYmIChjaGFyID09ICdeJyB8fCBjaGFyID09ICckJylcclxuICAgICAgICAgICMgTGluZSBiYXNlZCByZWdleHBcclxuICAgICAgICAgIGxpbmVfYmFzZWRfcmVnZXhwID0gdHJ1ZVxyXG4gICAgICAgIGVsc2lmIGNoYXIgPT0gJ1snXHJcbiAgICAgICAgICBkZXB0aCArPSAxXHJcbiAgICAgICAgICAjIFNraXAgYWRkaXRpb25hbCBbJ3MuIFRoaXMgaXMgaW1wb3J0YW50IGZvciBleHByZXNzaW9ucywgdGhhdCBhcmUgdmFsaWQgaW4gUnVieVxyXG4gICAgICAgICAgIyBsaWtlIFtbWzphbG51bTpdXV9dXHJcbiAgICAgICAgICBjYXB0dXJlID0gZmFsc2UgaWYgZGVwdGggPiAxXHJcbiAgICAgICAgZWxzaWYgY2hhciA9PSAnXSdcclxuICAgICAgICAgICMgU2tpcCBhZGRpdGlvbmFsIF0nc1xyXG4gICAgICAgICAgY2FwdHVyZSA9IGZhbHNlIGlmIGRlcHRoID4gMVxyXG4gICAgICAgICAgaWYgZGVwdGggPD0gMFxyXG4gICAgICAgICAgICAjIFJlLWFkZCBhIFssIHNpbmNlIGl0IGlzIHBvc3NpYmxlIGZvciB0aGF0IHRvIGhhcHBlbi5cclxuICAgICAgICAgICAgc3RyID0gJ1snICsgc3RyXHJcbiAgICAgICAgICAgIGRlcHRoID0gMFxyXG4gICAgICAgICAgZW5kXHJcbiAgICAgICAgICBkZXB0aCAtPSAxXHJcbiAgICAgICAgZWxzaWYgY2hhciA9PSAneydcclxuICAgICAgICAgICMgZXNjYXBlIHsgdG8gXFxcXHsgdW5sZXNzIGl0IGJlbG9uZ3MgdG9cclxuICAgICAgICAgICMgYSB1bmljb2RlIGNoYXJhY3RlciBjbGFzcyBcXHB7Li4ufSBvciBcXFB7Li4ufSBvclxyXG4gICAgICAgICAgIyBhIHF1YW50aWZpZXIgeHsxfSwgeHsxLH0gb3IgeHsxLDJ9XHJcbiAgICAgICAgICBpZiB1bmljb2RlX2NoYXJhY3Rlcl9jbGFzcyA9PSAxXHJcbiAgICAgICAgICAgICMgbG9vayBiZWhpbmRcclxuICAgICAgICAgICAgcHJldl9jaGFycyA9IFJVQllfRU5HSU5FID09ICdvcGFsJyA/IGByZWdleHAuc2xpY2UoaS0yKWAgOiByZWdleHBbaSAtIDIuLmkgLSAxXVxyXG4gICAgICAgICAgICBpZiBwcmV2X2NoYXJzID09ICdcXFxccCcgfHwgcHJldl9jaGFycyA9PSAnXFxcXFAnXHJcbiAgICAgICAgICAgICAgdW5pY29kZV9jaGFyYWN0ZXJfY2xhc3MgPSAyXHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICB1bmljb2RlX2NoYXJhY3Rlcl9jbGFzcyA9IGZhbHNlXHJcbiAgICAgICAgICAgICAgY2hhciA9ICdcXFxceydcclxuICAgICAgICAgICAgZW5kXHJcbiAgICAgICAgICBlbHNpZiBpID4gMFxyXG4gICAgICAgICAgICAjIGxvb2sgZm9yd2FyZFxyXG4gICAgICAgICAgICB0YWlsID0gUlVCWV9FTkdJTkUgPT0gJ29wYWwnID8gYHJlZ2V4cC5zbGljZShpKzEpYCA6IHJlZ2V4cFtpICsgMS4uXVxyXG4gICAgICAgICAgICBpZiB0YWlsID1+IC9cXEFcXGQrKCx8KVxcZCp9L1xyXG4gICAgICAgICAgICAgIHF1YW50aWZpZXIgPSB0cnVlXHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICBjaGFyID0gJ1xcXFx7J1xyXG4gICAgICAgICAgICBlbmRcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdW5pY29kZV9jaGFyYWN0ZXJfY2xhc3MgPSBmYWxzZVxyXG4gICAgICAgICAgICBxdWFudGlmaWVyID0gZmFsc2VcclxuICAgICAgICAgICAgY2hhciA9ICdcXFxceydcclxuICAgICAgICAgIGVuZFxyXG4gICAgICAgIGVsc2lmIGNoYXIgPT0gJ30nXHJcbiAgICAgICAgICAjIGVzY2FwZSB9IHRvIFxcXFx9IHVubGVzcyBpdCBiZWxvbmdzIHRvXHJcbiAgICAgICAgICAjIGEgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3MgXFxwey4uLn0gb3IgXFxQey4uLn0gb3JcclxuICAgICAgICAgICMgYSBxdWFudGlmaWVyIHh7MX0sIHh7MSx9IG9yIHh7MSwyfVxyXG4gICAgICAgICAgaWYgdW5pY29kZV9jaGFyYWN0ZXJfY2xhc3MgPT0gMlxyXG4gICAgICAgICAgICB1bmljb2RlX2NoYXJhY3Rlcl9jbGFzcyA9IGZhbHNlXHJcbiAgICAgICAgICBlbHNpZiBxdWFudGlmaWVyXHJcbiAgICAgICAgICAgIHF1YW50aWZpZXIgPSBmYWxzZVxyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB1bmljb2RlX2NoYXJhY3Rlcl9jbGFzcyA9IGZhbHNlXHJcbiAgICAgICAgICAgIHF1YW50aWZpZXIgPSBmYWxzZVxyXG4gICAgICAgICAgICBjaGFyID0gJ1xcXFx9J1xyXG4gICAgICAgICAgZW5kXHJcbiAgICAgICAgZW5kXHJcblxyXG4gICAgICAgIHN0ciArPSBjaGFyIGlmIGNhcHR1cmVcclxuXHJcbiAgICAgICAgY3Vycl9pbnNpZGUgPSBpbnNpZGVcclxuICAgICAgICBpbnNpZGUgPSBkZXB0aCA+IDBcclxuXHJcbiAgICAgICAgIyBTd2l0Y2hpbmcgYSB0b2tlblxyXG4gICAgICAgIGlmIGN1cnJfaW5zaWRlICE9IGluc2lkZVxyXG4gICAgICAgICAgIyBTaW5jZSB3ZSBhcmUgb3V0c2lkZSwgbGV0J3MgYXBwbHkgYSB0cmFuc2Zvcm1hdGlvblxyXG4gICAgICAgICAgYXBwbHlfb3V0c2lkZV90cmFuc2Zvcm0uY2FsbFxyXG4gICAgICAgICAgc3RyID0gJydcclxuICAgICAgICBlbmRcclxuXHJcbiAgICAgICAgaSArPSAxXHJcbiAgICAgIGVuZFxyXG5cclxuICAgICAgYXBwbHlfb3V0c2lkZV90cmFuc2Zvcm0uY2FsbFxyXG5cclxuICAgICAgIyBTZXQgbXVsdGlsaW5lIGZsYWcgdG8gZGVub3RlIHRoYXQgXiBhbmQgJCBzaG91bGQgbWF0Y2ggYm90aCBhdCBib3JkZXJzIG9mIGZpbGVcclxuICAgICAgIyBhbmQgYXQgdGhlIGJvcmRlcnMgb2YgbGluZS4gVGhpcyB3aWxsIGJyZWFrIGlmIGJvdGggXFxBIGFuZCBeIGFyZSB1c2VkIGluIGEgc2luZ2xlXHJcbiAgICAgICMgcmVnZXhwLlxyXG4gICAgICBmbGFncyA9IGFkZF9mbGFnKGZsYWdzLCAnbScpIGlmIGxpbmVfYmFzZWRfcmVnZXhwXHJcblxyXG4gICAgICAjIExldCdzIGNoZWNrIGZvciB0aGlzIGNhc2UgYW5kIHdhcm4gYXBwcm9wcmlhdGVseVxyXG4gICAgICBpZiBsaW5lX2Jhc2VkX3JlZ2V4cCAmJiBzdHJpbmdfYmFzZWRfcmVnZXhwXHJcbiAgICAgICAgd2FybiBcIndhcm5pbmc6IEJvdGggXFxcXEEgb3IgXFxcXHogYW5kIF4gb3IgJCB1c2VkIGluIGEgcmVnZXhwICN7b3JpZ2luYWxfcmVnZXhwLmluc3BlY3R9LiBJbiBPcGFsIHRoaXMgd2lsbCBjYXVzZSB1bmRlZmluZWQgYmVoYXZpb3IuXCJcclxuICAgICAgZW5kXHJcblxyXG4gICAgICBbbmV3X3JlZ2V4cCwgZmxhZ3NdXHJcbiAgICBlbmRcclxuXHJcbiAgICBpZiBSVUJZX0VOR0lORSA9PSAnb3BhbCdcclxuICAgICAgIyBydWJvY29wOiBkaXNhYmxlIExpbnQvVW51c2VkTWV0aG9kQXJndW1lbnRcclxuXHJcbiAgICAgICMgT3B0aW1pemVkIHZlcnNpb24gb2YgaGVscGVyIGZ1bmN0aW9ucywgc2tpcHBpbmcgdGhlIGVudGlyZSBTdHJpbmcjZ3N1YiBzaGVuYW5pZ2Fuc1xyXG4gICAgICAjIGFuZCBhbGxvd2luZyB0byBiZSB1c2VkIGVhcmx5IGluIHRoZSBib290c3RhZ2UuXHJcbiAgICAgIGRlZiB0cmFuc2Zvcm1fcmVnZXhwX2J5X3JlX2FuZF9oYXNoKHJlZ2V4cCwgdHJhbnNmb3JtZXIsIGhhc2gpXHJcbiAgICAgICAgJXh7XHJcbiAgICAgICAgICByZXR1cm4gcmVnZXhwLnJlcGxhY2UodHJhbnNmb3JtZXIsIGZ1bmN0aW9uKGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhc2guZ2V0KGkpIHx8IGk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIGVuZFxyXG5cclxuICAgICAgZGVmIGFkZF9mbGFnKGZsYWdzLCBmbGFnKVxyXG4gICAgICAgIGBmbGFncy5pbmNsdWRlcyhmbGFnKSA/IGZsYWdzIDogZmxhZ3MgKyBmbGFnYFxyXG4gICAgICBlbmRcclxuXHJcbiAgICAgIGRlZiByZW1vdmVfZmxhZyhmbGFncywgZmxhZylcclxuICAgICAgICBgZmxhZ3MucmVwbGFjZShmbGFnLCAnJylgXHJcbiAgICAgIGVuZFxyXG5cclxuICAgICAgIyBBcmUgd2Ugc3VyZSB0aGUgcmVnZXhwIGlzIG5vdCB1c2luZyBVVEYtMTYgZmVhdHVyZXM/XHJcbiAgICAgICMgVGhpcyBpcyBhIGNydWRlIGNoZWNrLlxyXG4gICAgICBkZWYgc2ltcGxlX3JlZ2V4cD8ocmVnZXhwKVxyXG4gICAgICAgIGAvXihcXFxcW2RucnRBelpcXFxcXXxcXChcXD9bOiFdfFtcXHdcXHMoKXt9fD8rKkBeJC1dKSokLy50ZXN0KHJlZ2V4cClgXHJcbiAgICAgIGVuZFxyXG5cclxuICAgICAgZGVmIGluY2x1ZGU/KHN0ciwgbmVlZGxlKVxyXG4gICAgICAgIGBzdHIuaW5jbHVkZXMobmVlZGxlKWBcclxuICAgICAgZW5kXHJcblxyXG4gICAgICAjIHJ1Ym9jb3A6ZGlzYWJsZSBTdHlsZS9NdXRhYmxlQ29uc3RhbnRcclxuICAgICAgRVNDQVBFU19SRUdFWFAgPSBgLyhcXFxcLnxcXFs6W2Etel0qOlxcXSkvZ2BcclxuICAgICAgT1VUU0lERV9FU0NBUEVTX1JFR0VYUCA9IGAvKFxcXFwuKS9nYFxyXG4gICAgICAjIHJ1Ym9jb3A6ZW5hYmxlIFN0eWxlL011dGFibGVDb25zdGFudCwgTGludC9VbnVzZWRNZXRob2RBcmd1bWVudFxyXG4gICAgZWxzZVxyXG5cclxuICAgICAgcHJpdmF0ZVxyXG5cclxuICAgICAgZGVmIHRyYW5zZm9ybV9yZWdleHBfYnlfcmVfYW5kX2hhc2gocmVnZXhwLCB0cmFuc2Zvcm1lciwgaGFzaClcclxuICAgICAgICByZWdleHAuZ3N1Yih0cmFuc2Zvcm1lcikgZG8gfGl8XHJcbiAgICAgICAgICBoYXNoW2ldIHx8IGlcclxuICAgICAgICBlbmRcclxuICAgICAgZW5kXHJcblxyXG4gICAgICBkZWYgYWRkX2ZsYWcoZmxhZ3MsIGZsYWcpXHJcbiAgICAgICAgZmxhZ3MuaW5jbHVkZT8oZmxhZykgPyBmbGFncyA6IGZsYWdzICsgZmxhZ1xyXG4gICAgICBlbmRcclxuXHJcbiAgICAgIGRlZiByZW1vdmVfZmxhZyhmbGFncywgZmxhZylcclxuICAgICAgICBmbGFncy5zdWIoZmxhZywgJycpXHJcbiAgICAgIGVuZFxyXG5cclxuICAgICAgIyBBcmUgd2Ugc3VyZSB0aGUgcmVnZXhwIGlzIG5vdCB1c2luZyBVVEYtMTYgZmVhdHVyZXM/XHJcbiAgICAgICMgVE9ETzogVGhpcyBpcyBhIGNydWRlIGNoZWNrLiBSZXZpc2l0IGluIHRoZSBmdXR1cmUuXHJcbiAgICAgIGRlZiBzaW1wbGVfcmVnZXhwPyhyZWdleHApXHJcbiAgICAgICAgL1xcQShcXFxcW2RucnRBelpcXFxcXXxcXChcXD9bOiFdfFtcXHdcXHMoKXt9fD8rKkBeJC1dKSpcXHovLm1hdGNoPyhyZWdleHApXHJcbiAgICAgIGVuZFxyXG5cclxuICAgICAgZGVmIGluY2x1ZGU/KHN0ciwgbmVlZGxlKVxyXG4gICAgICAgIHN0ci5pbmNsdWRlPyhuZWVkbGUpXHJcbiAgICAgIGVuZFxyXG5cclxuICAgICAgRVNDQVBFU19SRUdFWFAgPSAvKFxcXFwufFxcWzpbYS16XSo6XFxdKS9cclxuICAgICAgT1VUU0lERV9FU0NBUEVTX1JFR0VYUCA9IC8oXFxcXC4pL1xyXG4gICAgZW5kXHJcbiAgZW5kXHJcbmVuZFxyXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6T3BhbD4iLCI8bW9kdWxlOlJlZ2V4cFRyYW5zcGlsZXI+Iiwic2VsZiIsIm1vZHVsZV9mdW5jdGlvbiIsInRyYW5zZm9ybV9yZWdleHAiLCJvcmlnaW5hbF9yZWdleHAiLCJmbGFncyIsIiRyZXRfb3JfMSIsImluY2x1ZGU/IiwicnVieV9tdWx0aWxpbmUiLCJyZW1vdmVfZmxhZyIsImFkZF9mbGFnIiwicmVnZXhwIiwidHJhbnNmb3JtX3JlZ2V4cF9ieV9yZV9hbmRfaGFzaCIsIkVTQ0FQRVNfUkVHRVhQIiwiT3BhbDo6UkVHRVhQX0VRVUlWQUxFTlRTIiwiT3BhbCIsImVzY2FwaW5nIiwic3RyIiwiZGVwdGgiLCIwIiwiaW5zaWRlIiwiY3Vycl9pbnNpZGUiLCJuZXdfcmVnZXhwIiwibGluZV9iYXNlZF9yZWdleHAiLCJzdHJpbmdfYmFzZWRfcmVnZXhwIiwidW5pY29kZV9jaGFyYWN0ZXJfY2xhc3MiLCJxdWFudGlmaWVyIiwiYXBwbHlfb3V0c2lkZV90cmFuc2Zvcm0iLCJibG9jayBpbiB0cmFuc2Zvcm1fcmVnZXhwIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0cmFuc2Zvcm1fcmVnZXhwIiwiT1VUU0lERV9FU0NBUEVTX1JFR0VYUCIsIk9wYWw6OlJFR0VYUF9FUVVJVkFMRU5UU19PVVRTSURFIiwiKyIsImxlbmd0aCIsImkiLCI8IiwiY2hhciQiLCJjYXB0dXJlIiwiMSIsIj4iLCI8PSIsIi0iLCJwcmV2X2NoYXJzIiwiMiIsInRhaWwiLCI9fiIsImNhbGwiLCJ3YXJuIiwiaW5zcGVjdCIsInRyYW5zZm9ybWVyIiwiaGFzaCIsImZsYWciLCJzaW1wbGVfcmVnZXhwPyIsIm5lZWRsZSJdLCJtYXBwaW5ncyI6IkFBQUFBLHlDQUFBQSxnQkFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBO0VBS0FBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUM7SUFBQUE7O01BQUFBOzs7TUFDRUMsSUFBQUMsaUJBQUFBLENBQUFBOztBQUlBQyxNQUFBQSxnQ0FBQUEsNEJBQXFCQyxlQUFELEVBQWtCQyxLQUF0Q0Y7QUFBQUEsUUFBQUE7OztRQUNFRSxRQVpOLENBQUEsUUFBQUMsQ0FBQUEsWUFZTUQsS0FaTkMsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxTQUFBLElBQUEsQ0FZZ0JILEVBWmhCLENBQUE7UUFjTSxJQUFBLFFBQUdGLElBQUFNLGFBQUFBLENBQVNGLEtBQVQsRUFBZ0JGLEdBQWhCSSxDQUFILENBQUE7O1VBQ0VDLGlCQUFpQjtVQUNqQkgsUUFBUUosSUFBQVEsYUFBQUEsQ0FBWUosS0FBWixFQUFtQkYsR0FBbkJNO1FBRlY7UUFLQUosUUFBUUosSUFBQVMsVUFBQUEsQ0FBU0wsS0FBVCxFQUFnQkYsR0FBaEJPO1FBR1JDLFNBQVNWLElBQUFXLGlDQUFBQSxDQUFnQ1IsZUFBaEMsRUFBaURTLG9CQUFqRCxFQUFpRUMsSUFBQUMsVUFBQUQsdUJBQWpFRjtRQUdUSSxXQUFXO1FBQ1hDLE1BQU1kO1FBQ05lLFFBQVFDO1FBQ1JDLFNBQVM7UUFDVEMsY0FBYztRQUNkQyxhQUFhbkI7UUFDYm9CLG9CQUFvQjtRQUNwQkMsc0JBQXNCO1FBQ3RCQywwQkFBMEI7UUFDMUJDLGFBQWE7UUFFYkMsMEJBQTBCLFFBQUFDLGFBQUFBLEVBQUFDOzs7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RU5BO0FBQ0FBO0FBQ0FBO0FBQ0FBO01BTE1BLENBQUFBOztBQVFBRixNQUFBQSx3QkFBQUEsb0JBQWFMLEtBQUQsRUFBUThDLElBQXBCekM7QUFBQUE7UUFDRUEsT0FBQ0EsMkNBQURBO01BREZBLENBQUFBOztBQUlBRCxNQUFBQSwyQkFBQUEsdUJBQWdCSixLQUFELEVBQVE4QyxJQUF2QjFDO0FBQUFBO1FBQ0VBLE9BQUNBLHVCQUFEQTtNQURGQSxDQUFBQTs7QUFNQTJDLE1BQUFBLDhCQUFBQSxnREFBbUJ6QyxNQUFuQnlDO0FBQUFBO1FBQ0VBLE9BQUNBLDZEQUFEQTtNQURGQSxDQUFBQTs7QUFJQTdDLE1BQUFBLHdCQUFBQSwwQ0FBYVUsR0FBRCxFQUFNb0MsTUFBbEI5QztBQUFBQTtRQUNFQSxPQUFDQSxvQkFBREE7TUFERkEsQ0FBQUE7TUFLQSwwQ0FBa0JQLHFCQUFsQjtNQUNBQSxPQUFBLGtEQUEwQkEsUUFBMUI7SUFsTEpBLEdBQUFBLFdBQUFBO0VBREZELEdBQUFBLFdBQUFBO0FBTEFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMDQwMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm9wYWwvcmVnZXhwX2FuY2hvcnMucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBmcm96ZW5fc3RyaW5nX2xpdGVyYWw6IHRydWVcclxuXHJcbm1vZHVsZSBPcGFsXHJcbiAgIyBydWJvY29wOmRpc2FibGUgU3R5bGUvTXV0YWJsZUNvbnN0YW50XHJcbiAgc2VsZjo6UkVHRVhQX1NUQVJUID0gJ1xcQSdcclxuICBzZWxmOjpSRUdFWFBfRU5EID0gJ1xceidcclxuXHJcbiAgIyBVbmljb2RlIGNoYXJhY3RlcnMgaW4gcmFuZ2VzXHJcbiAgIyBcXHUwMDAxIC0gXFx1MDAyRiAoYmxhbmsgdW5pY29kZSBjaGFyYWN0ZXJzICsgc3BhY2UgKyAhXCIjJCUmJygpKissLS4vIGNoYXJzKVxyXG4gICMgXFx1MDAzQSAtIFxcdTAwNDAgKDo7PD0+P0AgY2hhcnMpXHJcbiAgIyBcXHUwMDVCIC0gXFx1MDA1RSAoW1xcXV4gY2hhcnMpXHJcbiAgIyBcXHUwMDYwICAgICAgICAgIChgIGNoYXIpXHJcbiAgIyBcXHUwMDdCIC0gXFx1MDA3RiAoe3x9fiBjaGFyc30pXHJcbiAgIyBhcmUgbm90IGFsbG93ZWQgdG8gYmUgdXNlZCBpbiBpZGVudGlmaWVyIGluIHRoZSBiZWdnaW5pbmcgb3IgbWlkZGxlIG9mIGl0cyBuYW1lXHJcbiAgc2VsZjo6Rk9SQklEREVOX1NUQVJUSU5HX0lERU5USUZJRVJfQ0hBUlMgPSAnXFx1MDAwMS1cXHUwMDJGXFx1MDAzQS1cXHUwMDQwXFx1MDA1Qi1cXHUwMDVFXFx1MDA2MFxcdTAwN0ItXFx1MDA3RidcclxuXHJcbiAgIyBBIG1hcCBvZiBzb21lIFJ1YnkgcmVnZXhwIHBhdHRlcm5zIHRvIHRoZWlyIEpTIHJlcHJlc2VudGF0aW9uc1xyXG4gIHNlbGY6OlJFR0VYUF9FUVVJVkFMRU5UUyA9IHtcclxuICAgICdcXGgnID0+ICdbXFxkQS1GYS1mXScsXHJcbiAgICAnXFxlJyA9PiAnXFx4MWInLFxyXG5cclxuICAgICMgSW52YWxpZCBjYXNlcyBpbiBKUyBVbmljb2RlIG1vZGVcclxuICAgICdcXF8nID0+ICdfJyxcclxuICAgICdcXH4nID0+ICd+JyxcclxuICAgICdcXCMnID0+ICcjJyxcclxuICAgICdcXFxcXFwnJyA9PiBcIidcIixcclxuICAgICdcXFwiJyA9PiAnXCInLFxyXG4gICAgJ1xcICcgPT4gJyAnLFxyXG4gICAgJ1xcPScgPT4gJz0nLFxyXG4gICAgJ1xcIScgPT4gJyEnLFxyXG4gICAgJ1xcJScgPT4gJyUnLFxyXG4gICAgJ1xcJicgPT4gJyYnLFxyXG4gICAgJ1xcPCcgPT4gJzwnLFxyXG4gICAgJ1xcPicgPT4gJz4nLFxyXG4gICAgJ1xcQCcgPT4gJ0AnLFxyXG4gICAgJ1xcOicgPT4gJzonLFxyXG4gICAgJ1xcYCcgPT4gJ2AnLFxyXG5cclxuICAgICMgUE9TSVggY2xhc3Nlc1xyXG4gICAgJ1s6YWxudW06XScgPT4gJ1xccHtBbHBoYWJldGljfVxccHtOdW1iZXJ9JywgICAjIEFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzXHJcbiAgICAnWzphbHBoYTpdJyA9PiAnXFxwe0FscGhhYmV0aWN9JywgICAgICAgICAgICAgIyBBbHBoYWJldGljIGNoYXJhY3RlcnNcclxuICAgICdbOmJsYW5rOl0nID0+ICdcXHB7U3BhY2VfU2VwYXJhdG9yfVxcdCcsICAgICAgIyBTcGFjZSBhbmQgdGFiXHJcbiAgICAnWzpjbnRybDpdJyA9PiAnXFxwe0NvbnRyb2x9JywgICAgICAgICAgICAgICAgIyBDb250cm9sIGNoYXJhY3RlcnNcclxuICAgICdbOmRpZ2l0Ol0nID0+ICdcXGQnLCAgICAgICAgICAgICAgICAgICAgICAgICAjIERpZ2l0c1xyXG4gICAgJ1s6Z3JhcGg6XScgPT4gJ1xccHtBbHBoYWJldGljfVxccHtOdW1iZXJ9XFxwe1B1bmN0dWF0aW9ufVxccHtTeW1ib2x9JywgIyBWaXNpYmxlIGNoYXJhY3RlcnNcclxuICAgICdbOmxvd2VyOl0nID0+ICdcXHB7TG93ZXJjYXNlX0xldHRlcn0nLCAjIExvd2VyY2FzZSBsZXR0ZXJzXHJcbiAgICAnWzpwcmludDpdJyA9PiAnXFxwe0FscGhhYmV0aWN9XFxwe051bWJlcn1cXHB7UHVuY3R1YXRpb259XFxwe1N5bWJvbH1cXHB7U3BhY2VfU2VwYXJhdG9yfScsICMgVmlzaWJsZSBjaGFyYWN0ZXJzIGFuZCBzcGFjZXNcclxuICAgICdbOnB1bmN0Ol0nID0+ICdcXHB7UHVuY3R1YXRpb259JywgICAgICAgICAgICAjIFB1bmN0dWF0aW9uIGNoYXJhY3RlcnNcclxuICAgICdbOnNwYWNlOl0nID0+ICdcXHB7V2hpdGVfU3BhY2V9JywgICAgICAgICAgICAjIFdoaXRlc3BhY2UgY2hhcmFjdGVyc1xyXG4gICAgJ1s6dXBwZXI6XScgPT4gJ1xccHtVcHBlcmNhc2VfTGV0dGVyfScsICAgICAgICMgVXBwZXJjYXNlIGxldHRlcnNcclxuICAgICdbOnhkaWdpdDpdJyA9PiAnXFxkQS1GYS1mJywgICAgICAgICAgICAgICAgICAjIEhleGFkZWNpbWFsIGRpZ2l0c1xyXG4gIH1cclxuXHJcbiAgIyBBIG1hcCBvZiBzb21lIFJ1YnkgcmVnZXhwIHBhdHRlcm5zIHRvIHRoZWlyIEpTIHJlcHJlc2VudGF0aW9ucywgYnV0IHRoaXMgc2V0IG9mXHJcbiAgIyByZXByZXNlbnRhdGlvbnMgaXMgb25seSBhcHBsaWVkIG91dHNpZGUgb2YgYFtgIGFuZCBgXWAuXHJcbiAgc2VsZjo6UkVHRVhQX0VRVUlWQUxFTlRTX09VVFNJREUgPSB7XHJcbiAgICAnXFxBJyA9PiAnXicsXHJcbiAgICAnXFx6JyA9PiAnJCcsXHJcbiAgICAnXFxaJyA9PiAnKD86XFxuPyQpJyxcclxuICAgICdcXC0nID0+ICctJyxcclxuICAgICdcXFInID0+ICcoPzpcXHJ8XFxufFxcclxcbnxcXGZ8XFx1MDA4NXxcXHUyMDI4fFxcdTIwMjkpJyxcclxuICB9XHJcblxyXG4gICMgVW5pY29kZSBjaGFyYWN0ZXJzIGluIHJhbmdlc1xyXG4gICMgXFx1MDAwMSAtIFxcdTAwMjAgKGJsYW5rIHVuaWNvZGUgY2hhcmFjdGVycyArIHNwYWNlKVxyXG4gICMgXFx1MDAyMiAtIFxcdTAwMkYgKFwiIyQlJicoKSorLC0uLyBjaGFycylcclxuICAjIFxcdTAwM0EgLSBcXHUwMDNFICg6Ozw9PiBjaGFycylcclxuICAjIFxcdTAwNDAgICAgICAgICAgKEAgY2hhcilcclxuICAjIFxcdTAwNUIgLSBcXHUwMDVFIChbXFxdXiBjaGFycylcclxuICAjIFxcdTAwNjAgICAgICAgICAgKGAgY2hhcilcclxuICAjIFxcdTAwN0IgLSBcXHUwMDdGICh7fH1+IGNoYXJzfSlcclxuICAjIGFyZSBub3QgYWxsb3dlZCB0byBiZSB1c2VkIGluIGlkZW50aWZpZXIgaW4gdGhlIGVuZCBvZiBpdHMgbmFtZVxyXG4gICMgSW4gZmFjdCwgRk9SQklEREVOX1NUQVJUSU5HX0lERU5USUZJRVJfQ0hBUlMgPSBGT1JCSURERU5fRU5ESU5HX0lERU5USUZJRVJfQ0hBUlMgKyBcXHUwMDIxICgnPycpICsgXFx1MDAzRiAoJyEnKVxyXG4gIHNlbGY6OkZPUkJJRERFTl9FTkRJTkdfSURFTlRJRklFUl9DSEFSUyA9ICdcXHUwMDAxLVxcdTAwMjBcXHUwMDIyLVxcdTAwMkZcXHUwMDNBLVxcdTAwM0VcXHUwMDQwXFx1MDA1Qi1cXHUwMDVFXFx1MDA2MFxcdTAwN0ItXFx1MDA3RidcclxuICBzZWxmOjpJTkxJTkVfSURFTlRJRklFUl9SRUdFWFAgPSBSZWdleHAubmV3KFwiW14je3NlbGY6OkZPUkJJRERFTl9TVEFSVElOR19JREVOVElGSUVSX0NIQVJTfV0qW14je3NlbGY6OkZPUkJJRERFTl9FTkRJTkdfSURFTlRJRklFUl9DSEFSU31dXCIpXHJcblxyXG4gICMgRm9yIGNvbnN0YW50cyBydWxlcyBhcmUgcHJldHR5IG11Y2ggdGhlIHNhbWUsIGJ1dCAnOicgaXMgYWxsb3dlZCBhbmQgJz8hJyBhcmUgbm90LlxyXG4gICMgUGx1cyBpdCBtYXkgc3RhcnQgd2l0aCBhICc6Oicgd2hpY2ggaW5kaWNhdGVzIHRoYXQgdGhlIGNvbnN0YW50IGNvbWVzIGZyb20gdG9wbGV2ZWwuXHJcbiAgc2VsZjo6Rk9SQklEREVOX0NPTlNUX05BTUVfQ0hBUlMgPSAnXFx1MDAwMS1cXHUwMDIwXFx1MDAyMS1cXHUwMDJGXFx1MDAzQi1cXHUwMDNGXFx1MDA0MFxcdTAwNUItXFx1MDA1RVxcdTAwNjBcXHUwMDdCLVxcdTAwN0YnXHJcbiAgc2VsZjo6Q09OU1RfTkFNRV9SRUdFWFAgPSBSZWdleHAubmV3KFwiI3tzZWxmOjpSRUdFWFBfU1RBUlR9KDo6KT9bQS1aXVteI3tzZWxmOjpGT1JCSURERU5fQ09OU1RfTkFNRV9DSEFSU31dKiN7c2VsZjo6UkVHRVhQX0VORH1cIilcclxuICAjIHJ1Ym9jb3A6ZW5hYmxlIFN0eWxlL011dGFibGVDb25zdGFudFxyXG5lbmRcclxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOk9wYWw+Iiwic2VsZiIsIlJlZ2V4cCIsIm5ldyIsInNlbGY6OkZPUkJJRERFTl9TVEFSVElOR19JREVOVElGSUVSX0NIQVJTIiwic2VsZjo6Rk9SQklEREVOX0VORElOR19JREVOVElGSUVSX0NIQVJTIiwic2VsZjo6UkVHRVhQX1NUQVJUIiwic2VsZjo6Rk9SQklEREVOX0NPTlNUX05BTUVfQ0hBUlMiLCJzZWxmOjpSRUdFWFBfRU5EIl0sIm1hcHBpbmdzIjoiQUFBQUEsc0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7SUFFRSxXQUFBQyxJQUFBLGtCQUFxQkQsS0FBckI7SUFDQSxXQUFBQyxJQUFBLGdCQUFtQkQsS0FBbkI7SUFTQSxXQUFBQyxJQUFBLHlDQUE0Q0QscUVBQTVDO0lBR0EsV0FBQUMsSUFBQSx3QkFBMkIsVUFBQSxLQUFBLEVBQ2pCRCxhQURpQixFQUFBLEtBQUEsRUFFakJBLE9BRmlCLEVBQUEsS0FBQSxFQUtqQkEsR0FMaUIsRUFBQSxLQUFBLEVBTWpCQSxHQU5pQixFQUFBLEtBQUEsRUFPakJBLEdBUGlCLEVBQUEsS0FBQSxFQVFmQSxHQVJlLEVBQUEsTUFBQSxFQVNqQkEsSUFUaUIsRUFBQSxLQUFBLEVBVWpCQSxHQVZpQixFQUFBLEtBQUEsRUFXakJBLEdBWGlCLEVBQUEsS0FBQSxFQVlqQkEsR0FaaUIsRUFBQSxLQUFBLEVBYWpCQSxHQWJpQixFQUFBLEtBQUEsRUFjakJBLEdBZGlCLEVBQUEsS0FBQSxFQWVqQkEsR0FmaUIsRUFBQSxLQUFBLEVBZ0JqQkEsR0FoQmlCLEVBQUEsS0FBQSxFQWlCakJBLEdBakJpQixFQUFBLEtBQUEsRUFrQmpCQSxHQWxCaUIsRUFBQSxLQUFBLEVBbUJqQkEsR0FuQmlCLEVBQUEsV0FBQSxFQXNCVkEsNEJBdEJVLEVBQUEsV0FBQSxFQXVCVkEsaUJBdkJVLEVBQUEsV0FBQSxFQXdCVkEseUJBeEJVLEVBQUEsV0FBQSxFQXlCVkEsY0F6QlUsRUFBQSxXQUFBLEVBMEJWQSxLQTFCVSxFQUFBLFdBQUEsRUEyQlZBLHVEQTNCVSxFQUFBLFdBQUEsRUE0QlZBLHVCQTVCVSxFQUFBLFdBQUEsRUE2QlZBLDJFQTdCVSxFQUFBLFdBQUEsRUE4QlZBLGtCQTlCVSxFQUFBLFdBQUEsRUErQlZBLGtCQS9CVSxFQUFBLFdBQUEsRUFnQ1ZBLHVCQWhDVSxFQUFBLFlBQUEsRUFpQ1RBLFdBakNTLENBQTNCO0lBc0NBLFdBQUFDLElBQUEsZ0NBQW1DLFVBQUEsS0FBQSxFQUN6QkQsR0FEeUIsRUFBQSxLQUFBLEVBRXpCQSxHQUZ5QixFQUFBLEtBQUEsRUFHekJBLFdBSHlCLEVBQUEsS0FBQSxFQUl6QkEsR0FKeUIsRUFBQSxLQUFBLEVBS3pCQSxnREFMeUIsQ0FBbkM7SUFrQkEsV0FBQUMsSUFBQSx1Q0FBMENELDJGQUExQztJQUNBLFdBQUFDLElBQUEsOEJBQWlDQyxZQUFNQyxLQUFBQSxDQUFNSCxJQUFELEdBQUEsTUFBS0ksSUFBQUgsSUFBQUcsd0NBQUwsQ0FBQSxHQUErQ0osTUFBL0MsR0FBQSxNQUFxREssSUFBQUosSUFBQUksc0NBQXJELENBQUEsR0FBNkZMLEdBQWxHRyxDQUF2QztJQUlBLFdBQUFGLElBQUEsZ0NBQW1DRCwyRkFBbkM7SUFDQUEsT0FBQSxXQUFBQyxJQUFBLHVCQUEwQkMsWUFBTUMsS0FBQUEsQ0FBSyxNQUFHRyxJQUFBTCxJQUFBSyxpQkFBSCxDQUFBLEdBQXNCTixjQUF0QixHQUFBLE1BQW9DTyxJQUFBTixJQUFBTSwrQkFBcEMsQ0FBQSxHQUFxRVAsSUFBckUsR0FBQSxNQUF5RVEsSUFBQVAsSUFBQU8sZUFBekUsQ0FBTEwsQ0FBaEM7RUE3RUZILEdBQUFBLFdBQUFBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMDQyMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvdmFyaWFibGVzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxyXG4jIHVzZV9zdHJpY3Q6IHRydWVcclxuXHJcbiMgcmVnZXhwIG1hdGNoZXNcclxuJXh7JGd2YXJzWycmJ10gPSAkZ3ZhcnNbJ34nXSA9ICRndmFyc1snYCddID0gJGd2YXJzW1wiJ1wiXSA9IG5pbH1cclxuXHJcbiMgcmVxdWlyZXNcclxuJExPQURFRF9GRUFUVVJFUyA9ICRcIiA9IGBPcGFsLmxvYWRlZF9mZWF0dXJlc2BcclxuJExPQURfUEFUSCAgICAgICA9ICQ6ID0gW11cclxuXHJcbiMgc3BsaXQgbGluZXNcclxuJC8gPSBcIlxcblwiXHJcbiQsID0gbmlsXHJcblxyXG46OkFSR1YgPSBbXVxyXG46OkFSR0YgPSA6Ok9iamVjdC5uZXdcclxuOjpFTlYgID0ge31cclxuXHJcbiRWRVJCT1NFID0gZmFsc2VcclxuJERFQlVHICAgPSBmYWxzZVxyXG4kU0FGRSAgICA9IDBcclxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCIkTE9BREVEX0ZFQVRVUkVTIiwiJFwiIiwiJExPQURfUEFUSCIsIiQ6IiwiJC8iLCIkLCIsIk9iamVjdCIsIm5ldyIsIiRWRVJCT1NFIiwiJERFQlVHIiwiJFNBRkUiLCIwIl0sIm1hcHBpbmdzIjoiQUFBQUEsb0NBQUFBLGdCQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7O0VBSUdBO0VBR0hDLHlCQUFtQkMsQ0FBQUEsZUFBTUYsb0JBQU5FO0VBQ25CQyxtQkFBbUJDLENBQUFBLGNBQUssRUFBTEE7RUFHbkJDLGNBQUtMO0VBQ0xNLGNBQUs7RUFFTCxXQUFBLElBQUEsVUFBUyxFQUFUO0VBQ0EsV0FBQSxJQUFBLFVBQVNDLE9BQVFDLEtBQUFBLENBQUFBLENBQWpCO0VBQ0EsV0FBQSxJQUFBLFNBQVMsV0FBVDtFQUVBQyxpQkFBVztFQUNYQyxlQUFXO0VBQ1hWLE9BQUFXLENBQUFBLGNBQVdDLENBQVhEO0FBcEJBWDsifX0seyJvZmZzZXQiOnsibGluZSI6MjA0NDIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3N0cmluZy9lbmNvZGluZy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcclxuIyBoZWxwZXJzOiBnbG9iYWxfcmVnZXhwXHJcblxyXG5jbGFzcyA6OkVuY29kaW5nXHJcbiAgY2xhc3MgPDwgc2VsZlxyXG4gICAgZGVmIHJlZ2lzdGVyKG5hbWUsIG9wdGlvbnMgPSB7fSwgJmJsb2NrKVxyXG4gICAgICBuYW1lcyA9IFtuYW1lXSArIChvcHRpb25zWzphbGlhc2VzXSB8fCBbXSlcclxuICAgICAgYXNjaWkgPSBvcHRpb25zWzphc2NpaV0gfHwgZmFsc2VcclxuICAgICAgZHVtbXkgPSBvcHRpb25zWzpkdW1teV0gfHwgZmFsc2VcclxuXHJcbiAgICAgIGlmIG9wdGlvbnNbOmluaGVyaXRzXVxyXG4gICAgICAgIGVuY29kaW5nID0gb3B0aW9uc1s6aW5oZXJpdHNdLmNsb25lXHJcbiAgICAgICAgZW5jb2RpbmcuaW5pdGlhbGl6ZShuYW1lLCBuYW1lcywgYXNjaWksIGR1bW15KVxyXG4gICAgICBlbHNlXHJcbiAgICAgICAgZW5jb2RpbmcgPSBuZXcobmFtZSwgbmFtZXMsIGFzY2lpLCBkdW1teSlcclxuICAgICAgZW5kXHJcbiAgICAgIGVuY29kaW5nLmluc3RhbmNlX2V2YWwoJmJsb2NrKSBpZiBibG9ja19naXZlbj9cclxuXHJcbiAgICAgIHJlZ2lzdGVyID0gYE9wYWwuZW5jb2RpbmdzYFxyXG4gICAgICBuYW1lcy5lYWNoIGRvIHxlbmNvZGluZ19uYW1lfFxyXG4gICAgICAgIGNvbnN0X3NldCBlbmNvZGluZ19uYW1lLnRyKCctJywgJ18nKSwgZW5jb2RpbmdcclxuICAgICAgICByZWdpc3Rlci5KU1tlbmNvZGluZ19uYW1lXSA9IGVuY29kaW5nXHJcbiAgICAgIGVuZFxyXG4gICAgZW5kXHJcblxyXG4gICAgZGVmIGZpbmQobmFtZSlcclxuICAgICAgcmV0dXJuIGRlZmF1bHRfZXh0ZXJuYWwgaWYgbmFtZSA9PSA6ZGVmYXVsdF9leHRlcm5hbFxyXG4gICAgICBgcmV0dXJuIE9wYWwuZmluZF9lbmNvZGluZyhuYW1lKWBcclxuICAgIGVuZFxyXG5cclxuICAgIGF0dHJfYWNjZXNzb3IgOmRlZmF1bHRfZXh0ZXJuYWwsIDpkZWZhdWx0X2ludGVybmFsXHJcbiAgZW5kXHJcblxyXG4gIGF0dHJfcmVhZGVyIDpuYW1lLCA6bmFtZXNcclxuXHJcbiAgZGVmIGluaXRpYWxpemUobmFtZSwgbmFtZXMsIGFzY2lpLCBkdW1teSlcclxuICAgIEBuYW1lICA9IG5hbWVcclxuICAgIEBuYW1lcyA9IG5hbWVzXHJcbiAgICBAYXNjaWkgPSBhc2NpaVxyXG4gICAgQGR1bW15ID0gZHVtbXlcclxuICBlbmRcclxuXHJcbiAgZGVmIGFzY2lpX2NvbXBhdGlibGU/XHJcbiAgICBAYXNjaWlcclxuICBlbmRcclxuXHJcbiAgZGVmIGR1bW15P1xyXG4gICAgQGR1bW15XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBiaW5hcnk/XHJcbiAgICBmYWxzZVxyXG4gIGVuZFxyXG5cclxuICBkZWYgdG9fc1xyXG4gICAgQG5hbWVcclxuICBlbmRcclxuXHJcbiAgZGVmIGluc3BlY3RcclxuICAgIFwiIzxFbmNvZGluZzoje0BuYW1lfSN7JyAoZHVtbXkpJyBpZiBAZHVtbXl9PlwiXHJcbiAgZW5kXHJcblxyXG4gICMgbWV0aG9kcyB0byBpbXBsZW1lbnQgcGVyIGVuY29kaW5nXHJcblxyXG4gIGRlZiBieXRlc2l6ZShzdHIsIGluZGV4KVxyXG4gICAgOjpLZXJuZWwucmFpc2UgOjpOb3RJbXBsZW1lbnRlZEVycm9yXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBieXRlc2xpY2Uoc3RyLCBpbmRleCwgbGVuZ3RoKVxyXG4gICAgOjpLZXJuZWwucmFpc2UgOjpOb3RJbXBsZW1lbnRlZEVycm9yXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBlYWNoX2J5dGUoc3RyKVxyXG4gICAgOjpLZXJuZWwucmFpc2UgOjpOb3RJbXBsZW1lbnRlZEVycm9yXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzY3J1YihzdHIsIHJlcGxhY2VtZW50LCAmYmxvY2spXHJcbiAgICA6Oktlcm5lbC5yYWlzZSA6Ok5vdEltcGxlbWVudGVkRXJyb3JcclxuICBlbmRcclxuXHJcbiAgZGVmIHZhbGlkX2VuY29kaW5nPyhzdHIpXHJcbiAgICA6Oktlcm5lbC5yYWlzZSA6Ok5vdEltcGxlbWVudGVkRXJyb3JcclxuICBlbmRcclxuXHJcbiAgY2xhc3MgOjpFbmNvZGluZ0Vycm9yIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcclxuICBjbGFzcyA6OkNvbXBhdGliaWxpdHlFcnJvciA8IDo6RW5jb2RpbmdFcnJvcjsgZW5kXHJcbiAgY2xhc3MgVW5kZWZpbmVkQ29udmVyc2lvbkVycm9yIDwgOjpFbmNvZGluZ0Vycm9yOyBlbmRcclxuZW5kXHJcblxyXG4leHtcclxuICBjb25zdCBTRkNQID0gU3RyaW5nLmZyb21Db2RlUG9pbnQ7XHJcbiAgY29uc3QgU0ZDQyA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XHJcblxyXG4gIGZ1bmN0aW9uIHNjcnViYmluZ19kZWNvZGVyKGVuYywgbGFiZWwpIHtcclxuICAgIGlmICghZW5jLnNjcnViYmluZ19kZWNvZGVyKSBlbmMuc2NydWJiaW5nX2RlY29kZXIgPSBuZXcgVGV4dERlY29kZXIobGFiZWwsIHsgZmF0YWw6IGZhbHNlIH0pO1xyXG4gICAgcmV0dXJuIGVuYy5zY3J1YmJpbmdfZGVjb2RlcjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHZhbGlkYXRpbmdfZGVjb2RlcihlbmMsIGxhYmVsKSB7XHJcbiAgICBpZiAoIWVuYy52YWxpZGF0aW5nX2RlY29kZXIpIGVuYy52YWxpZGF0aW5nX2RlY29kZXIgPSBuZXcgVGV4dERlY29kZXIobGFiZWwsIHsgZmF0YWw6IHRydWUgfSk7XHJcbiAgICByZXR1cm4gZW5jLnZhbGlkYXRpbmdfZGVjb2RlcjtcclxuICB9XHJcbn1cclxuXHJcbjo6RW5jb2RpbmcucmVnaXN0ZXIgJ1VURi04JywgYWxpYXNlczogWydDUDY1MDAxJ10sIGFzY2lpOiB0cnVlIGRvXHJcbiAgZGVmIGJ5dGVzaXplKHN0ciwgaW5kZXgpXHJcbiAgICAleHtcclxuICAgICAgbGV0IGNvZGVfcG9pbnQsIHNpemUgPSAwO1xyXG4gICAgICBmb3IgKGNvbnN0IGMgb2Ygc3RyKSB7XHJcbiAgICAgICAgY29kZV9wb2ludCA9IGMuY29kZVBvaW50QXQoMCk7XHJcbiAgICAgICAgaWYgKGNvZGVfcG9pbnQgPCAweDgwKSBzaXplKys7IC8vIGNoYXIgaXMgb25lIGJ5dGUgbG9uZyBpbiBVVEYtOFxyXG4gICAgICAgIGVsc2UgaWYgKGNvZGVfcG9pbnQgPCAweDgwMCkgc2l6ZSArPSAyOyAvLyBjaGFyIGlzIHR3byBieXRlcyBsb25nXHJcbiAgICAgICAgLy8gZWxzZSBpZiAoY29kZV9wb2ludCA8IDB4RDgwMCkgc2l6ZSArPSAzOyAvLyBjaGFyIGlzIHRocmVlIGJ5dGVzIGxvbmdcclxuICAgICAgICAvLyBlbHNlIGlmIChjb2RlX3BvaW50IDwgMHhFMDAwKSBzaXplICs9IDM7IC8vIGZvciBsb25lIHN1cnJvZ2F0ZXMgdGhlIDB4QkQgMHhCRiAweEVGLCAzIGJ5dGVzLCBnZXQgaW5zZXJ0ZWRcclxuICAgICAgICBlbHNlIGlmIChjb2RlX3BvaW50IDwgMHgxMDAwMCkgc2l6ZSArPSAzOyAvLyBjaGFyIGlzIHRocmVlIGJ5dGVzIGxvbmdcclxuICAgICAgICBlbHNlIGlmIChjb2RlX3BvaW50IDw9IDB4MTEwMDAwKSBzaXplICs9IDQ7IC8vIGNoYXIgaXMgZm91ciBieXRlcyBsb25nXHJcbiAgICAgICAgaWYgKGluZGV4LS0gPD0gMCkgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNpemU7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBieXRlc2xpY2Uoc3RyLCBpbmRleCwgbGVuZ3RoKVxyXG4gICAgIyBtdXN0IGhhbmRsZSBuZWdhdGl2ZSBpbmRleCBhbmQgbGVuZ3RoLCB3aXRoIGxlbmd0aCBiZWluZyBuZWdhdGl2ZSBpbmRpY2F0aW5nIGEgbmVnYXRpdmUgcmFuZ2UgZW5kXHJcbiAgICAjIHRoaXMgc2xpY2VzIGF0IFVURi0xNiBjaGFyYWN0ZXIgYm91bmRhcmllcywgYXMgcmVxdWlyZWQgYnkgc3BlY3NcclxuICAgICMgaG93ZXZlciwgc29tZSBzcGVjcyByZXF1aXJlIHNsaWNpbmcgVVRGLTE2IGNoYXJhY3RlciBpbnRvIGl0cyBieXRlcywgd2hpY2ggd29udCB3b3JrXHJcbiAgICAleHtcclxuICAgICAgbGV0IHJlc3VsdCA9IFwiXCIsIGNvZGVfcG9pbnQsIGlkeCwgbWF4O1xyXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgLy8gbmVnYXRpdmUgaW5kZXgsIHdhbGsgZnJvbSB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsXHJcbiAgICAgICAgbGV0IGkgPSBzdHIubGVuZ3RoIC0gMSxcclxuICAgICAgICAgICAgYmFkX2NwID0gLTE7IC8vIC0xID0gbm8sIHN0cmluZyBvaywgMCBvciBsYXJnZXIgPSB0aGUgY29kZSBwb2ludFxyXG4gICAgICAgIGlkeCA9IC0xO1xyXG4gICAgICAgIGlmIChsZW5ndGggPCAwKSBtYXggPSBsZW5ndGg7IC8vIGEgbmVnYXRpdmUgaW5kZXhcclxuICAgICAgICBlbHNlIGlmIChsZW5ndGggPT09IDApIG1heCA9IGluZGV4O1xyXG4gICAgICAgIGVsc2UgaWYgKChpbmRleCArIGxlbmd0aCkgPj0gMCkgbWF4ID0gLTE7IC8vIGZyb20gZW5kIG9mIHN0cmluZ1xyXG4gICAgICAgIGVsc2UgbWF4ID0gaW5kZXggKyBsZW5ndGggLSAxO1xyXG4gICAgICAgIGZvciAoOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgY29kZV9wb2ludCA9IHN0ci5jb2RlUG9pbnRBdChpKTtcclxuICAgICAgICAgIGlmIChjb2RlX3BvaW50ID49IDB4RDgwMCAmJiBjb2RlX3BvaW50IDw9IDB4REZGRikge1xyXG4gICAgICAgICAgICAvLyBsb3cgc3Vycm9nYXRlLCBnZXQgdGhlIGZ1bGwgY29kZV9wb2ludCBuZXh0XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGxlbmd0aCA+PSAwIHx8IGxlbmd0aCA9PT0gLTEgfHwgKGxlbmd0aCA8IDAgJiYgaWR4IDw9IGxlbmd0aCkpIHtcclxuICAgICAgICAgICAgaWYgKGNvZGVfcG9pbnQgPCAweDgwKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGlkeCA+PSBpbmRleCAmJiBpZHggPD0gbWF4KSByZXN1bHQgPSBTRkNQKGNvZGVfcG9pbnQpICsgcmVzdWx0O1xyXG4gICAgICAgICAgICAgIGlkeC0tO1xyXG4gICAgICAgICAgICAgIC8vIGFsd2F5cyBsYW5kaW5nIG9uIGNoYXJhY3RlciBib3VuZGFyeSwgbm8gbmVlZCB0byBjaGVja1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVfcG9pbnQgPCAweDgwMCkge1xyXG4gICAgICAgICAgICAgIC8vIDIgYnl0ZSBzdXJyb2dhdGVzXHJcbiAgICAgICAgICAgICAgaWYgKGlkeCA+PSBpbmRleCAmJiBpZHggPD0gbWF4KSByZXN1bHQgPSBTRkNQKGNvZGVfcG9pbnQpICsgcmVzdWx0O1xyXG4gICAgICAgICAgICAgIGlkeCAtPSAyO1xyXG4gICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBicm9rZW4gY2hhcmFjdGVyIGJvdW5kYXJ5LCByYWlzZSBpZiBzb1xyXG4gICAgICAgICAgICAvLyB9IGVsc2UgaWYgKGNvZGVfcG9pbnQgPCAweEQ4MDApIHtcclxuICAgICAgICAgICAgLy8gIC8vIDMgYnl0ZSBzdXJyb2dhdGVzXHJcbiAgICAgICAgICAgIC8vICBpZiAoaWR4ID49IGluZGV4ICYmIGlkeCA8PSBtYXgpIHJlc3VsdCA9IFNGQ1AoY29kZV9wb2ludCkgKyByZXN1bHQ7XHJcbiAgICAgICAgICAgIC8vICBpZHggLT0gMztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlX3BvaW50IDwgMHgxMDAwMCkge1xyXG4gICAgICAgICAgICAgIC8vIDMgYnl0ZSBzdXJyb2dhdGVzXHJcbiAgICAgICAgICAgICAgaWYgKGlkeCA+PSBpbmRleCAmJiBpZHggPD0gbWF4KSByZXN1bHQgPSBTRkNQKGNvZGVfcG9pbnQpICsgcmVzdWx0O1xyXG4gICAgICAgICAgICAgIGlkeCAtPSAzO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVfcG9pbnQgPCAweDExMDAwMCkge1xyXG4gICAgICAgICAgICAgIC8vIDQgYnl0ZSBzdXJyb2dhdGVzXHJcbiAgICAgICAgICAgICAgaWYgKGlkeCA+PSBpbmRleCAmJiBpZHggPD0gbWF4KSByZXN1bHQgPSBTRkNQKGNvZGVfcG9pbnQpICsgcmVzdWx0O1xyXG4gICAgICAgICAgICAgIGlkeCAtPSAzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoaWR4IDwgaW5kZXgpIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaWR4ID4gaW5kZXggfHwgcmVzdWx0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG5pbDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyAwIG9yIHBvc2l0aXZlIGluZGV4LCB3YWxrIGZyb20gYmVnaW5uaW5nXHJcbiAgICAgICAgaWR4ID0gMDtcclxuICAgICAgICBpZiAobGVuZ3RoIDwgMCkgbWF4ID0gSW5maW5pdHk7IC8vIHRvIGVuZCBvZiBzdHJpbmdcclxuICAgICAgICBlbHNlIGlmIChsZW5ndGggPT09IDApIG1heCA9IGluZGV4ICsgMTtcclxuICAgICAgICBlbHNlIG1heCA9IGluZGV4ICsgbGVuZ3RoO1xyXG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBzdHIpIHtcclxuICAgICAgICAgIGNvZGVfcG9pbnQgPSBjLmNvZGVQb2ludEF0KDApO1xyXG4gICAgICAgICAgaWYgKGNvZGVfcG9pbnQgPCAweDgwKSB7XHJcbiAgICAgICAgICAgIGlmIChpZHggPj0gaW5kZXggJiYgaWR4IDw9IG1heCkgcmVzdWx0ICs9IFNGQ1AoY29kZV9wb2ludCk7XHJcbiAgICAgICAgICAgIGlkeCsrO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChjb2RlX3BvaW50IDwgMHg4MDApIHtcclxuICAgICAgICAgICAgLy8gMiBieXRlIHN1cnJvZ2F0ZXNcclxuICAgICAgICAgICAgaWYgKGlkeCA+PSBpbmRleCAmJiBpZHggPD0gbWF4KSByZXN1bHQgKz0gU0ZDUChjb2RlX3BvaW50KTtcclxuICAgICAgICAgICAgaWR4ICs9IDI7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVfcG9pbnQgPCAweEQ4MDApIHtcclxuICAgICAgICAgICAgLy8gMyBieXRlIHN1cnJvZ2F0ZXNcclxuICAgICAgICAgICAgaWYgKGlkeCA+PSBpbmRleCAmJiBpZHggPD0gbWF4KSByZXN1bHQgKz0gU0ZDUChjb2RlX3BvaW50KTtcclxuICAgICAgICAgICAgaWR4ICs9IDM7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVfcG9pbnQgPCAweEUwMDApIHtcclxuICAgICAgICAgICAgaWYgKGlkeCA+PSBpbmRleCAmJiBpZHggPD0gbWF4KSByZXN1bHQgKz0gU0ZDUCgweEVGKTsgaWR4Kys7XHJcbiAgICAgICAgICAgIGlmIChpZHggPj0gaW5kZXggJiYgaWR4IDw9IG1heCkgcmVzdWx0ICs9IFNGQ1AoMHhCRik7IGlkeCsrO1xyXG4gICAgICAgICAgICBpZiAoaWR4ID49IGluZGV4ICYmIGlkeCA8PSBtYXgpIHJlc3VsdCArPSBTRkNQKDB4QkQpOyBpZHgrKztcclxuICAgICAgICAgIH0gZWxzZSBpZiAoY29kZV9wb2ludCA8IDB4MTAwMDApIHtcclxuICAgICAgICAgICAgLy8gMyBieXRlIHN1cnJvZ2F0ZXNcclxuICAgICAgICAgICAgaWYgKGlkeCA+PSBpbmRleCAmJiBpZHggPD0gbWF4KSByZXN1bHQgKz0gU0ZDUChjb2RlX3BvaW50KTtcclxuICAgICAgICAgICAgaWR4ICs9IDM7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVfcG9pbnQgPCAweDExMDAwMCkge1xyXG4gICAgICAgICAgICAvLyA0IGJ5dGUgc3Vycm9nYXRlc1xyXG4gICAgICAgICAgICBpZiAoaWR4ID49IGluZGV4ICYmIGlkeCA8PSBtYXgpIHJlc3VsdCArPSBTRkNQKGNvZGVfcG9pbnQpO1xyXG4gICAgICAgICAgICBpZHggKz0gNDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChpZHggPj0gbWF4KSBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIGlmIChpZHggPT09IGluZGV4KSByZXN1bHQgPSBcIlwiO1xyXG4gICAgICAgICAgZWxzZSByZXR1cm4gbmlsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xyXG4gICAgICAgICAgLy8gaWYgbGVuZ3RoIGlzIGEgbmVnYXRpdmUgaW5kZXggZnJvbSBhIHJhbmdlLCB3ZSB3YWxrZWQgdG8gdGhlIGVuZCxcclxuICAgICAgICAgIC8vIHNvIHNob3J0ZW4gdGhlIHJlc3VsdCBhY2NvcmRpbmdseVxyXG4gICAgICAgICAgLy8gcmVzdWx0IGhhcyB0aGUgYnl0ZXMgYWxyZWFkeSBzcHJlYWQgb3V0IGFzIGNoYXJzIHNvIHdlIGNhbiBzaW1wbHkgc2xpY2VcclxuICAgICAgICAgIGlmICgoaWR4ICsgbGVuZ3RoKSA+IDApIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCByZXN1bHQubGVuZ3RoICsgbGVuZ3RoKTtcclxuICAgICAgICAgIGVsc2UgcmVzdWx0ID0gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGxlbmd0aCA9PT0gMCkgcmVzdWx0ID0gXCJcIjtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGVhY2hfYnl0ZShzdHIsICZibG9jaylcclxuICAgICV4e1xyXG4gICAgICBsZXQgdW5pdHMgPSBJbmZpbml0eSxcclxuICAgICAgICAgIGNvZGVfcG9pbnQsXHJcbiAgICAgICAgICBsZW5ndGggPSBzdHIubGVuZ3RoO1xyXG4gICAgICBmb3IgKGNvbnN0IGMgb2Ygc3RyKSB7XHJcbiAgICAgICAgY29kZV9wb2ludCA9IGMuY29kZVBvaW50QXQoMCk7XHJcbiAgICAgICAgaWYgKGNvZGVfcG9pbnQgPCAweDgwKSB7XHJcbiAgICAgICAgICAje3lpZWxkIGBjb2RlX3BvaW50YH07XHJcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlX3BvaW50IDwgMHg4MDApIHtcclxuICAgICAgICAgICN7eWllbGQgYGNvZGVfcG9pbnQgPj4gMHg2IHwgMHhDMGB9O1xyXG4gICAgICAgICAgI3t5aWVsZCBgY29kZV9wb2ludCAmIDB4M0YgfCAweDgwYH07XHJcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlX3BvaW50IDwgMHhEODAwKSB7XHJcbiAgICAgICAgICAje3lpZWxkIGBjb2RlX3BvaW50ID4+IDB4QyB8IDB4RTBgfTtcclxuICAgICAgICAgICN7eWllbGQgYGNvZGVfcG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODBgfTtcclxuICAgICAgICAgICN7eWllbGQgYGNvZGVfcG9pbnQgJiAweDNGIHwgMHg4MGB9O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY29kZV9wb2ludCA8IDB4RTAwMCkge1xyXG4gICAgICAgICAgI3t5aWVsZCBgMHhFRmB9O1xyXG4gICAgICAgICAgI3t5aWVsZCBgMHhCRmB9O1xyXG4gICAgICAgICAgI3t5aWVsZCBgMHhCRGB9O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY29kZV9wb2ludCA8IDB4MTAwMDApIHtcclxuICAgICAgICAgICN7eWllbGQgYGNvZGVfcG9pbnQgPj4gMHhDIHwgMHhFMGB9O1xyXG4gICAgICAgICAgI3t5aWVsZCBgY29kZV9wb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MGB9O1xyXG4gICAgICAgICAgI3t5aWVsZCBgY29kZV9wb2ludCAmIDB4M0YgfCAweDgwYH07XHJcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlX3BvaW50IDwgMHgxMTAwMDApIHtcclxuICAgICAgICAgICN7eWllbGQgYGNvZGVfcG9pbnQgPj4gMHgxMiB8IDB4RjBgfTtcclxuICAgICAgICAgICN7eWllbGQgYGNvZGVfcG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODBgfTtcclxuICAgICAgICAgICN7eWllbGQgYGNvZGVfcG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODBgfTtcclxuICAgICAgICAgICN7eWllbGQgYGNvZGVfcG9pbnQgJiAweDNGIHwgMHg4MGB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc2NydWIoc3RyLCByZXBsYWNlbWVudCwgJmJsb2NrKVxyXG4gICAgJXh7XHJcbiAgICAgIGxldCByZXN1bHQgPSBzY3J1YmJpbmdfZGVjb2RlcihzZWxmLCAndXRmLTgnKS5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoc3RyLiRieXRlcygpKSk7XHJcbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XHJcbiAgICAgICAgLy8gZG9udCBrbm93IHRoZSBieXRlcyBhbnltb3JlIC4uLiDCr1xcXyjjg4QpXy/Cr1xyXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC/vv70vZywgKGJ5dGUpPT57IHJldHVybiAje3lpZWxkIGBieXRlYH07IH0pO1xyXG4gICAgICB9IGVsc2UgaWYgKHJlcGxhY2VtZW50ICYmIHJlcGxhY2VtZW50ICE9PSBuaWwpIHtcclxuICAgICAgICAvLyB0aGlzIG1heSByZXBsYWNlIHZhbGlkIO+/vSB0aGF0IGhhdmUgZXhpc3RlZCBpbiB0aGUgc3RyaW5nIGJlZm9yZSxcclxuICAgICAgICAvLyBidXQgdGhlcmUgY3VycmVudGx5IGlzIG5vIHdheSB0byBzcGVjaWZ5IGEgb3RoZXIgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGZvciBUZXh0RGVjb2RlclxyXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC/vv70vZywgcmVwbGFjZW1lbnQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHQuJGZvcmNlX2VuY29kaW5nKHNlbGYpO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgdmFsaWRfZW5jb2Rpbmc/KHN0cilcclxuICAgICV4e1xyXG4gICAgICB0cnkgeyB2YWxpZGF0aW5nX2RlY29kZXIoc2VsZiwgJ3V0Zi04JykuZGVjb2RlKG5ldyBVaW50OEFycmF5KHN0ci4kYnl0ZXMoKSkpOyB9XHJcbiAgICAgIGNhdGNoIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5lbmRcclxuXHJcbjo6RW5jb2RpbmcucmVnaXN0ZXIgJ1VURi0xNkxFJywgYWxpYXNlczogWydVVEYtMTYnXSBkb1xyXG4gIGRlZiBieXRlc2l6ZShzdHIsIGluZGV4KVxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChpbmRleCA8IHN0ci5sZW5ndGgpIHJldHVybiAoaW5kZXggKyAxKSAqIDI7XHJcbiAgICAgIHJldHVybiBzdHIubGVuZ3RoICogMjtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGJ5dGVzbGljZShzdHIsIGluZGV4LCBsZW5ndGgpXHJcbiAgICAjIG11c3QgaGFuZGxlIG5lZ2F0aXZlIGluZGV4IGFuZCBsZW5ndGgsIHdpdGggbGVuZ3RoIGJlaW5nIG5lZ2F0aXZlIGluZGljYXRpbmcgYSBuZWdhdGl2ZSByYW5nZSBlbmRcclxuICAgICV4e1xyXG4gICAgICBsZXQgcmVzdWx0ID0gXCJcIiwgY2hhcl9jb2RlLCBpZHgsIG1heCwgaTtcclxuICAgICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgIC8vIG5lZ2F0aXZlIGluZGV4LCB3YWxrIGZyb20gdGhlIGVuZCBvZiB0aGUgc3RyaW5nLFxyXG4gICAgICAgIGlkeCA9IC0xO1xyXG4gICAgICAgIGlmIChsZW5ndGggPCAwKSBtYXggPSBsZW5ndGg7IC8vIGEgbmVnYXRpdmUgaW5kZXhcclxuICAgICAgICBlbHNlIGlmIChsZW5ndGggPT09IDApIG1heCA9IGluZGV4O1xyXG4gICAgICAgIGVsc2UgaWYgKChpbmRleCArIGxlbmd0aCkgPj0gMCkgbWF4ID0gLTE7IC8vIGZyb20gZW5kIG9mIHN0cmluZ1xyXG4gICAgICAgIGVsc2UgbWF4ID0gaW5kZXggKyBsZW5ndGggLSAxO1xyXG4gICAgICAgIGZvciAoaSA9IHN0ci5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcclxuICAgICAgICAgIGNoYXJfY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgICAgaWYgKGxlbmd0aCA+PSAwIHx8IGxlbmd0aCA9PT0gLTEgfHwgKGxlbmd0aCA8IDAgJiYgaWR4IDw9IGxlbmd0aCkpIHtcclxuICAgICAgICAgICAgaWYgKGlkeCA+PSBpbmRleCAmJiBpZHggPD0gbWF4KSByZXN1bHQgPSBTRkNDKGNoYXJfY29kZSkgKyByZXN1bHQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZHggLT0gMjtcclxuICAgICAgICAgIGlmIChpZHggPCBpbmRleCkgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpZHggPiBpbmRleCB8fCByZXN1bHQubGVuZ3RoID09PSAwKSByZXR1cm4gbmlsO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIDAgb3IgcG9zaXRpdmUgaW5kZXgsIHdhbGsgZnJvbSBiZWdpbm5pbmdcclxuICAgICAgICBpZHggPSAwO1xyXG4gICAgICAgIGlmIChsZW5ndGggPCAwKSBtYXggPSBJbmZpbml0eTtcclxuICAgICAgICBlbHNlIGlmIChsZW5ndGggPT09IDApIG1heCA9IGluZGV4ICsgMTtcclxuICAgICAgICBlbHNlIG1heCA9IGluZGV4ICsgbGVuZ3RoO1xyXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHN0ci5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgY2hhcl9jb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgICBpZiAoaWR4ID49IGluZGV4ICYmIGlkeCA8PSBtYXgpIHJlc3VsdCArPSBTRkNDKGNoYXJfY29kZSk7XHJcbiAgICAgICAgICBpZHggKz0gMjtcclxuICAgICAgICAgIGlmIChpZHggPj0gbWF4KSBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIGlmIChpZHggPT09IGluZGV4KSByZXN1bHQgPSBcIlwiO1xyXG4gICAgICAgICAgZWxzZSByZXR1cm4gbmlsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xyXG4gICAgICAgICAgLy8gaWYgbGVuZ3RoIGlzIGEgbmVnYXRpdmUgaW5kZXggZnJvbSBhIHJhbmdlLCB3ZSB3YWxrZWQgdG8gdGhlIGVuZCwgc28gc2hvcnRlbiB0aGUgcmVzdWx0XHJcbiAgICAgICAgICBpZiAoKGlkeCArIGxlbmd0aCkgPiAwKSByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgcmVzdWx0Lmxlbmd0aCArIGxlbmd0aCk7XHJcbiAgICAgICAgICBlbHNlIHJlc3VsdCA9IFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChsZW5ndGggPT09IDApIHJlc3VsdCA9IFwiXCI7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBlYWNoX2J5dGUoc3RyLCAmYmxvY2spXHJcbiAgICAleHtcclxuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IHN0ci5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBjaGFyX2NvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuXHJcbiAgICAgICAgI3t5aWVsZCBgY2hhcl9jb2RlICYgMHhmZmB9O1xyXG4gICAgICAgICN7eWllbGQgYGNoYXJfY29kZSA+PiA4YH07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHNjcnViKHN0ciwgcmVwbGFjZW1lbnQsICZibG9jaylcclxuICAgICV4e1xyXG4gICAgICBsZXQgcmVzdWx0ID0gc2NydWJiaW5nX2RlY29kZXIoc2VsZiwgJ3V0Zi0xNicpLmRlY29kZShuZXcgVWludDhBcnJheShzdHIuJGJ5dGVzKCkpKTtcclxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcclxuICAgICAgICAvLyBkb250IGtub3cgdGhlIGJ5dGVzIGFueW1vcmUgLi4uIMKvXFxfKOODhClfL8KvXHJcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL++/vS9nLCAoYnl0ZSk9PnsgcmV0dXJuICN7eWllbGQgYGJ5dGVgfTsgfSk7XHJcbiAgICAgIH0gZWxzZSBpZiAocmVwbGFjZW1lbnQgJiYgcmVwbGFjZW1lbnQgIT09IG5pbCkge1xyXG4gICAgICAgIC8vIHRoaXMgbWF5IHJlcGxhY2UgdmFsaWQg77+9IHRoYXQgaGF2ZSBleGlzdGVkIGluIHRoZSBzdHJpbmcgYmVmb3JlLFxyXG4gICAgICAgIC8vIGJ1dCB0aGVyZSBjdXJyZW50bHkgaXMgbm8gd2F5IHRvIHNwZWNpZnkgYSBvdGhlciByZXBsYWNlbWVudCBjaGFyYWN0ZXIgZm9yIFRleHREZWNvZGVyXHJcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL++/vS9nLCByZXBsYWNlbWVudCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdC4kZm9yY2VfZW5jb2Rpbmcoc2VsZik7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiB2YWxpZF9lbmNvZGluZz8oc3RyKVxyXG4gICAgJXh7XHJcbiAgICAgIHRyeSB7IHZhbGlkYXRpbmdfZGVjb2RlcihzZWxmLCAndXRmLTE2JykuZGVjb2RlKG5ldyBVaW50OEFycmF5KHN0ci4kYnl0ZXMoKSkpOyB9XHJcbiAgICAgIGNhdGNoIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5lbmRcclxuXHJcbjo6RW5jb2RpbmcucmVnaXN0ZXIgJ1VURi0xNkJFJywgaW5oZXJpdHM6IDo6RW5jb2Rpbmc6OlVURl8xNkxFIGRvXHJcbiAgZGVmIGVhY2hfYnl0ZShzdHIsICZibG9jaylcclxuICAgICV4e1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGNoYXJfY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgICN7eWllbGQgYGNoYXJfY29kZSA+PiA4YH07XHJcbiAgICAgICAgI3t5aWVsZCBgY2hhcl9jb2RlICYgMHhmZmB9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzY3J1YihzdHIsIHJlcGxhY2VtZW50LCAmYmxvY2spXHJcbiAgICAleHtcclxuICAgICAgbGV0IHJlc3VsdCA9IHNjcnViYmluZ19kZWNvZGVyKHNlbGYsICd1dGYtMTZiZScpLmRlY29kZShuZXcgVWludDhBcnJheShzdHIuJGJ5dGVzKCkpKTtcclxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcclxuICAgICAgICAvLyBkb250IGtub3cgdGhlIGJ5dGVzIGFueW1vcmUgLi4uIMKvXFxfKOODhClfL8KvXHJcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL++/vS9nLCAoYnl0ZSk9PnsgcmV0dXJuICN7eWllbGQgYGJ5dGVgfTsgfSk7XHJcbiAgICAgIH0gZWxzZSBpZiAocmVwbGFjZW1lbnQgJiYgcmVwbGFjZW1lbnQgIT09IG5pbCkge1xyXG4gICAgICAgIC8vIHRoaXMgbWF5IHJlcGxhY2UgdmFsaWQg77+9IHRoYXQgaGF2ZSBleGlzdGVkIGluIHRoZSBzdHJpbmcgYmVmb3JlLFxyXG4gICAgICAgIC8vIGJ1dCB0aGVyZSBjdXJyZW50bHkgaXMgbm8gd2F5IHRvIHNwZWNpZnkgYSBvdGhlciByZXBsYWNlbWVudCBjaGFyYWN0ZXIgZm9yIFRleHREZWNvZGVyXHJcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL++/vS9nLCByZXBsYWNlbWVudCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdC4kZm9yY2VfZW5jb2Rpbmcoc2VsZik7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiB2YWxpZF9lbmNvZGluZz8oc3RyKVxyXG4gICAgJXh7XHJcbiAgICAgIHRyeSB7IHZhbGlkYXRpbmdfZGVjb2RlcihzZWxmLCAndXRmLTE2YmUnKS5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoc3RyLiRieXRlcygpKSk7IH1cclxuICAgICAgY2F0Y2ggeyByZXR1cm4gZmFsc2U7IH1cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgZW5kXHJcbmVuZFxyXG5cclxuOjpFbmNvZGluZy5yZWdpc3RlciAnVVRGLTMyTEUnIGRvXHJcbiAgZGVmIGJ5dGVzaXplKHN0ciwgaW5kZXgpXHJcbiAgICAleHtcclxuICAgICAgaWYgKGluZGV4IDwgc3RyLmxlbmd0aCkgcmV0dXJuIChpbmRleCArIDEpICogNDtcclxuICAgICAgcmV0dXJuIHN0ci5sZW5ndGggKiA0O1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgYnl0ZXNsaWNlKHN0ciwgaW5kZXgsIGxlbmd0aClcclxuICAgICMgbXVzdCBoYW5kbGUgbmVnYXRpdmUgaW5kZXggYW5kIGxlbmd0aCwgd2l0aCBsZW5ndGggYmVpbmcgbmVnYXRpdmUgaW5kaWNhdGluZyBhIG5lZ2F0aXZlIHJhbmdlIGVuZFxyXG4gICAgJXh7XHJcbiAgICAgIGxldCByZXN1bHQgPSBcIlwiLCBjaGFyX2NvZGUsIGlkeCwgbWF4LCBpO1xyXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgLy8gbmVnYXRpdmUgaW5kZXgsIHdhbGsgZnJvbSB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsXHJcbiAgICAgICAgaWR4ID0gLTE7XHJcbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIG1heCA9IGxlbmd0aDsgLy8gYSBuZWdhdGl2ZSBpbmRleFxyXG4gICAgICAgIGVsc2UgaWYgKGxlbmd0aCA9PT0gMCkgbWF4ID0gaW5kZXg7XHJcbiAgICAgICAgZWxzZSBpZiAoKGluZGV4ICsgbGVuZ3RoKSA+PSAwKSBtYXggPSAtMTsgLy8gZnJvbSBlbmQgb2Ygc3RyaW5nXHJcbiAgICAgICAgZWxzZSBtYXggPSBpbmRleCArIGxlbmd0aCAtIDE7XHJcbiAgICAgICAgZm9yIChpID0gc3RyLmxlbmd0aDsgaSA+IDA7IGktLSkge1xyXG4gICAgICAgICAgY2hhcl9jb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgICBpZiAobGVuZ3RoID4gMCB8fCBsZW5ndGggPT09IC0xIHx8IChsZW5ndGggPCAwICYmIGlkeCA8PSBsZW5ndGgpKSB7XHJcbiAgICAgICAgICAgIGlmIChpZHggPj0gaW5kZXggJiYgaWR4IDw9IG1heCkgcmVzdWx0ID0gU0ZDQyhjaGFyX2NvZGUpICsgcmVzdWx0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWR4IC09IDQ7XHJcbiAgICAgICAgICBpZiAoaWR4IDwgaW5kZXgpIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaWR4ID4gaW5kZXggfHwgcmVzdWx0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG5pbDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyAwIG9yIHBvc2l0aXZlIGluZGV4LCB3YWxrIGZyb20gYmVnaW5uaW5nXHJcbiAgICAgICAgaWR4ID0gMDtcclxuICAgICAgICBpZiAobGVuZ3RoIDwgMCkgbWF4ID0gSW5maW5pdHk7XHJcbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoID09PSAwKSBtYXggPSBpbmRleCArIDE7XHJcbiAgICAgICAgZWxzZSBtYXggPSBpbmRleCArIGxlbmd0aDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gc3RyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBjaGFyX2NvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICAgIGlmIChpZHggPj0gaW5kZXggJiYgaWR4IDw9IG1heCkgcmVzdWx0ICs9IFNGQ0MoY2hhcl9jb2RlKTtcclxuICAgICAgICAgIGlkeCArPSA0O1xyXG4gICAgICAgICAgaWYgKGlkeCA+PSBtYXgpIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgaWYgKGlkeCA9PT0gaW5kZXgpIHJlc3VsdCA9IFwiXCI7XHJcbiAgICAgICAgICBlbHNlIHJldHVybiBuaWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XHJcbiAgICAgICAgICAvLyBpZiBsZW5ndGggaXMgYSBuZWdhdGl2ZSBpbmRleCBmcm9tIGEgcmFuZ2UsIHdlIHdhbGtlZCB0byB0aGUgZW5kLCBzbyBzaG9ydGVuIHRoZSByZXN1bHRcclxuICAgICAgICAgIGlmICgoaWR4ICsgbGVuZ3RoKSA+IDApIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCByZXN1bHQubGVuZ3RoICsgbGVuZ3RoKTtcclxuICAgICAgICAgIGVsc2UgcmVzdWx0ID0gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGxlbmd0aCA9PT0gMCkgcmVzdWx0ID0gXCJcIjtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGVhY2hfYnl0ZShzdHIsICZibG9jaylcclxuICAgICV4e1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGNoYXJfY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG5cclxuICAgICAgICAje3lpZWxkIGBjaGFyX2NvZGUgJiAweGZmYH07XHJcbiAgICAgICAgI3t5aWVsZCBgY2hhcl9jb2RlID4+IDhgfTtcclxuICAgICAgICAje3lpZWxkIDB9O1xyXG4gICAgICAgICN7eWllbGQgMH07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHNjcnViKHN0ciwgcmVwbGFjZW1lbnQsICZibG9jaylcclxuICAgIHN0clxyXG4gIGVuZFxyXG5cclxuICBkZWYgdmFsaWRfZW5jb2Rpbmc/KHN0cilcclxuICAgIHRydWVcclxuICBlbmRcclxuZW5kXHJcblxyXG46OkVuY29kaW5nLnJlZ2lzdGVyICdVVEYtMzJCRScsIGluaGVyaXRzOiA6OkVuY29kaW5nOjpVVEZfMzJMRSBkb1xyXG4gIGRlZiBlYWNoX2J5dGUoc3RyLCAmYmxvY2spXHJcbiAgICAleHtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0ci5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBjaGFyX2NvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICAje3lpZWxkIDB9O1xyXG4gICAgICAgICN7eWllbGQgMH07XHJcbiAgICAgICAgI3t5aWVsZCBgY2hhcl9jb2RlID4+IDhgfTtcclxuICAgICAgICAje3lpZWxkIGBjaGFyX2NvZGUgJiAweGZmYH07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBlbmRcclxuZW5kXHJcblxyXG46OkVuY29kaW5nLnJlZ2lzdGVyICdBU0NJSS04QklUJywgYWxpYXNlczogWydCSU5BUlknXSwgYXNjaWk6IHRydWUgZG9cclxuICBkZWYgYmluYXJ5P1xyXG4gICAgdHJ1ZVxyXG4gIGVuZFxyXG5cclxuICBkZWYgYnl0ZXNpemUoc3RyLCBpbmRleClcclxuICAgICV4e1xyXG4gICAgICBpZiAoaW5kZXggPCBzdHIuc2l6ZSkgcmV0dXJuIGluZGV4ICsgMTtcclxuICAgICAgcmV0dXJuIHN0ci5sZW5ndGg7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBieXRlc2xpY2Uoc3RyLCBpbmRleCwgbGVuZ3RoKVxyXG4gICAgIyBtdXN0IGhhbmRsZSBuZWdhdGl2ZSBpbmRleCBhbmQgbGVuZ3RoLCB3aXRoIGxlbmd0aCBiZWluZyBuZWdhdGl2ZSBpbmRpY2F0aW5nIGEgbmVnYXRpdmUgcmFuZ2UgZW5kXHJcbiAgICAleHtcclxuICAgICAgbGV0IHJlc3VsdCA9IFwiXCIsIGNoYXJfY29kZSwgaTtcclxuICAgICAgaWYgKGluZGV4IDwgMCkgaW5kZXggPSBzdHIubGVuZ3RoICsgaW5kZXg7XHJcbiAgICAgIGlmIChpbmRleCA8IDApIHJldHVybiBuaWw7XHJcbiAgICAgIGlmIChsZW5ndGggPCAwKSBsZW5ndGggPSAoc3RyLmxlbmd0aCArIGxlbmd0aCkgLSBpbmRleDtcclxuICAgICAgaWYgKGxlbmd0aCA8IDApIHJldHVybiBuaWw7XHJcbiAgICAgIC8vIG11c3QgcHJvZHVjZSB0aGUgc2FtZSByZXN1bHQgYXMgZWFjaF9ieXRlLCBzbyB3ZSBjYW5ub3Qgc2ltcGx5IHVzZSBzbGljZSgpXHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGggJiYgKGluZGV4ICsgaSkgPD0gc3RyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY2hhcl9jb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyBpKTtcclxuICAgICAgICByZXN1bHQgPSBTRkNDKGNoYXJfY29kZSAmIDB4ZmYpICsgcmVzdWx0O1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSByZXR1cm4gbmlsO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZWFjaF9ieXRlKHN0ciwgJmJsb2NrKVxyXG4gICAgJXh7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBzdHIubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgY2hhcl9jb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgI3t5aWVsZCBgY2hhcl9jb2RlICYgMHhmZmB9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzY3J1YihzdHIsIHJlcGxhY2VtZW50LCAmYmxvY2spXHJcbiAgICAleHtcclxuICAgICAgbGV0IHJlc3VsdCA9IHNjcnViYmluZ19kZWNvZGVyKHNlbGYsICdhc2NpaScpLmRlY29kZShuZXcgVWludDhBcnJheShzdHIuJGJ5dGVzKCkpKTtcclxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcclxuICAgICAgICAvLyBkb250IGtub3cgYWxsIHRoZSBieXRlcyBhbnltb3JlIC4uLiDCr1xcXyjjg4QpXy/Cr1xyXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC9b77+9XFx4ODAtXFx4ZmZdL2csIChieXRlKT0+eyByZXR1cm4gI3t5aWVsZCBgYnl0ZWB9OyB9KTtcclxuICAgICAgfSBlbHNlIGlmIChyZXBsYWNlbWVudCAmJiByZXBsYWNlbWVudCAhPT0gbmlsKSB7XHJcbiAgICAgICAgLy8gdGhpcyBtYXkgcmVwbGFjZSB2YWxpZCDvv70gdGhhdCBoYXZlIGV4aXN0ZWQgaW4gdGhlIHN0cmluZyBiZWZvcmUsXHJcbiAgICAgICAgLy8gYnV0IHRoZXJlIGN1cnJlbnRseSBpcyBubyB3YXkgdG8gc3BlY2lmeSBhIG90aGVyIHJlcGxhY2VtZW50IGNoYXJhY3RlciBmb3IgVGV4dERlY29kZXJcclxuICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvW++/vVxceDgwLVxceGZmXS9nLCByZXBsYWNlbWVudCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL1vvv71cXHg4MC1cXHhmZl0vZywgJz8nKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0LiRmb3JjZV9lbmNvZGluZyhzZWxmKTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIHZhbGlkX2VuY29kaW5nPyhzdHIpXHJcbiAgICAleHtcclxuICAgICAgdHJ5IHsgdmFsaWRhdGluZ19kZWNvZGVyKHNlbGYsICdhc2NpaScpLmRlY29kZShuZXcgVWludDhBcnJheShzdHIuJGJ5dGVzKCkpKTsgfVxyXG4gICAgICBjYXRjaCB7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICBlbmRcclxuZW5kXHJcblxyXG46OkVuY29kaW5nLnJlZ2lzdGVyICdJU08tODg1OS0xJywgYWxpYXNlczogWydJU084ODU5LTEnXSwgYXNjaWk6IHRydWUsIGluaGVyaXRzOiA6OkVuY29kaW5nOjpBU0NJSV84QklUXHJcbjo6RW5jb2RpbmcucmVnaXN0ZXIgJ1VTLUFTQ0lJJywgYWxpYXNlczogWydBU0NJSSddLCBhc2NpaTogdHJ1ZSwgaW5oZXJpdHM6IDo6RW5jb2Rpbmc6OkFTQ0lJXzhCSVRcclxuXHJcbiMgdGhlc2UgZW5jb2RpbmdzIGFyZSByZXF1aXJlZCBmb3Igc29tZSBydWJ5IHNwZWNzLCBtYWtlIHRoZW0gZHVtbXkgZm9yIG5vd1xyXG4jIHRoZWlyIGV4aXN0ZW5jZSBpcyBvZnRlbiBlbm91Z2gsIGxpa2Ugc3BlY3MgY2hlY2tpbmcgaWYgYSBtZXRob2QgcmV0dXJuc1xyXG4jIGEgc3RyaW5nIGluIHRoZSBzYW1lIGVuY29kaW5nIGl0IGlzIGVuY29kZWQgaW5cclxuOjpFbmNvZGluZy5yZWdpc3RlciAnRVVDLUpQJywgaW5oZXJpdHM6IDo6RW5jb2Rpbmc6OlVURl8xNkxFLCBkdW1teTogdHJ1ZVxyXG46OkVuY29kaW5nLnJlZ2lzdGVyICdJQk00MzcnLCBpbmhlcml0czogOjpFbmNvZGluZzo6VVRGXzE2TEUsIGR1bW15OiB0cnVlXHJcbjo6RW5jb2RpbmcucmVnaXN0ZXIgJ0lCTTcyMCcsIGluaGVyaXRzOiA6OkVuY29kaW5nOjpVVEZfMTZMRSwgZHVtbXk6IHRydWVcclxuOjpFbmNvZGluZy5yZWdpc3RlciAnSVNPLTIwMjItSlAnLCBpbmhlcml0czogOjpFbmNvZGluZzo6VVRGXzE2TEUsIGR1bW15OiB0cnVlXHJcbjo6RW5jb2RpbmcucmVnaXN0ZXIgJ0lTTy04ODU5LTE1JywgaW5oZXJpdHM6IDo6RW5jb2Rpbmc6OlVURl8xNkxFLCBkdW1teTogdHJ1ZVxyXG46OkVuY29kaW5nLnJlZ2lzdGVyICdJU08tODg1OS01JywgaW5oZXJpdHM6IDo6RW5jb2Rpbmc6OlVURl8xNkxFLCBkdW1teTogdHJ1ZVxyXG46OkVuY29kaW5nLnJlZ2lzdGVyICdTaGlmdF9KSVMnLCBhbGlhc2VzOiBbJ1NISUZUX0pJUyddLCBpbmhlcml0czogOjpFbmNvZGluZzo6VVRGXzE2TEUsIGR1bW15OiB0cnVlXHJcbjo6RW5jb2RpbmcucmVnaXN0ZXIgJ1dpbmRvd3MtMTI1MScsIGFsaWFzZXM6IFsnV0lORE9XUy0xMjUxJ10sIGluaGVyaXRzOiA6OkVuY29kaW5nOjpVVEZfMTZMRSwgZHVtbXk6IHRydWVcclxuXHJcbjo6RW5jb2RpbmcuZGVmYXVsdF9leHRlcm5hbCA9IF9fRU5DT0RJTkdfX1xyXG46OkVuY29kaW5nLmRlZmF1bHRfaW50ZXJuYWwgPSBfX0VOQ09ESU5HX19cclxuXHJcbmBPcGFsLnByb3AoU3RyaW5nLnByb3RvdHlwZSwgJ2VuY29kaW5nJywgI3s6OkVuY29kaW5nOjpVVEZfOH0pYFxyXG5gT3BhbC5wcm9wKFN0cmluZy5wcm90b3R5cGUsICdpbnRlcm5hbF9lbmNvZGluZycsICN7OjpFbmNvZGluZzo6VVRGXzh9KWBcclxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6RW5jb2Rpbmc+IiwicmVnaXN0ZXIiLCJuYW1lIiwib3B0aW9ucyIsIm5hbWVzIiwiKyIsIiRyZXRfb3JfMSIsIltdIiwiYXNjaWkiLCJkdW1teSIsImVuY29kaW5nIiwiY2xvbmUiLCJpbml0aWFsaXplIiwic2VsZiIsIm5ldyIsImJsb2NrX2dpdmVuPyIsImluc3RhbmNlX2V2YWwiLCJibG9jayIsInRvX3Byb2MiLCJlYWNoIiwiYmxvY2sgaW4gcmVnaXN0ZXIiLCJlbmNvZGluZ19uYW1lIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWdpc3RlciIsImNvbnN0X3NldCIsInRyIiwiZmluZCIsImRlZmF1bHRfZXh0ZXJuYWwiLCJhdHRyX2FjY2Vzc29yIiwiYXR0cl9yZWFkZXIiLCJAbmFtZSIsIkBuYW1lcyIsIkBhc2NpaSIsIkBkdW1teSIsImFzY2lpX2NvbXBhdGlibGU/IiwiZHVtbXk/IiwiYmluYXJ5PyIsInRvX3MiLCJpbnNwZWN0IiwiYnl0ZXNpemUiLCJzdHIiLCJpbmRleCIsIktlcm5lbCIsInJhaXNlIiwiTm90SW1wbGVtZW50ZWRFcnJvciIsImJ5dGVzbGljZSIsImxlbmd0aCIsImVhY2hfYnl0ZSIsInNjcnViIiwicmVwbGFjZW1lbnQiLCJ2YWxpZF9lbmNvZGluZz8iLCI8Y2xhc3M6RW5jb2RpbmdFcnJvcj4iLCJTdGFuZGFyZEVycm9yIiwiPGNsYXNzOkNvbXBhdGliaWxpdHlFcnJvcj4iLCJFbmNvZGluZ0Vycm9yIiwiPGNsYXNzOlVuZGVmaW5lZENvbnZlcnNpb25FcnJvcj4iLCJFbmNvZGluZyIsImJsb2NrIGluIDx0b3AgKHJlcXVpcmVkKT4iLCJibG9jayAoMiBsZXZlbHMpIGluIDx0b3AgKHJlcXVpcmVkKT4iLCJFbmNvZGluZzo6VVRGXzE2TEUiLCIwIiwiRW5jb2Rpbmc6OlVURl8zMkxFIiwiRW5jb2Rpbmc6OkFTQ0lJXzhCSVQiLCJkZWZhdWx0X2V4dGVybmFsPSIsIkVuY29kaW5nOjpVVEZfOCIsImRlZmF1bHRfaW50ZXJuYWw9Il0sIm1hcHBpbmdzIjoiQUFBQUEsMENBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBR0FDO0VBQUFBOztJQUFBQTs7QUFBQUE7O0lBQ0U7Ozs7QUFDRUMsTUFBQUEsd0JBQUFBLG9CQUFhQyxJQUFELEVBQU9DLE9BQW5CRjtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQUFtQiwrQkFBVTtRQUMzQkcsUUFBZUMsU0FBUCxDQUFDSCxJQUFELENBQU9HLEVBQUcsQ0FBQSxRQUFBQyxDQUFBQSxZQUFBSCxPQUFPSSxPQUFBQSxDQUFDLFNBQURBLENBQVBELENBQUEsQ0FBQSxHQUFBLENBQUEsU0FBQSxJQUFBLENBQXFCLEVBQXJCLENBQUEsQ0FBSEQ7UUFDZkcsUUFBUSxDQUFBLFFBQUFGLENBQUFBLFlBQUFILE9BQU9JLE9BQUFBLENBQUMsT0FBREEsQ0FBUEQsQ0FBQSxDQUFBLElBQUEsQ0FBQSxTQUFBLENBQUE7UUFDUkcsUUFBUSxDQUFBLFFBQUFILENBQUFBLFlBQUFILE9BQU9JLE9BQUFBLENBQUMsT0FBREEsQ0FBUEQsQ0FBQSxDQUFBLElBQUEsQ0FBQSxTQUFBLENBQUE7UUFFUixJQUFBLFFBQUdILE9BQU9JLE9BQUFBLENBQUMsVUFBREEsQ0FBVixDQUFBOztVQUNFRyxXQUFXUCxPQUFPSSxPQUFBQSxDQUFDLFVBQURBLENBQVdJLE9BQUFBLENBQUFBO1VBQzdCRCxRQUFRRSxZQUFBQSxDQUFZVixJQUFwQixFQUEwQkUsS0FBMUIsRUFBaUNJLEtBQWpDLEVBQXdDQyxLQUFoQ0c7UUFGVjtVQUlFRixXQUFXRyxJQUFBQyxLQUFBQSxDQUFJWixJQUFKLEVBQVVFLEtBQVYsRUFBaUJJLEtBQWpCLEVBQXdCQyxLQUF4Qks7UUFKYjtRQU1BLElBQWtDQyxlQUFsQztVQUFRQyxNQUFSTixRQUFRTSxpQkFBQUEsRUFBQUEsRUFBQUEsRUFBZ0JDLEtBQURDLFNBQUFBLENBQUFBLENBQWZGO1FBQVI7UUFFQWYsV0FBWUE7UUFDWkEsT0FBS2tCLE1BQUxmLEtBQUtlLFFBQUFBLEVBQUFBLEVBQUFBLEVBQUxDLGFBQWVDLGFBQWZELEVBQUFFOzs7VUFBZTtVQUNiVCxJQUFBVSxXQUFBQSxDQUFVRixhQUFhRyxJQUFBQSxDQUFJRixHQUFqQixFQUFzQkEsR0FBVEUsQ0FBdkIsRUFBc0NkLFFBQXRDYTtVQUNBRCxPQUFBckIsUUFBQSxDQUFZb0IsYUFBWixJQUE2QlgsU0FGL0JVLENBQUFBLEdBQUFBLFNBQUFBLENBQUtEO01BZFBsQixDQUFBQSxJQUFBQTs7QUFvQkF3QixNQUFBQSxvQkFBQUEsZ0JBQVN2QixJQUFUdUI7QUFBQUEsUUFBQUE7OztRQUNFLElBQUEsTUFBMkJ2QixJQUEzQixFQUFtQyxrQkFBbkMsQ0FBQTtVQUFBLE9BQU9XLElBQUFhLGtCQUFBQSxDQUFBQTtRQUFQO1FBQ0NELCtCQUFEQTtNQUZGQSxDQUFBQTtNQUtBLE9BQUFaLElBQUFjLGVBQUFBLENBQWMsa0JBQWQsRUFBaUMsa0JBQWpDQTtJQTFCRiw0QkFBU2QsSUFBVDtJQTZCQUEsSUFBQWUsYUFBQUEsQ0FBWSxNQUFaLEVBQW1CLE9BQW5CQTs7QUFFQWhCLElBQUFBLDBCQUFBQSxzQkFBZVYsSUFBRCxFQUFPRSxLQUFQLEVBQWNJLEtBQWQsRUFBcUJDLEtBQW5DRztBQUFBQSxNQUFBQTs7O01BQ0VpQixZQUFTM0I7TUFDVDRCLGFBQVMxQjtNQUNUMkIsYUFBU3ZCO01BQ1RJLE9BQUFvQixDQUFBQSxhQUFTdkIsS0FBVHVCO0lBSkZwQixDQUFBQTs7QUFPQXFCLElBQUFBLGlDQUFBQSxhQUNFLE9BREZBLENBQUFBOztBQUlBQyxJQUFBQSxzQkFBQUEsYUFDRSxPQURGQSxDQUFBQTs7QUFJQUMsSUFBQUEsdUJBQUFBLFlBQ0UsS0FERkEsQ0FBQUE7O0FBSUFDLElBQUFBLG9CQUFBQSxhQUNFLE1BREZBLENBQUFBOztBQUlBQyxJQUFBQSx1QkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxhQUFELEdBQUEsTUFBY1IsU0FBZCxDQUFBLEdBQUEsTUFBc0IsQ0FBQSxRQUFjRyxVQUFkLENBQUEsR0FBQSxDQUFBSyxVQUFBLElBQUEsR0FBQSxDQUF0QixDQUFBLEdBQTJDQTtJQUQ3Q0EsQ0FBQUE7O0FBTUFDLElBQUFBLHdCQUFBQSxvQkFBYUMsR0FBRCxFQUFNQyxLQUFsQkY7QUFBQUE7TUFDRUEsT0FBQUcsT0FBUUMsT0FBQUEsQ0FBT0MsMEJBQVBEO0lBRFZKLENBQUFBOztBQUlBTSxJQUFBQSx5QkFBQUEscUJBQWNMLEdBQUQsRUFBTUMsS0FBTixFQUFhSyxNQUExQkQ7QUFBQUE7TUFDRUEsT0FBQUgsT0FBUUMsT0FBQUEsQ0FBT0MsMEJBQVBEO0lBRFZFLENBQUFBOztBQUlBRSxJQUFBQSx5QkFBQUEscUJBQWNQLEdBQWRPO0FBQUFBO01BQ0VBLE9BQUFMLE9BQVFDLE9BQUFBLENBQU9DLDBCQUFQRDtJQURWSSxDQUFBQTs7QUFJQUMsSUFBQUEscUJBQUFBLGlCQUFVUixHQUFELEVBQU1TLFdBQWZEO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQ0VBLE9BQUFOLE9BQVFDLE9BQUFBLENBQU9DLDBCQUFQRDtJQURWSyxDQUFBQTs7QUFJQUUsSUFBQUEsK0JBQUFBLHlDQUFvQlYsR0FBcEJVO0FBQUFBO01BQ0VBLE9BQUFSLE9BQVFDLE9BQUFBLENBQU9DLDBCQUFQRDtJQURWTyxDQUFBQTtJQUlBQyxPQUFNLElBQU5BLEVBQXdCQyxvQkFBeEJEO0lBQ0FFLE9BQU0sSUFBTkEsRUFBNkJDLG9CQUE3QkQ7SUFDQXBELE9BQUFzRCxRQUFBQSxXQUFBQSxFQUFpQ0Qsb0JBQWpDQztFQW5GRnRELEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7O0FBdUZBRDtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztFQUdVRSxNQUFWc0QsZUFBVXRELFlBQUFBLEVBQUFBLENBQVVGLE9BQXBCLEVBQTZCLFVBQUEsU0FBQSxFQUFTLENBQUNBLFNBQUQsQ0FBVCxFQUFBLE9BQUEsRUFBNkIsSUFBN0IsQ0FBbkJFLENBQUFBLEVBQVZ1RCxhQUFBQSxFQUFBQzs7OztBQUNFbkIsSUFBQUEsd0JBQUFBLG9CQUFhQyxHQUFELEVBQU1DLEtBQWxCRjtBQUFBQTs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUFkRUEsQ0FBQUE7O0FBaUJBTSxJQUFBQSx5QkFBQUEscUJBQWNMLEdBQUQsRUFBTUMsS0FBTixFQUFhSyxNQUExQkQ7QUFBQUE7O0FBS0ZBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBaEdFQSxDQUFBQTs7QUFtR0FFLElBQUFBLHlCQUFBQSxxQkFBY1AsR0FBZE87QUFBQUEsTUFBQUE7O01BQUFBOzs7O0FBRUZBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLFVBQVksbUJBQU9BLFVBQVAsQ0FBbUJBO0FBQy9CQTtBQUNBQSxVQUFZLG1CQUFPQSx3QkFBUCxDQUFpQ0E7QUFDN0NBLFVBQVksbUJBQU9BLHdCQUFQLENBQWlDQTtBQUM3Q0E7QUFDQUEsVUFBWSxtQkFBT0Esd0JBQVAsQ0FBaUNBO0FBQzdDQSxVQUFZLG1CQUFPQSwrQkFBUCxDQUF3Q0E7QUFDcERBLFVBQVksbUJBQU9BLHdCQUFQLENBQWlDQTtBQUM3Q0E7QUFDQUEsVUFBWSxtQkFBT0EsSUFBUCxDQUFhQTtBQUN6QkEsVUFBWSxtQkFBT0EsSUFBUCxDQUFhQTtBQUN6QkEsVUFBWSxtQkFBT0EsSUFBUCxDQUFhQTtBQUN6QkE7QUFDQUEsVUFBWSxtQkFBT0Esd0JBQVAsQ0FBaUNBO0FBQzdDQSxVQUFZLG1CQUFPQSwrQkFBUCxDQUF3Q0E7QUFDcERBLFVBQVksbUJBQU9BLHdCQUFQLENBQWlDQTtBQUM3Q0E7QUFDQUEsVUFBWSxtQkFBT0EseUJBQVAsQ0FBa0NBO0FBQzlDQSxVQUFZLG1CQUFPQSwrQkFBUCxDQUF3Q0E7QUFDcERBLFVBQVksbUJBQU9BLCtCQUFQLENBQXdDQTtBQUNwREEsVUFBWSxtQkFBT0Esd0JBQVAsQ0FBaUNBO0FBQzdDQTtBQUNBQTtBQUNBQTtJQS9CRUEsQ0FBQUE7O0FBa0NBQyxJQUFBQSxxQkFBQUEsaUJBQVVSLEdBQUQsRUFBTVMsV0FBZkQ7QUFBQUEsTUFBQUE7O01BQUFBOzs7O0FBRUZBO0FBQ0FBO0FBQ0FBO0FBQ0FBLHVEQUF5RCxtQkFBT0EsSUFBUCxDQUFhQTtBQUN0RUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUFaRUEsQ0FBQUE7SUFlQVUsT0FBQVIsK0JBQUFBLGdDQUFvQlYsR0FBcEJVO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7SUFMRUEsQ0FBQUEsRUF0S0ZPLENBQUFBLEdBQUFBLFNBQUFBLENBQVV2RDtFQStLQUEsTUFBVnNELGVBQVV0RCxZQUFBQSxFQUFBQSxDQUFVRixVQUFwQixFQUFnQyxVQUFBLFNBQUEsRUFBUyxDQUFDQSxRQUFELENBQVQsQ0FBdEJFLENBQUFBLEVBQVZ1RCxhQUFBQSxFQUFBQzs7OztBQUNFbkIsSUFBQUEsd0JBQUFBLG9CQUFhQyxHQUFELEVBQU1DLEtBQWxCRjtBQUFBQTs7QUFFRkE7QUFDQUE7QUFDQUE7SUFKRUEsQ0FBQUE7O0FBT0FNLElBQUFBLHlCQUFBQSxxQkFBY0wsR0FBRCxFQUFNQyxLQUFOLEVBQWFLLE1BQTFCRDtBQUFBQTs7QUFHRkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUE1Q0VBLENBQUFBOztBQStDQUUsSUFBQUEseUJBQUFBLHFCQUFjUCxHQUFkTztBQUFBQSxNQUFBQTs7TUFBQUE7Ozs7QUFFRkE7QUFDQUE7O0FBRUFBLFFBQVUsbUJBQU9BLGdCQUFQLENBQXlCQTtBQUNuQ0EsUUFBVSxtQkFBT0EsY0FBUCxDQUF1QkE7QUFDakNBO0FBQ0FBO0lBUkVBLENBQUFBOztBQVdBQyxJQUFBQSxxQkFBQUEsaUJBQVVSLEdBQUQsRUFBTVMsV0FBZkQ7QUFBQUEsTUFBQUE7O01BQUFBOzs7O0FBRUZBO0FBQ0FBO0FBQ0FBO0FBQ0FBLHVEQUF5RCxtQkFBT0EsSUFBUCxDQUFhQTtBQUN0RUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUFaRUEsQ0FBQUE7SUFlQVUsT0FBQVIsK0JBQUFBLGdDQUFvQlYsR0FBcEJVO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7SUFMRUEsQ0FBQUEsRUFqRkZPLENBQUFBLEdBQUFBLFNBQUFBLENBQVV2RDtFQTBGQUEsTUFBVnNELGVBQVV0RCxZQUFBQSxFQUFBQSxDQUFVRixVQUFwQixFQUFnQyxVQUFBLFVBQUEsRUFBVTJELElBQUFILGVBQUFHLGFBQVYsQ0FBdEJ6RCxDQUFBQSxFQUFWdUQsYUFBQUEsRUFBQUM7Ozs7QUFDRVgsSUFBQUEseUJBQUFBLHFCQUFjUCxHQUFkTztBQUFBQSxNQUFBQTs7TUFBQUE7Ozs7QUFFRkE7QUFDQUE7QUFDQUEsUUFBVSxtQkFBT0EsY0FBUCxDQUF1QkE7QUFDakNBLFFBQVUsbUJBQU9BLGdCQUFQLENBQXlCQTtBQUNuQ0E7QUFDQUE7SUFQRUEsQ0FBQUE7O0FBVUFDLElBQUFBLHFCQUFBQSxpQkFBVVIsR0FBRCxFQUFNUyxXQUFmRDtBQUFBQSxNQUFBQTs7TUFBQUE7Ozs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUEsdURBQXlELG1CQUFPQSxJQUFQLENBQWFBO0FBQ3RFQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQVpFQSxDQUFBQTtJQWVBVSxPQUFBUiwrQkFBQUEsZ0NBQW9CVixHQUFwQlU7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQTtBQUNBQTtBQUNBQTtJQUxFQSxDQUFBQSxFQTFCRk8sQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBVXZEO0VBbUNBQSxNQUFWc0QsZUFBVXRELFlBQUFBLEVBQUFBLENBQVVGLFVBQVZFLENBQUFBLEVBQVZ1RCxhQUFBQSxFQUFBQzs7OztBQUNFbkIsSUFBQUEsd0JBQUFBLG9CQUFhQyxHQUFELEVBQU1DLEtBQWxCRjtBQUFBQTs7QUFFRkE7QUFDQUE7QUFDQUE7SUFKRUEsQ0FBQUE7O0FBT0FNLElBQUFBLHlCQUFBQSxxQkFBY0wsR0FBRCxFQUFNQyxLQUFOLEVBQWFLLE1BQTFCRDtBQUFBQTs7QUFHRkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUE1Q0VBLENBQUFBOztBQStDQUUsSUFBQUEseUJBQUFBLHFCQUFjUCxHQUFkTztBQUFBQSxNQUFBQTs7TUFBQUE7Ozs7QUFFRkE7QUFDQUE7O0FBRUFBLFFBQVUsbUJBQU9BLGdCQUFQLENBQXlCQTtBQUNuQ0EsUUFBVSxtQkFBT0EsY0FBUCxDQUF1QkE7QUFDakNBLFFBQVUsbUJBQU1hLENBQU4sQ0FBUWI7QUFDbEJBLFFBQVUsbUJBQU1hLENBQU4sQ0FBUWI7QUFDbEJBO0FBQ0FBO0lBVkVBLENBQUFBOztBQWFBQyxJQUFBQSxxQkFBQUEsaUJBQVVSLEdBQUQsRUFBTVMsV0FBZkQ7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFDRUEsT0FBQVI7SUFERlEsQ0FBQUE7SUFJQVUsT0FBQVIsK0JBQUFBLFlBQ0UsSUFERkEsQ0FBQUEsRUF4RUZPLENBQUFBLEdBQUFBLFNBQUFBLENBQVV2RDtFQTZFQUEsTUFBVnNELGVBQVV0RCxZQUFBQSxFQUFBQSxDQUFVRixVQUFwQixFQUFnQyxVQUFBLFVBQUEsRUFBVTZELElBQUFMLGVBQUFLLGFBQVYsQ0FBdEIzRCxDQUFBQSxFQUFWdUQsY0FBQUEsRUFBQUM7O0lBQ0VBLE9BQUFYLHlCQUFBQSxxQkFBY1AsR0FBZE87QUFBQUEsTUFBQUE7O01BQUFBOzs7O0FBRUZBO0FBQ0FBO0FBQ0FBLFFBQVUsbUJBQU1hLENBQU4sQ0FBUWI7QUFDbEJBLFFBQVUsbUJBQU1hLENBQU4sQ0FBUWI7QUFDbEJBLFFBQVUsbUJBQU9BLGNBQVAsQ0FBdUJBO0FBQ2pDQSxRQUFVLG1CQUFPQSxnQkFBUCxDQUF5QkE7QUFDbkNBO0FBQ0FBO0lBVEVBLENBQUFBLENBREZVLENBQUFBLEdBQUFBLFNBQUFBLENBQVV2RDtFQWNBQSxNQUFWc0QsZUFBVXRELFlBQUFBLEVBQUFBLENBQVVGLFlBQXBCLEVBQWtDLFVBQUEsU0FBQSxFQUFTLENBQUNBLFFBQUQsQ0FBVCxFQUFBLE9BQUEsRUFBNEIsSUFBNUIsQ0FBeEJFLENBQUFBLEVBQVZ1RCxjQUFBQSxFQUFBQzs7OztBQUNFdEIsSUFBQUEsdUJBQUFBLFlBQ0UsSUFERkEsQ0FBQUE7O0FBSUFHLElBQUFBLHdCQUFBQSxvQkFBYUMsR0FBRCxFQUFNQyxLQUFsQkY7QUFBQUE7O0FBRUZBO0FBQ0FBO0FBQ0FBO0lBSkVBLENBQUFBOztBQU9BTSxJQUFBQSx5QkFBQUEscUJBQWNMLEdBQUQsRUFBTUMsS0FBTixFQUFhSyxNQUExQkQ7QUFBQUE7O0FBR0ZBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBZkVBLENBQUFBOztBQWtCQUUsSUFBQUEseUJBQUFBLHFCQUFjUCxHQUFkTztBQUFBQSxNQUFBQTs7TUFBQUE7Ozs7QUFFRkE7QUFDQUE7QUFDQUEsUUFBVSxtQkFBT0EsZ0JBQVAsQ0FBeUJBO0FBQ25DQTtBQUNBQTtJQU5FQSxDQUFBQTs7QUFTQUMsSUFBQUEscUJBQUFBLGlCQUFVUixHQUFELEVBQU1TLFdBQWZEO0FBQUFBLE1BQUFBOztNQUFBQTs7OztBQUVGQTtBQUNBQTtBQUNBQTtBQUNBQSxrRUFBb0UsbUJBQU9BLElBQVAsQ0FBYUE7QUFDakZBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBZEVBLENBQUFBO0lBaUJBVSxPQUFBUiwrQkFBQUEsaUNBQW9CVixHQUFwQlU7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQTtBQUNBQTtBQUNBQTtJQUxFQSxDQUFBQSxFQXhERk8sQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBVXZEO0VBaUVWc0QsZUFBVXRELFVBQUFBLENBQVVGLFlBQXBCLEVBQWtDLFVBQUEsU0FBQSxFQUFTLENBQUNBLFdBQUQsQ0FBVCxFQUFBLE9BQUEsRUFBK0IsSUFBL0IsRUFBQSxVQUFBLEVBQStDOEQsSUFBQU4sZUFBQU0sZUFBL0MsQ0FBeEI1RDtFQUNWc0QsZUFBVXRELFVBQUFBLENBQVVGLFVBQXBCLEVBQWdDLFVBQUEsU0FBQSxFQUFTLENBQUNBLE9BQUQsQ0FBVCxFQUFBLE9BQUEsRUFBMkIsSUFBM0IsRUFBQSxVQUFBLEVBQTJDOEQsSUFBQU4sZUFBQU0sZUFBM0MsQ0FBdEI1RDtFQUtWc0QsZUFBVXRELFVBQUFBLENBQVVGLFFBQXBCLEVBQThCLFVBQUEsVUFBQSxFQUFVMkQsSUFBQUgsZUFBQUcsYUFBVixFQUFBLE9BQUEsRUFBdUMsSUFBdkMsQ0FBcEJ6RDtFQUNWc0QsZUFBVXRELFVBQUFBLENBQVVGLFFBQXBCLEVBQThCLFVBQUEsVUFBQSxFQUFVMkQsSUFBQUgsZUFBQUcsYUFBVixFQUFBLE9BQUEsRUFBdUMsSUFBdkMsQ0FBcEJ6RDtFQUNWc0QsZUFBVXRELFVBQUFBLENBQVVGLFFBQXBCLEVBQThCLFVBQUEsVUFBQSxFQUFVMkQsSUFBQUgsZUFBQUcsYUFBVixFQUFBLE9BQUEsRUFBdUMsSUFBdkMsQ0FBcEJ6RDtFQUNWc0QsZUFBVXRELFVBQUFBLENBQVVGLGFBQXBCLEVBQW1DLFVBQUEsVUFBQSxFQUFVMkQsSUFBQUgsZUFBQUcsYUFBVixFQUFBLE9BQUEsRUFBdUMsSUFBdkMsQ0FBekJ6RDtFQUNWc0QsZUFBVXRELFVBQUFBLENBQVVGLGFBQXBCLEVBQW1DLFVBQUEsVUFBQSxFQUFVMkQsSUFBQUgsZUFBQUcsYUFBVixFQUFBLE9BQUEsRUFBdUMsSUFBdkMsQ0FBekJ6RDtFQUNWc0QsZUFBVXRELFVBQUFBLENBQVVGLFlBQXBCLEVBQWtDLFVBQUEsVUFBQSxFQUFVMkQsSUFBQUgsZUFBQUcsYUFBVixFQUFBLE9BQUEsRUFBdUMsSUFBdkMsQ0FBeEJ6RDtFQUNWc0QsZUFBVXRELFVBQUFBLENBQVVGLFdBQXBCLEVBQWlDLFVBQUEsU0FBQSxFQUFTLENBQUNBLFdBQUQsQ0FBVCxFQUFBLFVBQUEsRUFBa0MyRCxJQUFBSCxlQUFBRyxhQUFsQyxFQUFBLE9BQUEsRUFBK0QsSUFBL0QsQ0FBdkJ6RDtFQUNWc0QsZUFBVXRELFVBQUFBLENBQVVGLGNBQXBCLEVBQW9DLFVBQUEsU0FBQSxFQUFTLENBQUNBLGNBQUQsQ0FBVCxFQUFBLFVBQUEsRUFBcUMyRCxJQUFBSCxlQUFBRyxhQUFyQyxFQUFBLE9BQUEsRUFBa0UsSUFBbEUsQ0FBMUJ6RDtFQUVWc0QsZUFBVU8sc0JBQUFBLENBQW9CQyxJQS9qQjlCUixjQStqQjhCUSxVQUFwQkQ7RUFDVlAsZUFBVVMsc0JBQUFBLENBQW9CRCxJQWhrQjlCUixjQWdrQjhCUSxVQUFwQkM7RUFFVGpFLHdDQUEwQ2dFLElBQUFSLGVBQUFRLFVBQWtCaEU7RUFDN0RBLE9BQUNBLGlEQUFtRGdFLElBQUFSLGVBQUFRLFVBQWtCaEU7QUFua0J0RUE7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIxMTAyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9pby5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcclxuXHJcbmNsYXNzIDo6SU9cclxuICBzZWxmOjpTRUVLX1NFVCA9IDBcclxuICBzZWxmOjpTRUVLX0NVUiA9IDFcclxuICBzZWxmOjpTRUVLX0VORCA9IDJcclxuICBzZWxmOjpTRUVLX0RBVEEgPSAzXHJcbiAgc2VsZjo6U0VFS19IT0xFID0gNFxyXG5cclxuICBzZWxmOjpSRUFEQUJMRSA9IDFcclxuICBzZWxmOjpXUklUQUJMRSA9IDRcclxuXHJcbiAgYXR0cl9yZWFkZXIgOmVvZlxyXG5cclxuICBhdHRyX2FjY2Vzc29yIDpyZWFkX3Byb2MsICA6c3luYywgOnR0eSwgOndyaXRlX3Byb2NcclxuXHJcbiAgZGVmIGluaXRpYWxpemUoZmQsIGZsYWdzID0gJ3InKVxyXG4gICAgQGZkID0gZmRcclxuICAgIEBmbGFncyA9IGZsYWdzXHJcbiAgICBAZW9mID0gZmFsc2VcclxuXHJcbiAgICBpZiBmbGFncy5pbmNsdWRlPygncicpICYmICFmbGFncy5tYXRjaD8oL1t3YStdLylcclxuICAgICAgQGNsb3NlZCA9IDp3cml0ZVxyXG4gICAgZWxzaWYgZmxhZ3MubWF0Y2g/KC9bd2FdLykgJiYgIWZsYWdzLm1hdGNoPygvW3IrXS8pXHJcbiAgICAgIEBjbG9zZWQgPSA6cmVhZFxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBmaWxlbm9cclxuICAgIEBmZFxyXG4gIGVuZFxyXG5cclxuICBkZWYgdHR5P1xyXG4gICAgYHNlbGYudHR5ID09IHRydWVgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiB3cml0ZShzdHJpbmcpXHJcbiAgICBgc2VsZi53cml0ZV9wcm9jKHN0cmluZylgXHJcbiAgICBzdHJpbmcuc2l6ZVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZmx1c2hcclxuICAgICMgbm9vcFxyXG4gIGVuZFxyXG5cclxuICBkZWYgPDwoc3RyaW5nKVxyXG4gICAgd3JpdGUoc3RyaW5nKVxyXG4gICAgc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgcHJpbnQoKmFyZ3MpXHJcbiAgICAleHtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJncy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XHJcbiAgICAgICAgYXJnc1tpXSA9ICN7OjpLZXJuZWwuU3RyaW5nKGBhcmdzW2ldYCl9XHJcbiAgICAgIH1cclxuICAgICAgc2VsZi4kd3JpdGUoYXJncy5qb2luKCN7JCx9KSk7XHJcbiAgICB9XHJcbiAgICBuaWxcclxuICBlbmRcclxuXHJcbiAgZGVmIHB1dHMoKmFyZ3MpXHJcbiAgICAleHtcclxuICAgICAgdmFyIGxpbmVcclxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgI3t3cml0ZSBcIlxcblwifTtcclxuICAgICAgICByZXR1cm4gbmlsO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGFyZ3MubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xyXG4gICAgICAgICAgaWYgKGFyZ3NbaV0uJCRpc19hcnJheSl7XHJcbiAgICAgICAgICAgIHZhciBhcnkgPSAje2BhcmdzW2ldYC5mbGF0dGVufVxyXG4gICAgICAgICAgICBpZiAoYXJ5Lmxlbmd0aCA+IDApICN7cHV0cygqYGFyeWApfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3NbaV0uJCRpc19zdHJpbmcpIHtcclxuICAgICAgICAgICAgICBsaW5lID0gYXJnc1tpXS52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgbGluZSA9ICN7OjpLZXJuZWwuU3RyaW5nKGBhcmdzW2ldYCl9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghbGluZS5lbmRzV2l0aChcIlxcblwiKSkgbGluZSArPSBcIlxcblwiXHJcbiAgICAgICAgICAgICN7d3JpdGUgYGxpbmVgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgbmlsXHJcbiAgZW5kXHJcblxyXG4gICMgUmVhZGluZ1xyXG5cclxuICBkZWYgZ2V0Y1xyXG4gICAgQHJlYWRfYnVmZmVyIHx8PSAnJ1xyXG4gICAgcGFydHMgPSAnJ1xyXG5cclxuICAgICMgV2lsbCBleGVjdXJlIGF0IG1vc3QgdHdpY2UgLSBvbmUgdGltZSByZWFkaW5nIGZyb20gYSBidWZmZXJcclxuICAgICMgc2Vjb25kIHRpbWUgZXhlY3V0aW5nIHJlYWQgcHJvY1xyXG4gICAgYmVnaW5cclxuICAgICAgQHJlYWRfYnVmZmVyICs9IHBhcnRzXHJcbiAgICAgIGlmIEByZWFkX2J1ZmZlciAhPSAnJ1xyXG4gICAgICAgIHJldCA9IEByZWFkX2J1ZmZlclswXVxyXG4gICAgICAgIEByZWFkX2J1ZmZlciA9IEByZWFkX2J1ZmZlclsxLi4tMV1cclxuICAgICAgICByZXR1cm4gcmV0XHJcbiAgICAgIGVuZFxyXG4gICAgZW5kIHdoaWxlIHBhcnRzID0gc3lzcmVhZF9ub3JhaXNlKDEpXHJcblxyXG4gICAgbmlsXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBnZXRieXRlXHJcbiAgICBnZXRjJi5vcmRcclxuICBlbmRcclxuXHJcbiAgZGVmIHJlYWRieXRlXHJcbiAgICByZWFkY2hhci5vcmRcclxuICBlbmRcclxuXHJcbiAgZGVmIHJlYWRjaGFyXHJcbiAgICBnZXRjIHx8IDo6S2VybmVsLnJhaXNlKDo6RU9GRXJyb3IsICdlbmQgb2YgZmlsZSByZWFjaGVkJylcclxuICBlbmRcclxuXHJcbiAgZGVmIHJlYWRsaW5lKCphcmdzKVxyXG4gICAgZ2V0cygqYXJncykgfHwgOjpLZXJuZWwucmFpc2UoOjpFT0ZFcnJvciwgJ2VuZCBvZiBmaWxlIHJlYWNoZWQnKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZ2V0cyhzZXAgPSBmYWxzZSwgbGltaXQgPSBuaWwsIG9wdHMgPSB7fSlcclxuICAgIGlmIGBzZXAuJCRpc19udW1iZXJgICYmICFsaW1pdFxyXG4gICAgICBzZXAsIGxpbWl0LCBvcHRzID0gZmFsc2UsIHNlcCwgbGltaXRcclxuICAgIGVuZFxyXG4gICAgaWYgYHNlcC4kJGlzX2hhc2hgICYmICFsaW1pdCAmJiBvcHRzID09IHt9XHJcbiAgICAgIHNlcCwgbGltaXQsIG9wdHMgPSBmYWxzZSwgbmlsLCBzZXBcclxuICAgIGVsc2lmIGBsaW1pdC4kJGlzX2hhc2hgICYmIG9wdHMgPT0ge31cclxuICAgICAgc2VwLCBsaW1pdCwgb3B0cyA9IHNlcCwgbmlsLCBsaW1pdFxyXG4gICAgZW5kXHJcblxyXG4gICAgb3JpZ19zZXAgPSBzZXBcclxuXHJcbiAgICBzZXAgPSAkLyBpZiBzZXAgPT0gZmFsc2VcclxuICAgIHNlcCA9IC9cXHI/XFxuXFxyP1xcbi8gaWYgc2VwID09ICcnXHJcbiAgICBzZXAgfHw9ICcnXHJcbiAgICBzZXAgPSBzZXAudG9fc3RyIHVubGVzcyBvcmlnX3NlcCA9PSAnJ1xyXG5cclxuICAgICMgVHJ5IHRvIGRlZHVjZSBsZW5ndGggb2YgYSByZWdleHBcclxuICAgIHNlcGxlbiA9IG9yaWdfc2VwID09ICcnID8gMiA6IHNlcC5sZW5ndGhcclxuXHJcbiAgICBzZXAgPSAvIC8gaWYgc2VwID09ICcgJyAjIFdURiBpcyB0aGlzLCBTdHJpbmcjc3BsaXQoXCIgXCIpIG1hdGNoZXMgYWxsIHdoaXRlc3BhY2VzPz8/XHJcblxyXG4gICAgQHJlYWRfYnVmZmVyIHx8PSAnJ1xyXG4gICAgZGF0YSA9ICcnXHJcbiAgICByZXQgPSBuaWxcclxuXHJcbiAgICBiZWdpblxyXG4gICAgICBAcmVhZF9idWZmZXIgKz0gZGF0YVxyXG4gICAgICBpZiBzZXAgIT0gJycgJiYgKGBzZXAuJCRpc19yZWdleHBgID8gQHJlYWRfYnVmZmVyLm1hdGNoPyhzZXApIDogQHJlYWRfYnVmZmVyLmluY2x1ZGU/KHNlcCkpXHJcbiAgICAgICAgb3JpZ19idWZmZXIgPSBAcmVhZF9idWZmZXJcclxuICAgICAgICByZXQsIEByZWFkX2J1ZmZlciA9IEByZWFkX2J1ZmZlci5zcGxpdChzZXAsIDIpXHJcbiAgICAgICAgcmV0ICs9IG9yaWdfYnVmZmVyW3JldC5sZW5ndGgsIHNlcGxlbl0gaWYgcmV0ICE9IG9yaWdfYnVmZmVyXHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgZW5kXHJcbiAgICBlbmQgd2hpbGUgZGF0YSA9IHN5c3JlYWRfbm9yYWlzZShzZXAgPT0gJycgPyA2NV81MzYgOiAxKVxyXG5cclxuICAgIHVubGVzcyByZXRcclxuICAgICAgcmV0LCBAcmVhZF9idWZmZXIgPSBAcmVhZF9idWZmZXIgfHwgJycsICcnXHJcbiAgICAgIHJldCA9IG5pbCBpZiByZXQgPT0gJydcclxuICAgIGVuZFxyXG5cclxuICAgIGlmIHJldFxyXG4gICAgICBpZiBsaW1pdFxyXG4gICAgICAgIHJldCA9IHJldFswLi4ubGltaXRdXHJcbiAgICAgICAgQHJlYWRfYnVmZmVyID0gcmV0W2xpbWl0Li4tMV0gKyBAcmVhZF9idWZmZXJcclxuICAgICAgZW5kXHJcbiAgICAgIHJldCA9IHJldC5zdWIoL1xccj9cXG5cXHovLCAnJykgaWYgb3B0c1s6Y2hvbXBdXHJcbiAgICAgIHJldCA9IHJldC5zdWIoL1xcQVtcXHJcXG5dKy8sICcnKSBpZiBvcmlnX3NlcCA9PSAnJ1xyXG4gICAgZW5kXHJcblxyXG4gICAgJF8gPSByZXQgaWYgb3JpZ19zZXAgPT0gZmFsc2VcclxuICAgIHJldFxyXG4gIGVuZFxyXG5cclxuICAjIFRoaXMgbWV0aG9kIGlzIHRvIGJlIG92ZXJsb2FkZWQsIG9yIHJlYWRfcHJvYyBjYW4gYmUgY2hhbmdlZFxyXG4gIGRlZiBzeXNyZWFkKGludGVnZXIpXHJcbiAgICBgc2VsZi5yZWFkX3Byb2MoaW50ZWdlcilgIHx8IGJlZ2luXHJcbiAgICAgIEBlb2YgPSB0cnVlXHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6RU9GRXJyb3IsICdlbmQgb2YgZmlsZSByZWFjaGVkJ1xyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gICMgQHByaXZhdGVcclxuICBkZWYgc3lzcmVhZF9ub3JhaXNlKGludGVnZXIpXHJcbiAgICBzeXNyZWFkKGludGVnZXIpXHJcbiAgcmVzY3VlIDo6RU9GRXJyb3JcclxuICAgIG5pbFxyXG4gIGVuZFxyXG5cclxuICBkZWYgcmVhZHBhcnRpYWwoaW50ZWdlcilcclxuICAgIEByZWFkX2J1ZmZlciB8fD0gJydcclxuICAgIHBhcnQgPSBzeXNyZWFkKGludGVnZXIpXHJcbiAgICByZXQsIEByZWFkX2J1ZmZlciA9IEByZWFkX2J1ZmZlciArIChwYXJ0IHx8ICcnKSwgJydcclxuICAgIHJldCA9IG5pbCBpZiByZXQgPT0gJydcclxuICAgIHJldFxyXG4gIGVuZFxyXG5cclxuICBkZWYgcmVhZChpbnRlZ2VyID0gbmlsKVxyXG4gICAgQHJlYWRfYnVmZmVyIHx8PSAnJ1xyXG4gICAgcGFydHMgPSAnJ1xyXG4gICAgcmV0ID0gbmlsXHJcblxyXG4gICAgYmVnaW5cclxuICAgICAgQHJlYWRfYnVmZmVyICs9IHBhcnRzXHJcbiAgICAgIGlmIGludGVnZXIgJiYgQHJlYWRfYnVmZmVyLmxlbmd0aCA+IGludGVnZXJcclxuICAgICAgICByZXQsIEByZWFkX2J1ZmZlciA9IEByZWFkX2J1ZmZlclswLi4uaW50ZWdlcl0sIEByZWFkX2J1ZmZlcltpbnRlZ2VyLi4tMV1cclxuICAgICAgICByZXR1cm4gcmV0XHJcbiAgICAgIGVuZFxyXG4gICAgZW5kIHdoaWxlIHBhcnRzID0gc3lzcmVhZF9ub3JhaXNlKGludGVnZXIgfHwgNjVfNTM2KVxyXG5cclxuICAgIHJldCwgQHJlYWRfYnVmZmVyID0gQHJlYWRfYnVmZmVyLCAnJ1xyXG4gICAgcmV0XHJcbiAgZW5kXHJcblxyXG4gICMgRWFjaGVzXHJcblxyXG4gIGRlZiByZWFkbGluZXMoc2VwYXJhdG9yID0gJC8pXHJcbiAgICBlYWNoX2xpbmUoc2VwYXJhdG9yKS50b19hXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBlYWNoKHNlcCA9ICQvLCAqYXJncywgJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVudW1fZm9yIDplYWNoLCBzZXAsICphcmdzIHVubGVzcyBibG9ja19naXZlbj9cclxuXHJcbiAgICB3aGlsZSAocyA9IGdldHMoc2VwLCAqYXJncykpXHJcbiAgICAgIHlpZWxkKHMpXHJcbiAgICBlbmRcclxuXHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBlYWNoX2J5dGUoJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVudW1fZm9yIDplYWNoX2J5dGUgdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG5cclxuICAgIHdoaWxlIChzID0gZ2V0Ynl0ZSlcclxuICAgICAgeWllbGQocylcclxuICAgIGVuZFxyXG5cclxuICAgIHNlbGZcclxuICBlbmRcclxuXHJcbiAgZGVmIGVhY2hfY2hhcigmYmxvY2spXHJcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2hfY2hhciB1bmxlc3MgYmxvY2tfZ2l2ZW4/XHJcblxyXG4gICAgd2hpbGUgKHMgPSBnZXRjKVxyXG4gICAgICB5aWVsZChzKVxyXG4gICAgZW5kXHJcblxyXG4gICAgc2VsZlxyXG4gIGVuZFxyXG5cclxuICAjIENsb3NlZG5lc3NcclxuXHJcbiAgZGVmIGNsb3NlXHJcbiAgICBAY2xvc2VkID0gOmJvdGhcclxuICBlbmRcclxuXHJcbiAgZGVmIGNsb3NlX3JlYWRcclxuICAgIGlmIEBjbG9zZWQgPT0gOndyaXRlXHJcbiAgICAgIEBjbG9zZWQgPSA6Ym90aFxyXG4gICAgZWxzZVxyXG4gICAgICBAY2xvc2VkID0gOnJlYWRcclxuICAgIGVuZFxyXG4gIGVuZFxyXG5cclxuICBkZWYgY2xvc2Vfd3JpdGVcclxuICAgIGlmIEBjbG9zZWQgPT0gOnJlYWRcclxuICAgICAgQGNsb3NlZCA9IDpib3RoXHJcbiAgICBlbHNlXHJcbiAgICAgIEBjbG9zZWQgPSA6d3JpdGVcclxuICAgIGVuZFxyXG4gIGVuZFxyXG5cclxuICBkZWYgY2xvc2VkP1xyXG4gICAgQGNsb3NlZCA9PSA6Ym90aFxyXG4gIGVuZFxyXG5cclxuICBkZWYgY2xvc2VkX3JlYWQ/XHJcbiAgICBAY2xvc2VkID09IDpyZWFkIHx8IEBjbG9zZWQgPT0gOmJvdGhcclxuICBlbmRcclxuXHJcbiAgZGVmIGNsb3NlZF93cml0ZT9cclxuICAgIEBjbG9zZWQgPT0gOndyaXRlIHx8IEBjbG9zZWQgPT0gOmJvdGhcclxuICBlbmRcclxuXHJcbiAgIyBAcHJpdmF0ZVxyXG4gIGRlZiBjaGVja193cml0YWJsZVxyXG4gICAgaWYgY2xvc2VkX3dyaXRlP1xyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OklPRXJyb3IsICdub3Qgb3BlbmVkIGZvciB3cml0aW5nJ1xyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gICMgQHByaXZhdGVcclxuICBkZWYgY2hlY2tfcmVhZGFibGVcclxuICAgIGlmIGNsb3NlZF9yZWFkP1xyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OklPRXJyb3IsICdub3Qgb3BlbmVkIGZvciByZWFkaW5nJ1xyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGFsaWFzIGVhY2hfbGluZSBlYWNoXHJcbiAgYWxpYXMgZW9mPyBlb2ZcclxuZW5kXHJcblxyXG46OlNURElOICA9ICRzdGRpbiAgPSA6OklPLm5ldygwLCAncicpXHJcbjo6U1RET1VUID0gJHN0ZG91dCA9IDo6SU8ubmV3KDEsICd3JylcclxuOjpTVERFUlIgPSAkc3RkZXJyID0gOjpJTy5uZXcoMiwgJ3cnKVxyXG5cclxuYHZhciBjb25zb2xlID0gT3BhbC5nbG9iYWwuY29uc29sZWBcclxuOjpTVERPVVQud3JpdGVfcHJvYyA9IGB0eXBlb2YocHJvY2VzcykgPT09ICdvYmplY3QnICYmIHR5cGVvZihwcm9jZXNzLnN0ZG91dCkgPT09ICdvYmplY3QnID8gZnVuY3Rpb24ocyl7cHJvY2Vzcy5zdGRvdXQud3JpdGUocyl9IDogZnVuY3Rpb24ocyl7Y29uc29sZS5sb2cocyl9YFxyXG46OlNUREVSUi53cml0ZV9wcm9jID0gYHR5cGVvZihwcm9jZXNzKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mKHByb2Nlc3Muc3RkZXJyKSA9PT0gJ29iamVjdCcgPyBmdW5jdGlvbihzKXtwcm9jZXNzLnN0ZGVyci53cml0ZShzKX0gOiBmdW5jdGlvbihzKXtjb25zb2xlLndhcm4ocyl9YFxyXG5cclxuOjpTVERJTi5yZWFkX3Byb2MgPSBgZnVuY3Rpb24ocykgeyB2YXIgcCA9IHByb21wdCgpOyBpZiAocCAhPT0gbnVsbCkgcmV0dXJuIHAgKyBcIlxcblwiOyByZXR1cm4gbmlsOyB9YFxyXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpJTz4iLCJzZWxmIiwiMCIsIjEiLCIyIiwiMyIsIjQiLCJhdHRyX3JlYWRlciIsImF0dHJfYWNjZXNzb3IiLCJpbml0aWFsaXplIiwiZmQiLCJmbGFncyIsIkBmZCIsIkBmbGFncyIsIkBlb2YiLCJpbmNsdWRlPyIsIm1hdGNoPyIsIkBjbG9zZWQiLCJmaWxlbm8iLCJ0dHk/Iiwid3JpdGUiLCJzdHJpbmciLCJzaXplIiwiZmx1c2giLCI8PCIsInByaW50IiwiS2VybmVsIiwiU3RyaW5nIiwiJCwiLCJwdXRzIiwiZmxhdHRlbiIsImdldGMiLCJAcmVhZF9idWZmZXIiLCIkcmV0X29yXzEiLCJwYXJ0cyIsIisiLCJyZXQiLCJbXSIsIi0xIiwic3lzcmVhZF9ub3JhaXNlIiwiZ2V0Ynl0ZSIsInJlYWRieXRlIiwicmVhZGNoYXIiLCJvcmQiLCJyYWlzZSIsIkVPRkVycm9yIiwicmVhZGxpbmUiLCJnZXRzIiwiYXJncyIsInNlcCIsImxpbWl0Iiwib3B0cyIsIm9yaWdfc2VwIiwiJC8iLCJ0b19zdHIiLCJzZXBsZW4iLCJsZW5ndGgiLCJkYXRhIiwib3JpZ19idWZmZXIiLCJzcGxpdCIsIjY1NTM2Iiwic3ViIiwiJF8iLCJzeXNyZWFkIiwiaW50ZWdlciIsInJlYWRwYXJ0aWFsIiwicGFydCIsInJlYWQiLCI+IiwicmVhZGxpbmVzIiwic2VwYXJhdG9yIiwiZWFjaF9saW5lIiwidG9fYSIsImVhY2giLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsInMiLCJlYWNoX2J5dGUiLCJlYWNoX2NoYXIiLCJjbG9zZSIsImNsb3NlX3JlYWQiLCJjbG9zZV93cml0ZSIsImNsb3NlZD8iLCI9PSIsImNsb3NlZF9yZWFkPyIsImNsb3NlZF93cml0ZT8iLCJjaGVja193cml0YWJsZSIsIklPRXJyb3IiLCJjaGVja19yZWFkYWJsZSIsIiRzdGRpbiIsIklPIiwibmV3IiwiJHN0ZG91dCIsIiRzdGRlcnIiLCJTVERPVVQiLCJ3cml0ZV9wcm9jPSIsIlNUREVSUiIsInJlYWRfcHJvYz0iLCJTVERJTiJdLCJtYXBwaW5ncyI6IkFBQUFBLDZCQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQztFQUFBQTs7SUFBQUE7O0FBQUFBOztJQUNFLFdBQUFDLElBQUEsY0FBaUJDLENBQWpCO0lBQ0EsV0FBQUQsSUFBQSxjQUFpQkUsQ0FBakI7SUFDQSxXQUFBRixJQUFBLGNBQWlCRyxDQUFqQjtJQUNBLFdBQUFILElBQUEsZUFBa0JJLENBQWxCO0lBQ0EsV0FBQUosSUFBQSxlQUFrQkssQ0FBbEI7SUFFQSxXQUFBTCxJQUFBLGNBQWlCRSxDQUFqQjtJQUNBLFdBQUFGLElBQUEsY0FBaUJLLENBQWpCO0lBRUFMLElBQUFNLGFBQUFBLENBQVksS0FBWkE7SUFFQU4sSUFBQU8sZUFBQUEsQ0FBYyxXQUFkLEVBQTJCLE1BQTNCLEVBQWtDLEtBQWxDLEVBQXdDLFlBQXhDQTs7QUFFQUMsSUFBQUEsMEJBQUFBLHNCQUFlQyxFQUFELEVBQUtDLEtBQW5CRjtBQUFBQSxNQUFBQTs7O01BQW1CLDJCQUFRQTtNQUN6QkcsVUFBTUY7TUFDTkcsYUFBU0Y7TUFDVEcsV0FBTztNQUVQLElBQUcsQ0FBQSxRQUFBSCxLQUFLSSxhQUFBQSxDQUFVTixHQUFWTSxDQUFMLENBQUEsSUFBQSxDQUFBLEtBQXdCSixLQUFLSyxXQUFBQSxDQUFRLGlCQUFBLFFBQUEsV0FBUkEsQ0FBN0IsQ0FBQSxDQUFB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UUF2U0o0QyxPQUFBO01BdVNJO0lBREZBLENBQUFBO0lBTUEsYUFBTSxXQUFOLEVBQWdCLE1BQWhCO0lBQ0F4RixPQUFBLGFBQU0sTUFBTixFQUFXLEtBQVg7RUEzU0ZBLEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7RUE4U0EsV0FBQSxJQUFBLFdBQVd5RixDQUFBQSxlQUFVQyxTQUFJQyxLQUFBQSxDQUFLekYsQ0FBVCxFQUFZSCxHQUFSNEYsQ0FBZEYsQ0FBWDtFQUNBLFdBQUEsSUFBQSxZQUFXRyxDQUFBQSxnQkFBVUYsU0FBSUMsS0FBQUEsQ0FBS3hGLENBQVQsRUFBWUosR0FBUjRGLENBQWRDLENBQVg7RUFDQSxXQUFBLElBQUEsWUFBV0MsQ0FBQUEsZ0JBQVVILFNBQUlDLEtBQUFBLENBQUt2RixDQUFULEVBQVlMLEdBQVI0RixDQUFkRSxDQUFYO0VBRUM5RjtFQUNEK0YsYUFBUUMsZ0JBQUFBLENBQWVoRyx3SUFBZmdHO0VBQ1JDLGFBQVFELGdCQUFBQSxDQUFlaEcseUlBQWZnRztFQUVSaEcsT0FBT2tHLE1BQUFBLENBQWNsRyw4RUFBZGtHLENBQUFBLEVBQUFBLE1BQVBDLFlBQU9ELGNBQUFBLEVBQUFBLEVBQUFBLENBQUFBLEVBQUFBO0FBeFRQbEc7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIxNTQwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsib3BhbC9taW5pLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIjo6T2JqZWN0LnJlcXVpcmUgJ29wYWwvYmFzZSdcclxuXHJcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvbmlsJ1xyXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2Jvb2xlYW4nXHJcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvY29tcGFyYWJsZSdcclxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9yZWdleHAnXHJcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvc3RyaW5nJ1xyXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3N0cmluZy9tdXRhYmxlJ1xyXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2VudW1lcmFibGUnXHJcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYXRvcidcclxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9hcnJheSdcclxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9oYXNoJ1xyXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL251bWJlcidcclxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9yYW5nZSdcclxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9wcm9jJ1xyXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL21ldGhvZCdcclxuOjpPYmplY3QucmVxdWlyZSAnb3BhbC9yZWdleHBfdHJhbnNwaWxlcidcclxuOjpPYmplY3QucmVxdWlyZSAnb3BhbC9yZWdleHBfYW5jaG9ycydcclxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi92YXJpYWJsZXMnXHJcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvc3RyaW5nL2VuY29kaW5nJ1xyXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2lvJ1xyXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIk9iamVjdCIsInJlcXVpcmUiXSwibWFwcGluZ3MiOiJBQUFBQSw0QkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsT0FBUUMsU0FBQUEsQ0FBU0YsV0FBVEU7RUFFUkQsT0FBUUMsU0FBQUEsQ0FBU0YsYUFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsaUJBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLG9CQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixnQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsZ0JBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLHdCQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixvQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0Ysb0JBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGVBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGNBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGdCQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixlQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixjQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixnQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0Ysd0JBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLHFCQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixtQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YseUJBQVRFO0VBQ1JGLE9BQUFDLE9BQVFDLFNBQUFBLENBQVNGLFlBQVRFO0FBcEJSRjsifX0seyJvZmZzZXQiOnsibGluZSI6MjE1NjcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2tlcm5lbC9mb3JtYXQucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBjb2VyY2VfdG9cclxuIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXHJcblxyXG5tb2R1bGUgOjpLZXJuZWxcclxuICBkZWYgZm9ybWF0KGZvcm1hdF9zdHJpbmcsICphcmdzKVxyXG4gICAgaWYgYXJncy5sZW5ndGggPT0gMSAmJiBhcmdzWzBdLnJlc3BvbmRfdG8/KDp0b19hcnkpXHJcbiAgICAgIGFyeSA9IDo6T3BhbC5jb2VyY2VfdG8/KGFyZ3NbMF0sIDo6QXJyYXksIDp0b19hcnkpXHJcbiAgICAgIGFyZ3MgPSBhcnkudG9fYSB1bmxlc3MgYXJ5Lm5pbD9cclxuICAgIGVuZFxyXG5cclxuICAgICV4e1xyXG4gICAgICB2YXIgcmVzdWx0ID0gJycsXHJcbiAgICAgICAgICAvL3VzZWQgZm9yIHNsaWNpbmc6XHJcbiAgICAgICAgICBiZWdpbl9zbGljZSA9IDAsXHJcbiAgICAgICAgICBlbmRfc2xpY2UsXHJcbiAgICAgICAgICAvL3VzZWQgZm9yIGl0ZXJhdGluZyBvdmVyIHRoZSBmb3JtYXQgc3RyaW5nOlxyXG4gICAgICAgICAgaSxcclxuICAgICAgICAgIGxlbiA9IGZvcm1hdF9zdHJpbmcubGVuZ3RoLFxyXG4gICAgICAgICAgLy91c2VkIGZvciBwcm9jZXNzaW5nIGZpZWxkIHZhbHVlczpcclxuICAgICAgICAgIGFyZyxcclxuICAgICAgICAgIHN0cixcclxuICAgICAgICAgIC8vdXNlZCBmb3IgcHJvY2Vzc2luZyAlZyBhbmQgJUcgZmllbGRzOlxyXG4gICAgICAgICAgZXhwb25lbnQsXHJcbiAgICAgICAgICAvL3VzZWQgZm9yIGtlZXBpbmcgdHJhY2sgb2Ygd2lkdGggYW5kIHByZWNpc2lvbjpcclxuICAgICAgICAgIHdpZHRoLFxyXG4gICAgICAgICAgcHJlY2lzaW9uLFxyXG4gICAgICAgICAgLy91c2VkIGZvciBob2xkaW5nIHRlbXBvcmFyeSB2YWx1ZXM6XHJcbiAgICAgICAgICB0bXBfbnVtLFxyXG4gICAgICAgICAgLy91c2VkIGZvciBwcm9jZXNzaW5nICV7fSBhbmQgJTw+IGZpbGVkczpcclxuICAgICAgICAgIGhhc2hfcGFyYW1ldGVyX2tleSxcclxuICAgICAgICAgIGNsb3NpbmdfYnJhY2VfY2hhcixcclxuICAgICAgICAgIC8vdXNlZCBmb3IgcHJvY2Vzc2luZyAlYiwgJUIsICVvLCAleCwgYW5kICVYIGZpZWxkczpcclxuICAgICAgICAgIGJhc2VfbnVtYmVyLFxyXG4gICAgICAgICAgYmFzZV9wcmVmaXgsXHJcbiAgICAgICAgICBiYXNlX25lZ196ZXJvX3JlZ2V4LFxyXG4gICAgICAgICAgYmFzZV9uZWdfemVyb19kaWdpdCxcclxuICAgICAgICAgIC8vdXNlZCBmb3IgcHJvY2Vzc2luZyBhcmd1bWVudHM6XHJcbiAgICAgICAgICBuZXh0X2FyZyxcclxuICAgICAgICAgIHNlcV9hcmdfbnVtID0gMSxcclxuICAgICAgICAgIHBvc19hcmdfbnVtID0gMCxcclxuICAgICAgICAgIC8vdXNlZCBmb3Iga2VlcGluZyB0cmFjayBvZiBmbGFnczpcclxuICAgICAgICAgIGZsYWdzLFxyXG4gICAgICAgICAgRk5PTkUgID0gMCxcclxuICAgICAgICAgIEZTSEFSUCA9IDEsXHJcbiAgICAgICAgICBGTUlOVVMgPSAyLFxyXG4gICAgICAgICAgRlBMVVMgID0gNCxcclxuICAgICAgICAgIEZaRVJPICA9IDgsXHJcbiAgICAgICAgICBGU1BBQ0UgPSAxNixcclxuICAgICAgICAgIEZXSURUSCA9IDMyLFxyXG4gICAgICAgICAgRlBSRUMgID0gNjQsXHJcbiAgICAgICAgICBGUFJFQzAgPSAxMjg7XHJcblxyXG4gICAgICBmdW5jdGlvbiBDSEVDS19GT1JfRkxBR1MoKSB7XHJcbiAgICAgICAgaWYgKGZsYWdzJkZXSURUSCkgeyAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2ZsYWcgYWZ0ZXIgd2lkdGgnfSB9XHJcbiAgICAgICAgaWYgKGZsYWdzJkZQUkVDMCkgeyAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2ZsYWcgYWZ0ZXIgcHJlY2lzaW9uJ30gfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBDSEVDS19GT1JfV0lEVEgoKSB7XHJcbiAgICAgICAgaWYgKGZsYWdzJkZXSURUSCkgeyAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3dpZHRoIGdpdmVuIHR3aWNlJ30gfVxyXG4gICAgICAgIGlmIChmbGFncyZGUFJFQzApIHsgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd3aWR0aCBhZnRlciBwcmVjaXNpb24nfSB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIEdFVF9OVEhfQVJHKG51bSkge1xyXG4gICAgICAgIGlmIChudW0gPj0gYXJncy5sZW5ndGgpIHsgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0b28gZmV3IGFyZ3VtZW50cyd9IH1cclxuICAgICAgICByZXR1cm4gYXJnc1tudW1dO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBHRVRfTkVYVF9BUkcoKSB7XHJcbiAgICAgICAgc3dpdGNoIChwb3NfYXJnX251bSkge1xyXG4gICAgICAgIGNhc2UgLTE6ICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcInVubnVtYmVyZWQoI3tgc2VxX2FyZ19udW1gfSkgbWl4ZWQgd2l0aCBudW1iZXJlZFwifSAvLyByYWlzZVxyXG4gICAgICAgIGNhc2UgLTI6ICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcInVubnVtYmVyZWQoI3tgc2VxX2FyZ19udW1gfSkgbWl4ZWQgd2l0aCBuYW1lZFwifSAvLyByYWlzZVxyXG4gICAgICAgIH1cclxuICAgICAgICBwb3NfYXJnX251bSA9IHNlcV9hcmdfbnVtKys7XHJcbiAgICAgICAgcmV0dXJuIEdFVF9OVEhfQVJHKHBvc19hcmdfbnVtIC0gMSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIEdFVF9QT1NfQVJHKG51bSkge1xyXG4gICAgICAgIGlmIChwb3NfYXJnX251bSA+IDApIHtcclxuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIm51bWJlcmVkKCN7YG51bWB9KSBhZnRlciB1bm51bWJlcmVkKCN7YHBvc19hcmdfbnVtYH0pXCJ9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwb3NfYXJnX251bSA9PT0gLTIpIHtcclxuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIm51bWJlcmVkKCN7YG51bWB9KSBhZnRlciBuYW1lZFwifVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobnVtIDwgMSkge1xyXG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCBpbmRleCAtICN7YG51bWB9JFwifVxyXG4gICAgICAgIH1cclxuICAgICAgICBwb3NfYXJnX251bSA9IC0xO1xyXG4gICAgICAgIHJldHVybiBHRVRfTlRIX0FSRyhudW0gLSAxKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gR0VUX0FSRygpIHtcclxuICAgICAgICByZXR1cm4gKG5leHRfYXJnID09PSB1bmRlZmluZWQgPyBHRVRfTkVYVF9BUkcoKSA6IG5leHRfYXJnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gUkVBRF9OVU0obGFiZWwpIHtcclxuICAgICAgICB2YXIgbnVtLCBzdHIgPSAnJztcclxuICAgICAgICBmb3IgKDs7IGkrKykge1xyXG4gICAgICAgICAgaWYgKGkgPT09IGxlbikge1xyXG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ21hbGZvcm1lZCBmb3JtYXQgc3RyaW5nIC0gJSpbMC05XSd9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQ29kZUF0KGkpIDwgNDggfHwgZm9ybWF0X3N0cmluZy5jaGFyQ29kZUF0KGkpID4gNTcpIHtcclxuICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICBudW0gPSBwYXJzZUludChzdHIsIDEwKSB8fCAwO1xyXG4gICAgICAgICAgICBpZiAobnVtID4gMjE0NzQ4MzY0Nykge1xyXG4gICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIiN7YGxhYmVsYH0gdG9vIGJpZ1wifVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudW07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzdHIgKz0gZm9ybWF0X3N0cmluZy5jaGFyQXQoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBSRUFEX05VTV9BRlRFUl9BU1RFUihsYWJlbCkge1xyXG4gICAgICAgIHZhciBhcmcsIG51bSA9IFJFQURfTlVNKGxhYmVsKTtcclxuICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSArIDEpID09PSAnJCcpIHtcclxuICAgICAgICAgIGkrKztcclxuICAgICAgICAgIGFyZyA9IEdFVF9QT1NfQVJHKG51bSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGFyZyA9IEdFVF9ORVhUX0FSRygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gI3tgYXJnYC50b19pbnR9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGkgPSBmb3JtYXRfc3RyaW5nLmluZGV4T2YoJyUnKTsgaSAhPT0gLTE7IGkgPSBmb3JtYXRfc3RyaW5nLmluZGV4T2YoJyUnLCBpKSkge1xyXG4gICAgICAgIHN0ciA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgZmxhZ3MgPSBGTk9ORTtcclxuICAgICAgICB3aWR0aCA9IC0xO1xyXG4gICAgICAgIHByZWNpc2lvbiA9IC0xO1xyXG4gICAgICAgIG5leHRfYXJnID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICBlbmRfc2xpY2UgPSBpO1xyXG5cclxuICAgICAgICBpKys7XHJcblxyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkpIHtcclxuICAgICAgICBjYXNlICclJzpcclxuICAgICAgICAgIGJlZ2luX3NsaWNlID0gaTtcclxuICAgICAgICAgIC8vIG5vLWJyZWFrXHJcbiAgICAgICAgY2FzZSAnJzpcclxuICAgICAgICBjYXNlICdcXG4nOlxyXG4gICAgICAgIGNhc2UgJ1xcMCc6XHJcbiAgICAgICAgICBpKys7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvcm1hdF9zZXF1ZW5jZTogZm9yICg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgc3dpdGNoIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSkge1xyXG5cclxuICAgICAgICAgIGNhc2UgJyAnOlxyXG4gICAgICAgICAgICBDSEVDS19GT1JfRkxBR1MoKTtcclxuICAgICAgICAgICAgZmxhZ3MgfD0gRlNQQUNFO1xyXG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XHJcblxyXG4gICAgICAgICAgY2FzZSAnIyc6XHJcbiAgICAgICAgICAgIENIRUNLX0ZPUl9GTEFHUygpO1xyXG4gICAgICAgICAgICBmbGFncyB8PSBGU0hBUlA7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcclxuXHJcbiAgICAgICAgICBjYXNlICcrJzpcclxuICAgICAgICAgICAgQ0hFQ0tfRk9SX0ZMQUdTKCk7XHJcbiAgICAgICAgICAgIGZsYWdzIHw9IEZQTFVTO1xyXG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XHJcblxyXG4gICAgICAgICAgY2FzZSAnLSc6XHJcbiAgICAgICAgICAgIENIRUNLX0ZPUl9GTEFHUygpO1xyXG4gICAgICAgICAgICBmbGFncyB8PSBGTUlOVVM7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcclxuXHJcbiAgICAgICAgICBjYXNlICcwJzpcclxuICAgICAgICAgICAgQ0hFQ0tfRk9SX0ZMQUdTKCk7XHJcbiAgICAgICAgICAgIGZsYWdzIHw9IEZaRVJPO1xyXG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XHJcblxyXG4gICAgICAgICAgY2FzZSAnMSc6XHJcbiAgICAgICAgICBjYXNlICcyJzpcclxuICAgICAgICAgIGNhc2UgJzMnOlxyXG4gICAgICAgICAgY2FzZSAnNCc6XHJcbiAgICAgICAgICBjYXNlICc1JzpcclxuICAgICAgICAgIGNhc2UgJzYnOlxyXG4gICAgICAgICAgY2FzZSAnNyc6XHJcbiAgICAgICAgICBjYXNlICc4JzpcclxuICAgICAgICAgIGNhc2UgJzknOlxyXG4gICAgICAgICAgICB0bXBfbnVtID0gUkVBRF9OVU0oJ3dpZHRoJyk7XHJcbiAgICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpICsgMSkgPT09ICckJykge1xyXG4gICAgICAgICAgICAgIGlmIChpICsgMiA9PT0gbGVuKSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSAnJSc7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmIChuZXh0X2FyZyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ2YWx1ZSBnaXZlbiB0d2ljZSAtICUje2B0bXBfbnVtYH0kXCJ9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIG5leHRfYXJnID0gR0VUX1BPU19BUkcodG1wX251bSk7XHJcbiAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIENIRUNLX0ZPUl9XSURUSCgpO1xyXG4gICAgICAgICAgICAgIGZsYWdzIHw9IEZXSURUSDtcclxuICAgICAgICAgICAgICB3aWR0aCA9IHRtcF9udW07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xyXG5cclxuICAgICAgICAgIGNhc2UgJzwnOlxyXG4gICAgICAgICAgY2FzZSAnXFx7JzpcclxuICAgICAgICAgICAgY2xvc2luZ19icmFjZV9jaGFyID0gKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpID09PSAnPCcgPyAnPicgOiAnXFx9Jyk7XHJcbiAgICAgICAgICAgIGhhc2hfcGFyYW1ldGVyX2tleSA9ICcnO1xyXG5cclxuICAgICAgICAgICAgaSsrO1xyXG5cclxuICAgICAgICAgICAgZm9yICg7OyBpKyspIHtcclxuICAgICAgICAgICAgICBpZiAoaSA9PT0gbGVuKSB7XHJcbiAgICAgICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ21hbGZvcm1lZCBuYW1lIC0gdW5tYXRjaGVkIHBhcmVudGhlc2lzJ31cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpID09PSBjbG9zaW5nX2JyYWNlX2NoYXIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocG9zX2FyZ19udW0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIm5hbWVkICN7YGhhc2hfcGFyYW1ldGVyX2tleWB9IGFmdGVyIHVubnVtYmVyZWQoI3tgcG9zX2FyZ19udW1gfSlcIn1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwb3NfYXJnX251bSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwibmFtZWQgI3tgaGFzaF9wYXJhbWV0ZXJfa2V5YH0gYWZ0ZXIgbnVtYmVyZWRcIn1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBvc19hcmdfbnVtID0gLTI7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3NbMF0gPT09IHVuZGVmaW5lZCB8fCAhYXJnc1swXS4kJGlzX2hhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdvbmUgaGFzaCByZXF1aXJlZCd9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbmV4dF9hcmcgPSAje2BhcmdzWzBdYC5mZXRjaChgaGFzaF9wYXJhbWV0ZXJfa2V5YCl9O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjbG9zaW5nX2JyYWNlX2NoYXIgPT09ICc+Jykge1xyXG4gICAgICAgICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBzdHIgPSBuZXh0X2FyZy50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICBpZiAocHJlY2lzaW9uICE9PSAtMSkgeyBzdHIgPSBzdHIuc2xpY2UoMCwgcHJlY2lzaW9uKTsgfVxyXG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaGFzaF9wYXJhbWV0ZXJfa2V5ICs9IGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJhaXNlXHJcblxyXG4gICAgICAgICAgY2FzZSAnKic6XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgQ0hFQ0tfRk9SX1dJRFRIKCk7XHJcbiAgICAgICAgICAgIGZsYWdzIHw9IEZXSURUSDtcclxuICAgICAgICAgICAgd2lkdGggPSBSRUFEX05VTV9BRlRFUl9BU1RFUignd2lkdGgnKTtcclxuICAgICAgICAgICAgaWYgKHdpZHRoIDwgMCkge1xyXG4gICAgICAgICAgICAgIGZsYWdzIHw9IEZNSU5VUztcclxuICAgICAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XHJcblxyXG4gICAgICAgICAgY2FzZSAnLic6XHJcbiAgICAgICAgICAgIGlmIChmbGFncyZGUFJFQzApIHtcclxuICAgICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3ByZWNpc2lvbiBnaXZlbiB0d2ljZSd9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmxhZ3MgfD0gRlBSRUN8RlBSRUMwO1xyXG4gICAgICAgICAgICBwcmVjaXNpb24gPSAwO1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSA9PT0gJyonKSB7XHJcbiAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgIHByZWNpc2lvbiA9IFJFQURfTlVNX0FGVEVSX0FTVEVSKCdwcmVjaXNpb24nKTtcclxuICAgICAgICAgICAgICBpZiAocHJlY2lzaW9uIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgZmxhZ3MgJj0gfkZQUkVDO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJlY2lzaW9uID0gUkVBRF9OVU0oJ3ByZWNpc2lvbicpO1xyXG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XHJcblxyXG4gICAgICAgICAgY2FzZSAnZCc6XHJcbiAgICAgICAgICBjYXNlICdpJzpcclxuICAgICAgICAgIGNhc2UgJ3UnOlxyXG4gICAgICAgICAgICBhcmcgPSAjezo6S2VybmVsLkludGVnZXIoYEdFVF9BUkcoKWApfTtcclxuICAgICAgICAgICAgaWYgKGFyZyA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgc3RyID0gYXJnLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBwcmVjaXNpb24pIHsgc3RyID0gJzAnICsgc3RyOyB9XHJcbiAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgcHJlY2lzaW9uID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gKChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpID8gMSA6IDApKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxyXG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxyXG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBzdHIgPSAoLWFyZykudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHByZWNpc2lvbikgeyBzdHIgPSAnMCcgKyBzdHI7IH1cclxuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgcHJlY2lzaW9uID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gMSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cclxuICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XHJcblxyXG4gICAgICAgICAgY2FzZSAnYic6XHJcbiAgICAgICAgICBjYXNlICdCJzpcclxuICAgICAgICAgIGNhc2UgJ28nOlxyXG4gICAgICAgICAgY2FzZSAneCc6XHJcbiAgICAgICAgICBjYXNlICdYJzpcclxuICAgICAgICAgICAgc3dpdGNoIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSkge1xyXG4gICAgICAgICAgICBjYXNlICdiJzpcclxuICAgICAgICAgICAgY2FzZSAnQic6XHJcbiAgICAgICAgICAgICAgYmFzZV9udW1iZXIgPSAyO1xyXG4gICAgICAgICAgICAgIGJhc2VfcHJlZml4ID0gJzBiJztcclxuICAgICAgICAgICAgICBiYXNlX25lZ196ZXJvX3JlZ2V4ID0gL14xKy87XHJcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19kaWdpdCA9ICcxJztcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnbyc6XHJcbiAgICAgICAgICAgICAgYmFzZV9udW1iZXIgPSA4O1xyXG4gICAgICAgICAgICAgIGJhc2VfcHJlZml4ID0gJzAnO1xyXG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fcmVnZXggPSAvXjM/NysvO1xyXG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fZGlnaXQgPSAnNyc7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3gnOlxyXG4gICAgICAgICAgICBjYXNlICdYJzpcclxuICAgICAgICAgICAgICBiYXNlX251bWJlciA9IDE2O1xyXG4gICAgICAgICAgICAgIGJhc2VfcHJlZml4ID0gJzB4JztcclxuICAgICAgICAgICAgICBiYXNlX25lZ196ZXJvX3JlZ2V4ID0gL15mKy87XHJcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19kaWdpdCA9ICdmJztcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhcmcgPSAjezo6S2VybmVsLkludGVnZXIoYEdFVF9BUkcoKWApfTtcclxuICAgICAgICAgICAgaWYgKGFyZyA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgc3RyID0gYXJnLnRvU3RyaW5nKGJhc2VfbnVtYmVyKTtcclxuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHByZWNpc2lvbikgeyBzdHIgPSAnMCcgKyBzdHI7IH1cclxuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cclxuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlAgJiYgYXJnICE9PSAwKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgcHJlY2lzaW9uID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gKChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpID8gMSA6IDApIC0gKChmbGFncyZGU0hBUlAgJiYgYXJnICE9PSAwKSA/IGJhc2VfcHJlZml4Lmxlbmd0aCA6IDApKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxyXG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQICYmIGFyZyAhPT0gMCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxyXG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlAgJiYgYXJnICE9PSAwKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XHJcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxyXG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSAoLWFyZykudG9TdHJpbmcoYmFzZV9udW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBwcmVjaXNpb24pIHsgc3RyID0gJzAnICsgc3RyOyB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cclxuICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIHByZWNpc2lvbiA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gMSAtIChmbGFncyZGU0hBUlAgPyAyIDogMCkpIHsgc3RyID0gJzAnICsgc3RyOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxyXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3RyID0gKGFyZyA+Pj4gMCkudG9TdHJpbmcoYmFzZV9udW1iZXIpLnJlcGxhY2UoYmFzZV9uZWdfemVyb19yZWdleCwgYmFzZV9uZWdfemVyb19kaWdpdCk7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHByZWNpc2lvbiAtIDIpIHsgc3RyID0gYmFzZV9uZWdfemVyb19kaWdpdCArIHN0cjsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xyXG4gICAgICAgICAgICAgICAgICBzdHIgPSAnLi4nICsgc3RyO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XHJcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgcHJlY2lzaW9uID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAyIC0gKGZsYWdzJkZTSEFSUCA/IGJhc2VfcHJlZml4Lmxlbmd0aCA6IDApKSB7IHN0ciA9IGJhc2VfbmVnX3plcm9fZGlnaXQgKyBzdHI7IH1cclxuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLi4nICsgc3RyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLi4nICsgc3RyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSA9PT0gZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgIHN0ciA9IHN0ci50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcclxuXHJcbiAgICAgICAgICBjYXNlICdmJzpcclxuICAgICAgICAgIGNhc2UgJ2UnOlxyXG4gICAgICAgICAgY2FzZSAnRSc6XHJcbiAgICAgICAgICBjYXNlICdnJzpcclxuICAgICAgICAgIGNhc2UgJ0cnOlxyXG4gICAgICAgICAgICBhcmcgPSAjezo6S2VybmVsLkZsb2F0KGBHRVRfQVJHKClgKX07XHJcbiAgICAgICAgICAgIGlmIChhcmcgPj0gMCB8fCBpc05hTihhcmcpKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGFyZyA9PT0gSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgICAgIHN0ciA9ICdJbmYnO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdmJzpcclxuICAgICAgICAgICAgICAgICAgc3RyID0gYXJnLnRvRml4ZWQocHJlY2lzaW9uID09PSAtMSA/IDYgOiBwcmVjaXNpb24pO1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2UnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnRSc6XHJcbiAgICAgICAgICAgICAgICAgIHN0ciA9IGFyZy50b0V4cG9uZW50aWFsKHByZWNpc2lvbiA9PT0gLTEgPyA2IDogcHJlY2lzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdnJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ0cnOlxyXG4gICAgICAgICAgICAgICAgICBzdHIgPSBhcmcudG9FeHBvbmVudGlhbCgpO1xyXG4gICAgICAgICAgICAgICAgICBleHBvbmVudCA9IHBhcnNlSW50KHN0ci5zcGxpdCgnZScpWzFdLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgIGlmICghKGV4cG9uZW50IDwgLTQgfHwgZXhwb25lbnQgPj0gKHByZWNpc2lvbiA9PT0gLTEgPyA2IDogcHJlY2lzaW9uKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgPSBhcmcudG9QcmVjaXNpb24ocHJlY2lzaW9uID09PSAtMSA/IChmbGFncyZGU0hBUlAgPyA2IDogdW5kZWZpbmVkKSA6IHByZWNpc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIGFyZyAhPT0gSW5maW5pdHkgJiYgIWlzTmFOKGFyZykpIHtcclxuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCAtICgoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSA/IDEgOiAwKSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cclxuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cclxuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaWYgKGFyZyA9PT0gLUluZmluaXR5KSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSAnSW5mJztcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZic6XHJcbiAgICAgICAgICAgICAgICAgIHN0ciA9ICgtYXJnKS50b0ZpeGVkKHByZWNpc2lvbiA9PT0gLTEgPyA2IDogcHJlY2lzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdlJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ0UnOlxyXG4gICAgICAgICAgICAgICAgICBzdHIgPSAoLWFyZykudG9FeHBvbmVudGlhbChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZyc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdHJzpcclxuICAgICAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvRXhwb25lbnRpYWwoKTtcclxuICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSBwYXJzZUludChzdHIuc3BsaXQoJ2UnKVsxXSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoIShleHBvbmVudCA8IC00IHx8IGV4cG9uZW50ID49IChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvUHJlY2lzaW9uKHByZWNpc2lvbiA9PT0gLTEgPyAoZmxhZ3MmRlNIQVJQID8gNiA6IHVuZGVmaW5lZCkgOiBwcmVjaXNpb24pO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgYXJnICE9PSAtSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCAtIDEpIHsgc3RyID0gJzAnICsgc3RyOyB9XHJcbiAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpID09PSBmb3JtYXRfc3RyaW5nLmNoYXJBdChpKS50b1VwcGVyQ2FzZSgpICYmIGFyZyAhPT0gSW5maW5pdHkgJiYgYXJnICE9PSAtSW5maW5pdHkgJiYgIWlzTmFOKGFyZykpIHtcclxuICAgICAgICAgICAgICBzdHIgPSBzdHIudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvKFtlRV1bLStdPykoWzAtOV0pJC8sICckMTAkMicpO1xyXG4gICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XHJcblxyXG4gICAgICAgICAgY2FzZSAnYSc6XHJcbiAgICAgICAgICBjYXNlICdBJzpcclxuICAgICAgICAgICAgLy8gTm90IGltcGxlbWVudGVkIGJlY2F1c2UgdGhlcmUgYXJlIG5vIHNwZWNzIGZvciB0aGlzIGZpZWxkIHR5cGUuXHJcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpOb3RJbXBsZW1lbnRlZEVycm9yLCAnYEFgIGFuZCBgYWAgZm9ybWF0IGZpZWxkIHR5cGVzIGFyZSBub3QgaW1wbGVtZW50ZWQgaW4gT3BhbCB5ZXQnfVxyXG4gICAgICAgICAgICAvLyByYWlzZVxyXG5cclxuICAgICAgICAgIGNhc2UgJ2MnOlxyXG4gICAgICAgICAgICBhcmcgPSBHRVRfQVJHKCk7XHJcbiAgICAgICAgICAgIGlmICgje2BhcmdgLnJlc3BvbmRfdG8/KDp0b19hcnkpfSkgeyBhcmcgPSAje2BhcmdgLnRvX2FyeX1bMF07IH1cclxuICAgICAgICAgICAgaWYgKCN7YGFyZ2AucmVzcG9uZF90bz8oOnRvX3N0cil9KSB7XHJcbiAgICAgICAgICAgICAgc3RyID0gI3tgYXJnYC50b19zdHJ9O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHN0ciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoJGNvZXJjZV90byhhcmcsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnJWMgcmVxdWlyZXMgYSBjaGFyYWN0ZXInfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcclxuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ3AnOlxyXG4gICAgICAgICAgICBzdHIgPSAje2BHRVRfQVJHKClgLmluc3BlY3R9O1xyXG4gICAgICAgICAgICBpZiAocHJlY2lzaW9uICE9PSAtMSkgeyBzdHIgPSBzdHIuc2xpY2UoMCwgcHJlY2lzaW9uKTsgfVxyXG4gICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XHJcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcclxuXHJcbiAgICAgICAgICBjYXNlICdzJzpcclxuICAgICAgICAgICAgc3RyID0gI3tgR0VUX0FSRygpYC50b19zfTtcclxuICAgICAgICAgICAgaWYgKHByZWNpc2lvbiAhPT0gLTEpIHsgc3RyID0gc3RyLnNsaWNlKDAsIHByZWNpc2lvbik7IH1cclxuICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xyXG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XHJcblxyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwibWFsZm9ybWVkIGZvcm1hdCBzdHJpbmcgLSAlI3tgZm9ybWF0X3N0cmluZy5jaGFyQXQoaSlgfVwifVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ21hbGZvcm1lZCBmb3JtYXQgc3RyaW5nIC0gJSd9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXN1bHQgKz0gZm9ybWF0X3N0cmluZy5zbGljZShiZWdpbl9zbGljZSwgZW5kX3NsaWNlKSArIHN0cjtcclxuICAgICAgICBiZWdpbl9zbGljZSA9IGkgKyAxO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoI3skREVCVUd9ICYmIHBvc19hcmdfbnVtID49IDAgJiYgc2VxX2FyZ19udW0gPCBhcmdzLmxlbmd0aCkge1xyXG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAndG9vIG1hbnkgYXJndW1lbnRzIGZvciBmb3JtYXQgc3RyaW5nJ31cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdCArIGZvcm1hdF9zdHJpbmcuc2xpY2UoYmVnaW5fc2xpY2UpO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBhbGlhcyBzcHJpbnRmIGZvcm1hdFxyXG5lbmRcclxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOktlcm5lbD4iLCJmb3JtYXQiLCJmb3JtYXRfc3RyaW5nIiwiYXJncyIsImxlbmd0aCIsIjEiLCJbXSIsIjAiLCJyZXNwb25kX3RvPyIsImFyeSIsIk9wYWwiLCJjb2VyY2VfdG8/IiwiQXJyYXkiLCJuaWw/IiwidG9fYSIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsInRvX2ludCIsImZldGNoIiwiSW50ZWdlciIsIkZsb2F0IiwiTm90SW1wbGVtZW50ZWRFcnJvciIsInRvX2FyeSIsInRvX3N0ciIsImluc3BlY3QiLCJ0b19zIiwiJERFQlVHIl0sIm1hcHBpbmdzIjoiQUFBQUEsd0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFHQUEsT0FBQUM7RUFBQUE7Ozs7O0FBQ0VDLElBQUFBLHNCQUFBQSxrQkFBV0MsYUFBRCxFQUpaLEVBSUVEO0FBQUFBLE1BQUFBO0FBQUFBOzs7TUFKRjtNQUk0QjtNQUN4QixJQUFHLENBQUEsTUFBQUUsSUFBSUMsUUFBQUEsQ0FBQUEsQ0FBSixFQUFlQyxDQUFmLENBQUEsSUFBQSxDQUFBLFFBQW9CRixJQUFJRyxPQUFBQSxDQUFDQyxDQUFERCxDQUFHRSxnQkFBQUEsQ0FBYSxRQUFiQSxDQUEzQixDQUFBLENBQUEsQ0FBSDs7UUFDRUMsTUFBTUMsS0FBTUMsZUFBQUEsQ0FBWVIsSUFBSUcsT0FBQUEsQ0FBQ0MsQ0FBREQsQ0FBdEIsRUFBMkJNLFlBQTNCLEVBQW9DLFFBQTlCRDtRQUNaLEtBQUEsUUFB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c0JQO0FBQzdDQSxvQkFBc0JBLENBQUNBLEdBQURBLENBQUt1QixRQUFBQSxDQUFBQSxDQUFRdkI7QUFDbkNBO0FBQ0FBLHdEQUEwRG1CLGNBQVVuQjtBQUNwRUE7QUFDQUE7QUFDQUEsY0FBZ0JjLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWdDaEIseUJBQXhCZTtBQUN4QmY7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLGtCQUFvQkEsQ0FBQ0EsU0FBREEsQ0FBV3dCLFNBQUFBLENBQUFBLENBQVN4QjtBQUN4Q0E7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLGtCQUFvQkEsQ0FBQ0EsU0FBREEsQ0FBV3lCLE1BQUFBLENBQUFBLENBQU16QjtBQUNyQ0E7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLFlBQWNjLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWlDaEIsNkJBQUQsR0FBQSxNQUErQkEsdUJBQS9CLENBQXhCZTtBQUN0QmY7QUFDQUE7O0FBRUFBO0FBQ0FBLFVBQVljLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWdDaEIsNkJBQXhCZTtBQUNwQmY7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQSxVQUFZMEIsWUFBTzFCO0FBQ25CQSxRQUFVYyxPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFnQ2hCLHNDQUF4QmU7QUFDbEJmOztBQUVBQTtBQUNBQTtJQTdoQkVBLENBQUFBLElBQUFBO0lBZ2lCQUQsT0FBQSxhQUFNLFNBQU4sRUFBYyxRQUFkO0VBamlCRkEsR0FBTyxJQUFQQTtBQUhBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjIxMzIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL21hdGgucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0eXBlX2Vycm9yXHJcbiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxyXG4jIHVzZV9zdHJpY3Q6IHRydWVcclxuXHJcbm1vZHVsZSA6Ok1hdGhcclxuICBzZWxmOjpFICA9IGBNYXRoLkVgXHJcbiAgc2VsZjo6UEkgPSBgTWF0aC5QSWBcclxuXHJcbiAgc2VsZjo6RG9tYWluRXJyb3IgPSA6OkNsYXNzLm5ldyg6OlN0YW5kYXJkRXJyb3IpXHJcblxyXG4gIGRlZiBzZWxmLmNoZWNrZWQobWV0aG9kLCAqYXJncylcclxuICAgICV4e1xyXG4gICAgICBpZiAoaXNOYU4oYXJnc1swXSkgfHwgKGFyZ3MubGVuZ3RoID09IDIgJiYgaXNOYU4oYXJnc1sxXSkpKSB7XHJcbiAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHJlc3VsdCA9IE1hdGhbbWV0aG9kXS5hcHBseShudWxsLCBhcmdzKTtcclxuXHJcbiAgICAgIGlmIChpc05hTihyZXN1bHQpKSB7XHJcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSBEb21haW5FcnJvciwgXCJOdW1lcmljYWwgYXJndW1lbnQgaXMgb3V0IG9mIGRvbWFpbiAtIFxcXCIje21ldGhvZH1cXFwiXCJ9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc2VsZi5mbG9hdCEodmFsdWUpXHJcbiAgICA6Oktlcm5lbC5GbG9hdCh2YWx1ZSlcclxuICByZXNjdWUgOjpBcmd1bWVudEVycm9yXHJcbiAgICA6Oktlcm5lbC5yYWlzZSBgJHR5cGVfZXJyb3IodmFsdWUsICN7OjpGbG9hdH0pYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgc2VsZi5pbnRlZ2VyISh2YWx1ZSlcclxuICAgIDo6S2VybmVsLkludGVnZXIodmFsdWUpXHJcbiAgcmVzY3VlIDo6QXJndW1lbnRFcnJvclxyXG4gICAgOjpLZXJuZWwucmFpc2UgYCR0eXBlX2Vycm9yKHZhbHVlLCAjezo6SW50ZWdlcn0pYFxyXG4gIGVuZFxyXG5cclxuICBtb2R1bGVfZnVuY3Rpb25cclxuXHJcbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmVyZmApXHJcbiAgICAleHtcclxuICAgICAgT3BhbC5wcm9wKE1hdGgsICdlcmYnLCBmdW5jdGlvbih4KSB7XHJcbiAgICAgICAgdmFyIEExID0gIDAuMjU0ODI5NTkyLFxyXG4gICAgICAgICAgICBBMiA9IC0wLjI4NDQ5NjczNixcclxuICAgICAgICAgICAgQTMgPSAgMS40MjE0MTM3NDEsXHJcbiAgICAgICAgICAgIEE0ID0gLTEuNDUzMTUyMDI3LFxyXG4gICAgICAgICAgICBBNSA9ICAxLjA2MTQwNTQyOSxcclxuICAgICAgICAgICAgUCAgPSAgMC4zMjc1OTExO1xyXG5cclxuICAgICAgICB2YXIgc2lnbiA9IDE7XHJcblxyXG4gICAgICAgIGlmICh4IDwgMCkge1xyXG4gICAgICAgICAgICBzaWduID0gLTE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4ID0gTWF0aC5hYnMoeCk7XHJcblxyXG4gICAgICAgIHZhciB0ID0gMS4wIC8gKDEuMCArIFAgKiB4KTtcclxuICAgICAgICB2YXIgeSA9IDEuMCAtICgoKCgoQTUgKiB0ICsgQTQpICogdCkgKyBBMykgKiB0ICsgQTIpICogdCArIEExKSAqIHQgKiBNYXRoLmV4cCgteCAqIHgpO1xyXG5cclxuICAgICAgICByZXR1cm4gc2lnbiAqIHk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGguZXJmY2ApXHJcbiAgICAleHtcclxuICAgICAgT3BhbC5wcm9wKE1hdGgsICdlcmZjJywgZnVuY3Rpb24oeCkge1xyXG4gICAgICAgIHZhciB6ID0gTWF0aC5hYnMoeCksXHJcbiAgICAgICAgICAgIHQgPSAxLjAgLyAoMC41ICogeiArIDEuMCk7XHJcblxyXG4gICAgICAgIHZhciBBMSA9IHQgKiAwLjE3MDg3Mjc3ICsgLTAuODIyMTUyMjMsXHJcbiAgICAgICAgICAgIEEyID0gdCAqIEExICsgMS40ODg1MTU4NyxcclxuICAgICAgICAgICAgQTMgPSB0ICogQTIgKyAtMS4xMzUyMDM5OCxcclxuICAgICAgICAgICAgQTQgPSB0ICogQTMgKyAwLjI3ODg2ODA3LFxyXG4gICAgICAgICAgICBBNSA9IHQgKiBBNCArIC0wLjE4NjI4ODA2LFxyXG4gICAgICAgICAgICBBNiA9IHQgKiBBNSArIDAuMDk2Nzg0MTgsXHJcbiAgICAgICAgICAgIEE3ID0gdCAqIEE2ICsgMC4zNzQwOTE5NixcclxuICAgICAgICAgICAgQTggPSB0ICogQTcgKyAxLjAwMDAyMzY4LFxyXG4gICAgICAgICAgICBBOSA9IHQgKiBBOCxcclxuICAgICAgICAgICAgQTEwID0gLXogKiB6IC0gMS4yNjU1MTIyMyArIEE5O1xyXG5cclxuICAgICAgICB2YXIgYSA9IHQgKiBNYXRoLmV4cChBMTApO1xyXG5cclxuICAgICAgICBpZiAoeCA8IDAuMCkge1xyXG4gICAgICAgICAgcmV0dXJuIDIuMCAtIGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIGE7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgIyBTaW5nbGUgYXJndW1lbnQgZXF1aXZhbGVudCBmdW5jdGlvbnNcclxuICAlaVtcclxuICAgIGFjb3MgYWNvc2ggYXNpbiBhc2luaCBhdGFuIGF0YW5oIGNicnRcclxuICAgIGNvcyBjb3NoIGVyZiBlcmZjIGV4cCBzaW4gc2luaCBzcXJ0IHRhbmhcclxuICBdLmVhY2ggZG8gfG1ldGhvZHxcclxuICAgIGRlZmluZV9tZXRob2QgbWV0aG9kIGRvIHx4fFxyXG4gICAgICA6Ok1hdGguY2hlY2tlZCBtZXRob2QsIDo6TWF0aC5mbG9hdCEoeClcclxuICAgIGVuZFxyXG4gIGVuZFxyXG5cclxuICBkZWYgYXRhbjIoeSwgeClcclxuICAgIDo6TWF0aC5jaGVja2VkIDphdGFuMiwgOjpNYXRoLmZsb2F0ISh5KSwgOjpNYXRoLmZsb2F0ISh4KVxyXG4gIGVuZFxyXG5cclxuICBkZWYgaHlwb3QoeCwgeSlcclxuICAgIDo6TWF0aC5jaGVja2VkIDpoeXBvdCwgOjpNYXRoLmZsb2F0ISh4KSwgOjpNYXRoLmZsb2F0ISh5KVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZnJleHAoeClcclxuICAgIHggPSBNYXRoLmZsb2F0ISh4KVxyXG5cclxuICAgICV4e1xyXG4gICAgICBpZiAoaXNOYU4oeCkpIHtcclxuICAgICAgICByZXR1cm4gW05hTiwgMF07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBleCAgID0gTWF0aC5mbG9vcihNYXRoLmxvZyhNYXRoLmFicyh4KSkgLyBNYXRoLmxvZygyKSkgKyAxLFxyXG4gICAgICAgICAgZnJhYyA9IHggLyBNYXRoLnBvdygyLCBleCk7XHJcblxyXG4gICAgICByZXR1cm4gW2ZyYWMsIGV4XTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGdhbW1hKG4pXHJcbiAgICBuID0gTWF0aC5mbG9hdCEobilcclxuXHJcbiAgICAleHtcclxuICAgICAgdmFyIGksIHQsIHgsIHZhbHVlLCByZXN1bHQsIHR3b04sIHRocmVlTiwgZm91ck4sIGZpdmVOO1xyXG5cclxuICAgICAgdmFyIEcgPSA0Ljc0MjE4NzU7XHJcblxyXG4gICAgICAvKiBlc2xpbnQgbm8tbG9zcy1vZi1wcmVjaXNpb246IFwid2FyblwiICovXHJcbiAgICAgIHZhciBQID0gW1xyXG4gICAgICAgICAwLjk5OTk5OTk5OTk5OTk5NzA5MTgyLFxyXG4gICAgICAgICA1Ny4xNTYyMzU2NjU4NjI5MjM1MTcsXHJcbiAgICAgICAgLTU5LjU5Nzk2MDM1NTQ3NTQ5MTI0OCxcclxuICAgICAgICAgMTQuMTM2MDk3OTc0NzQxNzQ3MTc0LFxyXG4gICAgICAgIC0wLjQ5MTkxMzgxNjA5NzYyMDE5OTc4LFxyXG4gICAgICAgICAwLjMzOTk0NjQ5OTg0ODExODg4Njk5ZS00LFxyXG4gICAgICAgICAwLjQ2NTIzNjI4OTI3MDQ4NTc1NjY1ZS00LFxyXG4gICAgICAgIC0wLjk4Mzc0NDc1MzA0ODc5NTY0Njc3ZS00LFxyXG4gICAgICAgICAwLjE1ODA4ODcwMzIyNDkxMjQ4ODg0ZS0zLFxyXG4gICAgICAgIC0wLjIxMDI2NDQ0MTcyNDEwNDg4MzE5ZS0zLFxyXG4gICAgICAgICAwLjIxNzQzOTYxODExNTIxMjY0MzIwZS0zLFxyXG4gICAgICAgIC0wLjE2NDMxODEwNjUzNjc2Mzg5MDIyZS0zLFxyXG4gICAgICAgICAwLjg0NDE4MjIzOTgzODUyNzQzMjkzZS00LFxyXG4gICAgICAgIC0wLjI2MTkwODM4NDAxNTgxNDA4NjcwZS00LFxyXG4gICAgICAgICAwLjM2ODk5MTgyNjU5NTMxNjIyNzA0ZS01XHJcbiAgICAgIF07XHJcblxyXG4gICAgICBpZiAoaXNOYU4obikpIHtcclxuICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobiA9PT0gMCAmJiAxIC8gbiA8IDApIHtcclxuICAgICAgICByZXR1cm4gLUluZmluaXR5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobiA9PT0gLTEgfHwgbiA9PT0gLUluZmluaXR5KSB7XHJcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSBEb21haW5FcnJvciwgJ051bWVyaWNhbCBhcmd1bWVudCBpcyBvdXQgb2YgZG9tYWluIC0gXCJnYW1tYVwiJ307XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICgje0ludGVnZXIgPT09IG59KSB7XHJcbiAgICAgICAgaWYgKG4gPD0gMCkge1xyXG4gICAgICAgICAgcmV0dXJuIGlzRmluaXRlKG4pID8gSW5maW5pdHkgOiBOYU47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobiA+IDE3MSkge1xyXG4gICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFsdWUgID0gbiAtIDI7XHJcbiAgICAgICAgcmVzdWx0ID0gbiAtIDE7XHJcblxyXG4gICAgICAgIHdoaWxlICh2YWx1ZSA+IDEpIHtcclxuICAgICAgICAgIHJlc3VsdCAqPSB2YWx1ZTtcclxuICAgICAgICAgIHZhbHVlLS07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmVzdWx0ID09IDApIHtcclxuICAgICAgICAgIHJlc3VsdCA9IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobiA8IDAuNSkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLlBJIC8gKE1hdGguc2luKE1hdGguUEkgKiBuKSAqICN7OjpNYXRoLmdhbW1hKDEgLSBuKX0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobiA+PSAxNzEuMzUpIHtcclxuICAgICAgICByZXR1cm4gSW5maW5pdHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChuID4gODUuMCkge1xyXG4gICAgICAgIHR3b04gICA9IG4gKiBuO1xyXG4gICAgICAgIHRocmVlTiA9IHR3b04gKiBuO1xyXG4gICAgICAgIGZvdXJOICA9IHRocmVlTiAqIG47XHJcbiAgICAgICAgZml2ZU4gID0gZm91ck4gKiBuO1xyXG5cclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KDIgKiBNYXRoLlBJIC8gbikgKiBNYXRoLnBvdygobiAvIE1hdGguRSksIG4pICpcclxuICAgICAgICAgICgxICsgMSAvICgxMiAqIG4pICsgMSAvICgyODggKiB0d29OKSAtIDEzOSAvICg1MTg0MCAqIHRocmVlTikgLVxyXG4gICAgICAgICAgNTcxIC8gKDI0ODgzMjAgKiBmb3VyTikgKyAxNjM4NzkgLyAoMjA5MDE4ODgwICogZml2ZU4pICtcclxuICAgICAgICAgIDUyNDY4MTkgLyAoNzUyNDY3OTY4MDAgKiBmaXZlTiAqIG4pKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbiAtPSAxO1xyXG4gICAgICB4ICA9IFBbMF07XHJcblxyXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgUC5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHggKz0gUFtpXSAvIChuICsgaSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHQgPSBuICsgRyArIDAuNTtcclxuXHJcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoMiAqIE1hdGguUEkpICogTWF0aC5wb3codCwgbiArIDAuNSkgKiBNYXRoLmV4cCgtdCkgKiB4O1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgbGRleHAobWFudGlzc2EsIGV4cG9uZW50KVxyXG4gICAgbWFudGlzc2EgPSBNYXRoLmZsb2F0IShtYW50aXNzYSlcclxuICAgIGV4cG9uZW50ID0gTWF0aC5pbnRlZ2VyIShleHBvbmVudClcclxuXHJcbiAgICAleHtcclxuICAgICAgaWYgKGlzTmFOKGV4cG9uZW50KSkge1xyXG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCAnZmxvYXQgTmFOIG91dCBvZiByYW5nZSBvZiBpbnRlZ2VyJ307XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtYW50aXNzYSAqIE1hdGgucG93KDIsIGV4cG9uZW50KTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGxnYW1tYShuKVxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChuID09IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuIFtJbmZpbml0eSwgMV07XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFtNYXRoLmxvZyhNYXRoLmFicygjezo6TWF0aC5nYW1tYShuKX0pKSwgI3s6Ok1hdGguZ2FtbWEobil9IDwgMCA/IC0xIDogMV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGxvZyh4LCBiYXNlID0gdW5kZWZpbmVkKVxyXG4gICAgaWYgOjpTdHJpbmcgPT09IHhcclxuICAgICAgOjpLZXJuZWwucmFpc2UgYCR0eXBlX2Vycm9yKHgsICN7OjpGbG9hdH0pYFxyXG4gICAgZW5kXHJcblxyXG4gICAgaWYgYGJhc2UgPT0gbnVsbGBcclxuICAgICAgOjpNYXRoLmNoZWNrZWQgOmxvZywgOjpNYXRoLmZsb2F0ISh4KVxyXG4gICAgZWxzZVxyXG4gICAgICBpZiA6OlN0cmluZyA9PT0gYmFzZVxyXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIGAkdHlwZV9lcnJvcihiYXNlLCAjezo6RmxvYXR9KWBcclxuICAgICAgZW5kXHJcblxyXG4gICAgICA6Ok1hdGguY2hlY2tlZCg6bG9nLCA6Ok1hdGguZmxvYXQhKHgpKSAvIDo6TWF0aC5jaGVja2VkKDpsb2csIDo6TWF0aC5mbG9hdCEoYmFzZSkpXHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmIGxvZzEwKHgpXHJcbiAgICBpZiA6OlN0cmluZyA9PT0geFxyXG4gICAgICA6Oktlcm5lbC5yYWlzZSBgJHR5cGVfZXJyb3IoeCwgI3s6OkZsb2F0fSlgXHJcbiAgICBlbmRcclxuXHJcbiAgICA6Ok1hdGguY2hlY2tlZCA6bG9nMTAsIDo6TWF0aC5mbG9hdCEoeClcclxuICBlbmRcclxuXHJcbiAgZGVmIGxvZzIoeClcclxuICAgIGlmIDo6U3RyaW5nID09PSB4XHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIGAkdHlwZV9lcnJvcih4LCAjezo6RmxvYXR9KWBcclxuICAgIGVuZFxyXG5cclxuICAgIDo6TWF0aC5jaGVja2VkIDpsb2cyLCA6Ok1hdGguZmxvYXQhKHgpXHJcbiAgZW5kXHJcblxyXG4gIGRlZiB0YW4oeClcclxuICAgIHggPSA6Ok1hdGguZmxvYXQhKHgpXHJcblxyXG4gICAgaWYgeC5pbmZpbml0ZT9cclxuICAgICAgcmV0dXJuIDo6RmxvYXQ6Ok5BTlxyXG4gICAgZW5kXHJcblxyXG4gICAgOjpNYXRoLmNoZWNrZWQgOnRhbiwgOjpNYXRoLmZsb2F0ISh4KVxyXG4gIGVuZFxyXG5lbmRcclxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOk1hdGg+Iiwic2VsZiIsIkNsYXNzIiwibmV3IiwiU3RhbmRhcmRFcnJvciIsImNoZWNrZWQiLCJtZXRob2QiLCJLZXJuZWwiLCJyYWlzZSIsIkRvbWFpbkVycm9yIiwiZmxvYXQhIiwidmFsdWUiLCJGbG9hdCIsIkFyZ3VtZW50RXJyb3IiLCJpbnRlZ2VyISIsIkludGVnZXIiLCJtb2R1bGVfZnVuY3Rpb24iLCJlYWNoIiwiYmxvY2sgaW4gPG1vZHVsZTpNYXRoPiIsImJsb2NrICgyIGxldmVscykgaW4gPG1vZHVsZTpNYXRoPiIsImRlZmluZV9tZXRob2QiLCJ4IiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiA8bW9kdWxlOk1hdGg+IiwiTWF0aCIsImF0YW4yIiwieSIsImh5cG90IiwiZnJleHAiLCJnYW1tYSIsIm4iLCI9PT0iLCItIiwiMSIsImxkZXhwIiwibWFudGlzc2EiLCJleHBvbmVudCIsIlJhbmdlRXJyb3IiLCJsZ2FtbWEiLCJsb2ciLCJiYXNlIiwiU3RyaW5nIiwiLyIsImxvZzEwIiwibG9nMiIsInRhbiIsImluZmluaXRlPyIsIkZsb2F0OjpOQU4iXSwibWFwcGluZ3MiOiJBQUFBQSwrQkFBQUEsZ0JBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTtFQUlBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNFLFdBQUFDLElBQUEsT0FBWUQsTUFBWjtJQUNBLFdBQUFDLElBQUEsUUFBWUQsT0FBWjtJQUVBLFdBQUFDLElBQUEsaUJBQW9CQyxNQUFPQyxLQUFBQSxDQUFLQyxvQkFBTEQsQ0FBM0I7SUFFQUUsTUFBSUosSUFBSkksY0FBQUEsbUJBQWlCQyxNQUFELEVBVmxCLEVBVUVEO0FBQUFBLE1BQUFBOzs7TUFWRjtNQVUyQjs7QUFFM0JBO0FBQ0FBO0FBQ0FBOztBQUVBQTs7QUFFQUE7QUFDQUEsUUFBVUUsT0FBUUMsT0FBQUEsQ0FBT0MsaUJBQWYsRUFBNkJKLDBDQUFELEdBQUEsTUFBMkNDLE1BQTNDLENBQUEsR0FBa0RELElBQXRFRyxDQUEwRUg7QUFDNUZBOztBQUVBQTtBQUNBQTtJQWJFQSxDQUFBQSxJQUFBQTtJQWdCQUssTUFBSVQsSUFBSlMsYUFBQUEsNEJBQWdCQyxLQUFoQkQ7QUFB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LENBQUE7UUFDRWQsT0FBUUMsT0FBQUEsQ0FBUW1DLGVBQWlCL0IsWUFBUStCLENBQWpDbkM7TUFEVjtNQUlBbUMsT0FBQXBCLFdBQU1sQixTQUFBQSxDQUFTLE1BQWYsRUFBc0JrQixXQUFNYixXQUFBQSxDQUFRVyxDQUFSWCxDQUF0Qkw7SUFMUnNDLENBQUFBO0lBUUEzQyxPQUFBNEMsbUJBQUFBLGVBQVF2QixDQUFSdUI7QUFBQUE7O01BQ0V2QixJQUFJRSxXQUFNYixXQUFBQSxDQUFRVyxDQUFSWDtNQUVWLElBQUEsUUFBR1csQ0FBQ3dCLGNBQUFBLENBQUFBLENBQUosQ0FBQTtRQUNFLE9BQU9DLElBQUFsQyxZQUFBa0M7TUFEVDtNQUlBRixPQUFBckIsV0FBTWxCLFNBQUFBLENBQVMsS0FBZixFQUFxQmtCLFdBQU1iLFdBQUFBLENBQVFXLENBQVJYLENBQXJCTDtJQVBSdUMsQ0FBQUE7RUFwUkY1QyxHQUFPLElBQVBBO0FBSkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMjQ0OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvY29tcGxleC9iYXNlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSA6Oktlcm5lbFxyXG4gIGRlZiBDb21wbGV4KHJlYWwsIGltYWcgPSBuaWwpXHJcbiAgICBpZiBpbWFnXHJcbiAgICAgIENvbXBsZXgubmV3KHJlYWwsIGltYWcpXHJcbiAgICBlbHNlXHJcbiAgICAgIENvbXBsZXgubmV3KHJlYWwsIDApXHJcbiAgICBlbmRcclxuICBlbmRcclxuZW5kXHJcblxyXG5jbGFzcyA6OlN0cmluZ1xyXG4gIGRlZiB0b19jXHJcbiAgICBDb21wbGV4LmZyb21fc3RyaW5nKHNlbGYpXHJcbiAgZW5kXHJcbmVuZFxyXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6S2VybmVsPiIsIkNvbXBsZXgiLCJyZWFsIiwiaW1hZyIsIm5ldyIsIjAiLCI8Y2xhc3M6U3RyaW5nPiIsInRvX2MiLCJmcm9tX3N0cmluZyIsInNlbGYiXSwibWFwcGluZ3MiOiJBQUFBQSx1Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUM7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQyx1QkFBQUEsbUJBQVlDLElBQUQsRUFBT0MsSUFBbEJGO0FBQUFBOztNQUFrQix5QkFBTztNQUN2QixJQUFBLFFBQUdFLElBQUgsQ0FBQTtRQUNFRixPQUFBQSxhQUFPRyxLQUFBQSxDQUFLRixJQUFaLEVBQWtCQyxJQUFYQztNQURUO1FBR0VILE9BQUFBLGFBQU9HLEtBQUFBLENBQUtGLElBQVosRUFBa0JHLENBQVhEO01BSFQ7SUFERkgsQ0FBQUEsSUFBQUE7RUFERkQsR0FBTyxJQUFQQTtFQVVBRCxPQUFBTztFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUFDLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFOLGFBQU9PLGFBQUFBLENBQWFDLElBQWJEO0lBRFRELENBQUFBO0VBREZELEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUFWQVA7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIyNDgzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9jb21wbGV4LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxyXG5cclxucmVxdWlyZSAnY29yZWxpYi9udW1lcmljJ1xyXG5yZXF1aXJlICdjb3JlbGliL2NvbXBsZXgvYmFzZSdcclxuXHJcbmNsYXNzIDo6Q29tcGxleCA8IDo6TnVtZXJpY1xyXG4gIGRlZiBzZWxmLnJlY3QocmVhbCwgaW1hZyA9IDApXHJcbiAgICB1bmxlc3MgOjpOdW1lcmljID09PSByZWFsICYmIHJlYWwucmVhbD8gJiYgOjpOdW1lcmljID09PSBpbWFnICYmIGltYWcucmVhbD9cclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdub3QgYSByZWFsJ1xyXG4gICAgZW5kXHJcblxyXG4gICAgbmV3KHJlYWwsIGltYWcpXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzZWxmLnBvbGFyKHIsIHRoZXRhID0gMClcclxuICAgIHVubGVzcyA6Ok51bWVyaWMgPT09IHIgJiYgci5yZWFsPyAmJiA6Ok51bWVyaWMgPT09IHRoZXRhICYmIHRoZXRhLnJlYWw/XHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnbm90IGEgcmVhbCdcclxuICAgIGVuZFxyXG5cclxuICAgIG5ldyhyICogOjpNYXRoLmNvcyh0aGV0YSksIHIgKiA6Ok1hdGguc2luKHRoZXRhKSlcclxuICBlbmRcclxuXHJcbiAgYXR0cl9yZWFkZXIgOnJlYWwsIDppbWFnXHJcblxyXG4gIGRlZiBpbml0aWFsaXplKHJlYWwsIGltYWcgPSAwKVxyXG4gICAgQHJlYWwgPSByZWFsXHJcbiAgICBAaW1hZyA9IGltYWdcclxuICAgIGZyZWV6ZVxyXG4gIGVuZFxyXG5cclxuICBkZWYgY29lcmNlKG90aGVyKVxyXG4gICAgaWYgOjpDb21wbGV4ID09PSBvdGhlclxyXG4gICAgICBbb3RoZXIsIHNlbGZdXHJcbiAgICBlbHNpZiA6Ok51bWVyaWMgPT09IG90aGVyICYmIG90aGVyLnJlYWw/XHJcbiAgICAgIFs6OkNvbXBsZXgubmV3KG90aGVyLCAwKSwgc2VsZl1cclxuICAgIGVsc2VcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiI3tvdGhlci5jbGFzc30gY2FuJ3QgYmUgY29lcmNlZCBpbnRvIENvbXBsZXhcIlxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiA9PShvdGhlcilcclxuICAgIGlmIDo6Q29tcGxleCA9PT0gb3RoZXJcclxuICAgICAgQHJlYWwgPT0gb3RoZXIucmVhbCAmJiBAaW1hZyA9PSBvdGhlci5pbWFnXHJcbiAgICBlbHNpZiA6Ok51bWVyaWMgPT09IG90aGVyICYmIG90aGVyLnJlYWw/XHJcbiAgICAgIEByZWFsID09IG90aGVyICYmIEBpbWFnID09IDBcclxuICAgIGVsc2VcclxuICAgICAgb3RoZXIgPT0gc2VsZlxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiAtQFxyXG4gICAgOjpLZXJuZWwuQ29tcGxleCgtQHJlYWwsIC1AaW1hZylcclxuICBlbmRcclxuXHJcbiAgZGVmICsob3RoZXIpXHJcbiAgICBpZiA6OkNvbXBsZXggPT09IG90aGVyXHJcbiAgICAgIDo6S2VybmVsLkNvbXBsZXgoQHJlYWwgKyBvdGhlci5yZWFsLCBAaW1hZyArIG90aGVyLmltYWcpXHJcbiAgICBlbHNpZiA6Ok51bWVyaWMgPT09IG90aGVyICYmIG90aGVyLnJlYWw/XHJcbiAgICAgIDo6S2VybmVsLkNvbXBsZXgoQHJlYWwgKyBvdGhlciwgQGltYWcpXHJcbiAgICBlbHNlXHJcbiAgICAgIF9fY29lcmNlZF9fIDorLCBvdGhlclxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiAtKG90aGVyKVxyXG4gICAgaWYgOjpDb21wbGV4ID09PSBvdGhlclxyXG4gICAgICA6Oktlcm5lbC5Db21wbGV4KEByZWFsIC0gb3RoZXIucmVhbCwgQGltYWcgLSBvdGhlci5pbWFnKVxyXG4gICAgZWxzaWYgOjpOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xyXG4gICAgICA6Oktlcm5lbC5Db21wbGV4KEByZWFsIC0gb3RoZXIsIEBpbWFnKVxyXG4gICAgZWxzZVxyXG4gICAgICBfX2NvZXJjZWRfXyA6LSwgb3RoZXJcclxuICAgIGVuZFxyXG4gIGVuZFxyXG5cclxuICBkZWYgKihvdGhlcilcclxuICAgIGlmIDo6Q29tcGxleCA9PT0gb3RoZXJcclxuICAgICAgOjpLZXJuZWwuQ29tcGxleChAcmVhbCAqIG90aGVyLnJlYWwgLSBAaW1hZyAqIG90aGVyLmltYWcsXHJcbiAgICAgICAgQHJlYWwgKiBvdGhlci5pbWFnICsgQGltYWcgKiBvdGhlci5yZWFsLFxyXG4gICAgICApXHJcbiAgICBlbHNpZiA6Ok51bWVyaWMgPT09IG90aGVyICYmIG90aGVyLnJlYWw/XHJcbiAgICAgIDo6S2VybmVsLkNvbXBsZXgoQHJlYWwgKiBvdGhlciwgQGltYWcgKiBvdGhlcilcclxuICAgIGVsc2VcclxuICAgICAgX19jb2VyY2VkX18gOiosIG90aGVyXHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmIC8ob3RoZXIpXHJcbiAgICBpZiA6OkNvbXBsZXggPT09IG90aGVyXHJcbiAgICAgIGlmICg6Ok51bWJlciA9PT0gQHJlYWwgJiYgQHJlYWwubmFuPykgfHwgKDo6TnVtYmVyID09PSBAaW1hZyAmJiBAaW1hZy5uYW4/KSB8fFxyXG4gICAgICAgICAoOjpOdW1iZXIgPT09IG90aGVyLnJlYWwgJiYgb3RoZXIucmVhbC5uYW4/KSB8fCAoOjpOdW1iZXIgPT09IG90aGVyLmltYWcgJiYgb3RoZXIuaW1hZy5uYW4/KVxyXG4gICAgICAgIDo6Q29tcGxleC5uZXcoOjpGbG9hdDo6TkFOLCA6OkZsb2F0OjpOQU4pXHJcbiAgICAgIGVsc2VcclxuICAgICAgICBzZWxmICogb3RoZXIuY29uaiAvIG90aGVyLmFiczJcclxuICAgICAgZW5kXHJcbiAgICBlbHNpZiA6Ok51bWVyaWMgPT09IG90aGVyICYmIG90aGVyLnJlYWw/XHJcbiAgICAgIDo6S2VybmVsLkNvbXBsZXgoQHJlYWwucXVvKG90aGVyKSwgQGltYWcucXVvKG90aGVyKSlcclxuICAgIGVsc2VcclxuICAgICAgX19jb2VyY2VkX18gOi8sIG90aGVyXHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmICoqKG90aGVyKVxyXG4gICAgaWYgb3RoZXIgPT0gMFxyXG4gICAgICByZXR1cm4gOjpDb21wbGV4Lm5ldygxLCAwKVxyXG4gICAgZW5kXHJcblxyXG4gICAgaWYgOjpDb21wbGV4ID09PSBvdGhlclxyXG4gICAgICByLCB0aGV0YSA9IHBvbGFyXHJcbiAgICAgIG9yZSAgICAgID0gb3RoZXIucmVhbFxyXG4gICAgICBvaW0gICAgICA9IG90aGVyLmltYWdcclxuICAgICAgbnIgICAgICAgPSA6Ok1hdGguZXhwKG9yZSAqIDo6TWF0aC5sb2cocikgLSBvaW0gKiB0aGV0YSlcclxuICAgICAgbnRoZXRhICAgPSB0aGV0YSAqIG9yZSArIG9pbSAqIDo6TWF0aC5sb2cocilcclxuXHJcbiAgICAgIDo6Q29tcGxleC5wb2xhcihuciwgbnRoZXRhKVxyXG4gICAgZWxzaWYgOjpJbnRlZ2VyID09PSBvdGhlclxyXG4gICAgICBpZiBvdGhlciA+IDBcclxuICAgICAgICB4ID0gc2VsZlxyXG4gICAgICAgIHogPSB4XHJcbiAgICAgICAgbiA9IG90aGVyIC0gMVxyXG5cclxuICAgICAgICB3aGlsZSBuICE9IDBcclxuICAgICAgICAgIGRpdiwgbW9kID0gbi5kaXZtb2QoMilcclxuICAgICAgICAgIHdoaWxlIG1vZCA9PSAwXHJcbiAgICAgICAgICAgIHggPSA6Oktlcm5lbC5Db21wbGV4KHgucmVhbCAqIHgucmVhbCAtIHguaW1hZyAqIHguaW1hZywgMiAqIHgucmVhbCAqIHguaW1hZylcclxuICAgICAgICAgICAgbiA9IGRpdlxyXG4gICAgICAgICAgICBkaXYsIG1vZCA9IG4uZGl2bW9kKDIpXHJcbiAgICAgICAgICBlbmRcclxuXHJcbiAgICAgICAgICB6ICo9IHhcclxuICAgICAgICAgIG4gLT0gMVxyXG4gICAgICAgIGVuZFxyXG5cclxuICAgICAgICB6XHJcbiAgICAgIGVsc2VcclxuICAgICAgICAoOjpSYXRpb25hbC5uZXcoMSwgMSkgLyBzZWxmKSoqLW90aGVyXHJcbiAgICAgIGVuZFxyXG4gICAgZWxzaWYgOjpGbG9hdCA9PT0gb3RoZXIgfHwgOjpSYXRpb25hbCA9PT0gb3RoZXJcclxuICAgICAgciwgdGhldGEgPSBwb2xhclxyXG5cclxuICAgICAgOjpDb21wbGV4LnBvbGFyKHIqKm90aGVyLCB0aGV0YSAqIG90aGVyKVxyXG4gICAgZWxzZVxyXG4gICAgICBfX2NvZXJjZWRfXyA6KiosIG90aGVyXHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmIGFic1xyXG4gICAgOjpNYXRoLmh5cG90KEByZWFsLCBAaW1hZylcclxuICBlbmRcclxuXHJcbiAgZGVmIGFiczJcclxuICAgIEByZWFsICogQHJlYWwgKyBAaW1hZyAqIEBpbWFnXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBhbmdsZVxyXG4gICAgOjpNYXRoLmF0YW4yKEBpbWFnLCBAcmVhbClcclxuICBlbmRcclxuXHJcbiAgZGVmIGNvbmpcclxuICAgIDo6S2VybmVsLkNvbXBsZXgoQHJlYWwsIC1AaW1hZylcclxuICBlbmRcclxuXHJcbiAgZGVmIGRlbm9taW5hdG9yXHJcbiAgICBAcmVhbC5kZW5vbWluYXRvci5sY20oQGltYWcuZGVub21pbmF0b3IpXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBlcWw/KG90aGVyKVxyXG4gICAgQ29tcGxleCA9PT0gb3RoZXIgJiYgQHJlYWwuY2xhc3MgPT0gQGltYWcuY2xhc3MgJiYgc2VsZiA9PSBvdGhlclxyXG4gIGVuZFxyXG5cclxuICBkZWYgZmRpdihvdGhlcilcclxuICAgIHVubGVzcyA6Ok51bWVyaWMgPT09IG90aGVyXHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIiN7b3RoZXIuY2xhc3N9IGNhbid0IGJlIGNvZXJjZWQgaW50byBDb21wbGV4XCJcclxuICAgIGVuZFxyXG5cclxuICAgIHNlbGYgLyBvdGhlclxyXG4gIGVuZFxyXG5cclxuICBkZWYgZmluaXRlP1xyXG4gICAgQHJlYWwuZmluaXRlPyAmJiBAaW1hZy5maW5pdGU/XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBoYXNoXHJcbiAgICBbOjpDb21wbGV4LCBAcmVhbCwgQGltYWddLmhhc2hcclxuICBlbmRcclxuXHJcbiAgZGVmIGluZmluaXRlP1xyXG4gICAgQHJlYWwuaW5maW5pdGU/IHx8IEBpbWFnLmluZmluaXRlP1xyXG4gIGVuZFxyXG5cclxuICBkZWYgaW5zcGVjdFxyXG4gICAgXCIoI3tzZWxmfSlcIlxyXG4gIGVuZFxyXG5cclxuICBkZWYgbnVtZXJhdG9yXHJcbiAgICBkID0gZGVub21pbmF0b3JcclxuXHJcbiAgICA6Oktlcm5lbC5Db21wbGV4KEByZWFsLm51bWVyYXRvciAqIChkIC8gQHJlYWwuZGVub21pbmF0b3IpLFxyXG4gICAgICBAaW1hZy5udW1lcmF0b3IgKiAoZCAvIEBpbWFnLmRlbm9taW5hdG9yKSxcclxuICAgIClcclxuICBlbmRcclxuXHJcbiAgZGVmIHBvbGFyXHJcbiAgICBbYWJzLCBhcmddXHJcbiAgZW5kXHJcblxyXG4gIGRlZiByYXRpb25hbGl6ZShlcHMgPSB1bmRlZmluZWQpXHJcbiAgICAleHtcclxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAwLi4xKVwifTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIEBpbWFnICE9IDBcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tzZWxmfSBpbnRvIFJhdGlvbmFsXCJcclxuICAgIGVuZFxyXG5cclxuICAgIHJlYWwucmF0aW9uYWxpemUoZXBzKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgcmVhbD9cclxuICAgIGZhbHNlXHJcbiAgZW5kXHJcblxyXG4gIGRlZiByZWN0XHJcbiAgICBbQHJlYWwsIEBpbWFnXVxyXG4gIGVuZFxyXG5cclxuICBkZWYgdG9fZlxyXG4gICAgdW5sZXNzIEBpbWFnID09IDBcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tzZWxmfSBpbnRvIEZsb2F0XCJcclxuICAgIGVuZFxyXG5cclxuICAgIEByZWFsLnRvX2ZcclxuICBlbmRcclxuXHJcbiAgZGVmIHRvX2lcclxuICAgIHVubGVzcyBAaW1hZyA9PSAwXHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7c2VsZn0gaW50byBJbnRlZ2VyXCJcclxuICAgIGVuZFxyXG5cclxuICAgIEByZWFsLnRvX2lcclxuICBlbmRcclxuXHJcbiAgZGVmIHRvX3JcclxuICAgIHVubGVzcyBAaW1hZyA9PSAwXHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7c2VsZn0gaW50byBSYXRpb25hbFwiXHJcbiAgICBlbmRcclxuXHJcbiAgICBAcmVhbC50b19yXHJcbiAgZW5kXHJcblxyXG4gIGRlZiB0b19zXHJcbiAgICByZXN1bHQgPSBAcmVhbC5pbnNwZWN0XHJcblxyXG4gICAgcmVzdWx0ICs9XHJcbiAgICAgIGlmICg6Ok51bWJlciA9PT0gQGltYWcgJiYgQGltYWcubmFuPykgfHwgQGltYWcucG9zaXRpdmU/IHx8IEBpbWFnLnplcm8/XHJcbiAgICAgICAgJysnXHJcbiAgICAgIGVsc2VcclxuICAgICAgICAnLSdcclxuICAgICAgZW5kXHJcblxyXG4gICAgcmVzdWx0ICs9IEBpbWFnLmFicy5pbnNwZWN0XHJcblxyXG4gICAgaWYgOjpOdW1iZXIgPT09IEBpbWFnICYmIChAaW1hZy5uYW4/IHx8IEBpbWFnLmluZmluaXRlPylcclxuICAgICAgcmVzdWx0ICs9ICcqJ1xyXG4gICAgZW5kXHJcblxyXG4gICAgcmVzdWx0ICsgJ2knXHJcbiAgZW5kXHJcblxyXG4gIEkgPSBuZXcoMCwgMSlcclxuXHJcbiAgZGVmIHNlbGYuZnJvbV9zdHJpbmcoc3RyKVxyXG4gICAgJXh7XHJcbiAgICAgIHZhciByZSA9IC9bKy1dP1tcXGRfXSsoXFwuW1xcZF9dKyk/KGVcXGQrKT8vLFxyXG4gICAgICAgICAgbWF0Y2ggPSBzdHIubWF0Y2gocmUpLFxyXG4gICAgICAgICAgcmVhbCwgaW1hZywgZGVub21pbmF0b3I7XHJcblxyXG4gICAgICBmdW5jdGlvbiBpc0Zsb2F0KCkge1xyXG4gICAgICAgIHJldHVybiByZS50ZXN0KHN0cik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGN1dEZsb2F0KCkge1xyXG4gICAgICAgIHZhciBtYXRjaCA9IHN0ci5tYXRjaChyZSk7XHJcbiAgICAgICAgdmFyIG51bWJlciA9IG1hdGNoWzBdO1xyXG4gICAgICAgIHN0ciA9IHN0ci5zbGljZShudW1iZXIubGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4gbnVtYmVyLnJlcGxhY2UoL18vZywgJycpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBoYW5kbGVzIGJvdGggZmxvYXRzIGFuZCByYXRpb25hbHNcclxuICAgICAgZnVuY3Rpb24gY3V0TnVtYmVyKCkge1xyXG4gICAgICAgIGlmIChpc0Zsb2F0KCkpIHtcclxuICAgICAgICAgIHZhciBudW1lcmF0b3IgPSBwYXJzZUZsb2F0KGN1dEZsb2F0KCkpO1xyXG5cclxuICAgICAgICAgIGlmIChzdHJbMF0gPT09ICcvJykge1xyXG4gICAgICAgICAgICAvLyByYXRpb25hbCByZWFsIHBhcnRcclxuICAgICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGlzRmxvYXQoKSkge1xyXG4gICAgICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IHBhcnNlRmxvYXQoY3V0RmxvYXQoKSk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuUmF0aW9uYWwoYG51bWVyYXRvcmAsIGBkZW5vbWluYXRvcmApfTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyByZXZlcnRpbmcgJy8nXHJcbiAgICAgICAgICAgICAgc3RyID0gJy8nICsgc3RyO1xyXG4gICAgICAgICAgICAgIHJldHVybiBudW1lcmF0b3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGZsb2F0IHJlYWwgcGFydCwgbm8gZGVub21pbmF0b3JcclxuICAgICAgICAgICAgcmV0dXJuIG51bWVyYXRvcjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZWFsID0gY3V0TnVtYmVyKCk7XHJcblxyXG4gICAgICBpZiAoIXJlYWwpIHtcclxuICAgICAgICBpZiAoc3RyWzBdID09PSAnaScpIHtcclxuICAgICAgICAgIC8vIGkgPT4gQ29tcGxleCgwLCAxKVxyXG4gICAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuQ29tcGxleCgwLCAxKX07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdHJbMF0gPT09ICctJyAmJiBzdHJbMV0gPT09ICdpJykge1xyXG4gICAgICAgICAgLy8gLWkgPT4gQ29tcGxleCgwLCAtMSlcclxuICAgICAgICAgIHJldHVybiAjezo6S2VybmVsLkNvbXBsZXgoMCwgLTEpfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0clswXSA9PT0gJysnICYmIHN0clsxXSA9PT0gJ2knKSB7XHJcbiAgICAgICAgICAvLyAraSA9PiBDb21wbGV4KDAsIDEpXHJcbiAgICAgICAgICByZXR1cm4gI3s6Oktlcm5lbC5Db21wbGV4KDAsIDEpfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYW55dGhpbmcgPT4gQ29tcGxleCgwLCAwKVxyXG4gICAgICAgIHJldHVybiAjezo6S2VybmVsLkNvbXBsZXgoMCwgMCl9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpbWFnID0gY3V0TnVtYmVyKCk7XHJcbiAgICAgIGlmICghaW1hZykge1xyXG4gICAgICAgIGlmIChzdHJbMF0gPT09ICdpJykge1xyXG4gICAgICAgICAgLy8gM2kgPT4gQ29tcGxleCgwLCAzKVxyXG4gICAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuQ29tcGxleCgwLCBgcmVhbGApfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gMyA9PiBDb21wbGV4KDMsIDApXHJcbiAgICAgICAgICByZXR1cm4gI3s6Oktlcm5lbC5Db21wbGV4KGByZWFsYCwgMCl9O1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyAzKzJpID0+IENvbXBsZXgoMywgMilcclxuICAgICAgICByZXR1cm4gI3s6Oktlcm5lbC5Db21wbGV4KGByZWFsYCwgYGltYWdgKX07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgY2xhc3MgPDwgc2VsZlxyXG4gICAgYWxpYXMgcmVjdGFuZ3VsYXIgcmVjdFxyXG4gIGVuZFxyXG5cclxuICBhbGlhcyBhcmcgYW5nbGVcclxuICBhbGlhcyBjb25qdWdhdGUgY29ualxyXG4gIGFsaWFzIGRpdmlkZSAvXHJcbiAgYWxpYXMgaW1hZ2luYXJ5IGltYWdcclxuICBhbGlhcyBtYWduaXR1ZGUgYWJzXHJcbiAgYWxpYXMgcGhhc2UgYXJnXHJcbiAgYWxpYXMgcXVvIC9cclxuICBhbGlhcyByZWN0YW5ndWxhciByZWN0XHJcblxyXG4gIHVuZGVmIG5lZ2F0aXZlP1xyXG4gIHVuZGVmIHBvc2l0aXZlP1xyXG4gIHVuZGVmIHN0ZXBcclxuZW5kXHJcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6Q29tcGxleD4iLCJyZWN0IiwicmVhbCIsImltYWciLCIwIiwiTnVtZXJpYyIsInJlYWw/IiwiS2VybmVsIiwicmFpc2UiLCJUeXBlRXJyb3IiLCJuZXciLCJwb2xhciIsInIiLCJ0aGV0YSIsIioiLCJNYXRoIiwiY29zIiwic2luIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiQHJlYWwiLCJAaW1hZyIsImZyZWV6ZSIsImNvZXJjZSIsIm90aGVyIiwiQ29tcGxleCIsImNsYXNzIiwiPT0iLCIkcmV0X29yXzEiLCItQCIsIisiLCJfX2NvZXJjZWRfXyIsIi0iLCIvIiwiTnVtYmVyIiwibmFuPyIsIkZsb2F0OjpOQU4iLCJGbG9hdCIsImNvbmoiLCJhYnMyIiwicXVvIiwiKioiLCIxIiwib3JlIiwib2ltIiwibnIiLCJleHAiLCJsb2ciLCJudGhldGEiLCJJbnRlZ2VyIiwiPiIsIngiLCJ6IiwibiIsImRpdm1vZCIsIjIiLCJkaXYiLCJtb2QiLCJSYXRpb25hbCIsImFicyIsImh5cG90IiwiYW5nbGUiLCJhdGFuMiIsImRlbm9taW5hdG9yIiwibGNtIiwiZXFsPyIsIiRyZXRfb3JfMiIsIj09PSIsImZkaXYiLCJmaW5pdGU/IiwiaGFzaCIsImluZmluaXRlPyIsImluc3BlY3QiLCJudW1lcmF0b3IiLCJkIiwiYXJnIiwicmF0aW9uYWxpemUiLCJlcHMiLCJBcmd1bWVudEVycm9yIiwiUmFuZ2VFcnJvciIsInRvX2YiLCJ0b19pIiwidG9fciIsInRvX3MiLCJyZXN1bHQiLCJwb3NpdGl2ZT8iLCJ6ZXJvPyIsImZyb21fc3RyaW5nIiwic3RyIiwiLTEiXSwibWFwcGluZ3MiOiJBQUFBQSxrQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFFQUMsSUFBQUMsU0FBQUEsQ0FBUUYsaUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLHNCQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7O0FBQUFBOztJQUNFQyxNQUFJSCxJQUFKRyxXQUFBQSxnQkFBY0MsSUFBRCxFQUFPQyxJQUFwQkY7QUFBQUEsTUFBQUE7OztNQUFvQix5QkFBT0c7TUFDekIsS0FBTyxDQUFBLENBQUEsQ0FBQSxRQUFBQyxjQUFBLEVBQWNILElBQWQsQ0FBQSxJQUFBLENBQUEsUUFBc0JBLElBQUlJLFVBQUFBLENBQUFBLENBQTFCLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBQSxRQUFvQ0QsY0FBcEMsRUFBa0RGLElBQWxELENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBQSxRQUEwREEsSUFBSUcsVUFBQUEsQ0FBQUEsQ0FBOUQsQ0FBQSxDQUFBLENBQVA7UUFDRUMsT0FBUUMsT0FBQUEsQ0FBT0MsZ0JBQWYsRUFBNEJSLFlBQXBCTztNQURWO01BSUFQLE9BQUFILElBQUFZLEtBQUFBLENBQUlSLElB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Q0EsYUFBTSxXQUFOLEVBQWdCLE1BQWhCO0lBQ0EsYUFBTSxRQUFOLEVBQWEsR0FBYjtJQUNBLGFBQU0sV0FBTixFQUFnQixNQUFoQjtJQUNBLGFBQU0sV0FBTixFQUFnQixLQUFoQjtJQUNBLGFBQU0sT0FBTixFQUFZLEtBQVo7SUFDQSxhQUFNLEtBQU4sRUFBVSxHQUFWO0lBQ0EsYUFBTSxhQUFOLEVBQWtCLE1BQWxCOztJQUVBLHNCQUFNLFdBQU47O0lBQ0Esc0JBQU0sV0FBTjs7O0lBQ0Esc0JBQU0sTUFBTjtJQTdXRkUsT0FBQTtFQUtBQSxHQUFNLElBQU5BLEVBQWtCSyxjQUFsQkw7QUFMQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIyOTI5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9yYXRpb25hbC9iYXNlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSA6Oktlcm5lbFxyXG4gIGRlZiBSYXRpb25hbChudW1lcmF0b3IsIGRlbm9taW5hdG9yID0gMSlcclxuICAgIDo6UmF0aW9uYWwuY29udmVydChudW1lcmF0b3IsIGRlbm9taW5hdG9yKVxyXG4gIGVuZFxyXG5lbmRcclxuXHJcbmNsYXNzIDo6U3RyaW5nXHJcbiAgZGVmIHRvX3JcclxuICAgIDo6UmF0aW9uYWwuZnJvbV9zdHJpbmcoc2VsZilcclxuICBlbmRcclxuZW5kXHJcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpLZXJuZWw+IiwiUmF0aW9uYWwiLCJudW1lcmF0b3IiLCJkZW5vbWluYXRvciIsIjEiLCJjb252ZXJ0IiwiPGNsYXNzOlN0cmluZz4iLCJ0b19yIiwiZnJvbV9zdHJpbmciLCJzZWxmIl0sIm1hcHBpbmdzIjoiQUFBQUEsd0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDO0VBQUFBOzs7SUFDRUEsT0FBQUMsd0JBQUFBLG9CQUFhQyxTQUFELEVBQVlDLFdBQXhCRjtBQUFBQTs7TUFBd0IsdUNBQWNHO01BQ3BDSCxPQUFBQSxlQUFVSSxTQUFBQSxDQUFTSCxTQUFuQixFQUE4QkMsV0FBcEJFO0lBRFpKLENBQUFBLElBQUFBO0VBREZELEdBQU8sSUFBUEE7RUFNQUQsT0FBQU87RUFBQUE7OztJQUNFQSxPQUFBQyxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBTixlQUFVTyxhQUFBQSxDQUFhQyxJQUFiRDtJQURaRCxDQUFBQTtFQURGRCxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBTkFQOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMjk1NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmF0aW9uYWwucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXHJcblxyXG5yZXF1aXJlICdjb3JlbGliL251bWVyaWMnXHJcbnJlcXVpcmUgJ2NvcmVsaWIvcmF0aW9uYWwvYmFzZSdcclxuXHJcbmNsYXNzIDo6UmF0aW9uYWwgPCA6Ok51bWVyaWNcclxuICBkZWYgc2VsZi5yZWR1Y2UobnVtLCBkZW4pXHJcbiAgICBudW0gPSBudW0udG9faVxyXG4gICAgZGVuID0gZGVuLnRvX2lcclxuXHJcbiAgICBpZiBkZW4gPT0gMFxyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6Olplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSAwJ1xyXG4gICAgZWxzaWYgZGVuIDwgMFxyXG4gICAgICBudW0gPSAtbnVtXHJcbiAgICAgIGRlbiA9IC1kZW5cclxuICAgIGVsc2lmIGRlbiA9PSAxXHJcbiAgICAgIHJldHVybiBuZXcobnVtLCBkZW4pXHJcbiAgICBlbmRcclxuXHJcbiAgICBnY2QgPSBudW0uZ2NkKGRlbilcclxuXHJcbiAgICBuZXcobnVtIC8gZ2NkLCBkZW4gLyBnY2QpXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzZWxmLmNvbnZlcnQobnVtLCBkZW4pXHJcbiAgICBpZiBudW0ubmlsPyB8fCBkZW4ubmlsP1xyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ2Nhbm5vdCBjb252ZXJ0IG5pbCBpbnRvIFJhdGlvbmFsJ1xyXG4gICAgZW5kXHJcblxyXG4gICAgaWYgOjpJbnRlZ2VyID09PSBudW0gJiYgOjpJbnRlZ2VyID09PSBkZW5cclxuICAgICAgcmV0dXJuIHJlZHVjZShudW0sIGRlbilcclxuICAgIGVuZFxyXG5cclxuICAgIGlmIDo6RmxvYXQgPT09IG51bSB8fCA6OlN0cmluZyA9PT0gbnVtIHx8IDo6Q29tcGxleCA9PT0gbnVtXHJcbiAgICAgIG51bSA9IG51bS50b19yXHJcbiAgICBlbmRcclxuXHJcbiAgICBpZiA6OkZsb2F0ID09PSBkZW4gfHwgOjpTdHJpbmcgPT09IGRlbiB8fCA6OkNvbXBsZXggPT09IGRlblxyXG4gICAgICBkZW4gPSBkZW4udG9fclxyXG4gICAgZW5kXHJcblxyXG4gICAgaWYgZGVuLmVxdWFsPygxKSAmJiAhKDo6SW50ZWdlciA9PT0gbnVtKVxyXG4gICAgICA6Ok9wYWwuY29lcmNlX3RvIShudW0sIDo6UmF0aW9uYWwsIDp0b19yKVxyXG4gICAgZWxzaWYgOjpOdW1lcmljID09PSBudW0gJiYgOjpOdW1lcmljID09PSBkZW5cclxuICAgICAgbnVtIC8gZGVuXHJcbiAgICBlbHNlXHJcbiAgICAgIHJlZHVjZShudW0sIGRlbilcclxuICAgIGVuZFxyXG4gIGVuZFxyXG5cclxuICBkZWYgaW5pdGlhbGl6ZShudW0sIGRlbilcclxuICAgIEBudW0gPSBudW1cclxuICAgIEBkZW4gPSBkZW5cclxuICAgIGZyZWV6ZVxyXG4gIGVuZFxyXG5cclxuICBkZWYgbnVtZXJhdG9yXHJcbiAgICBAbnVtXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBkZW5vbWluYXRvclxyXG4gICAgQGRlblxyXG4gIGVuZFxyXG5cclxuICBkZWYgY29lcmNlKG90aGVyKVxyXG4gICAgY2FzZSBvdGhlclxyXG4gICAgd2hlbiA6OlJhdGlvbmFsXHJcbiAgICAgIFtvdGhlciwgc2VsZl1cclxuXHJcbiAgICB3aGVuIDo6SW50ZWdlclxyXG4gICAgICBbb3RoZXIudG9fciwgc2VsZl1cclxuXHJcbiAgICB3aGVuIDo6RmxvYXRcclxuICAgICAgW290aGVyLCB0b19mXVxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiA9PShvdGhlcilcclxuICAgIGNhc2Ugb3RoZXJcclxuICAgIHdoZW4gOjpSYXRpb25hbFxyXG4gICAgICBAbnVtID09IG90aGVyLm51bWVyYXRvciAmJiBAZGVuID09IG90aGVyLmRlbm9taW5hdG9yXHJcblxyXG4gICAgd2hlbiA6OkludGVnZXJcclxuICAgICAgQG51bSA9PSBvdGhlciAmJiBAZGVuID09IDFcclxuXHJcbiAgICB3aGVuIDo6RmxvYXRcclxuICAgICAgdG9fZiA9PSBvdGhlclxyXG5cclxuICAgIGVsc2VcclxuICAgICAgb3RoZXIgPT0gc2VsZlxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiA8PT4ob3RoZXIpXHJcbiAgICBjYXNlIG90aGVyXHJcbiAgICB3aGVuIDo6UmF0aW9uYWxcclxuICAgICAgQG51bSAqIG90aGVyLmRlbm9taW5hdG9yIC0gQGRlbiAqIG90aGVyLm51bWVyYXRvciA8PT4gMFxyXG5cclxuICAgIHdoZW4gOjpJbnRlZ2VyXHJcbiAgICAgIEBudW0gLSBAZGVuICogb3RoZXIgPD0+IDBcclxuXHJcbiAgICB3aGVuIDo6RmxvYXRcclxuICAgICAgdG9fZiA8PT4gb3RoZXJcclxuXHJcbiAgICBlbHNlXHJcbiAgICAgIF9fY29lcmNlZF9fIDo8PT4sIG90aGVyXHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmICsob3RoZXIpXHJcbiAgICBjYXNlIG90aGVyXHJcbiAgICB3aGVuIDo6UmF0aW9uYWxcclxuICAgICAgbnVtID0gQG51bSAqIG90aGVyLmRlbm9taW5hdG9yICsgQGRlbiAqIG90aGVyLm51bWVyYXRvclxyXG4gICAgICBkZW4gPSBAZGVuICogb3RoZXIuZGVub21pbmF0b3JcclxuXHJcbiAgICAgIDo6S2VybmVsLlJhdGlvbmFsKG51bSwgZGVuKVxyXG5cclxuICAgIHdoZW4gOjpJbnRlZ2VyXHJcbiAgICAgIDo6S2VybmVsLlJhdGlvbmFsKEBudW0gKyBvdGhlciAqIEBkZW4sIEBkZW4pXHJcblxyXG4gICAgd2hlbiA6OkZsb2F0XHJcbiAgICAgIHRvX2YgKyBvdGhlclxyXG5cclxuICAgIGVsc2VcclxuICAgICAgX19jb2VyY2VkX18gOissIG90aGVyXHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmIC0ob3RoZXIpXHJcbiAgICBjYXNlIG90aGVyXHJcbiAgICB3aGVuIDo6UmF0aW9uYWxcclxuICAgICAgbnVtID0gQG51bSAqIG90aGVyLmRlbm9taW5hdG9yIC0gQGRlbiAqIG90aGVyLm51bWVyYXRvclxyXG4gICAgICBkZW4gPSBAZGVuICogb3RoZXIuZGVub21pbmF0b3JcclxuXHJcbiAgICAgIDo6S2VybmVsLlJhdGlvbmFsKG51bSwgZGVuKVxyXG5cclxuICAgIHdoZW4gOjpJbnRlZ2VyXHJcbiAgICAgIDo6S2VybmVsLlJhdGlvbmFsKEBudW0gLSBvdGhlciAqIEBkZW4sIEBkZW4pXHJcblxyXG4gICAgd2hlbiA6OkZsb2F0XHJcbiAgICAgIHRvX2YgLSBvdGhlclxyXG5cclxuICAgIGVsc2VcclxuICAgICAgX19jb2VyY2VkX18gOi0sIG90aGVyXHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmICoob3RoZXIpXHJcbiAgICBjYXNlIG90aGVyXHJcbiAgICB3aGVuIDo6UmF0aW9uYWxcclxuICAgICAgbnVtID0gQG51bSAqIG90aGVyLm51bWVyYXRvclxyXG4gICAgICBkZW4gPSBAZGVuICogb3RoZXIuZGVub21pbmF0b3JcclxuXHJcbiAgICAgIDo6S2VybmVsLlJhdGlvbmFsKG51bSwgZGVuKVxyXG5cclxuICAgIHdoZW4gOjpJbnRlZ2VyXHJcbiAgICAgIDo6S2VybmVsLlJhdGlvbmFsKEBudW0gKiBvdGhlciwgQGRlbilcclxuXHJcbiAgICB3aGVuIDo6RmxvYXRcclxuICAgICAgdG9fZiAqIG90aGVyXHJcblxyXG4gICAgZWxzZVxyXG4gICAgICBfX2NvZXJjZWRfXyA6Kiwgb3RoZXJcclxuICAgIGVuZFxyXG4gIGVuZFxyXG5cclxuICBkZWYgLyhvdGhlcilcclxuICAgIGNhc2Ugb3RoZXJcclxuICAgIHdoZW4gOjpSYXRpb25hbFxyXG4gICAgICBudW0gPSBAbnVtICogb3RoZXIuZGVub21pbmF0b3JcclxuICAgICAgZGVuID0gQGRlbiAqIG90aGVyLm51bWVyYXRvclxyXG5cclxuICAgICAgOjpLZXJuZWwuUmF0aW9uYWwobnVtLCBkZW4pXHJcblxyXG4gICAgd2hlbiA6OkludGVnZXJcclxuICAgICAgaWYgb3RoZXIgPT0gMFxyXG4gICAgICAgIHRvX2YgLyAwLjBcclxuICAgICAgZWxzZVxyXG4gICAgICAgIDo6S2VybmVsLlJhdGlvbmFsKEBudW0sIEBkZW4gKiBvdGhlcilcclxuICAgICAgZW5kXHJcblxyXG4gICAgd2hlbiA6OkZsb2F0XHJcbiAgICAgIHRvX2YgLyBvdGhlclxyXG5cclxuICAgIGVsc2VcclxuICAgICAgX19jb2VyY2VkX18gOi8sIG90aGVyXHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmICoqKG90aGVyKVxyXG4gICAgY2FzZSBvdGhlclxyXG4gICAgd2hlbiA6OkludGVnZXJcclxuICAgICAgaWYgc2VsZiA9PSAwICYmIG90aGVyIDwgMFxyXG4gICAgICAgIDo6RmxvYXQ6OklORklOSVRZXHJcbiAgICAgIGVsc2lmIG90aGVyID4gMFxyXG4gICAgICAgIDo6S2VybmVsLlJhdGlvbmFsKEBudW0qKm90aGVyLCBAZGVuKipvdGhlcilcclxuICAgICAgZWxzaWYgb3RoZXIgPCAwXHJcbiAgICAgICAgOjpLZXJuZWwuUmF0aW9uYWwoQGRlbioqLW90aGVyLCBAbnVtKiotb3RoZXIpXHJcbiAgICAgIGVsc2VcclxuICAgICAgICA6Oktlcm5lbC5SYXRpb25hbCgxLCAxKVxyXG4gICAgICBlbmRcclxuXHJcbiAgICB3aGVuIDo6RmxvYXRcclxuICAgICAgdG9fZioqb3RoZXJcclxuXHJcbiAgICB3aGVuIDo6UmF0aW9uYWxcclxuICAgICAgaWYgb3RoZXIgPT0gMFxyXG4gICAgICAgIDo6S2VybmVsLlJhdGlvbmFsKDEsIDEpXHJcbiAgICAgIGVsc2lmIG90aGVyLmRlbm9taW5hdG9yID09IDFcclxuICAgICAgICBpZiBvdGhlciA8IDBcclxuICAgICAgICAgIDo6S2VybmVsLlJhdGlvbmFsKEBkZW4qKm90aGVyLm51bWVyYXRvci5hYnMsIEBudW0qKm90aGVyLm51bWVyYXRvci5hYnMpXHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgOjpLZXJuZWwuUmF0aW9uYWwoQG51bSoqb3RoZXIubnVtZXJhdG9yLCBAZGVuKipvdGhlci5udW1lcmF0b3IpXHJcbiAgICAgICAgZW5kXHJcbiAgICAgIGVsc2lmIHNlbGYgPT0gMCAmJiBvdGhlciA8IDBcclxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6Olplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSAwJ1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgdG9fZioqb3RoZXJcclxuICAgICAgZW5kXHJcblxyXG4gICAgZWxzZVxyXG4gICAgICBfX2NvZXJjZWRfXyA6KiosIG90aGVyXHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmIGFic1xyXG4gICAgOjpLZXJuZWwuUmF0aW9uYWwoQG51bS5hYnMsIEBkZW4uYWJzKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgY2VpbChwcmVjaXNpb24gPSAwKVxyXG4gICAgaWYgcHJlY2lzaW9uID09IDBcclxuICAgICAgKC0oLUBudW0gLyBAZGVuKSkuY2VpbFxyXG4gICAgZWxzZVxyXG4gICAgICB3aXRoX3ByZWNpc2lvbig6Y2VpbCwgcHJlY2lzaW9uKVxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBmbG9vcihwcmVjaXNpb24gPSAwKVxyXG4gICAgaWYgcHJlY2lzaW9uID09IDBcclxuICAgICAgKC0oLUBudW0gLyBAZGVuKSkuZmxvb3JcclxuICAgIGVsc2VcclxuICAgICAgd2l0aF9wcmVjaXNpb24oOmZsb29yLCBwcmVjaXNpb24pXHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmIGhhc2hcclxuICAgIFs6OlJhdGlvbmFsLCBAbnVtLCBAZGVuXS5oYXNoXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBpbnNwZWN0XHJcbiAgICBcIigje3NlbGZ9KVwiXHJcbiAgZW5kXHJcblxyXG4gIGRlZiByYXRpb25hbGl6ZShlcHMgPSB1bmRlZmluZWQpXHJcbiAgICAleHtcclxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAwLi4xKVwifTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGVwcyA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBlID0gI3tlcHMuYWJzfSxcclxuICAgICAgICAgIGEgPSAje3NlbGYgLSBgZWB9LFxyXG4gICAgICAgICAgYiA9ICN7c2VsZiArIGBlYH07XHJcblxyXG4gICAgICB2YXIgcDAgPSAwLFxyXG4gICAgICAgICAgcDEgPSAxLFxyXG4gICAgICAgICAgcTAgPSAxLFxyXG4gICAgICAgICAgcTEgPSAwLFxyXG4gICAgICAgICAgcDIsIHEyO1xyXG5cclxuICAgICAgdmFyIGMsIGssIHQ7XHJcblxyXG4gICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIGMgPSAje2BhYC5jZWlsfTtcclxuXHJcbiAgICAgICAgaWYgKCN7YGNgIDw9IGBiYH0pIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgayAgPSBjIC0gMTtcclxuICAgICAgICBwMiA9IGsgKiBwMSArIHAwO1xyXG4gICAgICAgIHEyID0gayAqIHExICsgcTA7XHJcbiAgICAgICAgdCAgPSAjezEgLyAoYGJgIC0gYGtgKX07XHJcbiAgICAgICAgYiAgPSAjezEgLyAoYGFgIC0gYGtgKX07XHJcbiAgICAgICAgYSAgPSB0O1xyXG5cclxuICAgICAgICBwMCA9IHAxO1xyXG4gICAgICAgIHEwID0gcTE7XHJcbiAgICAgICAgcDEgPSBwMjtcclxuICAgICAgICBxMSA9IHEyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gI3s6Oktlcm5lbC5SYXRpb25hbChgYyAqIHAxICsgcDBgLCBgYyAqIHExICsgcTBgKX07XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiByb3VuZChwcmVjaXNpb24gPSAwKVxyXG4gICAgcmV0dXJuIHdpdGhfcHJlY2lzaW9uKDpyb3VuZCwgcHJlY2lzaW9uKSB1bmxlc3MgcHJlY2lzaW9uID09IDBcclxuICAgIHJldHVybiAwIGlmIEBudW0gPT0gMFxyXG4gICAgcmV0dXJuIEBudW0gaWYgQGRlbiA9PSAxXHJcblxyXG4gICAgbnVtID0gQG51bS5hYnMgKiAyICsgQGRlblxyXG4gICAgZGVuID0gQGRlbiAqIDJcclxuXHJcbiAgICBhcHByb3ggPSAobnVtIC8gZGVuKS50cnVuY2F0ZVxyXG5cclxuICAgIGlmIEBudW0gPCAwXHJcbiAgICAgIC1hcHByb3hcclxuICAgIGVsc2VcclxuICAgICAgYXBwcm94XHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmIHRvX2ZcclxuICAgIEBudW0gLyBAZGVuXHJcbiAgZW5kXHJcblxyXG4gIGRlZiB0b19pXHJcbiAgICB0cnVuY2F0ZVxyXG4gIGVuZFxyXG5cclxuICBkZWYgdG9fclxyXG4gICAgc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgdG9fc1xyXG4gICAgXCIje0BudW19LyN7QGRlbn1cIlxyXG4gIGVuZFxyXG5cclxuICBkZWYgdHJ1bmNhdGUocHJlY2lzaW9uID0gMClcclxuICAgIGlmIHByZWNpc2lvbiA9PSAwXHJcbiAgICAgIEBudW0gPCAwID8gY2VpbCA6IGZsb29yXHJcbiAgICBlbHNlXHJcbiAgICAgIHdpdGhfcHJlY2lzaW9uKDp0cnVuY2F0ZSwgcHJlY2lzaW9uKVxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiB3aXRoX3ByZWNpc2lvbihtZXRob2QsIHByZWNpc2lvbilcclxuICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnbm90IGFuIEludGVnZXInIHVubGVzcyA6OkludGVnZXIgPT09IHByZWNpc2lvblxyXG5cclxuICAgIHAgPSAxMCoqcHJlY2lzaW9uXHJcbiAgICBzID0gc2VsZiAqIHBcclxuXHJcbiAgICBpZiBwcmVjaXNpb24gPCAxXHJcbiAgICAgIChzLnNlbmQobWV0aG9kKSAvIHApLnRvX2lcclxuICAgIGVsc2VcclxuICAgICAgOjpLZXJuZWwuUmF0aW9uYWwocy5zZW5kKG1ldGhvZCksIHApXHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmIHNlbGYuZnJvbV9zdHJpbmcoc3RyaW5nKVxyXG4gICAgJXh7XHJcbiAgICAgIHZhciBzdHIgPSBzdHJpbmcudHJpbUxlZnQoKSxcclxuICAgICAgICAgIHJlID0gL15bKy1dP1tcXGRfXSsoXFwuW1xcZF9dKyk/LyxcclxuICAgICAgICAgIG1hdGNoID0gc3RyLm1hdGNoKHJlKSxcclxuICAgICAgICAgIG51bWVyYXRvciwgZGVub21pbmF0b3I7XHJcblxyXG4gICAgICBmdW5jdGlvbiBpc0Zsb2F0KCkge1xyXG4gICAgICAgIHJldHVybiByZS50ZXN0KHN0cik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGN1dEZsb2F0KCkge1xyXG4gICAgICAgIHZhciBtYXRjaCA9IHN0ci5tYXRjaChyZSk7XHJcbiAgICAgICAgdmFyIG51bWJlciA9IG1hdGNoWzBdO1xyXG4gICAgICAgIHN0ciA9IHN0ci5zbGljZShudW1iZXIubGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4gbnVtYmVyLnJlcGxhY2UoL18vZywgJycpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXNGbG9hdCgpKSB7XHJcbiAgICAgICAgbnVtZXJhdG9yID0gcGFyc2VGbG9hdChjdXRGbG9hdCgpKTtcclxuXHJcbiAgICAgICAgaWYgKHN0clswXSA9PT0gJy8nKSB7XHJcbiAgICAgICAgICAvLyByYXRpb25hbCByZWFsIHBhcnRcclxuICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSgxKTtcclxuXHJcbiAgICAgICAgICBpZiAoaXNGbG9hdCgpKSB7XHJcbiAgICAgICAgICAgIGRlbm9taW5hdG9yID0gcGFyc2VGbG9hdChjdXRGbG9hdCgpKTtcclxuICAgICAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuUmF0aW9uYWwoYG51bWVyYXRvcmAsIGBkZW5vbWluYXRvcmApfTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAjezo6S2VybmVsLlJhdGlvbmFsKGBudW1lcmF0b3JgLCAxKX07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiAjezo6S2VybmVsLlJhdGlvbmFsKGBudW1lcmF0b3JgLCAxKX07XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAjezo6S2VybmVsLlJhdGlvbmFsKDAsIDEpfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBhbGlhcyBkaXZpZGUgL1xyXG4gIGFsaWFzIHF1byAvXHJcbmVuZFxyXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOlJhdGlvbmFsPiIsInJlZHVjZSIsIm51bSIsImRlbiIsInRvX2kiLCIwIiwiS2VybmVsIiwicmFpc2UiLCJaZXJvRGl2aXNpb25FcnJvciIsIjwiLCItQCIsIjEiLCJuZXciLCJnY2QiLCIvIiwiY29udmVydCIsIm5pbD8iLCJUeXBlRXJyb3IiLCJJbnRlZ2VyIiwiRmxvYXQiLCJTdHJpbmciLCJDb21wbGV4IiwidG9fciIsImVxdWFsPyIsIj09PSIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiUmF0aW9uYWwiLCJOdW1lcmljIiwiaW5pdGlhbGl6ZSIsIkBudW0iLCJAZGVuIiwiZnJlZXplIiwibnVtZXJhdG9yIiwiZGVub21pbmF0b3IiLCJjb2VyY2UiLCJvdGhlciIsIiRyZXRfb3JfMSIsInRvX2YiLCI9PSIsIiRyZXRfb3JfMiIsIjw9PiIsIi0iLCIqIiwiX19jb2VyY2VkX18iLCIrIiwiKioiLCJGbG9hdDo6SU5GSU5JVFkiLCI+IiwiYWJzIiwiY2VpbCIsInByZWNpc2lvbiIsIndpdGhfcHJlY2lzaW9uIiwiZmxvb3IiLCJoYXNoIiwiaW5zcGVjdCIsInJhdGlvbmFsaXplIiwiZXBzIiwiQXJndW1lbnRFcnJvciIsIjw9Iiwicm91bmQiLCIyIiwiYXBwcm94IiwidHJ1bmNhdGUiLCJ0b19zIiwibWV0aG9kIiwicCIsIjEwIiwicyIsInNlbmQiLCJmcm9tX3N0cmluZyIsInN0cmluZyJdLCJtYXBwaW5ncyI6IkFBQUFBLG1DQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQyxJQUFBQyxTQUFBQSxDQUFRRixpQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsdUJBQVJFO0VBRUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7QUFBQUE7O0lBQ0VDLE1BQUlILElBQUpHLGFBQUFBLGtCQUFnQkMsR0FBRCxFQUFNQyxHQUFyQkY7QUFBQUEsTUFBQUE7OztNQUNFQyxNQUFNQSxHQUFHRSxNQUFBQSxDQUFBQTtNQUNURCxNQUFNQSxHQUFHQyxNQUFBQSxDQUFBQTtNQUVULElBQUEsTUFBR0QsR0FBSCxFQUFVRSxDQUFWLENBQUE7UUFDRUMsT0FBUUMsT0FBQUEsQ0FBT0Msd0JBQWYsRUFBb0NQLGNBQTVCTTtNQURWLE9BRUEsSUFBQSxRQUFVRSxPQUFKTixHQUFJTSxFQUFFSixDQUFGSSxDQUFWLENBQUE7O1FBQ0VQLE1BQU9BLEdBQURRLE9B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QUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBLG1CQUFxQmhFLE9BQVFxQixVQUFBQSxDQUFXMkMsU0FBbkIsRUFBZ0NBLFdBQXhCM0MsQ0FBc0MyQztBQUNuRUE7QUFDQUEsbUJBQXFCaEUsT0FBUXFCLFVBQUFBLENBQVcyQyxTQUFuQixFQUErQjNELENBQXZCZ0IsQ0FBMEIyQztBQUN2REE7QUFDQUE7QUFDQUEsaUJBQW1CaEUsT0FBUXFCLFVBQUFBLENBQVcyQyxTQUFuQixFQUErQjNELENBQXZCZ0IsQ0FBMEIyQztBQUNyREE7QUFDQUE7QUFDQUEsZUFBaUJoRSxPQUFRcUIsVUFBQUEsQ0FBVXRCLENBQWxCLEVBQXFCTSxDQUFiZ0IsQ0FBZ0IyQztBQUN6Q0E7QUFDQUE7SUFyQ0VBLENBQUFBO0lBd0NBLGFBQU0sUUFBTixFQUFhLEdBQWI7SUFDQXRFLE9BQUEsYUFBTSxLQUFOLEVBQVUsR0FBVjtFQXJZRkEsR0FBTSxJQUFOQSxFQUFtQjRCLGNBQW5CNUI7QUFMQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIzMzk1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi90aW1lLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogc2xpY2UsIGRlbnlfZnJvemVuX2FjY2Vzc1xyXG4jIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcclxuIyB1c2Vfc3RyaWN0OiB0cnVlXHJcblxyXG5yZXF1aXJlICdjb3JlbGliL2NvbXBhcmFibGUnXHJcblxyXG5jbGFzcyA6OlRpbWUgPCBgRGF0ZWBcclxuICBpbmNsdWRlIDo6Q29tcGFyYWJsZVxyXG5cclxuICAleHtcclxuICAgIHZhciBkYXlzX29mX3dlZWsgPSAjeyV3W1N1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5IFN1bmRheV19LFxyXG4gICAgICAgIHNob3J0X2RheXMgICA9ICN7JXdbU3VuIE1vbiBUdWUgV2VkIFRodSBGcmkgU2F0XX0sXHJcbiAgICAgICAgc2hvcnRfbW9udGhzID0gI3sld1tKYW4gRmViIE1hciBBcHIgTWF5IEp1biBKdWwgQXVnIFNlcCBPY3QgTm92IERlY119LFxyXG4gICAgICAgIGxvbmdfbW9udGhzICA9ICN7JXdbSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlcl19O1xyXG4gIH1cclxuXHJcbiAgZGVmIHNlbGYuYXQoc2Vjb25kcywgZnJhYyA9IHVuZGVmaW5lZClcclxuICAgICV4e1xyXG4gICAgICB2YXIgcmVzdWx0O1xyXG5cclxuICAgICAgaWYgKCN7OjpUaW1lID09PSBzZWNvbmRzfSkge1xyXG4gICAgICAgIGlmIChmcmFjICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCBUaW1lIGludG8gYW4gZXhhY3QgbnVtYmVyXCJ9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdCA9IG5ldyBEYXRlKHNlY29uZHMuZ2V0VGltZSgpKTtcclxuICAgICAgICByZXN1bHQudGltZXpvbmUgPSBzZWNvbmRzLnRpbWV6b25lO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghc2Vjb25kcy4kJGlzX251bWJlcikge1xyXG4gICAgICAgIHNlY29uZHMgPSAjezo6T3BhbC5jb2VyY2VfdG8hKHNlY29uZHMsIDo6SW50ZWdlciwgOnRvX2ludCl9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZnJhYyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHNlY29uZHMgKiAxMDAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFmcmFjLiQkaXNfbnVtYmVyKSB7XHJcbiAgICAgICAgZnJhYyA9ICN7OjpPcGFsLmNvZXJjZV90byEoZnJhYywgOjpJbnRlZ2VyLCA6dG9faW50KX07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuZXcgRGF0ZShzZWNvbmRzICogMTAwMCArIChmcmFjIC8gMTAwMCkpO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICAleHtcclxuICAgIGZ1bmN0aW9uIHRpbWVfcGFyYW1zKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgc2VjKSB7XHJcbiAgICAgIGlmICh5ZWFyLiQkaXNfc3RyaW5nKSB7XHJcbiAgICAgICAgeWVhciA9IHBhcnNlSW50KHllYXIsIDEwKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB5ZWFyID0gI3s6Ok9wYWwuY29lcmNlX3RvIShgeWVhcmAsIDo6SW50ZWdlciwgOnRvX2ludCl9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobW9udGggPT09IG5pbCkge1xyXG4gICAgICAgIG1vbnRoID0gMTtcclxuICAgICAgfSBlbHNlIGlmICghbW9udGguJCRpc19udW1iZXIpIHtcclxuICAgICAgICBpZiAoI3tgbW9udGhgLnJlc3BvbmRfdG8/KDp0b19zdHIpfSkge1xyXG4gICAgICAgICAgbW9udGggPSAje2Btb250aGAudG9fc3RyfTtcclxuICAgICAgICAgIHN3aXRjaCAobW9udGgudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgY2FzZSAnamFuJzogbW9udGggPSAgMTsgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdmZWInOiBtb250aCA9ICAyOyBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ21hcic6IG1vbnRoID0gIDM7IGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnYXByJzogbW9udGggPSAgNDsgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdtYXknOiBtb250aCA9ICA1OyBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ2p1bic6IG1vbnRoID0gIDY7IGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnanVsJzogbW9udGggPSAgNzsgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdhdWcnOiBtb250aCA9ICA4OyBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ3NlcCc6IG1vbnRoID0gIDk7IGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnb2N0JzogbW9udGggPSAxMDsgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdub3YnOiBtb250aCA9IDExOyBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ2RlYyc6IG1vbnRoID0gMTI7IGJyZWFrO1xyXG4gICAgICAgICAgZGVmYXVsdDogbW9udGggPSAje2Btb250aGAudG9faX07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG1vbnRoID0gI3s6Ok9wYWwuY29lcmNlX3RvIShgbW9udGhgLCA6OkludGVnZXIsIDp0b19pbnQpfTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChtb250aCA8IDEgfHwgbW9udGggPiAxMikge1xyXG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIm1vbnRoIG91dCBvZiByYW5nZTogI3tgbW9udGhgfVwifVxyXG4gICAgICB9XHJcbiAgICAgIG1vbnRoID0gbW9udGggLSAxO1xyXG5cclxuICAgICAgaWYgKGRheSA9PT0gbmlsKSB7XHJcbiAgICAgICAgZGF5ID0gMTtcclxuICAgICAgfSBlbHNlIGlmIChkYXkuJCRpc19zdHJpbmcpIHtcclxuICAgICAgICBkYXkgPSBwYXJzZUludChkYXksIDEwKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkYXkgPSAjezo6T3BhbC5jb2VyY2VfdG8hKGBkYXlgLCA6OkludGVnZXIsIDp0b19pbnQpfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGRheSA8IDEgfHwgZGF5ID4gMzEpIHtcclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJkYXkgb3V0IG9mIHJhbmdlOiAje2BkYXlgfVwifVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaG91ciA9PT0gbmlsKSB7XHJcbiAgICAgICAgaG91ciA9IDA7XHJcbiAgICAgIH0gZWxzZSBpZiAoaG91ci4kJGlzX3N0cmluZykge1xyXG4gICAgICAgIGhvdXIgPSBwYXJzZUludChob3VyLCAxMCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaG91ciA9ICN7OjpPcGFsLmNvZXJjZV90byEoYGhvdXJgLCA6OkludGVnZXIsIDp0b19pbnQpfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGhvdXIgPCAwIHx8IGhvdXIgPiAyNCkge1xyXG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImhvdXIgb3V0IG9mIHJhbmdlOiAje2Bob3VyYH1cIn1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG1pbiA9PT0gbmlsKSB7XHJcbiAgICAgICAgbWluID0gMDtcclxuICAgICAgfSBlbHNlIGlmIChtaW4uJCRpc19zdHJpbmcpIHtcclxuICAgICAgICBtaW4gPSBwYXJzZUludChtaW4sIDEwKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBtaW4gPSAjezo6T3BhbC5jb2VyY2VfdG8hKGBtaW5gLCA6OkludGVnZXIsIDp0b19pbnQpfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG1pbiA8IDAgfHwgbWluID4gNTkpIHtcclxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJtaW4gb3V0IG9mIHJhbmdlOiAje2BtaW5gfVwifVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2VjID09PSBuaWwpIHtcclxuICAgICAgICBzZWMgPSAwO1xyXG4gICAgICB9IGVsc2UgaWYgKCFzZWMuJCRpc19udW1iZXIpIHtcclxuICAgICAgICBpZiAoc2VjLiQkaXNfc3RyaW5nKSB7XHJcbiAgICAgICAgICBzZWMgPSBwYXJzZUludChzZWMsIDEwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc2VjID0gI3s6Ok9wYWwuY29lcmNlX3RvIShgc2VjYCwgOjpJbnRlZ2VyLCA6dG9faW50KX07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2VjIDwgMCB8fCBzZWMgPiA2MCkge1xyXG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcInNlYyBvdXQgb2YgcmFuZ2U6ICN7YHNlY2B9XCJ9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBbeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWNdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVmIHNlbGYubmV3KHllYXIgPSB1bmRlZmluZWQsIG1vbnRoID0gbmlsLCBkYXkgPSBuaWwsIGhvdXIgPSBuaWwsIG1pbiA9IG5pbCwgc2VjID0gbmlsLCB1dGNfb2Zmc2V0ID0gbmlsKVxyXG4gICAgJXh7XHJcbiAgICAgIHZhciBhcmdzLCByZXN1bHQsIHRpbWV6b25lLCB1dGNfZGF0ZTtcclxuXHJcbiAgICAgIGlmICh5ZWFyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGUoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYXJncyAgPSB0aW1lX3BhcmFtcyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIHNlYyk7XHJcbiAgICAgIHllYXIgID0gYXJnc1swXTtcclxuICAgICAgbW9udGggPSBhcmdzWzFdO1xyXG4gICAgICBkYXkgICA9IGFyZ3NbMl07XHJcbiAgICAgIGhvdXIgID0gYXJnc1szXTtcclxuICAgICAgbWluICAgPSBhcmdzWzRdO1xyXG4gICAgICBzZWMgICA9IGFyZ3NbNV07XHJcblxyXG4gICAgICBpZiAodXRjX29mZnNldCA9PT0gbmlsKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCAwLCBzZWMgKiAxMDAwKTtcclxuICAgICAgICBpZiAoeWVhciA8IDEwMCkge1xyXG4gICAgICAgICAgcmVzdWx0LnNldEZ1bGxZZWFyKHllYXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aW1lem9uZSA9ICN7X3BhcnNlX29mZnNldCh1dGNfb2Zmc2V0KX07XHJcbiAgICAgIHV0Y19kYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCAwLCBzZWMgKiAxMDAwKSk7XHJcbiAgICAgIGlmICh5ZWFyIDwgMTAwKSB7XHJcbiAgICAgICAgdXRjX2RhdGUuc2V0VVRDRnVsbFllYXIoeWVhcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlc3VsdCA9IG5ldyBEYXRlKHV0Y19kYXRlLmdldFRpbWUoKSAtIHRpbWV6b25lICogMzYwMDAwMCk7XHJcbiAgICAgIHJlc3VsdC50aW1lem9uZSA9IHRpbWV6b25lO1xyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgIyBAcHJpdmF0ZVxyXG4gIGRlZiBzZWxmLl9wYXJzZV9vZmZzZXQodXRjX29mZnNldClcclxuICAgICV4e1xyXG4gICAgICB2YXIgdGltZXpvbmU7XHJcbiAgICAgIGlmICh1dGNfb2Zmc2V0LiQkaXNfc3RyaW5nKSB7XHJcbiAgICAgICAgaWYgKHV0Y19vZmZzZXQgPT0gJ1VUQycpIHtcclxuICAgICAgICAgIHRpbWV6b25lID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZigvXlsrLV1cXGRcXGQ6WzAtNV1cXGQkLy50ZXN0KHV0Y19vZmZzZXQpKSB7XHJcbiAgICAgICAgICB2YXIgc2lnbiwgaG91cnMsIG1pbnV0ZXM7XHJcbiAgICAgICAgICBzaWduID0gdXRjX29mZnNldFswXTtcclxuICAgICAgICAgIGhvdXJzID0gKyh1dGNfb2Zmc2V0WzFdICsgdXRjX29mZnNldFsyXSk7XHJcbiAgICAgICAgICBtaW51dGVzID0gKyh1dGNfb2Zmc2V0WzRdICsgdXRjX29mZnNldFs1XSk7XHJcblxyXG4gICAgICAgICAgdGltZXpvbmUgPSAoc2lnbiA9PSAnLScgPyAtMSA6IDEpICogKGhvdXJzICsgbWludXRlcyAvIDYwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAvLyBVbnN1cHBvcnRlZDogXCJBXCIuLlwiSVwiLFwiS1wiLi5cIlpcIlxyXG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICUnXCIrSEg6TU1cIiwgXCItSEg6TU1cIiwgXCJVVENcIiBleHBlY3RlZCBmb3IgdXRjX29mZnNldDogI3t1dGNfb2Zmc2V0fSd9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKHV0Y19vZmZzZXQuJCRpc19udW1iZXIpIHtcclxuICAgICAgICB0aW1lem9uZSA9IHV0Y19vZmZzZXQgLyAzNjAwO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIk9wYWwgZG9lc24ndCBzdXBwb3J0IG90aGVyIHR5cGVzIGZvciBhIHRpbWV6b25lIGFyZ3VtZW50IHRoYW4gSW50ZWdlciBhbmQgU3RyaW5nXCJ9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRpbWV6b25lO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc2VsZi5sb2NhbCh5ZWFyLCBtb250aCA9IG5pbCwgZGF5ID0gbmlsLCBob3VyID0gbmlsLCBtaW4gPSBuaWwsIHNlYyA9IG5pbCwgbWlsbGlzZWNvbmQgPSBuaWwsIF9kdW1teTEgPSBuaWwsIF9kdW1teTIgPSBuaWwsIF9kdW1teTMgPSBuaWwpXHJcbiAgICAjIFRoZSBfZHVtbXkgYXJncyBhcmUgdGhlcmUgb25seSBiZWNhdXNlIHRoZSBNUkkgdmVyc2lvbiBhY2NlcHRzIHVwIHRvIDEwIGFyZ3VtZW50c1xyXG4gICAgJXh7XHJcbiAgICAgIHZhciBhcmdzLCByZXN1bHQ7XHJcblxyXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMTApIHtcclxuICAgICAgICBhcmdzICA9ICRzbGljZShhcmd1bWVudHMpO1xyXG4gICAgICAgIHllYXIgID0gYXJnc1s1XTtcclxuICAgICAgICBtb250aCA9IGFyZ3NbNF07XHJcbiAgICAgICAgZGF5ICAgPSBhcmdzWzNdO1xyXG4gICAgICAgIGhvdXIgID0gYXJnc1syXTtcclxuICAgICAgICBtaW4gICA9IGFyZ3NbMV07XHJcbiAgICAgICAgc2VjICAgPSBhcmdzWzBdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhcmdzICA9IHRpbWVfcGFyYW1zKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgc2VjKTtcclxuICAgICAgeWVhciAgPSBhcmdzWzBdO1xyXG4gICAgICBtb250aCA9IGFyZ3NbMV07XHJcbiAgICAgIGRheSAgID0gYXJnc1syXTtcclxuICAgICAgaG91ciAgPSBhcmdzWzNdO1xyXG4gICAgICBtaW4gICA9IGFyZ3NbNF07XHJcbiAgICAgIHNlYyAgID0gYXJnc1s1XTtcclxuXHJcbiAgICAgIHJlc3VsdCA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgMCwgc2VjICogMTAwMCk7XHJcbiAgICAgIGlmICh5ZWFyIDwgMTAwKSB7XHJcbiAgICAgICAgcmVzdWx0LnNldEZ1bGxZZWFyKHllYXIpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzZWxmLmdtKHllYXIsIG1vbnRoID0gbmlsLCBkYXkgPSBuaWwsIGhvdXIgPSBuaWwsIG1pbiA9IG5pbCwgc2VjID0gbmlsLCBtaWxsaXNlY29uZCA9IG5pbCwgX2R1bW15MSA9IG5pbCwgX2R1bW15MiA9IG5pbCwgX2R1bW15MyA9IG5pbClcclxuICAgICMgVGhlIF9kdW1teSBhcmdzIGFyZSB0aGVyZSBvbmx5IGJlY2F1c2UgdGhlIE1SSSB2ZXJzaW9uIGFjY2VwdHMgdXAgdG8gMTAgYXJndW1lbnRzXHJcbiAgICAleHtcclxuICAgICAgdmFyIGFyZ3MsIHJlc3VsdDtcclxuXHJcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxMCkge1xyXG4gICAgICAgIGFyZ3MgID0gJHNsaWNlKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgeWVhciAgPSBhcmdzWzVdO1xyXG4gICAgICAgIG1vbnRoID0gYXJnc1s0XTtcclxuICAgICAgICBkYXkgICA9IGFyZ3NbM107XHJcbiAgICAgICAgaG91ciAgPSBhcmdzWzJdO1xyXG4gICAgICAgIG1pbiAgID0gYXJnc1sxXTtcclxuICAgICAgICBzZWMgICA9IGFyZ3NbMF07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGFyZ3MgID0gdGltZV9wYXJhbXMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWMpO1xyXG4gICAgICB5ZWFyICA9IGFyZ3NbMF07XHJcbiAgICAgIG1vbnRoID0gYXJnc1sxXTtcclxuICAgICAgZGF5ICAgPSBhcmdzWzJdO1xyXG4gICAgICBob3VyICA9IGFyZ3NbM107XHJcbiAgICAgIG1pbiAgID0gYXJnc1s0XTtcclxuICAgICAgc2VjICAgPSBhcmdzWzVdO1xyXG5cclxuICAgICAgcmVzdWx0ID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCAwLCBzZWMgKiAxMDAwKSk7XHJcbiAgICAgIGlmICh5ZWFyIDwgMTAwKSB7XHJcbiAgICAgICAgcmVzdWx0LnNldFVUQ0Z1bGxZZWFyKHllYXIpO1xyXG4gICAgICB9XHJcbiAgICAgIHJlc3VsdC50aW1lem9uZSA9IDA7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzZWxmLm5vd1xyXG4gICAgbmV3XHJcbiAgZW5kXHJcblxyXG4gIGRlZiArKG90aGVyKVxyXG4gICAgaWYgOjpUaW1lID09PSBvdGhlclxyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ3RpbWUgKyB0aW1lPydcclxuICAgIGVuZFxyXG5cclxuICAgICV4e1xyXG4gICAgICBpZiAoIW90aGVyLiQkaXNfbnVtYmVyKSB7XHJcbiAgICAgICAgb3RoZXIgPSAjezo6T3BhbC5jb2VyY2VfdG8hKG90aGVyLCA6OkludGVnZXIsIDp0b19pbnQpfTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IERhdGUoc2VsZi5nZXRUaW1lKCkgKyAob3RoZXIgKiAxMDAwKSk7XHJcbiAgICAgIHJlc3VsdC50aW1lem9uZSA9IHNlbGYudGltZXpvbmU7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiAtKG90aGVyKVxyXG4gICAgaWYgOjpUaW1lID09PSBvdGhlclxyXG4gICAgICByZXR1cm4gYChzZWxmLmdldFRpbWUoKSAtIG90aGVyLmdldFRpbWUoKSkgLyAxMDAwYFxyXG4gICAgZW5kXHJcblxyXG4gICAgJXh7XHJcbiAgICAgIGlmICghb3RoZXIuJCRpc19udW1iZXIpIHtcclxuICAgICAgICBvdGhlciA9ICN7OjpPcGFsLmNvZXJjZV90byEob3RoZXIsIDo6SW50ZWdlciwgOnRvX2ludCl9O1xyXG4gICAgICB9XHJcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgRGF0ZShzZWxmLmdldFRpbWUoKSAtIChvdGhlciAqIDEwMDApKTtcclxuICAgICAgcmVzdWx0LnRpbWV6b25lID0gc2VsZi50aW1lem9uZTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIDw9PihvdGhlcilcclxuICAgIGlmIDo6VGltZSA9PT0gb3RoZXJcclxuICAgICAgdG9fZiA8PT4gb3RoZXIudG9fZlxyXG4gICAgZWxzZVxyXG4gICAgICByID0gb3RoZXIgPD0+IHNlbGZcclxuICAgICAgaWYgci5uaWw/XHJcbiAgICAgICAgbmlsXHJcbiAgICAgIGVsc2lmIHIgPiAwXHJcbiAgICAgICAgLTFcclxuICAgICAgZWxzaWYgciA8IDBcclxuICAgICAgICAxXHJcbiAgICAgIGVsc2VcclxuICAgICAgICAwXHJcbiAgICAgIGVuZFxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiA9PShvdGhlcilcclxuICAgIDo6VGltZSA9PT0gb3RoZXIgJiYgYCN7dG9fZn0gPT09ICN7b3RoZXIudG9fZn1gXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBhc2N0aW1lXHJcbiAgICBzdHJmdGltZSAnJWEgJWIgJWUgJUg6JU06JVMgJVknXHJcbiAgZW5kXHJcblxyXG4gIFtcclxuICAgIFs6eWVhciwgJ2dldEZ1bGxZZWFyJywgJ2dldFVUQ0Z1bGxZZWFyJ10sXHJcbiAgICBbOm1vbiwgJ2dldE1vbnRoJywgJ2dldFVUQ01vbnRoJywgMV0sXHJcbiAgICBbOndkYXksICdnZXREYXknLCAnZ2V0VVRDRGF5J10sXHJcbiAgICBbOmRheSwgJ2dldERhdGUnLCAnZ2V0VVRDRGF0ZSddLFxyXG4gICAgWzpob3VyLCAnZ2V0SG91cnMnLCAnZ2V0VVRDSG91cnMnXSxcclxuICAgIFs6bWluLCAnZ2V0TWludXRlcycsICdnZXRVVENNaW51dGVzJ10sXHJcbiAgICBbOnNlYywgJ2dldFNlY29uZHMnLCAnZ2V0VVRDU2Vjb25kcyddLFxyXG4gIF0uZWFjaCBkbyB8bWV0aG9kLCBnZXR0ZXIsIHV0Y2dldHRlciwgZGlmZmVyZW5jZSA9IDB8XHJcbiAgICBkZWZpbmVfbWV0aG9kIG1ldGhvZCBkb1xyXG4gICAgICAleHtcclxuICAgICAgICByZXR1cm4gZGlmZmVyZW5jZSArICgoc2VsZi50aW1lem9uZSAhPSBudWxsKSA/XHJcbiAgICAgICAgICAobmV3IERhdGUoc2VsZi5nZXRUaW1lKCkgKyBzZWxmLnRpbWV6b25lICogMzYwMDAwMCkpW3V0Y2dldHRlcl0oKSA6XHJcbiAgICAgICAgICBzZWxmW2dldHRlcl0oKSlcclxuICAgICAgfVxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiB5ZGF5XHJcbiAgICAjIGh0dHA6Ly9qYXZhc2NyaXB0LmFib3V0LmNvbS9saWJyYXJ5L2JsZGF5eWVhci5odG1cclxuICAgICMgYWxzbyBzZWUgbW9tZW50LmpzIGltcGxlbWVudGF0aW9uOiBodHRwOi8vZ2l0LmlvL3ZDS05FXHJcblxyXG4gICAgc3RhcnRfb2ZfeWVhciA9IFRpbWUubmV3KHllYXIpLnRvX2lcclxuICAgIHN0YXJ0X29mX2RheSAgPSBUaW1lLm5ldyh5ZWFyLCBtb250aCwgZGF5KS50b19pXHJcbiAgICBvbmVfZGF5ICAgICAgID0gODZfNDAwXHJcblxyXG4gICAgKChzdGFydF9vZl9kYXkgLSBzdGFydF9vZl95ZWFyKSAvIG9uZV9kYXkpLnJvdW5kICsgMVxyXG4gIGVuZFxyXG5cclxuICBkZWYgaXNkc3RcclxuICAgICV4e1xyXG4gICAgICB2YXIgamFuID0gbmV3IERhdGUoc2VsZi5nZXRGdWxsWWVhcigpLCAwLCAxKSxcclxuICAgICAgICAgIGp1bCA9IG5ldyBEYXRlKHNlbGYuZ2V0RnVsbFllYXIoKSwgNiwgMSk7XHJcbiAgICAgIHJldHVybiBzZWxmLmdldFRpbWV6b25lT2Zmc2V0KCkgPCBNYXRoLm1heChqYW4uZ2V0VGltZXpvbmVPZmZzZXQoKSwganVsLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZHVwXHJcbiAgICBjb3B5ID0gYG5ldyBEYXRlKHNlbGYuZ2V0VGltZSgpKWBcclxuXHJcbiAgICBjb3B5LmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzKHNlbGYpXHJcbiAgICBjb3B5LmluaXRpYWxpemVfZHVwKHNlbGYpXHJcblxyXG4gICAgY29weVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZXFsPyhvdGhlcilcclxuICAgIG90aGVyLmlzX2E/KDo6VGltZSkgJiYgKHNlbGYgPD0+IG90aGVyKS56ZXJvP1xyXG4gIGVuZFxyXG5cclxuICBbXHJcbiAgICBbOnN1bmRheT8sIDBdLFxyXG4gICAgWzptb25kYXk/LCAxXSxcclxuICAgIFs6dHVlc2RheT8sIDJdLFxyXG4gICAgWzp3ZWRuZXNkYXk/LCAzXSxcclxuICAgIFs6dGh1cnNkYXk/LCA0XSxcclxuICAgIFs6ZnJpZGF5PywgNV0sXHJcbiAgICBbOnNhdHVyZGF5PywgNl1cclxuICBdLmVhY2ggZG8gfG1ldGhvZCwgd2Vla2RheXxcclxuICAgIGRlZmluZV9tZXRob2QgbWV0aG9kIGRvXHJcbiAgICAgIGAje3dkYXl9ID09PSB3ZWVrZGF5YFxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBoYXNoXHJcbiAgICBbOjpUaW1lLCBgc2VsZi5nZXRUaW1lKClgXS5oYXNoXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBpbnNwZWN0XHJcbiAgICBpZiB1dGM/XHJcbiAgICAgIHN0cmZ0aW1lICclWS0lbS0lZCAlSDolTTolUyBVVEMnXHJcbiAgICBlbHNlXHJcbiAgICAgIHN0cmZ0aW1lICclWS0lbS0lZCAlSDolTTolUyAleidcclxuICAgIGVuZFxyXG4gIGVuZFxyXG5cclxuICBkZWYgc3VjY1xyXG4gICAgJXh7XHJcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgRGF0ZShzZWxmLmdldFRpbWUoKSArIDEwMDApO1xyXG4gICAgICByZXN1bHQudGltZXpvbmUgPSBzZWxmLnRpbWV6b25lO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgdXNlY1xyXG4gICAgYHNlbGYuZ2V0TWlsbGlzZWNvbmRzKCkgKiAxMDAwYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgem9uZVxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChzZWxmLnRpbWV6b25lID09PSAwKSByZXR1cm4gXCJVVENcIjtcclxuICAgICAgZWxzZSBpZiAoc2VsZi50aW1lem9uZSAhPSBudWxsKSByZXR1cm4gbmlsO1xyXG5cclxuICAgICAgdmFyIHN0cmluZyA9IHNlbGYudG9TdHJpbmcoKSxcclxuICAgICAgICAgIHJlc3VsdDtcclxuXHJcbiAgICAgIGlmIChzdHJpbmcuaW5kZXhPZignKCcpID09IC0xKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gc3RyaW5nLm1hdGNoKC9bQS1aXXszLDR9LylbMF07XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ID0gc3RyaW5nLm1hdGNoKC9cXCgoLispXFwpKD86XFxzfCQpLylbMV1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJlc3VsdCA9PSBcIkdNVFwiICYmIC8oR01UXFxXKlxcZHs0fSkvLnRlc3Qoc3RyaW5nKSkge1xyXG4gICAgICAgIHJldHVybiBSZWdFeHAuJDE7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZ2V0Z21cclxuICAgICV4e1xyXG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IERhdGUoc2VsZi5nZXRUaW1lKCkpO1xyXG4gICAgICByZXN1bHQudGltZXpvbmUgPSAwO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZ210aW1lXHJcbiAgICAleHtcclxuICAgICAgaWYgKHNlbGYudGltZXpvbmUgIT09IDApIHtcclxuICAgICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xyXG4gICAgICAgIHNlbGYudGltZXpvbmUgPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgZ210P1xyXG4gICAgYHNlbGYudGltZXpvbmUgPT09IDBgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBnbXRfb2Zmc2V0XHJcbiAgICBgKHNlbGYudGltZXpvbmUgIT0gbnVsbCkgPyBzZWxmLnRpbWV6b25lICogNjAgOiAtc2VsZi5nZXRUaW1lem9uZU9mZnNldCgpICogNjBgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzdHJmdGltZShmb3JtYXQpXHJcbiAgICAleHtcclxuICAgICAgcmV0dXJuIGZvcm1hdC5yZXBsYWNlKC8lKFtcXC1fI14wXSo6ezAsMn0pKFxcZCspPyhbRU9dKikoLikvZywgZnVuY3Rpb24oZnVsbCwgZmxhZ3MsIHdpZHRoLCBfLCBjb252KSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCIsIGpkLCBjLCBzLFxyXG4gICAgICAgICAgICB6ZXJvICAgPSBmbGFncy5pbmRleE9mKCcwJykgIT09IC0xLFxyXG4gICAgICAgICAgICBwYWQgICAgPSBmbGFncy5pbmRleE9mKCctJykgPT09IC0xLFxyXG4gICAgICAgICAgICBibGFuayAgPSBmbGFncy5pbmRleE9mKCdfJykgIT09IC0xLFxyXG4gICAgICAgICAgICB1cGNhc2UgPSBmbGFncy5pbmRleE9mKCdeJykgIT09IC0xLFxyXG4gICAgICAgICAgICBpbnZlcnQgPSBmbGFncy5pbmRleE9mKCcjJykgIT09IC0xLFxyXG4gICAgICAgICAgICBjb2xvbnMgPSAoZmxhZ3MubWF0Y2goJzonKSB8fCBbXSkubGVuZ3RoO1xyXG5cclxuICAgICAgICB3aWR0aCA9IHBhcnNlSW50KHdpZHRoLCAxMCk7XHJcblxyXG4gICAgICAgIGlmICh6ZXJvICYmIGJsYW5rKSB7XHJcbiAgICAgICAgICBpZiAoZmxhZ3MuaW5kZXhPZignMCcpIDwgZmxhZ3MuaW5kZXhPZignXycpKSB7XHJcbiAgICAgICAgICAgIHplcm8gPSBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBibGFuayA9IGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3dpdGNoIChjb252KSB7XHJcbiAgICAgICAgICBjYXNlICdZJzpcclxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7eWVhcn07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ0MnOlxyXG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gTWF0aC5yb3VuZCgje3llYXJ9IC8gMTAwKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAneSc6XHJcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3t5ZWFyfSAlIDEwMCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ20nOlxyXG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gI3ttb259O1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlICdCJzpcclxuICAgICAgICAgICAgcmVzdWx0ICs9IGxvbmdfbW9udGhzWyN7bW9ufSAtIDFdO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlICdiJzpcclxuICAgICAgICAgIGNhc2UgJ2gnOlxyXG4gICAgICAgICAgICBibGFuayAgID0gIXplcm87XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBzaG9ydF9tb250aHNbI3ttb259IC0gMV07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ2QnOlxyXG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rXHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAje2RheX07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ2UnOlxyXG4gICAgICAgICAgICBibGFuayAgID0gIXplcm9cclxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7ZGF5fTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAnaic6XHJcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XHJcbiAgICAgICAgICAgIHdpZHRoICAgPSBpc05hTih3aWR0aCkgPyAzIDogd2lkdGg7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3lkYXl9O1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlICdIJzpcclxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcclxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7aG91cn07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ2snOlxyXG4gICAgICAgICAgICBibGFuayAgID0gIXplcm87XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAje2hvdXJ9O1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlICdJJzpcclxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcclxuICAgICAgICAgICAgcmVzdWx0ICs9ICgje2hvdXJ9ICUgMTIgfHwgMTIpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlICdsJzpcclxuICAgICAgICAgICAgYmxhbmsgICA9ICF6ZXJvO1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gKCN7aG91cn0gJSAxMiB8fCAxMik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ1AnOlxyXG4gICAgICAgICAgICByZXN1bHQgKz0gKCN7aG91cn0gPj0gMTIgPyBcInBtXCIgOiBcImFtXCIpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlICdwJzpcclxuICAgICAgICAgICAgcmVzdWx0ICs9ICgje2hvdXJ9ID49IDEyID8gXCJQTVwiIDogXCJBTVwiKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAnTSc6XHJcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAje21pbn07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ1MnOlxyXG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzZWN9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ0wnOlxyXG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xyXG4gICAgICAgICAgICB3aWR0aCAgID0gaXNOYU4od2lkdGgpID8gMyA6IHdpZHRoO1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gc2VsZi5nZXRNaWxsaXNlY29uZHMoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAnTic6XHJcbiAgICAgICAgICAgIHdpZHRoICAgPSBpc05hTih3aWR0aCkgPyA5IDogd2lkdGg7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAje2BzZWxmLmdldE1pbGxpc2Vjb25kcygpLnRvU3RyaW5nKClgLnJqdXN0KDMsICcwJyl9O1xyXG4gICAgICAgICAgICByZXN1bHQgID0gI3tgcmVzdWx0YC5sanVzdChgd2lkdGhgLCAnMCcpfTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAneic6XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgID0gKHNlbGYudGltZXpvbmUgPT0gbnVsbCkgPyBzZWxmLmdldFRpbWV6b25lT2Zmc2V0KCkgOiAoLXNlbGYudGltZXpvbmUgKiA2MCksXHJcbiAgICAgICAgICAgICAgICBob3VycyAgID0gTWF0aC5mbG9vcihNYXRoLmFicyhvZmZzZXQpIC8gNjApLFxyXG4gICAgICAgICAgICAgICAgbWludXRlcyA9IE1hdGguYWJzKG9mZnNldCkgJSA2MDtcclxuXHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBvZmZzZXQgPCAwID8gXCIrXCIgOiBcIi1cIjtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IGhvdXJzIDwgMTAgPyBcIjBcIiA6IFwiXCI7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBob3VycztcclxuXHJcbiAgICAgICAgICAgIGlmIChjb2xvbnMgPiAwKSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiOlwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXN1bHQgKz0gbWludXRlcyA8IDEwID8gXCIwXCIgOiBcIlwiO1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gbWludXRlcztcclxuXHJcbiAgICAgICAgICAgIGlmIChjb2xvbnMgPiAxKSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiOjAwXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ1onOlxyXG4gICAgICAgICAgICByZXN1bHQgKz0gI3t6b25lfTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAnQSc6XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBkYXlzX29mX3dlZWtbI3t3ZGF5fV07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ2EnOlxyXG4gICAgICAgICAgICByZXN1bHQgKz0gc2hvcnRfZGF5c1sje3dkYXl9XTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAndSc6XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3t3ZGF5fSArIDEpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlICd3JzpcclxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7d2RheX07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ1YnOlxyXG4gICAgICAgICAgICByZXN1bHQgKz0gI3tjd2Vla19jeWVhclswXS50b19zLnJqdXN0KDIsICcwJyl9O1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlICdHJzpcclxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7Y3dlZWtfY3llYXJbMV19O1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlICdnJzpcclxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7Y3dlZWtfY3llYXJbMV1bLTIuLi0xXX07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ3MnOlxyXG4gICAgICAgICAgICByZXN1bHQgKz0gI3t0b19pfTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAnbic6XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcblwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlICd0JzpcclxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFx0XCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJyUnOlxyXG4gICAgICAgICAgICByZXN1bHQgKz0gXCIlXCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ2MnOlxyXG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJWEgJWIgJWUgJVQgJVknKX07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ0QnOlxyXG4gICAgICAgICAgY2FzZSAneCc6XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclbS8lZC8leScpfTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAnRic6XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclWS0lbS0lZCcpfTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAndic6XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclZS0lXmItJTRZJyl9O1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlICdyJzpcclxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVJOiVNOiVTICVwJyl9O1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlICdSJzpcclxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVIOiVNJyl9O1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlICdUJzpcclxuICAgICAgICAgIGNhc2UgJ1gnOlxyXG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJUg6JU06JVMnKX07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIC8vIE5vbi1zdGFuZGFyZDogSklTIFggMDMwMSBkYXRlIGZvcm1hdFxyXG4gICAgICAgICAgY2FzZSAnSic6XHJcbiAgICAgICAgICAgIGpkID0gI3t0b19kYXRlLmpkfTtcclxuICAgICAgICAgICAgaWYgKGpkIDwgMjQwNTE2MCkge1xyXG4gICAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclWS0lbS0lZCcpfTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChqZCA8IDI0MTk2MTQpXHJcbiAgICAgICAgICAgICAgYyA9ICdNJywgcyA9IDE4Njc7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGpkIDwgMjQyNDg3NSlcclxuICAgICAgICAgICAgICBjID0gJ1QnLCBzID0gMTkxMTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoamQgPCAyNDQ3NTM1KVxyXG4gICAgICAgICAgICAgIGMgPSAnUycsIHMgPSAxOTI1O1xyXG4gICAgICAgICAgICBlbHNlIGlmIChqZCA8IDI0NTg2MDUpXHJcbiAgICAgICAgICAgICAgYyA9ICdIJywgcyA9IDE5ODg7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICBjID0gJ1InLCBzID0gMjAxODtcclxuXHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAje2Zvcm1hdCAnJWMlMDJkJywgYGNgLCB5ZWFyIC0gYHNgfTtcclxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJy0lbS0lZCcpfTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodXBjYXNlKSB7XHJcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQudG9VcHBlckNhc2UoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpbnZlcnQpIHtcclxuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC9bQS1aXS8sIGZ1bmN0aW9uKGMpIHsgYy50b0xvd2VyQ2FzZSgpIH0pLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2UoL1thLXpdLywgZnVuY3Rpb24oYykgeyBjLnRvVXBwZXJDYXNlKCkgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocGFkICYmICh6ZXJvIHx8IGJsYW5rKSkge1xyXG4gICAgICAgICAgcmVzdWx0ID0gI3tgcmVzdWx0YC5yanVzdChgaXNOYU4od2lkdGgpID8gMiA6IHdpZHRoYCwgYGJsYW5rID8gXCIgXCIgOiBcIjBcImApfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgdG9fYVxyXG4gICAgW3NlYywgbWluLCBob3VyLCBkYXksIG1vbnRoLCB5ZWFyLCB3ZGF5LCB5ZGF5LCBpc2RzdCwgem9uZV1cclxuICBlbmRcclxuXHJcbiAgZGVmIHRvX2ZcclxuICAgIGBzZWxmLmdldFRpbWUoKSAvIDEwMDBgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiB0b19pXHJcbiAgICBgcGFyc2VJbnQoc2VsZi5nZXRUaW1lKCkgLyAxMDAwLCAxMClgXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBjd2Vla19jeWVhclxyXG4gICAgamFuMDEgPSA6OlRpbWUubmV3KHllYXIsIDEsIDEpXHJcbiAgICBqYW4wMV93ZGF5ID0gamFuMDEud2RheVxyXG4gICAgZmlyc3RfbW9uZGF5ID0gMFxyXG4gICAgeWVhciA9IHNlbGYueWVhclxyXG4gICAgaWYgamFuMDFfd2RheSA8PSA0ICYmIGphbjAxX3dkYXkgIT0gMFxyXG4gICAgICAjIEphbiAwMSBpcyBpbiB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhclxyXG4gICAgICBvZmZzZXQgPSBqYW4wMV93ZGF5IC0gMVxyXG4gICAgZWxzZVxyXG4gICAgICAjIEphbiAwMSBpcyBpbiB0aGUgbGFzdCB3ZWVrIG9mIHRoZSBwcmV2aW91cyB5ZWFyXHJcbiAgICAgIG9mZnNldCA9IGphbjAxX3dkYXkgLSA3IC0gMVxyXG4gICAgICBvZmZzZXQgPSAtMSBpZiBvZmZzZXQgPT0gLTggIyBBZGp1c3QgaWYgSmFuIDAxIGlzIGEgU3VuZGF5XHJcbiAgICBlbmRcclxuXHJcbiAgICB3ZWVrID0gKCh5ZGF5ICsgb2Zmc2V0KSAvIDcuMDApLmNlaWxcclxuXHJcbiAgICBpZiB3ZWVrIDw9IDBcclxuICAgICAgIyBHZXQgdGhlIGxhc3Qgd2VlayBvZiB0aGUgcHJldmlvdXMgeWVhclxyXG4gICAgICByZXR1cm4gOjpUaW1lLm5ldyhzZWxmLnllYXIgLSAxLCAxMiwgMzEpLmN3ZWVrX2N5ZWFyXHJcbiAgICBlbHNpZiB3ZWVrID09IDUzXHJcbiAgICAgICMgRmluZCBvdXQgd2hldGhlciB0aGlzIGlzIGFjdHVhbGx5IHdlZWsgNTMgb3IgYWxyZWFkeSB3ZWVrIDAxIG9mIHRoZSBmb2xsb3dpbmcgeWVhclxyXG4gICAgICBkZWMzMSA9IDo6VGltZS5uZXcoc2VsZi55ZWFyLCAxMiwgMzEpXHJcbiAgICAgIGRlYzMxX3dkYXkgPSBkZWMzMS53ZGF5XHJcbiAgICAgIGlmIGRlYzMxX3dkYXkgPD0gMyAmJiBkZWMzMV93ZGF5ICE9IDBcclxuICAgICAgICB3ZWVrID0gMVxyXG4gICAgICAgIHllYXIgKz0gMVxyXG4gICAgICBlbmRcclxuICAgIGVuZFxyXG5cclxuICAgIFt3ZWVrLCB5ZWFyXVxyXG4gIGVuZFxyXG5cclxuICBjbGFzcyA8PCBzZWxmXHJcbiAgICBhbGlhcyBta3RpbWUgbG9jYWxcclxuICAgIGFsaWFzIHV0YyBnbVxyXG4gIGVuZFxyXG5cclxuICBhbGlhcyBjdGltZSBhc2N0aW1lXHJcbiAgYWxpYXMgZHN0PyBpc2RzdFxyXG4gIGFsaWFzIGdldHV0YyBnZXRnbVxyXG4gIGFsaWFzIGdtdG9mZiBnbXRfb2Zmc2V0XHJcbiAgYWxpYXMgbWRheSBkYXlcclxuICBhbGlhcyBtb250aCBtb25cclxuICBhbGlhcyB0b19zIGluc3BlY3RcclxuICBhbGlhcyB0dl9zZWMgdG9faVxyXG4gIGFsaWFzIHR2X3VzZWMgdXNlY1xyXG4gIGFsaWFzIHV0YyBnbXRpbWVcclxuICBhbGlhcyB1dGM/IGdtdD9cclxuICBhbGlhcyB1dGNfb2Zmc2V0IGdtdF9vZmZzZXRcclxuZW5kXHJcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6VGltZT4iLCJpbmNsdWRlIiwiQ29tcGFyYWJsZSIsImF0Iiwic2Vjb25kcyIsImZyYWMiLCJUaW1lIiwiPT09IiwiS2VybmVsIiwicmFpc2UiLCJUeXBlRXJyb3IiLCJPcGFsIiwiY29lcmNlX3RvISIsIkludGVnZXIiLCJyZXNwb25kX3RvPyIsInRvX3N0ciIsInRvX2kiLCJBcmd1bWVudEVycm9yIiwibmV3IiwieWVhciIsIm1vbnRoIiwiZGF5IiwiaG91ciIsIm1pbiIsInNlYyIsInV0Y19vZmZzZXQiLCJfcGFyc2Vfb2Zmc2V0IiwibG9jYWwiLCJtaWxsaXNlY29uZCIsIl9kdW1teTEiLCJfZHVtbXkyIiwiX2R1bW15MyIsImdtIiwibm93IiwiKyIsIm90aGVyIiwiLSIsIjw9PiIsInRvX2YiLCJyIiwibmlsPyIsIj4iLCIwIiwiLTEiLCI8IiwiMSIsIj09IiwiJHJldF9vcl8xIiwiYXNjdGltZSIsInN0cmZ0aW1lIiwiZWFjaCIsImJsb2NrIGluIDxjbGFzczpUaW1lPiIsIm1ldGhvZCIsImdldHRlciIsInV0Y2dldHRlciIsImRpZmZlcmVuY2UiLCJibG9jayAoMiBsZXZlbHMpIGluIDxjbGFzczpUaW1lPiIsImRlZmluZV9tZXRob2QiLCJibG9jayAoMyBsZXZlbHMpIGluIDxjbGFzczpUaW1lPiIsInlkYXkiLCJzdGFydF9vZl95ZWFyIiwic3RhcnRfb2ZfZGF5Iiwib25lX2RheSIsIjg2NDAwIiwiLyIsInJvdW5kIiwiaXNkc3QiLCJkdXAiLCJjb3B5IiwiY29weV9pbnN0YW5jZV92YXJpYWJsZXMiLCJpbml0aWFsaXplX2R1cCIsImVxbD8iLCJpc19hPyIsInplcm8/IiwiMiIsIjMiLCI0IiwiNSIsIjYiLCJ3ZWVrZGF5Iiwid2RheSIsImhhc2giLCJpbnNwZWN0IiwidXRjPyIsInN1Y2MiLCJ1c2VjIiwiem9uZSIsImdldGdtIiwiZ210aW1lIiwiZ210PyIsImdtdF9vZmZzZXQiLCJmb3JtYXQiLCJtb24iLCJyanVzdCIsImxqdXN0IiwiY3dlZWtfY3llYXIiLCJbXSIsInRvX3MiLCItMiIsInRvX2RhdGUiLCJqZCIsInRvX2EiLCJqYW4wMSIsImphbjAxX3dkYXkiLCJmaXJzdF9tb25kYXkiLCI8PSIsIm9mZnNldCIsIjciLCItOCIsIndlZWsiLCJjZWlsIiwiMTIiLCIzMSIsIjUzIiwiZGVjMzEiLCJkZWMzMV93ZGF5Il0sIm1hcHBpbmdzIjoiQUFBQUEsK0JBQUFBLGdCQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7O0VBSUFDLElBQUFDLFNBQUFBLENBQVFGLG9CQUFSRTtFQUVBRixPQUFBRztF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aUIsWUFBakI7RUE3d0JGQSxHQUFNLElBQU5BLEVBQWdCSCxJQUFoQkc7QUFOQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0MjU5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9zdHJ1Y3QucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXHJcblxyXG5yZXF1aXJlICdjb3JlbGliL2VudW1lcmFibGUnXHJcblxyXG5jbGFzcyA6OlN0cnVjdFxyXG4gIGluY2x1ZGUgOjpFbnVtZXJhYmxlXHJcblxyXG4gIGRlZiBzZWxmLm5ldyhjb25zdF9uYW1lLCAqYXJncywga2V5d29yZF9pbml0OiBmYWxzZSwgJmJsb2NrKVxyXG4gICAgaWYgY29uc3RfbmFtZVxyXG4gICAgICBpZiBjb25zdF9uYW1lLmNsYXNzID09IDo6U3RyaW5nICYmIGNvbnN0X25hbWVbMF0udXBjYXNlICE9IGNvbnN0X25hbWVbMF1cclxuICAgICAgICAjIEZhc3QgdHJhY2sgc28gdGhhdCB3ZSBza2lwIG5lZWRsZXNzbHkgZ29pbmcgdGhydSBleGNlcHRpb25zXHJcbiAgICAgICAgIyBpbiBtb3N0IGNhc2VzLlxyXG4gICAgICAgIGFyZ3MudW5zaGlmdChjb25zdF9uYW1lKVxyXG4gICAgICAgIGNvbnN0X25hbWUgPSBuaWxcclxuICAgICAgZWxzZVxyXG4gICAgICAgIGJlZ2luXHJcbiAgICAgICAgICBjb25zdF9uYW1lID0gOjpPcGFsLmNvbnN0X25hbWUhKGNvbnN0X25hbWUpXHJcbiAgICAgICAgcmVzY3VlIDo6VHlwZUVycm9yLCA6Ok5hbWVFcnJvclxyXG4gICAgICAgICAgYXJncy51bnNoaWZ0KGNvbnN0X25hbWUpXHJcbiAgICAgICAgICBjb25zdF9uYW1lID0gbmlsXHJcbiAgICAgICAgZW5kXHJcbiAgICAgIGVuZFxyXG4gICAgZW5kXHJcblxyXG4gICAgYXJncy5tYXAgZG8gfGFyZ3xcclxuICAgICAgOjpPcGFsLmNvZXJjZV90byEoYXJnLCA6OlN0cmluZywgOnRvX3N0cilcclxuICAgIGVuZFxyXG5cclxuICAgIGtsYXNzID0gOjpDbGFzcy5uZXcoc2VsZikgZG9cclxuICAgICAgYXJncy5lYWNoIHsgfGFyZ3wgZGVmaW5lX3N0cnVjdF9hdHRyaWJ1dGUoYXJnKSB9XHJcblxyXG4gICAgICBjbGFzcyA8PCBzZWxmXHJcbiAgICAgICAgZGVmIG5ldygqYXJncylcclxuICAgICAgICAgIGluc3RhbmNlID0gYWxsb2NhdGVcclxuICAgICAgICAgIGAje2luc3RhbmNlfS4kJGRhdGEgPSB7fWBcclxuICAgICAgICAgIGluc3RhbmNlLmluaXRpYWxpemUoKmFyZ3MpXHJcbiAgICAgICAgICBpbnN0YW5jZVxyXG4gICAgICAgIGVuZFxyXG5cclxuICAgICAgICBhbGlhc19tZXRob2QgOltdLCA6bmV3XHJcbiAgICAgIGVuZFxyXG4gICAgZW5kXHJcblxyXG4gICAga2xhc3MubW9kdWxlX2V2YWwoJmJsb2NrKSBpZiBibG9ja1xyXG4gICAgYGtsYXNzLiQka2V5d29yZF9pbml0ID0ga2V5d29yZF9pbml0YFxyXG5cclxuICAgIGlmIGNvbnN0X25hbWVcclxuICAgICAgOjpTdHJ1Y3QuY29uc3Rfc2V0KGNvbnN0X25hbWUsIGtsYXNzKVxyXG4gICAgZW5kXHJcblxyXG4gICAga2xhc3NcclxuICBlbmRcclxuXHJcbiAgZGVmIHNlbGYuZGVmaW5lX3N0cnVjdF9hdHRyaWJ1dGUobmFtZSlcclxuICAgIGlmIHNlbGYgPT0gOjpTdHJ1Y3RcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAneW91IGNhbm5vdCBkZWZpbmUgYXR0cmlidXRlcyB0byB0aGUgU3RydWN0IGNsYXNzJ1xyXG4gICAgZW5kXHJcblxyXG4gICAgbWVtYmVycyA8PCBuYW1lXHJcblxyXG4gICAgZGVmaW5lX21ldGhvZCBuYW1lIGRvXHJcbiAgICAgIGBzZWxmLiQkZGF0YVtuYW1lXWBcclxuICAgIGVuZFxyXG5cclxuICAgIGRlZmluZV9tZXRob2QgXCIje25hbWV9PVwiIGRvIHx2YWx1ZXxcclxuICAgICAgYHNlbGYuJCRkYXRhW25hbWVdID0gdmFsdWVgXHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmIHNlbGYubWVtYmVyc1xyXG4gICAgaWYgc2VsZiA9PSA6OlN0cnVjdFxyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0aGUgU3RydWN0IGNsYXNzIGhhcyBubyBtZW1iZXJzJ1xyXG4gICAgZW5kXHJcblxyXG4gICAgQG1lbWJlcnMgfHw9IFtdXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzZWxmLmluaGVyaXRlZChrbGFzcylcclxuICAgIG1lbWJlcnMgPSBAbWVtYmVyc1xyXG5cclxuICAgIGtsYXNzLmluc3RhbmNlX2V2YWwgZG9cclxuICAgICAgQG1lbWJlcnMgPSBtZW1iZXJzXHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmIGluaXRpYWxpemUoKmFyZ3MpXHJcbiAgICBpZiBgI3tzZWxmLmNsYXNzfS4kJGtleXdvcmRfaW5pdGBcclxuICAgICAga3dhcmdzID0gYXJncy5sYXN0IHx8IHt9XHJcblxyXG4gICAgICBpZiBhcmdzLmxlbmd0aCA+IDEgfHwgYChhcmdzLmxlbmd0aCA9PT0gMSAmJiAha3dhcmdzLiQkaXNfaGFzaClgXHJcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKGdpdmVuICN7YXJncy5sZW5ndGh9LCBleHBlY3RlZCAwKVwiXHJcbiAgICAgIGVuZFxyXG5cclxuICAgICAgZXh0cmEgPSBrd2FyZ3Mua2V5cyAtIHNlbGYuY2xhc3MubWVtYmVyc1xyXG4gICAgICBpZiBleHRyYS5hbnk/XHJcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcInVua25vd24ga2V5d29yZHM6ICN7ZXh0cmEuam9pbignLCAnKX1cIlxyXG4gICAgICBlbmRcclxuXHJcbiAgICAgIHNlbGYuY2xhc3MubWVtYmVycy5lYWNoIGRvIHxuYW1lfFxyXG4gICAgICAgIHNlbGZbbmFtZV0gPSBrd2FyZ3NbbmFtZV1cclxuICAgICAgZW5kXHJcbiAgICBlbHNlXHJcbiAgICAgIGlmIGFyZ3MubGVuZ3RoID4gc2VsZi5jbGFzcy5tZW1iZXJzLmxlbmd0aFxyXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3N0cnVjdCBzaXplIGRpZmZlcnMnXHJcbiAgICAgIGVuZFxyXG5cclxuICAgICAgc2VsZi5jbGFzcy5tZW1iZXJzLmVhY2hfd2l0aF9pbmRleCBkbyB8bmFtZSwgaW5kZXh8XHJcbiAgICAgICAgc2VsZltuYW1lXSA9IGFyZ3NbaW5kZXhdXHJcbiAgICAgIGVuZFxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBpbml0aWFsaXplX2NvcHkoZnJvbSlcclxuICAgICV4e1xyXG4gICAgICBzZWxmLiQkZGF0YSA9IHt9XHJcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJvbS4kJGRhdGEpLCBpLCBtYXgsIG5hbWU7XHJcbiAgICAgIGZvciAoaSA9IDAsIG1heCA9IGtleXMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcclxuICAgICAgICBuYW1lID0ga2V5c1tpXTtcclxuICAgICAgICBzZWxmLiQkZGF0YVtuYW1lXSA9IGZyb20uJCRkYXRhW25hbWVdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzZWxmLmtleXdvcmRfaW5pdD9cclxuICAgIGBzZWxmLiQka2V5d29yZF9pbml0YFxyXG4gIGVuZFxyXG5cclxuICBkZWYgbWVtYmVyc1xyXG4gICAgc2VsZi5jbGFzcy5tZW1iZXJzXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBoYXNoXHJcbiAgICBbc2VsZi5jbGFzcywgdG9fYV0uaGFzaFxyXG4gIGVuZFxyXG5cclxuICBkZWYgW10obmFtZSlcclxuICAgIGlmIDo6SW50ZWdlciA9PT0gbmFtZVxyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkluZGV4RXJyb3IsIFwib2Zmc2V0ICN7bmFtZX0gdG9vIHNtYWxsIGZvciBzdHJ1Y3Qoc2l6ZToje3NlbGYuY2xhc3MubWVtYmVycy5zaXplfSlcIiBpZiBuYW1lIDwgLXNlbGYuY2xhc3MubWVtYmVycy5zaXplXHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCJvZmZzZXQgI3tuYW1lfSB0b28gbGFyZ2UgZm9yIHN0cnVjdChzaXplOiN7c2VsZi5jbGFzcy5tZW1iZXJzLnNpemV9KVwiIGlmIG5hbWUgPj0gc2VsZi5jbGFzcy5tZW1iZXJzLnNpemVcclxuXHJcbiAgICAgIG5hbWUgPSBzZWxmLmNsYXNzLm1lbWJlcnNbbmFtZV1cclxuICAgIGVsc2lmIDo6U3RyaW5nID09PSBuYW1lXHJcbiAgICAgICV4e1xyXG4gICAgICAgIGlmKCFzZWxmLiQkZGF0YS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvci5uZXcoXCJubyBtZW1iZXIgJyN7bmFtZX0nIGluIHN0cnVjdFwiLCBuYW1lKX1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIGVsc2VcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwibm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiAje25hbWUuY2xhc3N9IGludG8gSW50ZWdlclwiXHJcbiAgICBlbmRcclxuXHJcbiAgICBuYW1lID0gOjpPcGFsLmNvZXJjZV90byEobmFtZSwgOjpTdHJpbmcsIDp0b19zdHIpXHJcbiAgICBgc2VsZi4kJGRhdGFbbmFtZV1gXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBbXT0obmFtZSwgdmFsdWUpXHJcbiAgICBpZiA6OkludGVnZXIgPT09IG5hbWVcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpJbmRleEVycm9yLCBcIm9mZnNldCAje25hbWV9IHRvbyBzbWFsbCBmb3Igc3RydWN0KHNpemU6I3tzZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZX0pXCIgaWYgbmFtZSA8IC1zZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZVxyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkluZGV4RXJyb3IsIFwib2Zmc2V0ICN7bmFtZX0gdG9vIGxhcmdlIGZvciBzdHJ1Y3Qoc2l6ZToje3NlbGYuY2xhc3MubWVtYmVycy5zaXplfSlcIiBpZiBuYW1lID49IHNlbGYuY2xhc3MubWVtYmVycy5zaXplXHJcblxyXG4gICAgICBuYW1lID0gc2VsZi5jbGFzcy5tZW1iZXJzW25hbWVdXHJcbiAgICBlbHNpZiA6OlN0cmluZyA9PT0gbmFtZVxyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvci5uZXcoXCJubyBtZW1iZXIgJyN7bmFtZX0nIGluIHN0cnVjdFwiLCBuYW1lKSB1bmxlc3Mgc2VsZi5jbGFzcy5tZW1iZXJzLmluY2x1ZGU/KG5hbWUudG9fc3ltKVxyXG4gICAgZWxzZVxyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJubyBpbXBsaWNpdCBjb252ZXJzaW9uIG9mICN7bmFtZS5jbGFzc30gaW50byBJbnRlZ2VyXCJcclxuICAgIGVuZFxyXG5cclxuICAgIG5hbWUgPSA6Ok9wYWwuY29lcmNlX3RvIShuYW1lLCA6OlN0cmluZywgOnRvX3N0cilcclxuICAgIGBzZWxmLiQkZGF0YVtuYW1lXSA9IHZhbHVlYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgPT0ob3RoZXIpXHJcbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIG90aGVyLmluc3RhbmNlX29mPyhzZWxmLmNsYXNzKVxyXG5cclxuICAgICV4e1xyXG4gICAgICB2YXIgcmVjdXJzZWQxID0ge30sIHJlY3Vyc2VkMiA9IHt9O1xyXG5cclxuICAgICAgZnVuY3Rpb24gX2VxZXEoc3RydWN0LCBvdGhlcikge1xyXG4gICAgICAgIHZhciBrZXksIGEsIGI7XHJcblxyXG4gICAgICAgIHJlY3Vyc2VkMVsje2BzdHJ1Y3RgLl9faWRfX31dID0gdHJ1ZTtcclxuICAgICAgICByZWN1cnNlZDJbI3tgb3RoZXJgLl9faWRfX31dID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgZm9yIChrZXkgaW4gc3RydWN0LiQkZGF0YSkge1xyXG4gICAgICAgICAgYSA9IHN0cnVjdC4kJGRhdGFba2V5XTtcclxuICAgICAgICAgIGIgPSBvdGhlci4kJGRhdGFba2V5XTtcclxuXHJcbiAgICAgICAgICBpZiAoI3s6OlN0cnVjdCA9PT0gYGFgfSkge1xyXG4gICAgICAgICAgICBpZiAoIXJlY3Vyc2VkMS5oYXNPd25Qcm9wZXJ0eSgje2BhYC5fX2lkX199KSB8fCAhcmVjdXJzZWQyLmhhc093blByb3BlcnR5KCN7YGJgLl9faWRfX30pKSB7XHJcbiAgICAgICAgICAgICAgaWYgKCFfZXFlcShhLCBiKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCEje2BhYCA9PSBgYmB9KSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIF9lcWVxKHNlbGYsIG90aGVyKTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGVxbD8ob3RoZXIpXHJcbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIG90aGVyLmluc3RhbmNlX29mPyhzZWxmLmNsYXNzKVxyXG5cclxuICAgICV4e1xyXG4gICAgICB2YXIgcmVjdXJzZWQxID0ge30sIHJlY3Vyc2VkMiA9IHt9O1xyXG5cclxuICAgICAgZnVuY3Rpb24gX2VxZXEoc3RydWN0LCBvdGhlcikge1xyXG4gICAgICAgIHZhciBrZXksIGEsIGI7XHJcblxyXG4gICAgICAgIHJlY3Vyc2VkMVsje2BzdHJ1Y3RgLl9faWRfX31dID0gdHJ1ZTtcclxuICAgICAgICByZWN1cnNlZDJbI3tgb3RoZXJgLl9faWRfX31dID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgZm9yIChrZXkgaW4gc3RydWN0LiQkZGF0YSkge1xyXG4gICAgICAgICAgYSA9IHN0cnVjdC4kJGRhdGFba2V5XTtcclxuICAgICAgICAgIGIgPSBvdGhlci4kJGRhdGFba2V5XTtcclxuXHJcbiAgICAgICAgICBpZiAoI3s6OlN0cnVjdCA9PT0gYGFgfSkge1xyXG4gICAgICAgICAgICBpZiAoIXJlY3Vyc2VkMS5oYXNPd25Qcm9wZXJ0eSgje2BhYC5fX2lkX199KSB8fCAhcmVjdXJzZWQyLmhhc093blByb3BlcnR5KCN7YGJgLl9faWRfX30pKSB7XHJcbiAgICAgICAgICAgICAgaWYgKCFfZXFlcShhLCBiKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCEje2BhYC5lcWw/KGBiYCl9KSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIF9lcWVxKHNlbGYsIG90aGVyKTtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGVhY2hcclxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG5cclxuICAgIHNlbGYuY2xhc3MubWVtYmVycy5lYWNoIHsgfG5hbWV8IHlpZWxkIHNlbGZbbmFtZV0gfVxyXG4gICAgc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgZWFjaF9wYWlyXHJcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfcGFpcikgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG5cclxuICAgIHNlbGYuY2xhc3MubWVtYmVycy5lYWNoIHsgfG5hbWV8IHlpZWxkIFtuYW1lLCBzZWxmW25hbWVdXSB9XHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBsZW5ndGhcclxuICAgIHNlbGYuY2xhc3MubWVtYmVycy5sZW5ndGhcclxuICBlbmRcclxuXHJcbiAgZGVmIHRvX2FcclxuICAgIHNlbGYuY2xhc3MubWVtYmVycy5tYXAgeyB8bmFtZXwgc2VsZltuYW1lXSB9XHJcbiAgZW5kXHJcblxyXG4gIGB2YXIgaW5zcGVjdF9zdGFjayA9IFtdYFxyXG5cclxuICBkZWYgaW5zcGVjdFxyXG4gICAgcmVzdWx0ID0gJyM8c3RydWN0ICdcclxuXHJcbiAgICBpZiBgaW5zcGVjdF9zdGFja2AuaW5jbHVkZT8gX19pZF9fXHJcbiAgICAgIHJlc3VsdCArICc6Li4uPidcclxuICAgIGVsc2VcclxuICAgICAgYGluc3BlY3Rfc3RhY2tgIDw8IF9faWRfX1xyXG4gICAgICBwdXNoZWQgPSB0cnVlXHJcblxyXG4gICAgICBpZiA6OlN0cnVjdCA9PT0gc2VsZiAmJiBzZWxmLmNsYXNzLm5hbWVcclxuICAgICAgICByZXN1bHQgKz0gXCIje3NlbGYuY2xhc3N9IFwiXHJcbiAgICAgIGVuZFxyXG5cclxuICAgICAgcmVzdWx0ICs9IGVhY2hfcGFpci5tYXAgZG8gfG5hbWUsIHZhbHVlfFxyXG4gICAgICAgIFwiI3tuYW1lfT0je09wYWwuaW5zcGVjdCh2YWx1ZSl9XCJcclxuICAgICAgZW5kLmpvaW4gJywgJ1xyXG5cclxuICAgICAgcmVzdWx0ICs9ICc+J1xyXG5cclxuICAgICAgcmVzdWx0XHJcbiAgICBlbmRcclxuICBlbnN1cmVcclxuICAgIGBpbnNwZWN0X3N0YWNrLnBvcCgpYCBpZiBwdXNoZWRcclxuICBlbmRcclxuXHJcbiAgZGVmIHRvX2goKmFyZ3MsICZibG9jaylcclxuICAgIHJldHVybiBtYXAoJmJsb2NrKS50b19oKCphcmdzKSBpZiBibG9ja19naXZlbj9cclxuXHJcbiAgICBzZWxmLmNsYXNzLm1lbWJlcnMuZWFjaF93aXRoX29iamVjdCh7fSkgeyB8bmFtZSwgaHwgaFtuYW1lXSA9IHNlbGZbbmFtZV0gfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgdmFsdWVzX2F0KCphcmdzKVxyXG4gICAgYXJncyA9IGFyZ3MubWFwIHsgfGFyZ3wgYGFyZy4kJGlzX3JhbmdlID8gI3thcmcudG9fYX0gOiBhcmdgIH0uZmxhdHRlblxyXG4gICAgJXh7XHJcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBpZiAoIWFyZ3NbaV0uJCRpc19udW1iZXIpIHtcclxuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwibm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiAje2BhcmdzW2ldYC5jbGFzc30gaW50byBJbnRlZ2VyXCJ9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC5wdXNoKCN7c2VsZltgYXJnc1tpXWBdfSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICBlbmRcclxuXHJcbiAgZGVmIGRpZyhrZXksICprZXlzKVxyXG4gICAgaXRlbSA9IGlmIGBrZXkuJCRpc19zdHJpbmcgJiYgc2VsZi4kJGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KWBcclxuICAgICAgICAgICAgIGBzZWxmLiQkZGF0YVtrZXldIHx8IG5pbGBcclxuICAgICAgICAgICBlbmRcclxuXHJcbiAgICAleHtcclxuICAgICAgaWYgKGl0ZW0gPT09IG5pbCB8fCBrZXlzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdW5sZXNzIGl0ZW0ucmVzcG9uZF90bz8oOmRpZylcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiI3tpdGVtLmNsYXNzfSBkb2VzIG5vdCBoYXZlICNkaWcgbWV0aG9kXCJcclxuICAgIGVuZFxyXG5cclxuICAgIGl0ZW0uZGlnKCprZXlzKVxyXG4gIGVuZFxyXG5cclxuICBhbGlhcyBzaXplIGxlbmd0aFxyXG4gIGFsaWFzIHRvX3MgaW5zcGVjdFxyXG4gIGFsaWFzIHZhbHVlcyB0b19hXHJcbmVuZFxyXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOlN0cnVjdD4iLCJpbmNsdWRlIiwiRW51bWVyYWJsZSIsIm5ldyIsImNvbnN0X25hbWUiLCJjbGFzcyIsIlN0cmluZyIsIltdIiwiMCIsInVwY2FzZSIsImFyZ3MiLCJ1bnNoaWZ0IiwiT3BhbCIsImNvbnN0X25hbWUhIiwiVHlwZUVycm9yIiwiTmFtZUVycm9yIiwibWFwIiwiYmxvY2sgaW4gbmV3IiwiYXJnIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBuZXciLCJjb2VyY2VfdG8hIiwia2xhc3MiLCJDbGFzcyIsImVhY2giLCJibG9jayAoMyBsZXZlbHMpIGluIG5ldyIsImRlZmluZV9zdHJ1Y3RfYXR0cmlidXRlIiwiaW5zdGFuY2UiLCJhbGxvY2F0ZSIsImluaXRpYWxpemUiLCJhbGlhc19tZXRob2QiLCJibG9jayIsIm1vZHVsZV9ldmFsIiwidG9fcHJvYyIsIlN0cnVjdCIsImNvbnN0X3NldCIsIm5hbWUiLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJtZW1iZXJzIiwiPDwiLCJkZWZpbmVfbWV0aG9kIiwiYmxvY2sgaW4gZGVmaW5lX3N0cnVjdF9hdHRyaWJ1dGUiLCJibG9jayAoMiBsZXZlbHMpIGluIGRlZmluZV9zdHJ1Y3RfYXR0cmlidXRlIiwidmFsdWUiLCJAbWVtYmVycyIsIiRyZXRfb3JfMSIsImluaGVyaXRlZCIsImluc3RhbmNlX2V2YWwiLCJibG9jayBpbiBpbmhlcml0ZWQiLCJibG9jayAoMiBsZXZlbHMpIGluIGluaGVyaXRlZCIsImt3YXJncyIsImxhc3QiLCI+IiwibGVuZ3RoIiwiMSIsImV4dHJhIiwiLSIsImtleXMiLCJhbnk/Iiwiam9pbiIsImJsb2NrIGluIGluaXRpYWxpemUiLCJibG9jayAoMiBsZXZlbHMpIGluIGluaXRpYWxpemUiLCJbXT0iLCJlYWNoX3dpdGhfaW5kZXgiLCJpbmRleCIsImluaXRpYWxpemVfY29weSIsImZyb20iLCJrZXl3b3JkX2luaXQ/IiwiaGFzaCIsInRvX2EiLCJJbnRlZ2VyIiwiPCIsInNpemUiLCItQCIsIkluZGV4RXJyb3IiLCI+PSIsImluY2x1ZGU/IiwidG9fc3ltIiwiPT0iLCJvdGhlciIsImluc3RhbmNlX29mPyIsIl9faWRfXyIsIj09PSIsImVxbD8iLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsImJsb2NrIGluIGVhY2giLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2giLCJlYWNoX3BhaXIiLCJibG9jayBpbiBlYWNoX3BhaXIiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfcGFpciIsImJsb2NrIGluIHRvX2EiLCJibG9jayAoMiBsZXZlbHMpIGluIHRvX2EiLCJpbnNwZWN0IiwicmVzdWx0IiwiKyIsInB1c2hlZCIsImJsb2NrIGluIGluc3BlY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIGluc3BlY3QiLCJ0b19oIiwiZWFjaF93aXRoX29iamVjdCIsImJsb2NrIGluIHRvX2giLCJoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0b19oIiwidmFsdWVzX2F0IiwiYmxvY2sgaW4gdmFsdWVzX2F0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB2YWx1ZXNfYXQiLCJmbGF0dGVuIiwiZGlnIiwia2V5IiwiaXRlbSIsInJlc3BvbmRfdG8/Il0sIm1hcHBpbmdzIjoiQUFBQUEsaUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBRUFDLElBQUFDLFNBQUFBLENBQVFGLG9CQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7OztJQUNFRixJQUFBRyxTQUFBQSxDQUFRQyxpQkFB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QUNBQSxVQUFZckUsT0FBUUMsT0FBQUEsQ0FBT3ZCLGdCQUFmLEVBQTZCMkYsNEJBQUQsR0FBQSxNQUE2QkEsQ0FBQ0EsT0FBREEsQ0FBU3BHLE9BQUFBLENBQUFBLENBQXRDLENBQUEsR0FBNkNvRyxlQUFqRXBFO0FBQ3BCb0U7QUFDQUEsb0JBQXNCM0csSUFBSVMsT0FBQUEsQ0FBRWtHLE9BQUZsRyxDQUFZa0c7QUFDdENBO0FBQ0FBO0FBQ0FBO0lBWEVBLENBQUFBLElBQUFBOztBQWNBSSxJQUFBQSxtQkFBQUEsZUFBUUMsR0FBRCxFQXhUVCxFQXdURUQ7QUFBQUEsTUFBQUE7OztNQXhURjtNQXdUZTtNQUNYRSxPQUFPLENBQUEsUUFBSUYsa0RBQUosQ0FBQSxHQUFBLENBQ0dBLHVCQURILElBQUEsR0FBQTs7QUFLWEE7QUFDQUE7QUFDQUE7QUFDQUE7TUFFSSxLQUFBLFFBQU9FLElBQUlDLGdCQUFBQSxDQUFhLEtBQWJBLENBQVgsQ0FBQTtRQUNFNUUsT0FBUUMsT0FBQUEsQ0FBT3ZCLGdCQUFmLEVBQTRCLE1BQUdpRyxJQUFJMUcsT0FBQUEsQ0FBQUEsQ0FBUCxDQUFBLEdBQWN3Ryw0QkFBbEN4RTtNQURWO01BSUF3RSxPQUFJQSxNQUFKRSxJQUFJRixPQUFBQSxFQUFLLE1BQUNuRCxJQUFELENBQUxtRDtJQWZOQSxDQUFBQSxJQUFBQTtJQWtCQSxhQUFNLE1BQU4sRUFBVyxRQUFYO0lBQ0EsYUFBTSxNQUFOLEVBQVcsU0FBWDtJQUNBN0csT0FBQSxhQUFNLFFBQU4sRUFBYSxNQUFiO0VBeFVGQSxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBSkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNDcyMCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvc2V0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogZnJlZXplXHJcbiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxyXG4jIHVzZV9zdHJpY3Q6IHRydWVcclxuXHJcbiMgUG9ydGlvbnMgQ29weXJpZ2h0IChjKSAyMDAyLTIwMTMgQWtpbm9yaSBNVVNIQSA8a251QGlEYWVtb25zLm9yZz5cclxuY2xhc3MgOjpTZXRcclxuICBpbmNsdWRlIDo6RW51bWVyYWJsZVxyXG5cclxuICBkZWYgc2VsZi5bXSgqYXJ5KVxyXG4gICAgbmV3KGFyeSlcclxuICBlbmRcclxuXHJcbiAgZGVmIGluaXRpYWxpemUoZW51bSA9IG5pbCwgJmJsb2NrKVxyXG4gICAgQGhhc2ggPSB7fVxyXG5cclxuICAgIHJldHVybiBpZiBlbnVtLm5pbD9cclxuICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3ZhbHVlIG11c3QgYmUgZW51bWVyYWJsZScgdW5sZXNzIDo6RW51bWVyYWJsZSA9PT0gZW51bVxyXG5cclxuICAgIGlmIGJsb2NrXHJcbiAgICAgIGVudW0uZWFjaCB7IHxpdGVtfCBhZGQgeWllbGQoaXRlbSkgfVxyXG4gICAgZWxzZVxyXG4gICAgICBtZXJnZShlbnVtKVxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBkdXBcclxuICAgIHJlc3VsdCA9IHNlbGYuY2xhc3MubmV3XHJcbiAgICByZXN1bHQubWVyZ2Uoc2VsZilcclxuICBlbmRcclxuXHJcbiAgZGVmIC0oZW51bSlcclxuICAgIHVubGVzcyBlbnVtLnJlc3BvbmRfdG8/IDplYWNoXHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3ZhbHVlIG11c3QgYmUgZW51bWVyYWJsZSdcclxuICAgIGVuZFxyXG5cclxuICAgIGR1cC5zdWJ0cmFjdChlbnVtKVxyXG4gIGVuZFxyXG5cclxuICBkZWYgaW5zcGVjdFxyXG4gICAgXCIjPFNldDogeyN7dG9fYS5qb2luKCcsJyl9fT5cIlxyXG4gIGVuZFxyXG5cclxuICBkZWYgPT0ob3RoZXIpXHJcbiAgICBpZiBlcXVhbD8ob3RoZXIpXHJcbiAgICAgIHRydWVcclxuICAgIGVsc2lmIG90aGVyLmluc3RhbmNlX29mPyhzZWxmLmNsYXNzKVxyXG4gICAgICBAaGFzaCA9PSBvdGhlci5pbnN0YW5jZV92YXJpYWJsZV9nZXQoOkBoYXNoKVxyXG4gICAgZWxzaWYgb3RoZXIuaXNfYT8oOjpTZXQpICYmIHNpemUgPT0gb3RoZXIuc2l6ZVxyXG4gICAgICBvdGhlci5hbGw/IHsgfG98IEBoYXNoLmluY2x1ZGU/KG8pIH1cclxuICAgIGVsc2VcclxuICAgICAgZmFsc2VcclxuICAgIGVuZFxyXG4gIGVuZFxyXG5cclxuICBkZWYgYWRkKG8pXHJcbiAgICBAaGFzaFtvXSA9IHRydWVcclxuICAgIHNlbGZcclxuICBlbmRcclxuXHJcbiAgZGVmIGNsYXNzaWZ5KCZibG9jaylcclxuICAgIHJldHVybiBlbnVtX2Zvcig6Y2xhc3NpZnkpIHVubGVzcyBibG9ja19naXZlbj9cclxuXHJcbiAgICByZXN1bHQgPSA6Okhhc2gubmV3IHsgfGgsIGt8IGhba10gPSBzZWxmLmNsYXNzLm5ldyB9XHJcblxyXG4gICAgZWFjaCB7IHxpdGVtfCByZXN1bHRbeWllbGQoaXRlbSldLmFkZCBpdGVtIH1cclxuXHJcbiAgICByZXN1bHRcclxuICBlbmRcclxuXHJcbiAgZGVmIGNvbGxlY3QhKCZibG9jaylcclxuICAgIHJldHVybiBlbnVtX2Zvcig6Y29sbGVjdCEpIHVubGVzcyBibG9ja19naXZlbj9cclxuICAgIHJlc3VsdCA9IHNlbGYuY2xhc3MubmV3XHJcbiAgICBlYWNoIHsgfGl0ZW18IHJlc3VsdCA8PCB5aWVsZChpdGVtKSB9XHJcbiAgICByZXBsYWNlIHJlc3VsdFxyXG4gIGVuZFxyXG5cclxuICBkZWYgY29tcGFyZV9ieV9pZGVudGl0eVxyXG4gICAgaWYgQGhhc2gucmVzcG9uZF90bz8oOmNvbXBhcmVfYnlfaWRlbnRpdHkpXHJcbiAgICAgIEBoYXNoLmNvbXBhcmVfYnlfaWRlbnRpdHlcclxuICAgICAgc2VsZlxyXG4gICAgZWxzZVxyXG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBcIiN7c2VsZi5jbGFzcy5uYW1lfVxcIyN7X19tZXRob2RfX30gaXMgbm90IGltcGxlbWVudGVkXCJcclxuICAgIGVuZFxyXG4gIGVuZFxyXG5cclxuICBkZWYgY29tcGFyZV9ieV9pZGVudGl0eT9cclxuICAgIEBoYXNoLnJlc3BvbmRfdG8/KDpjb21wYXJlX2J5X2lkZW50aXR5PykgJiYgQGhhc2guY29tcGFyZV9ieV9pZGVudGl0eT9cclxuICBlbmRcclxuXHJcbiAgZGVmIGRlbGV0ZShvKVxyXG4gICAgQGhhc2guZGVsZXRlKG8pXHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBkZWxldGU/KG8pXHJcbiAgICBpZiBpbmNsdWRlPyhvKVxyXG4gICAgICBkZWxldGUobylcclxuICAgICAgc2VsZlxyXG4gICAgZW5kXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBkZWxldGVfaWZcclxuICAgIHJldHVybiBlbnVtX2Zvcig6ZGVsZXRlX2lmKSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XHJcbiAgICAjIEBoYXNoLmRlbGV0ZV9pZiBzaG91bGQgYmUgZmFzdGVyLCBidXQgdXNpbmcgaXQgYnJlYWtzIHRoZSBvcmRlclxyXG4gICAgIyBvZiBlbnVtZXJhdGlvbiBpbiBzdWJjbGFzc2VzLlxyXG4gICAgc2VsZWN0IHsgfG98IHlpZWxkIG8gfS5lYWNoIHsgfG98IEBoYXNoLmRlbGV0ZShvKSB9XHJcbiAgICBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBmcmVlemVcclxuICAgIHJldHVybiBzZWxmIGlmIGZyb3plbj9cclxuXHJcbiAgICBAaGFzaC5mcmVlemVcclxuICAgIGAkZnJlZXplKHNlbGYpYFxyXG4gIGVuZFxyXG5cclxuICBkZWYga2VlcF9pZlxyXG4gICAgcmV0dXJuIGVudW1fZm9yKDprZWVwX2lmKSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XHJcbiAgICByZWplY3QgeyB8b3wgeWllbGQgbyB9LmVhY2ggeyB8b3wgQGhhc2guZGVsZXRlKG8pIH1cclxuICAgIHNlbGZcclxuICBlbmRcclxuXHJcbiAgZGVmIHJlamVjdCEoJmJsb2NrKVxyXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZWplY3QhKSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XHJcbiAgICBiZWZvcmUgPSBzaXplXHJcbiAgICBkZWxldGVfaWYoJmJsb2NrKVxyXG4gICAgc2l6ZSA9PSBiZWZvcmUgPyBuaWwgOiBzZWxmXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzZWxlY3QhKCZibG9jaylcclxuICAgIHJldHVybiBlbnVtX2Zvcig6c2VsZWN0ISkgdW5sZXNzIGJsb2NrX2dpdmVuP1xyXG4gICAgYmVmb3JlID0gc2l6ZVxyXG4gICAga2VlcF9pZigmYmxvY2spXHJcbiAgICBzaXplID09IGJlZm9yZSA/IG5pbCA6IHNlbGZcclxuICBlbmRcclxuXHJcbiAgZGVmIGFkZD8obylcclxuICAgIGlmIGluY2x1ZGU/KG8pXHJcbiAgICAgIG5pbFxyXG4gICAgZWxzZVxyXG4gICAgICBhZGQobylcclxuICAgIGVuZFxyXG4gIGVuZFxyXG5cclxuICBkZWYgZWFjaCgmYmxvY2spXHJcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2gpIHVubGVzcyBibG9ja19naXZlbj9cclxuICAgIEBoYXNoLmVhY2hfa2V5KCZibG9jaylcclxuICAgIHNlbGZcclxuICBlbmRcclxuXHJcbiAgZGVmIGVtcHR5P1xyXG4gICAgQGhhc2guZW1wdHk/XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBlcWw/KG90aGVyKVxyXG4gICAgQGhhc2guZXFsPyhvdGhlci5pbnN0YW5jZV9ldmFsIHsgQGhhc2ggfSlcclxuICBlbmRcclxuXHJcbiAgZGVmIGNsZWFyXHJcbiAgICBAaGFzaC5jbGVhclxyXG4gICAgc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgaW5jbHVkZT8obylcclxuICAgIEBoYXNoLmluY2x1ZGU/KG8pXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBtZXJnZShlbnVtKVxyXG4gICAgZW51bS5lYWNoIHsgfGl0ZW18IGFkZCBpdGVtIH1cclxuICAgIHNlbGZcclxuICBlbmRcclxuXHJcbiAgZGVmIHJlcGxhY2UoZW51bSlcclxuICAgIGNsZWFyXHJcbiAgICBtZXJnZShlbnVtKVxyXG5cclxuICAgIHNlbGZcclxuICBlbmRcclxuXHJcbiAgZGVmIHNpemVcclxuICAgIEBoYXNoLnNpemVcclxuICBlbmRcclxuXHJcbiAgZGVmIHN1YnRyYWN0KGVudW0pXHJcbiAgICBlbnVtLmVhY2ggeyB8aXRlbXwgZGVsZXRlIGl0ZW0gfVxyXG4gICAgc2VsZlxyXG4gIGVuZFxyXG5cclxuICBkZWYgfChlbnVtKVxyXG4gICAgdW5sZXNzIGVudW0ucmVzcG9uZF90bz8gOmVhY2hcclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAndmFsdWUgbXVzdCBiZSBlbnVtZXJhYmxlJ1xyXG4gICAgZW5kXHJcbiAgICBkdXAubWVyZ2UoZW51bSlcclxuICBlbmRcclxuXHJcbiAgJXh7XHJcbiAgICBmdW5jdGlvbiBpc19zZXQoc2V0KSB7XHJcbiAgICAgICN7YHNldGAuaXNfYT8oOjpTZXQpIHx8IDo6S2VybmVsLnJhaXNlKDo6QXJndW1lbnRFcnJvciwgJ3ZhbHVlIG11c3QgYmUgYSBzZXQnKX1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRlZiBzdXBlcnNldD8oc2V0KVxyXG4gICAgYGlzX3NldChzZXQpYFxyXG4gICAgcmV0dXJuIGZhbHNlIGlmIHNpemUgPCBzZXQuc2l6ZVxyXG4gICAgc2V0LmFsbD8geyB8b3wgaW5jbHVkZT8obykgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgcHJvcGVyX3N1cGVyc2V0PyhzZXQpXHJcbiAgICBgaXNfc2V0KHNldClgXHJcbiAgICByZXR1cm4gZmFsc2UgaWYgc2l6ZSA8PSBzZXQuc2l6ZVxyXG4gICAgc2V0LmFsbD8geyB8b3wgaW5jbHVkZT8obykgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc3Vic2V0PyhzZXQpXHJcbiAgICBgaXNfc2V0KHNldClgXHJcbiAgICByZXR1cm4gZmFsc2UgaWYgc2V0LnNpemUgPCBzaXplXHJcbiAgICBhbGw/IHsgfG98IHNldC5pbmNsdWRlPyhvKSB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBwcm9wZXJfc3Vic2V0PyhzZXQpXHJcbiAgICBgaXNfc2V0KHNldClgXHJcbiAgICByZXR1cm4gZmFsc2UgaWYgc2V0LnNpemUgPD0gc2l6ZVxyXG4gICAgYWxsPyB7IHxvfCBzZXQuaW5jbHVkZT8obykgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgaW50ZXJzZWN0PyhzZXQpXHJcbiAgICBgaXNfc2V0KHNldClgXHJcbiAgICBpZiBzaXplIDwgc2V0LnNpemVcclxuICAgICAgYW55PyB7IHxvfCBzZXQuaW5jbHVkZT8obykgfVxyXG4gICAgZWxzZVxyXG4gICAgICBzZXQuYW55PyB7IHxvfCBpbmNsdWRlPyhvKSB9XHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgZGVmIGRpc2pvaW50PyhzZXQpXHJcbiAgICAhaW50ZXJzZWN0PyhzZXQpXHJcbiAgZW5kXHJcblxyXG4gIGRlZiB0b19hXHJcbiAgICBAaGFzaC5rZXlzXHJcbiAgZW5kXHJcblxyXG4gIGFsaWFzICsgfFxyXG4gIGFsaWFzIDwgcHJvcGVyX3N1YnNldD9cclxuICBhbGlhcyA8PCBhZGRcclxuICBhbGlhcyA8PSBzdWJzZXQ/XHJcbiAgYWxpYXMgPiBwcm9wZXJfc3VwZXJzZXQ/XHJcbiAgYWxpYXMgPj0gc3VwZXJzZXQ/XHJcbiAgYWxpYXMgZGlmZmVyZW5jZSAtXHJcbiAgYWxpYXMgZmlsdGVyISBzZWxlY3QhXHJcbiAgYWxpYXMgbGVuZ3RoIHNpemVcclxuICBhbGlhcyBtYXAhIGNvbGxlY3QhXHJcbiAgYWxpYXMgbWVtYmVyPyBpbmNsdWRlP1xyXG4gIGFsaWFzIHVuaW9uIHxcclxuZW5kXHJcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlNldD4iLCJzZWxmIiwiaW5jbHVkZSIsIkVudW1lcmFibGUiLCJbXSIsIm5ldyIsImFyeSIsImluaXRpYWxpemUiLCJlbnVtJCIsIkBoYXNoIiwibmlsPyIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsImJsb2NrIiwiZWFjaCIsImJsb2NrIGluIGluaXRpYWxpemUiLCJpdGVtIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbml0aWFsaXplIiwiYWRkIiwibWVyZ2UiLCJkdXAiLCJyZXN1bHQiLCJjbGFzcyIsIi0iLCJyZXNwb25kX3RvPyIsInN1YnRyYWN0IiwiaW5zcGVjdCIsInRvX2EiLCJqb2luIiwiPT0iLCJvdGhlciIsImVxdWFsPyIsImluc3RhbmNlX29mPyIsImluc3RhbmNlX3ZhcmlhYmxlX2dldCIsImlzX2E/IiwiU2V0Iiwic2l6ZSIsImFsbD8iLCJibG9jayBpbiA9PSIsIm8iLCJibG9jayAoMiBsZXZlbHMpIGluID09IiwiaW5jbHVkZT8iLCJbXT0iLCJjbGFzc2lmeSIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwiSGFzaCIsImJsb2NrIGluIGNsYXNzaWZ5IiwiaCIsImsiLCJibG9jayAoMiBsZXZlbHMpIGluIGNsYXNzaWZ5IiwiY29sbGVjdCEiLCJibG9jayBpbiBjb2xsZWN0ISIsImJsb2NrICgyIGxldmVscykgaW4gY29sbGVjdCEiLCI8PCIsInJlcGxhY2UiLCJjb21wYXJlX2J5X2lkZW50aXR5IiwiTm90SW1wbGVtZW50ZWRFcnJvciIsIm5hbWUiLCJfX21ldGhvZF9fIiwiY29tcGFyZV9ieV9pZGVudGl0eT8iLCIkcmV0X29yXzEiLCJkZWxldGUiLCJkZWxldGU/IiwiZGVsZXRlX2lmIiwic2VsZWN0IiwiYmxvY2sgaW4gZGVsZXRlX2lmIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkZWxldGVfaWYiLCJmcmVlemUiLCJmcm96ZW4/Iiwia2VlcF9pZiIsInJlamVjdCIsImJsb2NrIGluIGtlZXBfaWYiLCJibG9jayAoMiBsZXZlbHMpIGluIGtlZXBfaWYiLCJyZWplY3QhIiwiYmVmb3JlIiwidG9fcHJvYyIsInNlbGVjdCEiLCJhZGQ/IiwiZWFjaF9rZXkiLCJlbXB0eT8iLCJlcWw/IiwiaW5zdGFuY2VfZXZhbCIsImJsb2NrIGluIGVxbD8iLCJibG9jayAoMiBsZXZlbHMpIGluIGVxbD8iLCJjbGVhciIsImJsb2NrIGluIG1lcmdlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBtZXJnZSIsImJsb2NrIGluIHN1YnRyYWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzdWJ0cmFjdCIsInwiLCJzdXBlcnNldD8iLCJzZXQiLCI8IiwiYmxvY2sgaW4gc3VwZXJzZXQ/IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzdXBlcnNldD8iLCJwcm9wZXJfc3VwZXJzZXQ/IiwiPD0iLCJibG9jayBpbiBwcm9wZXJfc3VwZXJzZXQ/IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwcm9wZXJfc3VwZXJzZXQ/Iiwic3Vic2V0PyIsImJsb2NrIGluIHN1YnNldD8iLCJibG9jayAoMiBsZXZlbHMpIGluIHN1YnNldD8iLCJwcm9wZXJfc3Vic2V0PyIsImJsb2NrIGluIHByb3Blcl9zdWJzZXQ/IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwcm9wZXJfc3Vic2V0PyIsImludGVyc2VjdD8iLCJhbnk/IiwiYmxvY2sgaW4gaW50ZXJzZWN0PyIsImJsb2NrICgyIGxldmVscykgaW4gaW50ZXJzZWN0PyIsImRpc2pvaW50PyIsIiEiLCJrZXlzIl0sIm1hcHBpbmdzIjoiQUFBQUEsOEJBQUFBLGdCQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7RUFLQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUMsaUJBQVJEO0lBRUFFLE1BQUlILElBQUpHLFNBQUFBLG1CQVJGLEVBUUVBO0FBQUFBLE1BQUFBOzs7TUFSRjtNQVFjO01BQ1ZBLE9BQUFILElBQUFJLEtBQUFBLENBQUlDLEdBQUpEO0lBREZELENBQUFBLElBQUFBOztBQUlBRyxJQUFBQSwwQkFBQUEsc0JBQWVDLEtBQWZEO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQWUsMkJBQU87TUFDcEJFLFlBQVE7TUFFUixJQUFBLFFBQVVELEtBQUlFLFNBQUFBLENBQUFBLENBQWQsQ0FBQTtRQUFBLE9BQUE7TUFBQTtNQUNBLEtBQUEsUUFB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ZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZGlyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxyXG5cclxuY2xhc3MgOjpEaXJcclxuICBjbGFzcyA8PCBzZWxmXHJcbiAgICBkZWYgY2hkaXIoZGlyKVxyXG4gICAgICBwcmV2X2N3ZCA9IGBPcGFsLmN1cnJlbnRfZGlyYFxyXG4gICAgICBgT3BhbC5jdXJyZW50X2RpciA9ICN7ZGlyfWBcclxuICAgICAgeWllbGRcclxuICAgIGVuc3VyZVxyXG4gICAgICBgT3BhbC5jdXJyZW50X2RpciA9ICN7cHJldl9jd2R9YFxyXG4gICAgZW5kXHJcblxyXG4gICAgZGVmIHB3ZFxyXG4gICAgICBgT3BhbC5jdXJyZW50X2RpciB8fCAnLidgXHJcbiAgICBlbmRcclxuXHJcbiAgICBkZWYgaG9tZVxyXG4gICAgICA6OkVOVlsnSE9NRSddIHx8ICcuJ1xyXG4gICAgZW5kXHJcblxyXG4gICAgYWxpYXMgZ2V0d2QgcHdkXHJcbiAgZW5kXHJcbmVuZFxyXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpEaXI+IiwiY2hkaXIiLCJkaXIiLCJwcmV2X2N3ZCIsInB3ZCIsImhvbWUiLCIkcmV0X29yXzEiLCJFTlYiLCJbXSIsInNlbGYiXSwibWFwcGluZ3MiOiJBQUFBQSw4QkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUVBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUE7Ozs7QUFDRUMsTUFBQUEscUJBQUFBLGlCQUFVQyxHQUFWRDtBQUFBQSxRQUFBQTs7UUFBQUE7UUFDRUEsT0FBQSxjQUFBOztRQUFBRSxXQUFZRjtRQUNYQSxtQkFBcUJDO1FBQ3RCLE9BQUEscUJBQUEsRUFBQTtRQUZBO1VBSUNELG1CQUFxQkU7UUFKdEIsQ0FBQTtNQURGRixDQUFBQTs7QUFRQUcsTUFBQUEsbUJBQUFBLGVBQUFBO0FBQUFBO1FBQ0VBLE9BQUNBLHVCQUFEQTtNQURGQSxDQUFBQTs7QUFJQUMsTUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxRQUFBQTs7UUFDRSxJQUFBLFFBQUFDLENBQUFBLFlBQUFDLFVBQUtDLE9BQUFBLENBQUNILE1BQURHLENBQUxGLENBQUEsQ0FBQTtVQUFBRCxPQUFBO1FBQUE7VUFBaUJBLE9BQUFBO1FBQWpCO01BREZBLENBQUFBO01BSUEsT0FBQSxhQUFNLE9BQU4sRUFBWSxLQUFaO0lBakJGLDRCQUFTSSxJQUFUO0VBREZULEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI1MjQxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9maWxlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHJ1dGh5XHJcbiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxyXG5cclxuY2xhc3MgOjpGaWxlIDwgOjpJT1xyXG4gIFNlcGFyYXRvciA9IFNFUEFSQVRPUiA9ICcvJ1xyXG4gIEFMVF9TRVBBUkFUT1IgPSBuaWxcclxuICBQQVRIX1NFUEFSQVRPUiA9ICc6J1xyXG4gICMgQXNzdW1pbmcgY2FzZSBpbnNlbnN0aXZlIGZpbGVzeXN0ZW1cclxuICBGTk1fU1lTQ0FTRSA9IDBcclxuICB3aW5kb3dzX3Jvb3RfcnggPSAlcnteW2EtekEtWl06KD86XFxcXHxcXC8pfVxyXG5cclxuICBjbGFzcyA8PCBzZWxmXHJcbiAgICBkZWYgYWJzb2x1dGVfcGF0aChwYXRoLCBiYXNlZGlyID0gbmlsKVxyXG4gICAgICBzZXAgPSBTRVBBUkFUT1JcclxuICAgICAgc2VwX2NoYXJzID0gYCRzZXBfY2hhcnMoKWBcclxuICAgICAgbmV3X3BhcnRzID0gW11cclxuXHJcbiAgICAgIHBhdGggPSBwYXRoLnJlc3BvbmRfdG8/KDp0b19wYXRoKSA/IHBhdGgudG9fcGF0aCA6IHBhdGhcclxuICAgICAgcGF0aCA9IDo6T3BhbC5jb2VyY2VfdG8hKGBwYXRoYCwgOjpTdHJpbmcsIDp0b19zdHIpXHJcblxyXG4gICAgICBiYXNlZGlyIHx8PSA6OkRpci5wd2RcclxuICAgICAgcGF0aF9hYnMgICAgPSBgcGF0aC5zdWJzdHIoMCwgc2VwLmxlbmd0aCkgPT09IHNlcCB8fCB3aW5kb3dzX3Jvb3RfcngudGVzdChwYXRoKWBcclxuICAgICAgYmFzZWRpcl9hYnMgPSBgYmFzZWRpci5zdWJzdHIoMCwgc2VwLmxlbmd0aCkgPT09IHNlcCB8fCB3aW5kb3dzX3Jvb3RfcngudGVzdChiYXNlZGlyKWBcclxuXHJcbiAgICAgIGlmIHBhdGhfYWJzXHJcbiAgICAgICAgcGFydHMgICAgICAgPSBwYXRoLnNwbGl0KC9bI3tzZXBfY2hhcnN9XS8pXHJcbiAgICAgICAgbGVhZGluZ19zZXAgPSBgd2luZG93c19yb290X3J4LnRlc3QocGF0aCkgPyAnJyA6ICN7cGF0aC5zdWIoL14oWyN7c2VwX2NoYXJzfV0rKS4qJC8sICdcXDEnKX1gXHJcbiAgICAgICAgYWJzICAgICAgICAgPSB0cnVlXHJcbiAgICAgIGVsc2VcclxuICAgICAgICBwYXJ0cyAgICAgICA9IGJhc2VkaXIuc3BsaXQoL1sje3NlcF9jaGFyc31dLykgKyBwYXRoLnNwbGl0KC9bI3tzZXBfY2hhcnN9XS8pXHJcbiAgICAgICAgbGVhZGluZ19zZXAgPSBgd2luZG93c19yb290X3J4LnRlc3QoYmFzZWRpcikgPyAnJyA6ICN7YmFzZWRpci5zdWIoL14oWyN7c2VwX2NoYXJzfV0rKS4qJC8sICdcXDEnKX1gXHJcbiAgICAgICAgYWJzICAgICAgICAgPSBiYXNlZGlyX2Fic1xyXG4gICAgICBlbmRcclxuXHJcbiAgICAgICV4e1xyXG4gICAgICAgIHZhciBwYXJ0O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhcnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcclxuICAgICAgICAgIHBhcnQgPSBwYXJ0c1tpXTtcclxuXHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIChwYXJ0ID09PSBuaWwpIHx8XHJcbiAgICAgICAgICAgIChwYXJ0ID09ICcnICAmJiAoKG5ld19wYXJ0cy5sZW5ndGggPT09IDApIHx8IGFicykpIHx8XHJcbiAgICAgICAgICAgIChwYXJ0ID09ICcuJyAmJiAoKG5ld19wYXJ0cy5sZW5ndGggPT09IDApIHx8IGFicykpXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAocGFydCA9PSAnLi4nKSB7XHJcbiAgICAgICAgICAgIG5ld19wYXJ0cy5wb3AoKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld19wYXJ0cy5wdXNoKHBhcnQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFhYnMgJiYgcGFydHNbMF0gIT0gJy4nKSB7XHJcbiAgICAgICAgICAje25ld19wYXJ0cy51bnNoaWZ0ICcuJ31cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG5ld19wYXRoID0gbmV3X3BhcnRzLmpvaW4oc2VwKVxyXG4gICAgICBuZXdfcGF0aCA9IGxlYWRpbmdfc2VwICsgbmV3X3BhdGggaWYgYWJzXHJcbiAgICAgIG5ld19wYXRoXHJcbiAgICBlbmRcclxuXHJcbiAgICBkZWYgZXhwYW5kX3BhdGgocGF0aCwgYmFzZWRpciA9IG5pbClcclxuICAgICAgc2VwID0gU0VQQVJBVE9SXHJcbiAgICAgIHNlcF9jaGFycyA9IGAkc2VwX2NoYXJzKClgXHJcbiAgICAgIGlmIGBwYXRoWzBdID09PSAnficgfHwgKGJhc2VkaXIgJiYgYmFzZWRpclswXSA9PT0gJ34nKWBcclxuICAgICAgICBob21lID0gRGlyLmhvbWVcclxuICAgICAgICA6Oktlcm5lbC5yYWlzZSg6OkFyZ3VtZW50RXJyb3IsIFwiY291bGRuJ3QgZmluZCBIT01FIGVudmlyb25tZW50IC0tIGV4cGFuZGluZyBgfidcIikgdW5sZXNzIGhvbWVcclxuICAgICAgICBsZWFkaW5nX3NlcCA9IGB3aW5kb3dzX3Jvb3RfcngudGVzdChob21lKSA/ICcnIDogI3tob21lLnN1YigvXihbI3tzZXBfY2hhcnN9XSspLiokLywgJ1xcMScpfWBcclxuICAgICAgICA6Oktlcm5lbC5yYWlzZSg6OkFyZ3VtZW50RXJyb3IsICdub24tYWJzb2x1dGUgaG9tZScpIHVubGVzcyBob21lLnN0YXJ0X3dpdGg/KGxlYWRpbmdfc2VwKVxyXG5cclxuICAgICAgICBob21lICAgICAgICAgICAgKz0gc2VwXHJcbiAgICAgICAgaG9tZV9wYXRoX3JlZ2V4cCA9IC9eXFx+KD86I3tzZXB9fCQpL1xyXG4gICAgICAgIHBhdGggICAgICAgICAgICAgPSBwYXRoLnN1Yihob21lX3BhdGhfcmVnZXhwLCBob21lKVxyXG4gICAgICAgIGJhc2VkaXIgICAgICAgICAgPSBiYXNlZGlyLnN1Yihob21lX3BhdGhfcmVnZXhwLCBob21lKSBpZiBiYXNlZGlyXHJcbiAgICAgIGVuZFxyXG4gICAgICBhYnNvbHV0ZV9wYXRoKHBhdGgsIGJhc2VkaXIpXHJcbiAgICBlbmRcclxuXHJcbiAgICAleHtcclxuICAgICAgLy8gQ29lcmNlIGEgZ2l2ZW4gcGF0aCB0byBhIHBhdGggc3RyaW5nIHVzaW5nICN0b19wYXRoIGFuZCAjdG9fc3RyXHJcbiAgICAgIGZ1bmN0aW9uICRjb2VyY2VfdG9fcGF0aChwYXRoKSB7XHJcbiAgICAgICAgaWYgKCR0cnV0aHkoI3tgcGF0aGAucmVzcG9uZF90bz8oOnRvX3BhdGgpfSkpIHtcclxuICAgICAgICAgIHBhdGggPSBwYXRoLiR0b19wYXRoKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXRoID0gI3s6Ok9wYWwuY29lcmNlX3RvIShgcGF0aGAsIDo6U3RyaW5nLCA6dG9fc3RyKX07XHJcblxyXG4gICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZXR1cm4gYSBSZWdFeHAgY29tcGF0aWJsZSBjaGFyIGNsYXNzXHJcbiAgICAgIGZ1bmN0aW9uICRzZXBfY2hhcnMoKSB7XHJcbiAgICAgICAgaWYgKCN7QUxUX1NFUEFSQVRPUn0gPT09IG5pbCkge1xyXG4gICAgICAgICAgcmV0dXJuIE9wYWwuZXNjYXBlX3JlZ2V4cCgje1NFUEFSQVRPUn0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gT3BhbC5lc2NhcGVfcmVnZXhwKCN7U0VQQVJBVE9SICsgQUxUX1NFUEFSQVRPUn0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGRlZiBkaXJuYW1lKHBhdGgsIGxldmVsID0gMSlcclxuICAgICAgcmV0dXJuIHBhdGggaWYgbGV2ZWwgPT0gMFxyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwibGV2ZWwgY2FuJ3QgYmUgbmVnYXRpdmVcIiBpZiBsZXZlbCA8IDBcclxuXHJcbiAgICAgIHNlcF9jaGFycyA9IGAkc2VwX2NoYXJzKClgXHJcbiAgICAgIHBhdGggPSBgJGNvZXJjZV90b19wYXRoKHBhdGgpYFxyXG4gICAgICAleHtcclxuICAgICAgICB2YXIgYWJzb2x1dGUgPSBwYXRoLm1hdGNoKG5ldyBSZWdFeHAoI3tcIl5bI3tzZXBfY2hhcnN9XVwifSkpLCBvdXQ7XHJcblxyXG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UobmV3IFJlZ0V4cCgje1wiWyN7c2VwX2NoYXJzfV0rJFwifSksICcnKTsgLy8gcmVtb3ZlIHRyYWlsaW5nIHNlcGFyYXRvcnNcclxuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIlteI3tzZXBfY2hhcnN9XSskXCJ9KSwgJycpOyAvLyByZW1vdmUgdHJhaWxpbmcgYmFzZW5hbWVcclxuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIlsje3NlcF9jaGFyc31dKyRcIn0pLCAnJyk7IC8vIHJlbW92ZSBmaW5hbCB0cmFpbGluZyBzZXBhcmF0b3JzXHJcblxyXG4gICAgICAgIGlmIChwYXRoID09PSAnJykge1xyXG4gICAgICAgICAgb3V0ID0gYWJzb2x1dGUgPyAnLycgOiAnLic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgb3V0ID0gcGF0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChsZXZlbCA9PSAxKSB7XHJcbiAgICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiAje2Rpcm5hbWUoYG91dGAsIGxldmVsIC0gMSl9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICBlbmRcclxuXHJcbiAgICBkZWYgYmFzZW5hbWUobmFtZSwgc3VmZml4ID0gbmlsKVxyXG4gICAgICBzZXBfY2hhcnMgPSBgJHNlcF9jaGFycygpYFxyXG4gICAgICBuYW1lID0gYCRjb2VyY2VfdG9fcGF0aChuYW1lKWBcclxuICAgICAgJXh7XHJcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHN1ZmZpeCAhPT0gbmlsKSB7XHJcbiAgICAgICAgICBzdWZmaXggPSAjezo6T3BhbC5jb2VyY2VfdG8hKHN1ZmZpeCwgOjpTdHJpbmcsIDp0b19zdHIpfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzdWZmaXggPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShuZXcgUmVnRXhwKCN7XCIoLilbI3tzZXBfY2hhcnN9XSokXCJ9KSwgJyQxJyk7XHJcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShuZXcgUmVnRXhwKCN7XCJeKD86LipbI3tzZXBfY2hhcnN9XSk/KFteI3tzZXBfY2hhcnN9XSspJFwifSksICckMScpO1xyXG5cclxuICAgICAgICBpZiAoc3VmZml4ID09PSBcIi4qXCIpIHtcclxuICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1xcLlteXFwuXSskLywgJycpO1xyXG4gICAgICAgIH0gZWxzZSBpZihzdWZmaXggIT09IG51bGwpIHtcclxuICAgICAgICAgIHN1ZmZpeCA9IE9wYWwuZXNjYXBlX3JlZ2V4cChzdWZmaXgpO1xyXG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShuZXcgUmVnRXhwKCN7XCIje3N1ZmZpeH0kXCJ9KSwgJycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICAgIH1cclxuICAgIGVuZFxyXG5cclxuICAgIGRlZiBleHRuYW1lKHBhdGgpXHJcbiAgICAgIGBwYXRoID0gJGNvZXJjZV90b19wYXRoKHBhdGgpYFxyXG4gICAgICBmaWxlbmFtZSA9IGJhc2VuYW1lKHBhdGgpXHJcbiAgICAgIHJldHVybiAnJyBpZiBmaWxlbmFtZS5lbXB0eT9cclxuICAgICAgbGFzdF9kb3RfaWR4ID0gZmlsZW5hbWVbMS4uLTFdLnJpbmRleCgnLicpXHJcbiAgICAgICMgZXh0ZW5zaW9uIG5hbWUgbXVzdCBjb250YWlucyBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyIC4oc29tZXRoaW5nKVxyXG4gICAgICBsYXN0X2RvdF9pZHgubmlsPyB8fCBsYXN0X2RvdF9pZHggKyAxID09IGZpbGVuYW1lLmxlbmd0aCAtIDEgPyAnJyA6IGZpbGVuYW1lWyhsYXN0X2RvdF9pZHggKyAxKS4uLTFdXHJcbiAgICBlbmRcclxuXHJcbiAgICBkZWYgZXhpc3Q/KHBhdGgpXHJcbiAgICAgIGBPcGFsLm1vZHVsZXNbI3twYXRofV0gIT0gbnVsbGBcclxuICAgIGVuZFxyXG5cclxuICAgIGRlZiBkaXJlY3Rvcnk/KHBhdGgpXHJcbiAgICAgIGZpbGVzID0gW11cclxuICAgICAgJXh7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIE9wYWwubW9kdWxlcykge1xyXG4gICAgICAgICAgI3tmaWxlc30ucHVzaChrZXkpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHBhdGggPSBwYXRoLmdzdWIoLyheLiN7U0VQQVJBVE9SfSt8I3tTRVBBUkFUT1J9KyQpLylcclxuICAgICAgZmlsZSA9IGZpbGVzLmZpbmQgeyB8ZnwgZiA9fiAvXiN7cGF0aH0vIH1cclxuICAgICAgZmlsZVxyXG4gICAgZW5kXHJcblxyXG4gICAgZGVmIGpvaW4oKnBhdGhzKVxyXG4gICAgICBpZiBwYXRocy5lbXB0eT9cclxuICAgICAgICByZXR1cm4gJydcclxuICAgICAgZW5kXHJcbiAgICAgIHJlc3VsdCA9ICcnXHJcbiAgICAgIHBhdGhzID0gcGF0aHMuZmxhdHRlbi5lYWNoX3dpdGhfaW5kZXgubWFwIGRvIHxpdGVtLCBpbmRleHxcclxuICAgICAgICBpZiBpbmRleCA9PSAwICYmIGl0ZW0uZW1wdHk/XHJcbiAgICAgICAgICBTRVBBUkFUT1JcclxuICAgICAgICBlbHNpZiBwYXRocy5sZW5ndGggPT0gaW5kZXggKyAxICYmIGl0ZW0uZW1wdHk/XHJcbiAgICAgICAgICBTRVBBUkFUT1JcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBpdGVtXHJcbiAgICAgICAgZW5kXHJcbiAgICAgIGVuZFxyXG4gICAgICBwYXRocyA9IHBhdGhzLnJlamVjdCgmOmVtcHR5PylcclxuICAgICAgcGF0aHMuZWFjaF93aXRoX2luZGV4IGRvIHxpdGVtLCBpbmRleHxcclxuICAgICAgICBuZXh0X2l0ZW0gPSBwYXRoc1tpbmRleCArIDFdXHJcbiAgICAgICAgaWYgbmV4dF9pdGVtLm5pbD9cclxuICAgICAgICAgIHJlc3VsdCA9IFwiI3tyZXN1bHR9I3tpdGVtfVwiXHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgaWYgaXRlbS5lbmRfd2l0aD8oU0VQQVJBVE9SKSAmJiBuZXh0X2l0ZW0uc3RhcnRfd2l0aD8oU0VQQVJBVE9SKVxyXG4gICAgICAgICAgICBpdGVtID0gaXRlbS5zdWIoLyN7U0VQQVJBVE9SfSskLywgJycpXHJcbiAgICAgICAgICBlbmRcclxuICAgICAgICAgIHJlc3VsdCA9IGlmIGl0ZW0uZW5kX3dpdGg/KFNFUEFSQVRPUikgfHwgbmV4dF9pdGVtLnN0YXJ0X3dpdGg/KFNFUEFSQVRPUilcclxuICAgICAgICAgICAgICAgICAgICAgXCIje3Jlc3VsdH0je2l0ZW19XCJcclxuICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgXCIje3Jlc3VsdH0je2l0ZW19I3tTRVBBUkFUT1J9XCJcclxuICAgICAgICAgICAgICAgICAgIGVuZFxyXG4gICAgICAgIGVuZFxyXG4gICAgICBlbmRcclxuICAgICAgcmVzdWx0XHJcbiAgICBlbmRcclxuXHJcbiAgICBkZWYgc3BsaXQocGF0aClcclxuICAgICAgcGF0aC5zcGxpdChTRVBBUkFUT1IpXHJcbiAgICBlbmRcclxuXHJcbiAgICBhbGlhcyByZWFscGF0aCBleHBhbmRfcGF0aFxyXG4gICAgYWxpYXMgZXhpc3RzPyBleGlzdD9cclxuICBlbmRcclxuZW5kXHJcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkZpbGU+IiwiMCIsIndpbmRvd3Nfcm9vdF9yeCIsImFic29sdXRlX3BhdGgiLCJwYXRoIiwiYmFzZWRpciIsInNlcCIsIlNFUEFSQVRPUiIsInNlcF9jaGFycyIsIm5ld19wYXJ0cyIsInJlc3BvbmRfdG8/IiwidG9fcGF0aCIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiU3RyaW5nIiwiJHJldF9vcl8xIiwiRGlyIiwicHdkIiwicGF0aF9hYnMiLCJiYXNlZGlyX2FicyIsInBhcnRzIiwic3BsaXQiLCJsZWFkaW5nX3NlcCIsInN1YiIsImFicyIsIisiLCJ1bnNoaWZ0IiwibmV3X3BhdGgiLCJqb2luIiwiZXhwYW5kX3BhdGgiLCJob21lIiwiS2VybmVsIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwic3RhcnRfd2l0aD8iLCJob21lX3BhdGhfcmVnZXhwIiwic2VsZiIsIkFMVF9TRVBBUkFUT1IiLCJkaXJuYW1lIiwibGV2ZWwiLCIxIiwiPCIsIi0iLCJiYXNlbmFtZSIsIm5hbWUiLCJzdWZmaXgiLCJleHRuYW1lIiwiZmlsZW5hbWUiLCJlbXB0eT8iLCJsYXN0X2RvdF9pZHgiLCJbXSIsIi0xIiwicmluZGV4IiwibmlsPyIsImxlbmd0aCIsImV4aXN0PyIsImRpcmVjdG9yeT8iLCJmaWxlcyIsImdzdWIiLCJmaW5kIiwiYmxvY2sgaW4gZGlyZWN0b3J5PyIsImYiLCJibG9jayAoMiBsZXZlbHMpIGluIGRpcmVjdG9yeT8iLCI9fiIsInBhdGhzIiwicmVzdWx0IiwibWFwIiwiZmxhdHRlbiIsImVhY2hfd2l0aF9pbmRleCIsImJsb2NrIGluIGpvaW4iLCJpdGVtIiwiaW5kZXgiLCJibG9jayAoMiBsZXZlbHMpIGluIGpvaW4iLCJyZWplY3QiLCJ0b19wcm9jIiwibmV4dF9pdGVtIiwiZW5kX3dpdGg/IiwiSU8iXSwibWFwcGluZ3MiOiJBQUFBQSwrQkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUdBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNFLHFDQUFZLHFDQUFZQSxHQUFaLENBQVo7SUFDQSx5Q0FBZ0IsR0FBaEI7SUFDQSwwQ0FBaUJBLEdBQWpCO0lBRUEsdUNBQWNDLENBQWQ7SUFDQUMsa0JBQWtCLGlCQUFBLHVCQUFBO0lBRWxCRixPQUFBO01BQUE7Ozs7QUFDRUcsTUFBQUEsNkJBQUFBLHlCQUFrQkMsSUFBRCxFQUFPQyxPQUF4QkY7QUFBQUEsUUFBQUE7OztRQUF3QiwrQkFBVTtRQUNoQ0csTUFBTUM7UUFDTkMsWUFBYUw7UUFDYk0sWUFBWTtRQUVaTCxPQUFPLENBQUEsUUFBQUEsSUFBSU0sZ0JBQUFBLENBQWEsU0FBYkEsQ0FBSixDQUFBLEdBQUEsQ0FBNkJOLElBQUlPLFNBQUFBLENBQUFBLENBQWpDLElBQUEsQ0FBNENQLElBQTVDLENBQUE7UUFDUEEsT0FBT1EsS0FBTUMsZUFBQUEsQ0FBYVYsSUFBbkIsRUFBMEJXLGFBQTFCLEVBQW9DLFFBQTlCRDtRQUViUixVQXBCTixDQUFBLFFBQUFVLENBQUFBLFlBb0JNVixPQXBCTlUs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QUFBLEdBQUEsTUFBbUIvRCxlQUFuQixDQUhGLENBQUEsQ0FBVDBEO1VBTkYsRUFGRkksQ0FBS0Q7UUFlTHhDLE9BQUFxQztNQTlCRnJDLENBQUFBLElBQUFBOztBQWlDQVAsTUFBQUEscUJBQUFBLGlCQUFVakIsSUFBVmlCO0FBQUFBO1FBQ0VBLE9BQUFqQixJQUFJaUIsT0FBQUEsQ0FBT2QsZUFBUGM7TUFETkEsQ0FBQUE7TUFJQSxhQUFNLFVBQU4sRUFBZSxhQUFmO01BQ0EsT0FBQSxhQUFNLFNBQU4sRUFBYyxRQUFkO0lBbk5GLDRCQUFTZSxJQUFUO0VBUkZwQyxHQUFNLElBQU5BLEVBQWU2RSxTQUFmN0U7QUFIQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI1NTIwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9wcm9jZXNzL2Jhc2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgOjpTaWduYWxcclxuICBkZWYgc2VsZi50cmFwKCopXHJcbiAgZW5kXHJcbmVuZFxyXG5cclxuY2xhc3MgOjpHQ1xyXG4gIGRlZiBzZWxmLnN0YXJ0XHJcbiAgZW5kXHJcbmVuZFxyXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpTaWduYWw+IiwidHJhcCIsInNlbGYiLCI8Y2xhc3M6R0M+Iiwic3RhcnQiXSwibWFwcGluZ3MiOiJBQUFBQSx1Q0FBQUEsZ0JBQUFBO0VBQUFBOzs7RUFBQUM7RUFBQUE7OztJQUNFQSxPQUFBQyxNQUFJQyxJQUFKRCxXQUFBQSxnQkFERixFQUNFQTtBQUFBQSxNQUFBQTs7O01BREY7TUFDZ0I7TUFEaEJBLE9BQUE7SUFDRUEsQ0FBQUEsSUFBQUE7RUFERkQsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtFQUtBRCxPQUFBSTtFQUFBQTs7O0lBQ0VBLE9BQUFDLE1BQUlGLElBQUpFLFlBQUFBLFlBTkYsR0FNRUEsQ0FBQUE7RUFERkQsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQUxBSjsifX0seyJvZmZzZXQiOnsibGluZSI6MjU1NDUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3Byb2Nlc3MucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXHJcblxyXG5tb2R1bGUgOjpQcm9jZXNzXHJcbiAgQF9fY2xvY2tzX18gPSBbXVxyXG4gIGRlZiBzZWxmLl9fcmVnaXN0ZXJfY2xvY2tfXyhuYW1lLCBmdW5jKVxyXG4gICAgY29uc3Rfc2V0IG5hbWUsIEBfX2Nsb2Nrc19fLnNpemVcclxuICAgIEBfX2Nsb2Nrc19fIDw8IGZ1bmNcclxuICBlbmRcclxuXHJcbiAgX19yZWdpc3Rlcl9jbG9ja19fIDpDTE9DS19SRUFMVElNRSwgYGZ1bmN0aW9uKCkgeyByZXR1cm4gRGF0ZS5ub3coKSB9YFxyXG5cclxuICBtb25vdG9uaWMgPSBmYWxzZVxyXG5cclxuICAleHtcclxuICAgIGlmIChPcGFsLmdsb2JhbC5wZXJmb3JtYW5jZSkge1xyXG4gICAgICBtb25vdG9uaWMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KClcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKE9wYWwuZ2xvYmFsLnByb2Nlc3MgJiYgcHJvY2Vzcy5ocnRpbWUpIHtcclxuICAgICAgLy8gbGV0IG5vdyBiZSB0aGUgYmFzZSB0byBnZXQgc21hbGxlciBudW1iZXJzXHJcbiAgICAgIHZhciBocnRpbWVfYmFzZSA9IHByb2Nlc3MuaHJ0aW1lKCk7XHJcblxyXG4gICAgICBtb25vdG9uaWMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgaHJ0aW1lID0gcHJvY2Vzcy5ocnRpbWUoaHJ0aW1lX2Jhc2UpO1xyXG4gICAgICAgIHZhciB1cyA9IChocnRpbWVbMV0gLyAxMDAwKSB8IDA7IC8vIGN1dCBiZWxvdyBtaWNyb3NlY3M7XHJcbiAgICAgICAgcmV0dXJuICgoaHJ0aW1lWzBdICogMTAwMCkgKyAodXMgLyAxMDAwKSk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfX3JlZ2lzdGVyX2Nsb2NrX18oOkNMT0NLX01PTk9UT05JQywgbW9ub3RvbmljKSBpZiBtb25vdG9uaWNcclxuXHJcbiAgZGVmIHNlbGYucGlkXHJcbiAgICAwXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzZWxmLnRpbWVzXHJcbiAgICB0ID0gOjpUaW1lLm5vdy50b19mXHJcbiAgICA6OkJlbmNobWFyazo6VG1zLm5ldyh0LCB0LCB0LCB0LCB0KVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc2VsZi5jbG9ja19nZXR0aW1lKGNsb2NrX2lkLCB1bml0ID0gOmZsb2F0X3NlY29uZClcclxuICAgIChjbG9jayA9IEBfX2Nsb2Nrc19fW2Nsb2NrX2lkXSkgfHwgOjpLZXJuZWwucmFpc2UoOjpFcnJubzo6RUlOVkFMLCBcImNsb2NrX2dldHRpbWUoI3tjbG9ja19pZH0pICN7QF9fY2xvY2tzX19bY2xvY2tfaWRdfVwiKVxyXG4gICAgJXh7XHJcbiAgICAgIHZhciBtcyA9IGNsb2NrKCk7XHJcbiAgICAgIHN3aXRjaCAodW5pdCkge1xyXG4gICAgICAgIGNhc2UgJ2Zsb2F0X3NlY29uZCc6ICAgICAgcmV0dXJuICAobXMgLyAxMDAwKTsgICAgICAgICAvLyBudW1iZXIgb2Ygc2Vjb25kcyBhcyBhIGZsb2F0IChkZWZhdWx0KVxyXG4gICAgICAgIGNhc2UgJ2Zsb2F0X21pbGxpc2Vjb25kJzogcmV0dXJuICAobXMgLyAxKTsgICAgICAgICAgICAvLyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGFzIGEgZmxvYXRcclxuICAgICAgICBjYXNlICdmbG9hdF9taWNyb3NlY29uZCc6IHJldHVybiAgKG1zICogMTAwMCk7ICAgICAgICAgLy8gbnVtYmVyIG9mIG1pY3Jvc2Vjb25kcyBhcyBhIGZsb2F0XHJcbiAgICAgICAgY2FzZSAnc2Vjb25kJzogICAgICAgICAgICByZXR1cm4gKChtcyAvIDEwMDApICAgIHwgMCk7IC8vIG51bWJlciBvZiBzZWNvbmRzIGFzIGFuIGludGVnZXJcclxuICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6ICAgICAgIHJldHVybiAoKG1zIC8gMSkgICAgICAgfCAwKTsgLy8gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBhcyBhbiBpbnRlZ2VyXHJcbiAgICAgICAgY2FzZSAnbWljcm9zZWNvbmQnOiAgICAgICByZXR1cm4gKChtcyAqIDEwMDApICAgIHwgMCk7IC8vIG51bWJlciBvZiBtaWNyb3NlY29uZHMgYXMgYW4gaW50ZWdlclxyXG4gICAgICAgIGNhc2UgJ25hbm9zZWNvbmQnOiAgICAgICAgcmV0dXJuICgobXMgKiAxMDAwMDAwKSB8IDApOyAvLyBudW1iZXIgb2YgbmFub3NlY29uZHMgYXMgYW4gaW50ZWdlclxyXG4gICAgICAgIGRlZmF1bHQ6ICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcInVuZXhwZWN0ZWQgdW5pdDogI3t1bml0fVwifVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgZW5kXHJcbmVuZFxyXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6UHJvY2Vzcz4iLCJAX19jbG9ja3NfXyIsIl9fcmVnaXN0ZXJfY2xvY2tfXyIsInNlbGYiLCJuYW1lIiwiZnVuYyIsImNvbnN0X3NldCIsInNpemUiLCI8PCIsIm1vbm90b25pYyIsInBpZCIsIjAiLCJ0aW1lcyIsInQiLCJUaW1lIiwibm93IiwidG9fZiIsIkJlbmNobWFyazo6VG1zIiwiQmVuY2htYXJrIiwibmV3IiwiY2xvY2tfZ2V0dGltZSIsImNsb2NrX2lkIiwidW5pdCIsIiRyZXRfb3JfMSIsImNsb2NrIiwiW10iLCJLZXJuZWwiLCJyYWlzZSIsIkVycm5vOjpFSU5WQUwiLCJFcnJubyIsIkFyZ3VtZW50RXJyb3IiXSwibWFwcGluZ3MiOiJBQUFBQSxrQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUVBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNFQyxrQkFBYztJQUNkQyxNQUFJQyxJQUFKRCx5QkFBQUEsOEJBQTRCRSxJQUFELEVBQU9DLElBQWxDSDtBQUFBQSxNQUFBQTtBQUFBQTs7O01BQ0VDLElBQUFHLFdBQUFBLENBQVVGLElBQVYsRUFBZ0JILGVBQVdNLE1BQUFBLENBQUFBLENBQTNCRDtNQUNBSixPQUFBRCxlQUFZTyxPQUFBQSxDQUFHSCxJQUFIRztJQUZkTixDQUFBQTtJQUtBQyxJQUFBRCxvQkFBQUEsQ0FBbUIsZ0JBQW5CLEVBQXFDRixnQ0FBckNFO0lBRUFPLFlBQVk7O0FBR2RUO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQUVFLElBQUEsUUFBbURTLFNBQW5ELENBQUE7TUFBQU4sSUFBQUQsb0JBQUFBLENBQW1CLGlCQUFuQixFQUFxQ08sU0FBckNQO0lBQUE7SUFFQVEsTUFBSVAsSUFBSk8sVUFBQUEsWUFDRUMsQ0FERkQsQ0FBQUE7SUFJQUUsTUFBSVQsSUFBSlMsWUFBQUEsaUJBQUFBO0FBQUFBLE1BQUFBOzs7TUFDRUMsSUFBSUMsV0FBTUMsS0FBQUEsQ0FBQUEsQ0FBSUMsTUFBQUEsQ0FBQUE7TUFDZEosT0FBQUssSUFBQUMsZ0JBQUFELFFBQWdCRSxLQUFBQSxDQUFLTixDQUFyQixFQUF3QkEsQ0FBeEIsRUFBMkJBLENBQTNCLEVBQThCQSxDQUE5QixFQUFpQ0EsQ0FBakJNO0lBRmxCUCxDQUFBQTtJQUtBWixPQUFBb0IsTUFBSWpCLElBQUppQixvQkFBQUEseUJBQXVCQyxRQUFELEVBQVdDLElBQWpDRjtBQUFBQSxNQUFBQTtBQUFBQTs7O01BQWlDLHlCQUFPO01BQ3RDLElBQUEsUUFBQUcsQ0FBQUEsWUFBQ0MsQ0FBQUEsUUFBUXZCLGVBQVd3QixPQUFBQSxDQUFDSixRQUFESSxDQUFuQkQsQ0FBREQsQ0FBQSxDQUFBO1FBQUE7TUFBQTtRQUFtQ0csT0FBUUMsT0FBQUEsQ0FBT0MsSUFBQUMsWUFBQUQsV0FBZixFQUFpQ1IsZ0JBQUQsR0FBQSxNQUFpQkMsUUFBakIsQ0FBQSxHQUEwQkQsSUFBMUIsR0FBQSxNQUE4Qm5CLGVBQVd3QixPQUFBQSxDQUFDSixRQUFESSxDQUF6QyxDQUF4QkU7TUFBM0M7O0FBRUpQO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLGlCQUFtQk0sT0FBUUMsT0FBQUEsQ0FBT0csb0JBQWYsRUFBaUNWLG1CQUFELEdBQUEsTUFBb0JFLElBQXBCLENBQXhCSztBQUMzQlA7QUFDQUE7SUFkRUEsQ0FBQUEsSUFBQUE7RUF4Q0ZwQixHQUFPLElBQVBBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNTYyMiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmFuZG9tL2Zvcm1hdHRlci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcclxuIyB1c2Vfc3RyaWN0OiB0cnVlXHJcblxyXG5jbGFzcyA6OlJhbmRvbVxyXG4gIG1vZHVsZSBzZWxmOjpGb3JtYXR0ZXJcclxuICAgIGRlZiBoZXgoY291bnQgPSBuaWwpXHJcbiAgICAgIGNvdW50ID0gOjpSYW5kb20uX3ZlcmlmeV9jb3VudChjb3VudClcclxuICAgICAgJXh7XHJcbiAgICAgICAgdmFyIGJ5dGVzID0gI3tieXRlcyhjb3VudCl9O1xyXG4gICAgICAgIHZhciBvdXQgPSBcIlwiO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgI3tjb3VudH07IGkrKykge1xyXG4gICAgICAgICAgb3V0ICs9IGJ5dGVzLmNoYXJDb2RlQXQoaSkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAje2BvdXRgLmVuY29kZSgnVVMtQVNDSUknKX07XHJcbiAgICAgIH1cclxuICAgIGVuZFxyXG5cclxuICAgIGRlZiByYW5kb21fYnl0ZXMoY291bnQgPSBuaWwpXHJcbiAgICAgIGJ5dGVzKGNvdW50KVxyXG4gICAgZW5kXHJcblxyXG4gICAgZGVmIGJhc2U2NChjb3VudCA9IG5pbClcclxuICAgICAgOjpCYXNlNjQuc3RyaWN0X2VuY29kZTY0KHJhbmRvbV9ieXRlcyhjb3VudCkpLmVuY29kZSgnVVMtQVNDSUknKVxyXG4gICAgZW5kXHJcblxyXG4gICAgZGVmIHVybHNhZmVfYmFzZTY0KGNvdW50ID0gbmlsLCBwYWRkaW5nID0gZmFsc2UpXHJcbiAgICAgIDo6QmFzZTY0LnVybHNhZmVfZW5jb2RlNjQocmFuZG9tX2J5dGVzKGNvdW50KSwgcGFkZGluZykuZW5jb2RlKCdVUy1BU0NJSScpXHJcbiAgICBlbmRcclxuXHJcbiAgICBkZWYgdXVpZFxyXG4gICAgICBzdHIgPSBoZXgoMTYpLnNwbGl0KCcnKVxyXG4gICAgICBzdHJbMTJdID0gJzQnXHJcbiAgICAgIHN0clsxNl0gPSBgKHBhcnNlSW50KCN7c3RyWzE2XX0sIDE2KSAmIDMgfCA4KS50b1N0cmluZygxNilgXHJcbiAgICAgIHN0ciA9IFtzdHJbMC4uLjhdLCBzdHJbOC4uLjEyXSwgc3RyWzEyLi4uMTZdLCBzdHJbMTYuLi4yMF0sIHN0clsyMC4uLjMyXV1cclxuICAgICAgc3RyID0gc3RyLm1hcCgmOmpvaW4pXHJcbiAgICAgIHN0ci5qb2luKCctJylcclxuICAgIGVuZFxyXG5cclxuICAgICMgSW1wbGVtZW50ZWQgaW4gdGVybXMgb2YgYCNieXRlc2AgZm9yIFNlY3VyZVJhbmRvbSwgYnV0IFJhbmRvbSBvdmVycmlkZXMgdGhpc1xyXG4gICAgIyBtZXRob2QgdG8gaW1wbGVtZW50IGAjYnl0ZXNgIGluIHRlcm1zIG9mIGAjcmFuZG9tX2Zsb2F0YC4gTm90IHBhcnQgb2Ygc3RhbmRhcmRcclxuICAgICMgUnVieSBpbnRlcmZhY2UgLSB1c2UgcmFuZG9tX251bWJlciBmb3IgcG9ydGFiaWxpdHkuXHJcbiAgICBkZWYgcmFuZG9tX2Zsb2F0XHJcbiAgICAgIGJzID0gYnl0ZXMoNClcclxuICAgICAgbnVtID0gMFxyXG4gICAgICA0LnRpbWVzIGRvIHxpfFxyXG4gICAgICAgIG51bSA8PD0gOFxyXG4gICAgICAgIG51bSB8PSBic1tpXS5vcmRcclxuICAgICAgZW5kXHJcbiAgICAgIG51bS5hYnMgLyAweDdmZmZmZmZmXHJcbiAgICBlbmRcclxuXHJcbiAgICBkZWYgcmFuZG9tX251bWJlcihsaW1pdCA9IHVuZGVmaW5lZClcclxuICAgICAgJXh7XHJcbiAgICAgICAgZnVuY3Rpb24gcmFuZG9tRmxvYXQoKSB7XHJcbiAgICAgICAgICByZXR1cm4gI3tyYW5kb21fZmxvYXR9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmFuZG9tSW50KG1heCkge1xyXG4gICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IocmFuZG9tRmxvYXQoKSAqIG1heCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiByYW5kb21SYW5nZSgpIHtcclxuICAgICAgICAgIHZhciBtaW4gPSBsaW1pdC5iZWdpbixcclxuICAgICAgICAgICAgICBtYXggPSBsaW1pdC5lbmQ7XHJcblxyXG4gICAgICAgICAgaWYgKG1pbiA9PT0gbmlsIHx8IG1heCA9PT0gbmlsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuaWw7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIGxlbmd0aCA9IG1heCAtIG1pbjtcclxuXHJcbiAgICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmlsO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1pbjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAobWF4ICUgMSA9PT0gMCAmJiBtaW4gJSAxID09PSAwICYmICFsaW1pdC5leGNsKSB7XHJcbiAgICAgICAgICAgIGxlbmd0aCsrO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiByYW5kb21JbnQobGVuZ3RoKSArIG1pbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChsaW1pdCA9PSBudWxsKSB7XHJcbiAgICAgICAgICByZXR1cm4gcmFuZG9tRmxvYXQoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGxpbWl0LiQkaXNfcmFuZ2UpIHtcclxuICAgICAgICAgIHJldHVybiByYW5kb21SYW5nZSgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobGltaXQuJCRpc19udW1iZXIpIHtcclxuICAgICAgICAgIGlmIChsaW1pdCA8PSAwKSB7XHJcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgYXJndW1lbnQgLSAje2xpbWl0fVwifVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChsaW1pdCAlIDEgPT09IDApIHtcclxuICAgICAgICAgICAgLy8gaW50ZWdlclxyXG4gICAgICAgICAgICByZXR1cm4gcmFuZG9tSW50KGxpbWl0KTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiByYW5kb21GbG9hdCgpICogbGltaXQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGxpbWl0ID0gI3s6Ok9wYWwuY29lcmNlX3RvIShsaW1pdCwgOjpJbnRlZ2VyLCA6dG9faW50KX07XHJcblxyXG4gICAgICAgICAgaWYgKGxpbWl0IDw9IDApIHtcclxuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCBhcmd1bWVudCAtICN7bGltaXR9XCJ9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHJhbmRvbUludChsaW1pdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICBlbmRcclxuXHJcbiAgICBkZWYgYWxwaGFudW1lcmljKGNvdW50ID0gbmlsKVxyXG4gICAgICBjb3VudCA9IFJhbmRvbS5fdmVyaWZ5X2NvdW50KGNvdW50KVxyXG4gICAgICBtYXAgPSBbJzAnLi4nOScsICdhJy4uJ3onLCAnQScuLidaJ10ubWFwKCY6dG9fYSkuZmxhdHRlblxyXG4gICAgICA6OkFycmF5Lm5ldyhjb3VudCkgZG8gfGl8XHJcbiAgICAgICAgbWFwW3JhbmRvbV9udW1iZXIobWFwLmxlbmd0aCldXHJcbiAgICAgIGVuZC5qb2luXHJcbiAgICBlbmRcclxuICBlbmRcclxuXHJcbiAgaW5jbHVkZSA6OlJhbmRvbTo6Rm9ybWF0dGVyXHJcbiAgZXh0ZW5kIDo6UmFuZG9tOjpGb3JtYXR0ZXJcclxuZW5kXHJcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlJhbmRvbT4iLCI8bW9kdWxlOnNlbGY6OkZvcm1hdHRlcj4iLCJoZXgiLCJjb3VudCIsIlJhbmRvbSIsIl92ZXJpZnlfY291bnQiLCJzZWxmIiwiYnl0ZXMiLCJlbmNvZGUiLCJyYW5kb21fYnl0ZXMiLCJiYXNlNjQiLCJCYXNlNjQiLCJzdHJpY3RfZW5jb2RlNjQiLCJ1cmxzYWZlX2Jhc2U2NCIsInBhZGRpbmciLCJ1cmxzYWZlX2VuY29kZTY0IiwidXVpZCIsInN0ciIsIjE2Iiwic3BsaXQiLCJbXT0iLCIxMiIsIltdIiwiMCIsIjgiLCIyMCIsIjMyIiwibWFwIiwidG9fcHJvYyIsImpvaW4iLCJyYW5kb21fZmxvYXQiLCJicyIsIjQiLCJudW0iLCJ0aW1lcyIsImJsb2NrIGluIHJhbmRvbV9mbG9hdCIsImkiLCI8PCIsImJsb2NrICgyIGxldmVscykgaW4gcmFuZG9tX2Zsb2F0IiwifCIsIm9yZCIsIi8iLCJhYnMiLCIyMTQ3NDgzNjQ3IiwicmFuZG9tX251bWJlciIsImxpbWl0IiwiS2VybmVsIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiT3BhbCIsImNvZXJjZV90byEiLCJJbnRlZ2VyIiwiYWxwaGFudW1lcmljIiwiZmxhdHRlbiIsIm5ldyIsIkFycmF5IiwiYmxvY2sgaW4gYWxwaGFudW1lcmljIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBhbHBoYW51bWVyaWMiLCJsZW5ndGgiLCJpbmNsdWRlIiwiUmFuZG9tOjpGb3JtYXR0ZXIiLCJleHRlbmQiXSwibWFwcGluZ3MiOiJBQUFBQSwyQ0FBQUEsZ0JBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTtFQUdBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNFQztJQUFBQTs7TUFBQUE7Ozs7QUFDRUMsTUFBQUEsbUJBQUFBLGVBQVFDLEtBQVJEO0FBQUFBLFFBQUFBOzs7UUFBUSwyQkFBUTtRQUNkQyxRQUFRQyxhQUFRQyxlQUFBQSxDQUFlRixLQUFmRTs7QUFFdEJILG9CQUFzQkksSUFBQUMsT0FBQUEsQ0FBTUosS0FBTkksQ0FBYUw7QUFDbkNBO0FBQ0FBLDRCQUE4QkMsS0FBTUQ7QUFDcENBO0FBQ0FBO0FBQ0FBLGVBQWlCQSxDQUFDQSxHQUFEQSxDQUFLTSxRQUFBQSxDQUFRTixVQUFSTSxDQUFvQk47QUFDMUNBO01BVElBLENBQUFBLElBQUFBOztBQVlBTyxNQUFBQSw0QkFBQUEsd0JBQWlCTixLQUFqQk07QUFBQUEsUUFBQUE7OztRQUFpQiwyQkFBUTtRQUN2QkEsT0FBQUgsSUFBQUMsT0FBQUEsQ0FBTUosS0FBTkk7TUFERkUsQ0FBQUEsSUFBQUE7O0FBSUFDLE1BQUFBLHNCQUFBQSxrQkFBV1AsS0FBWE87QUFBQUEsUUFBQUE7OztRQUFXLDJCQUFRO1FBQ2pCQSxPQUFBQyxhQUFRQyxpQkFBQUEsQ0FBaUJOLElBQUFHLGNBQUFBLENBQWFOLEtBQWJNLENBQWpCRyxDQUFxQ0osUUFBQUEsQ0FBUUUsVUFBUkY7TUFEL0NFLENBQUFBLElBQUFBOztBQUlBRyxNQUFBQSw4QkFBQUEsMEJBQW1CVixLQUFELEVBQWNXLE9BQWhDRDtBQUFBQSxRQUFBQTs7O1FBQW1CLDJCQUFRO1FBQUssK0JBQVU7UUFDeENBLE9BQUFGLGFBQVFJLGtCQUFBQSxDQUFrQlQsSUFBQUcs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QUNkc0IsTUFBb0NBLE1BQTlCLENBQUMsT0FBQXlCLEdBQUEsRUFBS0EsR0FBTCxRQUFELEVBQVcsT0FBQUEsR0FBQSxFQUFLQSxHQUFMLFFBQVgsRUFBcUIsT0FBQUEsR0FBQSxFQUFLQSxHQUFMLFFBQXJCLENBQThCekIsT0FBQUEsRUFBQUEsRUFBQUEsRUFBTSxNQUFEQyxTQUFBQSxDQUFBQSxDQUFMRCxDQUFZMEIsU0FBQUEsQ0FBQUE7UUFDaERELE9BQU9FLE1BQVBDLFlBQU9ELE9BQUFBLEVBQUFBLENBQUtuRCxLQUFMbUQsQ0FBQUEsRUFBUEUsYUFBdUJwQixDQUF2Qm9CLEVBQUFDOzs7VUFBdUI7VUFDckJBLE9BQUE5QixHQUFHTCxPQUFBQSxDQUFDaEIsSUFBQXNDLGVBQUFBLENBQWNqQixHQUFHK0IsUUFBQUEsQ0FBQUEsQ0FBakJkLENBQUR0QixFQURMa0MsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBT0YsQ0FFSnpCLE1BQUFBLENBQUFBO01BTEx1QixDQUFBQSxJQUFBQTtJQTdHRm5ELEdBQU9LLElBQVBMO0lBc0hBSyxJQUFBcUQsU0FBQUEsQ0FBUUMsSUFBQXhELGFBQUF3RCxjQUFSRDtJQUNBM0QsT0FBQU0sSUFBQXVELFFBQUFBLENBQU9ELElBQUF4RCxhQUFBd0QsY0FBUEM7RUF4SEY3RCxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBSEFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNTc5MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmFuZG9tL21lcnNlbm5lX3R3aXN0ZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXHJcbiMgdXNlX3N0cmljdDogdHJ1ZVxyXG5cclxuIyBUaGlzIGlzIGJhc2VkIG9uIGFuIGFkYXB0YXRpb24gb2YgTWFrb3RvIE1hdHN1bW90byBhbmQgVGFrdWppIE5pc2hpbXVyYSdzIGNvZGVcclxuIyBkb25lIGJ5IFNlYW4gTWNDdWxsb3VnaCA8YmFua3NlYW5AZ21haWwuY29tPiBhbmQgRGF2ZSBIZWl0em1hblxyXG4jIDxkYXZlaGVpdHptYW5AeWFob28uY29tPiwgc3Vic2VxdWVudGx5IHJlYWRhcHRlZCBmcm9tIGFuIHVwZGF0ZWQgdmVyc2lvbiBvZlxyXG4jIHJ1YnkncyByYW5kb20uYyAocmV2IGMzOGExODMwMzJhNzgyNmRmMWFkYWJkOGFhMDcyNWM3MTNkNTNlMWMpLlxyXG4jXHJcbiMgVGhlIG9yaWdpbmFsIGNvcHlyaWdodCBub3RpY2UgZnJvbSByYW5kb20uYyBmb2xsb3dzLlxyXG4jXHJcbiMgICBUaGlzIGlzIGJhc2VkIG9uIHRyaW1tZWQgdmVyc2lvbiBvZiBNVDE5OTM3LiAgVG8gZ2V0IHRoZSBvcmlnaW5hbCB2ZXJzaW9uLFxyXG4jICAgY29udGFjdCA8aHR0cDovL3d3dy5tYXRoLnNjaS5oaXJvc2hpbWEtdS5hYy5qcC9+bS1tYXQvTVQvZW10Lmh0bWw+LlxyXG4jXHJcbiMgICBUaGUgb3JpZ2luYWwgY29weXJpZ2h0IG5vdGljZSBmb2xsb3dzLlxyXG4jXHJcbiMgICAgICBBIEMtcHJvZ3JhbSBmb3IgTVQxOTkzNywgd2l0aCBpbml0aWFsaXphdGlvbiBpbXByb3ZlZCAyMDAyLzIvMTAuXHJcbiMgICAgICBDb2RlZCBieSBUYWt1amkgTmlzaGltdXJhIGFuZCBNYWtvdG8gTWF0c3Vtb3RvLlxyXG4jICAgICAgVGhpcyBpcyBhIGZhc3RlciB2ZXJzaW9uIGJ5IHRha2luZyBTaGF3biBDb2t1cydzIG9wdGltaXphdGlvbixcclxuIyAgICAgIE1hdHRoZSBCZWxsZXcncyBzaW1wbGlmaWNhdGlvbiwgSXNha3UgV2FkYSdzIHJlYWwgdmVyc2lvbi5cclxuI1xyXG4jICAgICAgQmVmb3JlIHVzaW5nLCBpbml0aWFsaXplIHRoZSBzdGF0ZSBieSB1c2luZyBpbml0X2dlbnJhbmQobXQsIHNlZWQpXHJcbiMgICAgICBvciBpbml0X2J5X2FycmF5KG10LCBpbml0X2tleSwga2V5X2xlbmd0aCkuXHJcbiNcclxuIyAgICAgIENvcHlyaWdodCAoQykgMTk5NyAtIDIwMDIsIE1ha290byBNYXRzdW1vdG8gYW5kIFRha3VqaSBOaXNoaW11cmEsXHJcbiMgICAgICBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4jXHJcbiMgICAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcclxuIyAgICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xyXG4jICAgICAgYXJlIG1ldDpcclxuI1xyXG4jICAgICAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxyXG4jICAgICAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbiNcclxuIyAgICAgICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcclxuIyAgICAgICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxyXG4jICAgICAgICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4jXHJcbiMgICAgICAgIDMuIFRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGVcclxuIyAgICAgICAgICAgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuXHJcbiMgICAgICAgICAgIHBlcm1pc3Npb24uXHJcbiNcclxuIyAgICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcclxuIyAgICAgIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcclxuIyAgICAgIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxyXG4jICAgICAgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SXHJcbiMgICAgICBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcclxuIyAgICAgIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcclxuIyAgICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxyXG4jICAgICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxyXG4jICAgICAgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcclxuIyAgICAgIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xyXG4jICAgICAgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbiNcclxuI1xyXG4jICAgICAgQW55IGZlZWRiYWNrIGlzIHZlcnkgd2VsY29tZS5cclxuIyAgICAgIGh0dHA6Ly93d3cubWF0aC5rZWlvLmFjLmpwL21hdHVtb3RvL2VtdC5odG1sXHJcbiMgICAgICBlbWFpbDogbWF0dW1vdG9AbWF0aC5rZWlvLmFjLmpwXHJcbm1lcnNlbm5lX3R3aXN0ZXIgPSAleHsoZnVuY3Rpb24oKSB7XHJcbiAgLyogUGVyaW9kIHBhcmFtZXRlcnMgKi9cclxuICB2YXIgTiA9IDYyNDtcclxuICB2YXIgTSA9IDM5NztcclxuICB2YXIgTUFUUklYX0EgPSAweDk5MDhiMGRmOyAgICAgIC8qIGNvbnN0YW50IHZlY3RvciBhICovXHJcbiAgdmFyIFVNQVNLID0gMHg4MDAwMDAwMDsgICAgICAgICAvKiBtb3N0IHNpZ25pZmljYW50IHctciBiaXRzICovXHJcbiAgdmFyIExNQVNLID0gMHg3ZmZmZmZmZjsgICAgICAgICAvKiBsZWFzdCBzaWduaWZpY2FudCByIGJpdHMgKi9cclxuICB2YXIgTUlYQklUUyA9IGZ1bmN0aW9uKHUsdikgeyByZXR1cm4gKCAoKHUpICYgVU1BU0spIHwgKCh2KSAmIExNQVNLKSApOyB9O1xyXG4gIHZhciBUV0lTVCA9IGZ1bmN0aW9uKHUsdikgeyByZXR1cm4gKE1JWEJJVFMoKHUpLCh2KSkgPj4+IDEpIF4gKCh2ICYgMHgxKSA/IE1BVFJJWF9BIDogMHgwKTsgfTtcclxuXHJcbiAgZnVuY3Rpb24gaW5pdChzKSB7XHJcbiAgICB2YXIgbXQgPSB7bGVmdDogMCwgbmV4dDogTiwgc3RhdGU6IG5ldyBBcnJheShOKX07XHJcbiAgICBpbml0X2dlbnJhbmQobXQsIHMpO1xyXG4gICAgcmV0dXJuIG10O1xyXG4gIH1cclxuXHJcbiAgLyogaW5pdGlhbGl6ZXMgbXRbTl0gd2l0aCBhIHNlZWQgKi9cclxuICBmdW5jdGlvbiBpbml0X2dlbnJhbmQobXQsIHMpIHtcclxuICAgIHZhciBqLCBpO1xyXG4gICAgbXQuc3RhdGVbMF0gPSBzID4+PiAwO1xyXG4gICAgZm9yIChqPTE7IGo8TjsgaisrKSB7XHJcbiAgICAgIG10LnN0YXRlW2pdID0gKDE4MTI0MzMyNTMgKiAoKG10LnN0YXRlW2otMV0gXiAobXQuc3RhdGVbai0xXSA+PiAzMCkgPj4+IDApKSArIGopO1xyXG4gICAgICAvKiBTZWUgS251dGggVEFPQ1AgVm9sMi4gM3JkIEVkLiBQLjEwNiBmb3IgbXVsdGlwbGllci4gKi9cclxuICAgICAgLyogSW4gdGhlIHByZXZpb3VzIHZlcnNpb25zLCBNU0JzIG9mIHRoZSBzZWVkIGFmZmVjdCAgICovXHJcbiAgICAgIC8qIG9ubHkgTVNCcyBvZiB0aGUgYXJyYXkgc3RhdGVbXS4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAvKiAyMDAyLzAxLzA5IG1vZGlmaWVkIGJ5IE1ha290byBNYXRzdW1vdG8gICAgICAgICAgICAgKi9cclxuICAgICAgbXQuc3RhdGVbal0gJj0gMHhmZmZmZmZmZjsgIC8qIGZvciA+MzIgYml0IG1hY2hpbmVzICovXHJcbiAgICB9XHJcbiAgICBtdC5sZWZ0ID0gMTtcclxuICAgIG10Lm5leHQgPSBOO1xyXG4gIH1cclxuXHJcbiAgLyogZ2VuZXJhdGUgTiB3b3JkcyBhdCBvbmUgdGltZSAqL1xyXG4gIGZ1bmN0aW9uIG5leHRfc3RhdGUobXQpIHtcclxuICAgIHZhciBwID0gMCwgX3AgPSBtdC5zdGF0ZTtcclxuICAgIHZhciBqO1xyXG5cclxuICAgIG10LmxlZnQgPSBOO1xyXG4gICAgbXQubmV4dCA9IDA7XHJcblxyXG4gICAgZm9yIChqPU4tTSsxOyAtLWo7IHArKylcclxuICAgICAgX3BbcF0gPSBfcFtwKyhNKV0gXiBUV0lTVChfcFtwKygwKV0sIF9wW3ArKDEpXSk7XHJcblxyXG4gICAgZm9yIChqPU07IC0tajsgcCsrKVxyXG4gICAgICBfcFtwXSA9IF9wW3ArKE0tTildIF4gVFdJU1QoX3BbcCsoMCldLCBfcFtwKygxKV0pO1xyXG5cclxuICAgIF9wW3BdID0gX3BbcCsoTS1OKV0gXiBUV0lTVChfcFtwKygwKV0sIF9wWzBdKTtcclxuICB9XHJcblxyXG4gIC8qIGdlbmVyYXRlcyBhIHJhbmRvbSBudW1iZXIgb24gWzAsMHhmZmZmZmZmZl0taW50ZXJ2YWwgKi9cclxuICBmdW5jdGlvbiBnZW5yYW5kX2ludDMyKG10KSB7XHJcbiAgICAvKiBtdCBtdXN0IGJlIGluaXRpYWxpemVkICovXHJcbiAgICB2YXIgeTtcclxuXHJcbiAgICBpZiAoLS1tdC5sZWZ0IDw9IDApIG5leHRfc3RhdGUobXQpO1xyXG4gICAgeSA9IG10LnN0YXRlW210Lm5leHQrK107XHJcblxyXG4gICAgLyogVGVtcGVyaW5nICovXHJcbiAgICB5IF49ICh5ID4+PiAxMSk7XHJcbiAgICB5IF49ICh5IDw8IDcpICYgMHg5ZDJjNTY4MDtcclxuICAgIHkgXj0gKHkgPDwgMTUpICYgMHhlZmM2MDAwMDtcclxuICAgIHkgXj0gKHkgPj4+IDE4KTtcclxuXHJcbiAgICByZXR1cm4geSA+Pj4gMDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGludF9wYWlyX3RvX3JlYWxfZXhjbHVzaXZlKGEsIGIpIHtcclxuICAgIGEgPj4+PSA1O1xyXG4gICAgYiA+Pj49IDY7XHJcbiAgICByZXR1cm4oYSo2NzEwODg2NC4wK2IpKigxLjAvOTAwNzE5OTI1NDc0MDk5Mi4wKTtcclxuICB9XHJcblxyXG4gIC8vIGdlbmVyYXRlcyBhIHJhbmRvbSBudW1iZXIgb24gWzAsMSkgd2l0aCA1My1iaXQgcmVzb2x1dGlvblxyXG4gIGZ1bmN0aW9uIGdlbnJhbmRfcmVhbChtdCkge1xyXG4gICAgLyogbXQgbXVzdCBiZSBpbml0aWFsaXplZCAqL1xyXG4gICAgdmFyIGEgPSBnZW5yYW5kX2ludDMyKG10KSwgYiA9IGdlbnJhbmRfaW50MzIobXQpO1xyXG4gICAgcmV0dXJuIGludF9wYWlyX3RvX3JlYWxfZXhjbHVzaXZlKGEsIGIpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHsgZ2VucmFuZF9yZWFsOiBnZW5yYW5kX3JlYWwsIGluaXQ6IGluaXQgfTtcclxufSkoKX1cclxuXHJcbmNsYXNzIDo6UmFuZG9tXHJcbiAgYHZhciBNQVhfSU5UID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgTWF0aC5wb3coMiwgNTMpIC0gMWBcclxuXHJcbiAgc2VsZjo6TUVSU0VOTkVfVFdJU1RFUl9HRU5FUkFUT1IgPSBge1xyXG4gICAgbmV3X3NlZWQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogTUFYX0lOVCk7IH0sXHJcbiAgICByZXNlZWQ6IGZ1bmN0aW9uKHNlZWQpIHsgcmV0dXJuIG1lcnNlbm5lX3R3aXN0ZXIuaW5pdChzZWVkKTsgfSxcclxuICAgIHJhbmQ6IGZ1bmN0aW9uKG10KSB7IHJldHVybiBtZXJzZW5uZV90d2lzdGVyLmdlbnJhbmRfcmVhbChtdCk7IH1cclxuICB9YFxyXG5cclxuICBzZWxmLmdlbmVyYXRvciA9IHNlbGY6Ok1FUlNFTk5FX1RXSVNURVJfR0VORVJBVE9SXHJcbmVuZFxyXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIm1lcnNlbm5lX3R3aXN0ZXIiLCI8Y2xhc3M6UmFuZG9tPiIsInNlbGYiLCJnZW5lcmF0b3I9Iiwic2VsZjo6TUVSU0VOTkVfVFdJU1RFUl9HRU5FUkFUT1IiXSwibWFwcGluZ3MiOiJBQUFBQSxrREFBQUEsZ0JBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTs7RUF5REFDLG1CQUFzQkQ7QUFDdEJBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7RUFFQUEsT0FBQUU7RUFBQUE7O0lBQUFBOzs7SUFDR0E7SUFFRCxXQUFBQyxJQUFBLGdDQUFvQ0Q7QUFDdENBO0FBQ0FBO0FBQ0FBO0FBQ0FBLEdBSkU7SUFNQUEsT0FBSUUsTUFBQUEsQ0FBYUMsSUFBQUYsSUFBQUUsK0JBQWJELENBQUFBLEVBQUFBLE1BQUpELElBQUlDLGNBQUFBLEVBQUFBLEVBQUFBLENBQUFBLEVBQUFBO0VBVE5GLEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUEzSUFGOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNTg5NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmFuZG9tLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHJ1dGh5XHJcbiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxyXG4jIHVzZV9zdHJpY3Q6IHRydWVcclxuXHJcbnJlcXVpcmUgJ2NvcmVsaWIvcmFuZG9tL2Zvcm1hdHRlcidcclxuXHJcbmNsYXNzIDo6UmFuZG9tXHJcbiAgYXR0cl9yZWFkZXIgOnNlZWQsIDpzdGF0ZVxyXG5cclxuICBkZWYgc2VsZi5fdmVyaWZ5X2NvdW50KGNvdW50KVxyXG4gICAgJXh7XHJcbiAgICAgIGlmICghJHRydXRoeShjb3VudCkpIGNvdW50ID0gMTY7XHJcbiAgICAgIGlmICh0eXBlb2YgY291bnQgIT09IFwibnVtYmVyXCIpIGNvdW50ID0gI3tgY291bnRgLnRvX2ludH07XHJcbiAgICAgIGlmIChjb3VudCA8IDApICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgc3RyaW5nIHNpemUgKG9yIHNpemUgdG9vIGJpZyknfTtcclxuICAgICAgY291bnQgPSBNYXRoLmZsb29yKGNvdW50KTtcclxuICAgICAgcmV0dXJuIGNvdW50O1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgaW5pdGlhbGl6ZShzZWVkID0gOjpSYW5kb20ubmV3X3NlZWQpXHJcbiAgICBzZWVkID0gOjpPcGFsLmNvZXJjZV90byEoc2VlZCwgOjpJbnRlZ2VyLCA6dG9faW50KVxyXG4gICAgQHN0YXRlID0gc2VlZFxyXG4gICAgcmVzZWVkKHNlZWQpXHJcbiAgZW5kXHJcblxyXG4gIGRlZiByZXNlZWQoc2VlZClcclxuICAgIEBzZWVkID0gc2VlZFxyXG4gICAgYHNlbGYuJHJuZyA9IE9wYWwuJCRyYW5kLnJlc2VlZChzZWVkKWBcclxuICBlbmRcclxuXHJcbiAgZGVmIHNlbGYubmV3X3NlZWRcclxuICAgIGBPcGFsLiQkcmFuZC5uZXdfc2VlZCgpYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgc2VsZi5yYW5kKGxpbWl0ID0gdW5kZWZpbmVkKVxyXG4gICAgc2VsZjo6REVGQVVMVC5yYW5kKGxpbWl0KVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc2VsZi5zcmFuZChuID0gOjpSYW5kb20ubmV3X3NlZWQpXHJcbiAgICBuID0gOjpPcGFsLmNvZXJjZV90byEobiwgOjpJbnRlZ2VyLCA6dG9faW50KVxyXG5cclxuICAgIHByZXZpb3VzX3NlZWQgPSBzZWxmOjpERUZBVUxULnNlZWRcclxuICAgIHNlbGY6OkRFRkFVTFQucmVzZWVkKG4pXHJcbiAgICBwcmV2aW91c19zZWVkXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzZWxmLnVyYW5kb20oc2l6ZSlcclxuICAgIDo6U2VjdXJlUmFuZG9tLmJ5dGVzKHNpemUpXHJcbiAgZW5kXHJcblxyXG4gIGRlZiA9PShvdGhlcilcclxuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgOjpSYW5kb20gPT09IG90aGVyXHJcblxyXG4gICAgc2VlZCA9PSBvdGhlci5zZWVkICYmIHN0YXRlID09IG90aGVyLnN0YXRlXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBieXRlcyhsZW5ndGgpXHJcbiAgICBsZW5ndGggPSA6OlJhbmRvbS5fdmVyaWZ5X2NvdW50KGxlbmd0aClcclxuXHJcbiAgICA6OkFycmF5Lm5ldyhsZW5ndGgpIHsgcmFuZCgyNTUpLmNociB9LmpvaW4uZW5jb2RlKCdBU0NJSS04QklUJylcclxuICBlbmRcclxuXHJcbiAgZGVmIHNlbGYuYnl0ZXMobGVuZ3RoKVxyXG4gICAgc2VsZjo6REVGQVVMVC5ieXRlcyhsZW5ndGgpXHJcbiAgZW5kXHJcblxyXG4gIGRlZiByYW5kKGxpbWl0ID0gdW5kZWZpbmVkKVxyXG4gICAgcmFuZG9tX251bWJlcihsaW1pdClcclxuICBlbmRcclxuXHJcbiAgIyBOb3QgcGFydCBvZiB0aGUgUnVieSBpbnRlcmZhY2UgKHVzZSAjcmFuZG9tX251bWJlciBmb3IgcG9ydGFiaWxpdHkpLCBidXRcclxuICAjIHVzZWQgYnkgUmFuZG9tOjpGb3JtYXR0ZXIgYXMgYSBzaG9ydGN1dCwgYXMgZm9yIFJhbmRvbSBpbnRlcmZhY2UgdGhlIGZsb2F0XHJcbiAgIyBSTkcgaXMgcHJpbWFyeS5cclxuICBkZWYgcmFuZG9tX2Zsb2F0XHJcbiAgICAleHtcclxuICAgICAgc2VsZi5zdGF0ZSsrO1xyXG4gICAgICByZXR1cm4gT3BhbC4kJHJhbmQucmFuZChzZWxmLiRybmcpO1xyXG4gICAgfVxyXG4gIGVuZFxyXG5cclxuICBkZWYgc2VsZi5yYW5kb21fZmxvYXRcclxuICAgIHNlbGY6OkRFRkFVTFQucmFuZG9tX2Zsb2F0XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBzZWxmLmdlbmVyYXRvcj0oZ2VuZXJhdG9yKVxyXG4gICAgYE9wYWwuJCRyYW5kID0gI3tnZW5lcmF0b3J9YFxyXG5cclxuICAgIGlmIGNvbnN0X2RlZmluZWQ/IDpERUZBVUxUXHJcbiAgICAgIHNlbGY6OkRFRkFVTFQucmVzZWVkXHJcbiAgICBlbHNlXHJcbiAgICAgIGNvbnN0X3NldCA6REVGQVVMVCwgbmV3KG5ld19zZWVkKVxyXG4gICAgZW5kXHJcbiAgZW5kXHJcbmVuZFxyXG5cclxucmVxdWlyZSAnY29yZWxpYi9yYW5kb20vbWVyc2VubmVfdHdpc3RlcidcclxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpSYW5kb20+IiwiYXR0cl9yZWFkZXIiLCJfdmVyaWZ5X2NvdW50IiwiY291bnQiLCJ0b19pbnQiLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJpbml0aWFsaXplIiwic2VlZCIsIlJhbmRvbSIsIm5ld19zZWVkIiwiT3BhbCIsImNvZXJjZV90byEiLCJJbnRlZ2VyIiwiQHN0YXRlIiwicmVzZWVkIiwiQHNlZWQiLCJyYW5kIiwibGltaXQiLCJzZWxmOjpERUZBVUxUIiwic3JhbmQiLCJuIiwicHJldmlvdXNfc2VlZCIsInVyYW5kb20iLCJzaXplIiwiU2VjdXJlUmFuZG9tIiwiYnl0ZXMiLCI9PSIsIm90aGVyIiwiJHJldF9vcl8xIiwic3RhdGUiLCJsZW5ndGgiLCJuZXciLCJBcnJheSIsImJsb2NrIGluIGJ5dGVzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBieXRlcyIsIjI1NSIsImNociIsImpvaW4iLCJlbmNvZGUiLCJyYW5kb21fbnVtYmVyIiwicmFuZG9tX2Zsb2F0IiwiZ2VuZXJhdG9yPSIsImdlbmVyYXRvciIsImNvbnN0X2RlZmluZWQ/IiwiY29uc3Rfc2V0Il0sIm1hcHBpbmdzIjoiQUFBQUEsaUNBQUFBLGdCQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7O0VBSUFDLElBQUFDLFNBQUFBLENBQVFGLDBCQUFSRTtFQUVBQztFQUFBQTs7OztJQUNFRixJQUFBRyxhQUFBQSxDQUFZLE1BQVosRUFBbUIsT0FBbkJBO0lBRUFDLE1BQUlKLElBQUpJLG9CQUFBQSx5QkFBdUJDLEtBQXZCRDtBQUFBQTs7QUFFRkE7QUFDQUEsNkNBQStDQSxDQUFDQSxLQUFEQSxDQUFPRSxRQUFBQSxDQUFBQSxDQUFRRjtBQUM5REEscUJBQXVCRyxPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFnQ0wsd0NBQXhCSSxDQUFpRUo7QUFDaEdB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QU9BQSxNQUFJNUMsSUFBSjRDLG1CQUFBQSx3QkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUF0QixJQUFBdEIsSUFBQXNCLFlBQWFzQixjQUFBQSxDQUFBQTtJQURmQSxDQUFBQTtJQUlBMUMsT0FBQTJDLE1BQUk3QyxJQUFKNkMsaUJBQUFBLGdDQUFvQkMsU0FBcEJEO0FBQUFBLE1BQUFBOzs7TUFDR0EsY0FBZ0JDO01BRWpCLElBQUEsUUFBRzlDLElBQUErQyxtQkFBQUEsQ0FBZSxTQUFmQSxDQUFILENBQUE7UUFDRUYsT0FBQXZCLElBQUF0QixJQUFBc0IsWUFBYUosUUFBQUEsQ0FBQUE7TUFEZjtRQUdFMkIsT0FBQTdDLElBQUFnRCxXQUFBQSxDQUFVLFNBQVYsRUFBb0JoRCxJQUFBbUMsS0FBQUEsQ0FBSW5DLElBQUFhLFVBQUFBLENBQUFBLENBQUpzQixDQUFwQmE7TUFIRjtJQUhGSCxDQUFBQTtFQTlFRjNDLEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7RUF5RkFILE9BQUFDLElBQUFDLFNBQUFBLENBQVFGLGlDQUFSRTtBQS9GQUY7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI2MDI2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi91bnN1cHBvcnRlZC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcclxuIyB1c2Vfc3RyaWN0OiB0cnVlXHJcblxyXG5jbGFzcyA6OlN0cmluZ1xyXG4gIGB2YXIgRVJST1IgPSBcIlN0cmluZyMlcyBub3Qgc3VwcG9ydGVkLiBNdXRhYmxlIFN0cmluZyBtZXRob2RzIGFyZSBub3Qgc3VwcG9ydGVkIGluIE9wYWwuXCJgXHJcblxyXG4gICVpW1xyXG4gICAgY2FwaXRhbGl6ZSEgY2hvbXAhIGNob3AhIGRvd25jYXNlISBnc3ViISBsc3RyaXAhIG5leHQhIHJldmVyc2UhXHJcbiAgICBzbGljZSEgc3F1ZWV6ZSEgc3RyaXAhIHN1YiEgc3VjYyEgc3dhcGNhc2UhIHRyISB0cl9zISB1cGNhc2UhIHByZXBlbmRcclxuICAgIFtdPSBjbGVhciBlbmNvZGUhIHVuaWNvZGVfbm9ybWFsaXplIVxyXG4gIF0uZWFjaCBkbyB8bWV0aG9kX25hbWV8XHJcbiAgICBkZWZpbmVfbWV0aG9kIG1ldGhvZF9uYW1lIGRvIHwqfFxyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6Ok5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSBtZXRob2RfbmFtZVxyXG4gICAgZW5kXHJcbiAgZW5kXHJcbmVuZFxyXG5cclxuY2xhc3MgOjpNb2R1bGVcclxuICBkZWYgcHVibGljKCptZXRob2RzKVxyXG4gICAgJXh7XHJcbiAgICAgIGlmIChtZXRob2RzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHNlbGYuJCRtb2R1bGVfZnVuY3Rpb24gPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gbmlsO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAobWV0aG9kcy5sZW5ndGggPT09IDEpID8gbWV0aG9kc1swXSA6IG1ldGhvZHM7XHJcbiAgICB9XHJcbiAgZW5kXHJcblxyXG4gIGRlZiBwcml2YXRlX2NsYXNzX21ldGhvZCgqbWV0aG9kcylcclxuICAgIGByZXR1cm4gKG1ldGhvZHMubGVuZ3RoID09PSAxKSA/IG1ldGhvZHNbMF0gOiBtZXRob2RzYFxyXG4gIGVuZFxyXG5cclxuICBkZWYgcHJpdmF0ZV9tZXRob2RfZGVmaW5lZD8ob2JqKVxyXG4gICAgZmFsc2VcclxuICBlbmRcclxuXHJcbiAgZGVmIHByaXZhdGVfY29uc3RhbnQoKilcclxuICBlbmRcclxuXHJcbiAgYWxpYXMgbmVzdGluZyBwdWJsaWNcclxuICBhbGlhcyBwcml2YXRlIHB1YmxpY1xyXG4gIGFsaWFzIHByb3RlY3RlZCBwdWJsaWNcclxuICBhbGlhcyBwcm90ZWN0ZWRfbWV0aG9kX2RlZmluZWQ/IHByaXZhdGVfbWV0aG9kX2RlZmluZWQ/XHJcbiAgYWxpYXMgcHVibGljX2NsYXNzX21ldGhvZCBwcml2YXRlX2NsYXNzX21ldGhvZFxyXG4gIGFsaWFzIHB1YmxpY19pbnN0YW5jZV9tZXRob2QgaW5zdGFuY2VfbWV0aG9kXHJcbiAgYWxpYXMgcHVibGljX2luc3RhbmNlX21ldGhvZHMgaW5zdGFuY2VfbWV0aG9kc1xyXG4gIGFsaWFzIHB1YmxpY19tZXRob2RfZGVmaW5lZD8gbWV0aG9kX2RlZmluZWQ/XHJcbmVuZFxyXG5cclxubW9kdWxlIDo6S2VybmVsXHJcbiAgZGVmIHByaXZhdGVfbWV0aG9kcygqbWV0aG9kcylcclxuICAgIFtdXHJcbiAgZW5kXHJcblxyXG4gIGFsaWFzIHByb3RlY3RlZF9tZXRob2RzIHByaXZhdGVfbWV0aG9kc1xyXG4gIGFsaWFzIHByaXZhdGVfaW5zdGFuY2VfbWV0aG9kcyBwcml2YXRlX21ldGhvZHNcclxuICBhbGlhcyBwcm90ZWN0ZWRfaW5zdGFuY2VfbWV0aG9kcyBwcml2YXRlX21ldGhvZHNcclxuZW5kXHJcblxyXG5tb2R1bGUgOjpLZXJuZWxcclxuICBkZWYgZXZhbCgqKVxyXG4gICAgOjpLZXJuZWwucmFpc2UgOjpOb3RJbXBsZW1lbnRlZEVycm9yLCBcIlRvIHVzZSBLZXJuZWwjZXZhbCwgeW91IG11c3QgZmlyc3QgcmVxdWlyZSAnb3BhbC1wYXJzZXInLiBcIlxcXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGFsL29wYWwvYmxvYi8je1JVQllfRU5HSU5FX1ZFUlNJT059L2RvY3Mvb3BhbF9wYXJzZXIubWQgZm9yIGRldGFpbHMuXCJcclxuICBlbmRcclxuZW5kXHJcblxyXG5kZWYgc2VsZi5wdWJsaWMoKm1ldGhvZHMpXHJcbiAgYHJldHVybiAobWV0aG9kcy5sZW5ndGggPT09IDEpID8gbWV0aG9kc1swXSA6IG1ldGhvZHNgXHJcbmVuZFxyXG5cclxuZGVmIHNlbGYucHJpdmF0ZSgqbWV0aG9kcylcclxuICBgcmV0dXJuIChtZXRob2RzLmxlbmd0aCA9PT0gMSkgPyBtZXRob2RzWzBdIDogbWV0aG9kc2BcclxuZW5kXHJcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlN0cmluZz4iLCJlYWNoIiwiYmxvY2sgaW4gPGNsYXNzOlN0cmluZz4iLCJtZXRob2RfbmFtZSIsImJsb2NrICgyIGxldmVscykgaW4gPGNsYXNzOlN0cmluZz4iLCJkZWZpbmVfbWV0aG9kIiwic2VsZiIsImJsb2NrICgzIGxldmVscykgaW4gPGNsYXNzOlN0cmluZz4iLCJLZXJuZWwiLCJyYWlzZSIsIk5vdEltcGxlbWVudGVkRXJyb3IiLCIlIiwiPGNsYXNzOk1vZHVsZT4iLCJwdWJsaWMiLCJwcml2YXRlX2NsYXNzX21ldGhvZCIsInByaXZhdGVfbWV0aG9kX2RlZmluZWQ/IiwicHJpdmF0ZV9jb25zdGFudCIsIjxtb2R1bGU6S2VybmVsPiIsInByaXZhdGVfbWV0aG9kcyIsImV2YWwiLCJSVUJZX0VOR0lORV9WRVJTSU9OIiwicHJpdmF0ZSJdLCJtYXBwaW5ncyI6IkFBQUFBLHNDQUFBQSxnQkFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBOztFQUdBQztFQUFBQTs7OztJQUNHQTtJQUVEQSxPQUlDQyxNQUpELENBQ0UsYUFERixFQUNjLFFBRGQsRUFDcUIsT0FEckIsRUFDMkIsV0FEM0IsRUFDcUMsT0FEckMsRUFDMkMsU0FEM0MsRUFDbUQsT0FEbkQsRUFDeUQsVUFEekQsRUFFRSxRQUZGLEVBRVMsVUFGVCxFQUVrQixRQUZsQixFQUV5QixNQUZ6QixFQUU4QixPQUY5QixFQUVvQyxXQUZwQyxFQUU4QyxLQUY5QyxFQUVrRCxPQUZsRCxFQUV3RCxTQUZ4RCxFQUVnRSxTQUZoRSxFQUdFLEtBSEYsRUFHTSxPQUhOLEVBR1ksU0FIWixFQUdvQixvQkFIcEIsQ0FJQ0EsUUFBQUEsRUFBQUEsRUFBQUEsRUFKREMsbUJBSVdDLFdBSlhELEVBQUFFOzs7TUFJVztNQUNUQSxPQUFBQyxNQUFBQyxJQUFBRCxpQkFBQUEsRUFBQUEsQ0FBY0YsV0FBZEUsQ0FBQUEsRUFBQUQsYUFYSixFQVdJQSxFQUFBRzs7O1FBWEo7UUFXa0M7UUFDNUJBLE9BQUFDLE9BQVFDLE9BQUFBLENBQU9DLDBCQUFmLEVBQXNDSCxDQUFDQSxLQUFEQSxDQUFRSSxNQUFBQSxDQUFFUixXQUFGUSxDQUF0Q0YsRUFEVkwsQ0FBQUEsSUFBQUMsRUFMRkgsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FJQ0Q7RUFQSEQsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtFQWNBWTtFQUFBQTs7Ozs7QUFDRUMsSUFBQUEsc0JBQUFBLDBCQWxCRixFQWtCRUE7QUFBQUEsTUFBQUE7OztNQWxCRjtNQWtCYTs7QUFFYkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUFQRUEsQ0FBQUEsSUFBQUE7O0FBVUFDLElBQUFBLG9DQUFBQSxnQ0E1QkYsRUE0QkVBO0FBQUFBLE1BQUFBOzs7TUE1QkY7TUE0QjJCO01BQ3RCQSxvREFBREE7SUFERkEsQ0FBQUEsSUFBQUE7O0FBSUFDLElBQUFBLHVDQUFBQSxZQUNFLEtBREZBLENBQUFBOztBQUlBQyxJQUFBQSxnQ0FBQUEsNEJBcENGLEVBb0NFQTtBQUFBQSxNQUFBQTs7O01BcENGO01Bb0N1QjtNQXBDdkJBLE9BQUE7SUFvQ0VBLENBQUFBLElBQUFBO0lBR0EsYUFBTSxTQUFOLEVBQWMsUUFBZDtJQUNBLGFBQU0sU0FBTixFQUFjLFFBQWQ7SUFDQSxhQUFNLFdBQU4sRUFBZ0IsUUFBaEI7SUFDQSxhQUFNLDJCQUFOLEVBQWdDLHlCQUFoQztJQUNBLGFBQU0scUJBQU4sRUFBMEIsc0JBQTFCO0lBQ0EsYUFBTSx3QkFBTixFQUE2QixpQkFBN0I7SUFDQSxhQUFNLHlCQUFOLEVBQThCLGtCQUE5QjtJQUNBSixPQUFBLGFBQU0sd0JBQU4sRUFBNkIsaUJBQTdCO0VBN0JGQSxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0VBZ0NBSztFQUFBQTs7Ozs7QUFDRUMsSUFBQUEsK0JBQUFBLDJCQWxERixFQWtERUE7QUFBQUEsTUFBQUE7OztNQWxERjtNQWtEc0I7TUFDbEJBLE9BQUE7SUFERkEsQ0FBQUEsSUFBQUE7SUFJQSxhQUFNLG1CQUFOLEVBQXdCLGlCQUF4QjtJQUNBLGFBQU0sMEJBQU4sRUFBK0IsaUJBQS9CO0lBQ0FELE9BQUEsYUFBTSw0QkFBTixFQUFpQyxpQkFBakM7RUFQRkEsR0FBTyxJQUFQQTtFQVVBQTtFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUFFLG9CQUFBQSx3QkE1REYsRUE0REVBO0FBQUFBLE1BQUFBOzs7TUE1REY7TUE0RFc7TUFDUEEsT0FBQVgsT0FBUUMsT0FBQUEsQ0FBT0MsMEJBQWYsRUFBc0NTLDREQUFBLEdBQUEsTUFDQ0Esd0NBQUQsR0FBQSxNQUF5Q0MseUJBQXpDLENBQUEsR0FBNkRELG1DQUQ3RCxDQUE5QlY7SUFEVlUsQ0FBQUEsSUFBQUE7RUFERkYsR0FBTyxJQUFQQTtFQU9BSixNQUFJUCxJQUFKTyxhQUFBQSxtQkFsRUEsRUFrRUFBO0FBQUFBLElBQUFBOzs7SUFsRUE7SUFrRWdCO0lBQ2JBLG9EQUFEQTtFQURGQSxDQUFBQSxJQUFBQTtFQUlBZCxPQUFBc0IsTUFBSWYsSUFBSmUsY0FBQUEsb0JBdEVBLEVBc0VBQTtBQUFBQSxJQUFBQTs7O0lBdEVBO0lBc0VpQjtJQUNkQSxvREFBREE7RUFERkEsQ0FBQUEsSUFBQUE7QUF0RUF0QjsifX0seyJvZmZzZXQiOnsibGluZSI6MjYxNDgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2JpbmRpbmcucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXHJcblxyXG5jbGFzcyA6OkJpbmRpbmdcclxuICAjIEBwcml2YXRlXHJcbiAgZGVmIGluaXRpYWxpemUoanNldmFsLCBzY29wZV92YXJpYWJsZXMgPSBbXSwgcmVjZWl2ZXIgPSB1bmRlZmluZWQsIHNvdXJjZV9sb2NhdGlvbiA9IG5pbClcclxuICAgIEBqc2V2YWwsIEBzY29wZV92YXJpYWJsZXMsIEByZWNlaXZlciwgQHNvdXJjZV9sb2NhdGlvbiA9IFxcXHJcbiAgICAgIGpzZXZhbCwgc2NvcGVfdmFyaWFibGVzLCByZWNlaXZlciwgc291cmNlX2xvY2F0aW9uXHJcbiAgICAleHtcclxuICAgICAgLyogZXNsaW50IG5vLWNvbnN0YW50LWJpbmFyeS1leHByZXNzaW9uOiBcIndhcm5cIiAqL1xyXG4gICAgICAvKiBlc2xpbnQgdmFsaWQtdHlwZW9mOiBcIndhcm5cIiAqL1xyXG4gICAgfVxyXG4gICAgcmVjZWl2ZXIgPSBqc19ldmFsKCdzZWxmJykgdW5sZXNzIGB0eXBlb2YgcmVjZWl2ZXIgIT09IHVuZGVmaW5lZGBcclxuICBlbmRcclxuXHJcbiAgZGVmIGpzX2V2YWwoKmFyZ3MpXHJcbiAgICBpZiBAanNldmFsXHJcbiAgICAgIEBqc2V2YWwuY2FsbCgqYXJncylcclxuICAgIGVsc2VcclxuICAgICAgOjpLZXJuZWwucmFpc2UgJ0V2YWx1YXRpb24gb24gYSBQcm9jI2JpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCdcclxuICAgIGVuZFxyXG4gIGVuZFxyXG5cclxuICBkZWYgbG9jYWxfdmFyaWFibGVfZ2V0KHN5bWJvbClcclxuICAgIGpzX2V2YWwoc3ltYm9sKVxyXG4gIHJlc2N1ZSA6OkV4Y2VwdGlvblxyXG4gICAgOjpLZXJuZWwucmFpc2UgOjpOYW1lRXJyb3IsIFwibG9jYWwgdmFyaWFibGUgYCN7c3ltYm9sfScgaXMgbm90IGRlZmluZWQgZm9yICN7aW5zcGVjdH1cIlxyXG4gIGVuZFxyXG5cclxuICBkZWYgbG9jYWxfdmFyaWFibGVfc2V0KHN5bWJvbCwgdmFsdWUpXHJcbiAgICBgT3BhbC5CaW5kaW5nLnRtcF92YWx1ZSA9IHZhbHVlYFxyXG4gICAganNfZXZhbChcIiN7c3ltYm9sfSA9IE9wYWwuQmluZGluZy50bXBfdmFsdWVcIilcclxuICAgIGBkZWxldGUgT3BhbC5CaW5kaW5nLnRtcF92YWx1ZWBcclxuICAgIHZhbHVlXHJcbiAgZW5kXHJcblxyXG4gIGRlZiBsb2NhbF92YXJpYWJsZXNcclxuICAgIEBzY29wZV92YXJpYWJsZXNcclxuICBlbmRcclxuXHJcbiAgZGVmIGxvY2FsX3ZhcmlhYmxlX2RlZmluZWQ/KHZhbHVlKVxyXG4gICAgQHNjb3BlX3ZhcmlhYmxlcy5pbmNsdWRlPyh2YWx1ZSlcclxuICBlbmRcclxuXHJcbiAgZGVmIGV2YWwoc3RyLCBmaWxlID0gbmlsLCBsaW5lID0gbmlsKVxyXG4gICAgcmV0dXJuIHJlY2VpdmVyIGlmIHN0ciA9PSAnc2VsZidcclxuXHJcbiAgICA6Oktlcm5lbC5ldmFsKHN0ciwgc2VsZiwgZmlsZSwgbGluZSlcclxuICBlbmRcclxuXHJcbiAgYXR0cl9yZWFkZXIgOnJlY2VpdmVyLCA6c291cmNlX2xvY2F0aW9uXHJcbmVuZFxyXG5cclxubW9kdWxlIDo6S2VybmVsXHJcbiAgZGVmIGJpbmRpbmdcclxuICAgIDo6S2VybmVsLnJhaXNlIFwiT3BhbCBkb2Vzbid0IHN1cHBvcnQgZHluYW1pYyBjYWxscyB0byBiaW5kaW5nXCJcclxuICBlbmRcclxuZW5kXHJcblxyXG5UT1BMRVZFTF9CSU5ESU5HID0gOjpCaW5kaW5nLm5ldyhcclxuICAleHtcclxuICAgIGZ1bmN0aW9uKGpzKSB7XHJcbiAgICAgIHJldHVybiAobmV3IEZ1bmN0aW9uKFwic2VsZlwiLCBcInJldHVybiBcIiArIGpzKSkoc2VsZik7XHJcbiAgICB9XHJcbiAgfSxcclxuICBbXSwgc2VsZiwgWyc8bWFpbj4nLCAwXVxyXG4pXHJcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkJpbmRpbmc+IiwiaW5pdGlhbGl6ZSIsImpzZXZhbCIsInNjb3BlX3ZhcmlhYmxlcyIsInJlY2VpdmVyIiwic291cmNlX2xvY2F0aW9uIiwiQGpzZXZhbCIsIkBzY29wZV92YXJpYWJsZXMiLCJAcmVjZWl2ZXIiLCJAc291cmNlX2xvY2F0aW9uIiwic2VsZiIsImpzX2V2YWwiLCJjYWxsIiwiYXJncyIsIktlcm5lbCIsInJhaXNlIiwibG9jYWxfdmFyaWFibGVfZ2V0Iiwic3ltYm9sIiwiRXhjZXB0aW9uIiwiTmFtZUVycm9yIiwiaW5zcGVjdCIsImxvY2FsX3ZhcmlhYmxlX3NldCIsInZhbHVlIiwibG9jYWxfdmFyaWFibGVzIiwibG9jYWxfdmFyaWFibGVfZGVmaW5lZD8iLCJpbmNsdWRlPyIsImV2YWwiLCJzdHIiLCJmaWxlIiwibGluZSIsImF0dHJfcmVhZGVyIiwiPG1vZHVsZTpLZXJuZWw+IiwiYmluZGluZyIsIkJpbmRpbmciLCJuZXciLCIwIl0sIm1hcHBpbmdzIjoiQUFBQUEsa0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBRUFDO0VBQUFBOztJQUFBQTs7QUFBQUE7OztBQUVFQyxJQUFBQSwwQkFBQUEsc0JBQWVDLE1BQUQsRUFBU0MsZUFBVCxFQUErQkMsUUFBL0IsRUFBcURDLGVBQW5FSjtBQUFBQSxNQUFBQTs7O01BQXVCLCtDQUFrQjs7TUFBMEIsK0NBQWtCO01BQ25GLEtBQ0UsQ0FBQUMsTUFBQSxFQUFRQyxlQUFSLEVBQXlCQyxRQUF6QixFQUFtQ0MsZUFBbkMsQ0FERixFQUFBQyxDQUFBQSxjQUFBLEtBQUFBLENBQUEsRUFBU0MsQ0FBQUEsdUJBQVQsS0FBU0EsQ0FBVCxFQUEyQkMsQ0FBQUEsZ0JBQTNCLEtBQTJCQSxDQUEzQixFQUFzQ0MsQ0FBQUEsdUJBQXRDLEtBQXNDQSxDQUF0Qzs7QUFHSlI7QUFDQUE7QUFDQUE7TUFDSSxJQUFBLFFBQW1DQSw2QkFBbkMsQ0FBQTtRQVhKQSxPQUFBO01BV0k7UUFBQUEsT0FBQUcsQ0FBQUEsV0FBV00sSUFBQUMsU0FBQUEsQ0FBUVYsTUFBUlUsQ0FBWFA7TUFBQTtJQVBGSCxDQUFBQSxJQUFBQTs7QUFVQVUsSUFBQUEsdUJBQUFBLG1CQWRGLEVBY0VBO0FBQUFBLE1BQUFBOzs7TUFkRjtNQWNjO01BQ1YsSUFBQSxRQUFHTCxXQUFILENBQUE7UUFDRUssT0FBT0MsTUFBUE4sV0FBT00sUUFBQUEsRUFBTSxNQUFDQyxJQUFELENBQU5EO01BRFQ7UUFHRUQsT0FBQUcsT0FBUUMsT0FBQUEsQ0FBT0osK0NBQVBJO01BSFY7SUFERkosQ0FBQUEsSUFBQUE7O0FBUUFLLElBQUFBLGtDQUFBQSw4QkFBdUJDLE1BQXZCRDtBQUFBQSxNQUFBQTs7TUFDRTtRQUFBQSxPQUFBTixJQUFBQyxTQUFBQSxDQUFRTSxNQUFSTjtNQUFBO1FBQ0Ysc0JBQU8sQ0FBQU8sZ0JBQUEsQ0FBUDtVQUFBO1lBQ0VGLE9BQUFGLE9BQVFDLE9BQUFBLENBQU9JLGdCQUFmLEVBQTZCSCxrQkFBRCxHQUFBLE1BQW1CQyxNQUFuQixDQUFBLEdBQTBCRCx1QkFBMUIsR0FBQSxNQUFpRE4sSUFBQVUsU0FBQUEsQ0FBQUEsQ0FBakQsQ0FBcEJMO1VBRFY7UUFBQSxDQURFO01BQUE7SUFERkMsQ0FBQUE7O0FBTUFLLElBQUFBLGtDQUFBQSw4QkFBdUJKLE1BQUQsRUFBU0ssS0FBL0JEO0FBQUFBLE1BQUFBOzs7TUFDR0E7TUFDRFgsSUFBQUMsU0FBQUEsQ0FBUSxNQUFHTSxNQUFILENBQUEsR0FBVUksMkJBQWxCVjtNQUNDVTtNQUNEQSxPQUFBQztJQUpGRCxDQUFBQTs7QUFPQUUsSUFBQUEsK0JBQUFBLGFBQ0UsaUJBREZBLENBQUFBOztBQUlBQyxJQUFBQSx1Q0FBQUEsZ0RBQTRCRixLQUE1QkU7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFqQixvQkFBZ0JrQixhQUFBQSxDQUFVSCxLQUFWRztJQURsQkQsQ0FBQUE7O0FBSUFFLElBQUFBLG9CQUFBQSx5QkFBU0MsR0FBRCxFQUFNQyxJQUFOLEVBQWtCQyxJQUExQkgsR0FBQUE7QUFBQUEsTUFBQUE7OztNQUFjLHlCQUFPO01BQUsseUJBQU87TUFDL0IsSUFBQSxNQUFtQkMsR0FBbkIsRUFBMEJELE1BQTFCLENBQUE7UUFBQSxPQUFPaEIsSUFBQU4sVUFBQUEsQ0FBQUE7TUFBUDtNQUVBc0IsT0FBQVosT0FBUVksTUFBQUEsQ0FBTUMsR0FBZCxFQUFtQmpCLElBQW5CLEVBQXlCa0IsSUFBekIsRUFBK0JDLElBQXZCSCxFQUhWQTtRQUFBQTtRQUFBQTtNQUFBQTtJQUFBQSxDQUFBQSxJQUFBQTtJQU1BMUIsT0FBQVUsSUFBQW9CLGFBQUFBLENBQVksVUFBWixFQUF1QixpQkFBdkJBO0VBL0NGOUIsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtFQWtEQStCO0VBQUFBOzs7SUFDRUEsT0FBQUMsdUJBQUFBLG1CQUFBQTtBQUFBQTtNQUNFQSxPQUFBbEIsT0FBUUMsT0FBQUEsQ0FBT2lCLCtDQUFQakI7SUFEVmlCLENBQUFBO0VBREZELEdBQU8sSUFBUEE7RUFNQWhDLE9BQUEsNENBQW1Ca0MsY0FBU0MsS0FBQUE7QUFFNUJuQztBQUNBQTtBQUNBQTtBQUNBQSxFQUxtQixFQU1qQixFQU5pQixFQU1iVyxJQU5hLEVBTVAsQ0FBQ1gsUUFBRCxFQUFXb0MsQ0FBWCxDQU5nQkQsQ0FBNUI7QUExREFuQzsifX0seyJvZmZzZXQiOnsibGluZSI6MjYyNTcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2lyYi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcclxuXHJcbiMgRGVidWcgaXMgYSBoZWxwZXIgbW9kdWxlIHRoYXQgYWxsb3dzIHVzIHRvIGNvbmR1Y3Qgc29tZSBkZWJ1Z2dpbmcgb25cclxuIyBhIGxpdmUgY29kZWJhc2UuIEl0IGdvZXMgd2l0aCBhbiBhc3N1bXB0aW9uLCB0aGF0IG9wYWwtcGFyc2VyIG9yXHJcbiMgb3BhbC1yZXBsdXRpbHMgd2lsbCBub3QgYmUgbG9hZGVkLCBpbiB3aGljaCBjYXNlIHdlIHdpbGwgZG8gd2hhdCB3ZSBjYW5cclxuIyB0byBwcm92aXNpb24gaXQuXHJcblxyXG5tb2R1bGUgT3BhbFxyXG4gIG1vZHVsZSBJUkJcclxuICAgIGRlZiBzZWxmLmVuc3VyZV9sb2FkZWQobGlicmFyeSlcclxuICAgICAgcmV0dXJuIGlmIGBPcGFsLmxvYWRlZF9mZWF0dXJlc2AuaW5jbHVkZT8gbGlicmFyeVxyXG5cclxuICAgICAgdmVyc2lvbiA9IGlmIFJVQllfRU5HSU5FX1ZFUlNJT04uaW5jbHVkZT8gJ2RldidcclxuICAgICAgICAgICAgICAgICAgJ21hc3RlcidcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgUlVCWV9FTkdJTkVfVkVSU0lPTlxyXG4gICAgICAgICAgICAgICAgZW5kXHJcblxyXG4gICAgICB1cmwgPSBcImh0dHBzOi8vY2RuLm9wYWxyYi5jb20vb3BhbC8je3ZlcnNpb259LyN7bGlicmFyeX0uanNcIlxyXG5cclxuICAgICAgJXh7XHJcbiAgICAgICAgdmFyIGxpYmNvZGU7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7IC8vIEJyb3dzZXJcclxuICAgICAgICAgIHZhciByID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICByLm9wZW4oXCJHRVRcIiwgdXJsLCBmYWxzZSk7XHJcbiAgICAgICAgICByLnNlbmQoJycpO1xyXG4gICAgICAgICAgbGliY29kZSA9IHIucmVzcG9uc2VUZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgXCJZb3UgbmVlZCB0byBwcm92aXNpb24gI3tsaWJyYXJ5fSB5b3Vyc2VsZiBpbiB0aGlzIGVudmlyb25tZW50XCJ9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAobmV3IEZ1bmN0aW9uKCdPcGFsJywgbGliY29kZSkpKE9wYWwpO1xyXG5cclxuICAgICAgICBPcGFsLnJlcXVpcmUobGlicmFyeSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIDo6S2VybmVsLnJhaXNlIFwiQ291bGQgbm90IGxvYWQgI3tsaWJyYXJ5fSBmb3Igc29tZSByZWFzb25cIiB1bmxlc3MgYE9wYWwubG9hZGVkX2ZlYXR1cmVzYC5pbmNsdWRlPyBsaWJyYXJ5XHJcbiAgICBlbmRcclxuXHJcbiAgICBzaW5nbGV0b25fY2xhc3MuYXR0cl9hY2Nlc3NvciA6b3V0cHV0XHJcblxyXG4gICAgZGVmIHNlbGYucHJlcGFyZV9jb25zb2xlKCZibG9jaylcclxuICAgICAgc2VsZi5vdXRwdXQgPSAnJ1xyXG5cclxuICAgICAgb3JpZ2luYWwgPSB7XHJcbiAgICAgICAgJHN0ZG91dCA9PiAtPihpKSB7ICRzdGRvdXQgPSBpIH0sXHJcbiAgICAgICAgJHN0ZGVyciA9PiAtPihpKSB7ICRzdGRlcnIgPSBpIH0sXHJcbiAgICAgIH1cclxuXHJcbiAgICAgICMgUHJlcGFyZSBhIGJldHRlciBwcm9tcHQgZXhwZXJpZW5jZSBmb3IgYSBicm93c2VyXHJcbiAgICAgIGlmIGJyb3dzZXI/XHJcbiAgICAgICAgb3JpZ2luYWwuZWFjaCBkbyB8cGlwZSwgcGlwZV9zZXR0ZXJ8XHJcbiAgICAgICAgICBuZXdfcGlwZSA9IHBpcGUuZHVwXHJcbiAgICAgICAgICBuZXdfcGlwZS53cml0ZV9wcm9jID0gcHJvYyBkbyB8c3RyfFxyXG4gICAgICAgICAgICBzZWxmLm91dHB1dCArPSBzdHJcclxuICAgICAgICAgICAgc2VsZi5vdXRwdXQgPSBvdXRwdXQuc3BsaXQoXCJcXG5cIikubGFzdCgzMCkuam9pbihcIlxcblwiKVxyXG4gICAgICAgICAgICBzZWxmLm91dHB1dCArPSBcIlxcblwiIGlmIHN0ci5lbmRfd2l0aD8gXCJcXG5cIlxyXG5cclxuICAgICAgICAgICAgcGlwZS53cml0ZV9wcm9jLmNhbGwoc3RyKVxyXG4gICAgICAgICAgZW5kXHJcbiAgICAgICAgICBuZXdfcGlwZS50dHkgPSBmYWxzZVxyXG4gICAgICAgICAgcGlwZV9zZXR0ZXIuY2FsbChuZXdfcGlwZSlcclxuICAgICAgICBlbmRcclxuXHJcbiAgICAgICAgb3JpZ2luYWxfcmVhZF9wcm9jID0gJHN0ZGluLnJlYWRfcHJvY1xyXG4gICAgICAgICRzdGRpbi5yZWFkX3Byb2MgPSBgZnVuY3Rpb24ocykgeyB2YXIgcCA9IHByb21wdCgje291dHB1dH0pOyBpZiAocCAhPT0gbnVsbCkgcmV0dXJuIHAgKyBcIlxcblwiOyByZXR1cm4gbmlsOyB9YFxyXG4gICAgICBlbmRcclxuXHJcbiAgICAgIHlpZWxkXHJcbiAgICBlbnN1cmVcclxuICAgICAgb3JpZ2luYWwuZWFjaCBkbyB8cGlwZSwgcGlwZV9zZXR0ZXJ8XHJcbiAgICAgICAgcGlwZV9zZXR0ZXIuY2FsbChwaXBlKVxyXG4gICAgICBlbmRcclxuICAgICAgJHN0ZGluLnJlYWRfcHJvYyA9IG9yaWdpbmFsX3JlYWRfcHJvY1xyXG4gICAgICBzZWxmLm91dHB1dCA9ICcnXHJcbiAgICBlbmRcclxuXHJcbiAgICBkZWYgc2VsZi5icm93c2VyP1xyXG4gICAgICBgdHlwZW9mKGRvY3VtZW50KSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mKHByb21wdCkgIT09ICd1bmRlZmluZWQnYFxyXG4gICAgZW5kXHJcblxyXG4gICAgTElORUJSRUFLUyA9IFtcclxuICAgICAgJ3VuZXhwZWN0ZWQgdG9rZW4gJGVuZCcsXHJcbiAgICAgICd1bnRlcm1pbmF0ZWQgc3RyaW5nIG1lZXRzIGVuZCBvZiBmaWxlJ1xyXG4gICAgXS5mcmVlemVcclxuXHJcbiAgICBjbGFzcyBTaWxlbmNlclxyXG4gICAgICBkZWYgaW5pdGlhbGl6ZVxyXG4gICAgICAgIEBzdGRlcnIgPSAkc3RkZXJyXHJcbiAgICAgIGVuZFxyXG5cclxuICAgICAgZGVmIHNpbGVuY2VcclxuICAgICAgICBAY29sbGVjdG9yID0gOjpTdHJpbmdJTy5uZXdcclxuICAgICAgICAkc3RkZXJyID0gQGNvbGxlY3RvclxyXG4gICAgICAgIHlpZWxkXHJcbiAgICAgIGVuc3VyZVxyXG4gICAgICAgICRzdGRlcnIgPSBAc3RkZXJyXHJcbiAgICAgIGVuZFxyXG5cclxuICAgICAgZGVmIHdhcm5pbmdzXHJcbiAgICAgICAgQGNvbGxlY3Rvci5zdHJpbmdcclxuICAgICAgZW5kXHJcbiAgICBlbmRcclxuICBlbmRcclxuZW5kXHJcblxyXG5jbGFzcyA6OkJpbmRpbmdcclxuICBkZWYgaXJiXHJcbiAgICA6Ok9wYWw6OklSQi5lbnN1cmVfbG9hZGVkKCdvcGFsLXJlcGx1dGlscycpXHJcblxyXG4gICAgc2lsZW5jZXIgPSA6Ok9wYWw6OklSQjo6U2lsZW5jZXIubmV3XHJcblxyXG4gICAgOjpPcGFsOjpJUkIucHJlcGFyZV9jb25zb2xlIGRvXHJcbiAgICAgIGxvb3AgZG9cclxuICAgICAgICBwcmludCAnPj4gJ1xyXG4gICAgICAgIGxpbmUgPSBnZXRzXHJcbiAgICAgICAgYnJlYWsgdW5sZXNzIGxpbmVcclxuICAgICAgICBjb2RlID0gJydcclxuXHJcbiAgICAgICAgcHV0cyBsaW5lIGlmIDo6T3BhbDo6SVJCLmJyb3dzZXI/XHJcblxyXG4gICAgICAgIGlmIGxpbmUuc3RhcnRfd2l0aD8gJ2xzICdcclxuICAgICAgICAgIGNvZGUgPSBsaW5lWzMuLi0xXVxyXG4gICAgICAgICAgbW9kZSA9IDpsc1xyXG4gICAgICAgIGVsc2lmIGxpbmUgPT0gXCJsc1xcblwiXHJcbiAgICAgICAgICBjb2RlID0gJ3NlbGYnXHJcbiAgICAgICAgICBtb2RlID0gOmxzXHJcbiAgICAgICAgZWxzaWYgbGluZS5zdGFydF93aXRoPyAnc2hvdyAnXHJcbiAgICAgICAgICBjb2RlID0gbGluZVs1Li4tMV1cclxuICAgICAgICAgIG1vZGUgPSA6c2hvd1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIGNvZGUgPSBsaW5lXHJcbiAgICAgICAgICBtb2RlID0gOmluc3BlY3RcclxuICAgICAgICBlbmRcclxuXHJcbiAgICAgICAganNfY29kZSA9IG5pbFxyXG5cclxuICAgICAgICBiZWdpblxyXG4gICAgICAgICAgc2lsZW5jZXIuc2lsZW5jZSBkb1xyXG4gICAgICAgICAgICBqc19jb2RlID0gYE9wYWwuY29tcGlsZShjb2RlLCB7aXJiOiB0cnVlfSlgXHJcbiAgICAgICAgICBlbmRcclxuICAgICAgICByZXNjdWUgU3ludGF4RXJyb3IgPT4gZVxyXG4gICAgICAgICAgaWYgOjpPcGFsOjpJUkI6OkxJTkVCUkVBS1MuaW5jbHVkZT8oZS5tZXNzYWdlKVxyXG4gICAgICAgICAgICBwcmludCAnLi4gJ1xyXG4gICAgICAgICAgICBsaW5lID0gZ2V0c1xyXG4gICAgICAgICAgICByZXR1cm4gdW5sZXNzIGxpbmVcclxuICAgICAgICAgICAgcHV0cyBsaW5lIGlmIDo6T3BhbDo6SVJCLmJyb3dzZXI/XHJcbiAgICAgICAgICAgIGNvZGUgKz0gbGluZVxyXG4gICAgICAgICAgICByZXRyeVxyXG4gICAgICAgICAgZWxzaWYgc2lsZW5jZXIud2FybmluZ3MuZW1wdHk/XHJcbiAgICAgICAgICAgIHdhcm4gZS5mdWxsX21lc3NhZ2VcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgIyBNb3N0IGxpa2VseSBhIHBhcnNlciBlcnJvclxyXG4gICAgICAgICAgICB3YXJuIHNpbGVuY2VyLndhcm5pbmdzXHJcbiAgICAgICAgICBlbmRcclxuICAgICAgICBlbmRcclxuXHJcbiAgICAgICAgaWYgbW9kZSA9PSA6c2hvd1xyXG4gICAgICAgICAgcHV0cyBqc19jb2RlXHJcbiAgICAgICAgICByZXR1cm5cclxuICAgICAgICBlbmRcclxuXHJcbiAgICAgICAgcHV0cyA6OlJFUExVdGlscy5ldmFsX2FuZF9wcmludChqc19jb2RlLCBtb2RlLCBmYWxzZSwgc2VsZilcclxuICAgICAgZW5kXHJcbiAgICBlbmRcclxuICBlbmRcclxuZW5kXHJcblxyXG4leHtcclxuICAvLyBSdW4gaW4gV2ViVG9vbHMgY29uc29sZSB3aXRoOiBPcGFsLmlyYihjID0+IGV2YWwoYykpXHJcbiAgT3BhbC5pcmIgPSBmdW5jdGlvbihmdW4pIHtcclxuICAgICN7OjpCaW5kaW5nLm5ldyhgZnVuYCkuaXJifVxyXG4gIH1cclxuXHJcbiAgT3BhbC5sb2FkX3BhcnNlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgT3BhbC5PcGFsLklSQi4kZW5zdXJlX2xvYWRlZCgnb3BhbC1wYXJzZXInKTtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgT3BhbC5ldmFsID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgT3BhbC5ldmFsID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgIE9wYWwubG9hZF9wYXJzZXIoKTtcclxuICAgICAgcmV0dXJuIE9wYWwuZXZhbChzdHIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiBPcGFsLmNvbXBpbGUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBPcGFsLmNvbXBpbGUgPSBmdW5jdGlvbihzdHIsIG9wdGlvbnMpIHtcclxuICAgICAgT3BhbC5sb2FkX3BhcnNlcigpO1xyXG4gICAgICByZXR1cm4gT3BhbC5jb21waWxlKHN0ciwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpPcGFsPiIsIjxtb2R1bGU6SVJCPiIsImVuc3VyZV9sb2FkZWQiLCJzZWxmIiwibGlicmFyeSIsImluY2x1ZGU/IiwidmVyc2lvbiIsIlJVQllfRU5HSU5FX1ZFUlNJT04iLCJ1cmwiLCJLZXJuZWwiLCJyYWlzZSIsInNpbmdsZXRvbl9jbGFzcyIsImF0dHJfYWNjZXNzb3IiLCJwcmVwYXJlX2NvbnNvbGUiLCJvdXRwdXQ9Iiwib3JpZ2luYWwiLCIkc3Rkb3V0IiwiYmxvY2sgaW4gcHJlcGFyZV9jb25zb2xlIiwiaSIsImJsb2NrICgyIGxldmVscykgaW4gcHJlcGFyZV9jb25zb2xlIiwiJHN0ZGVyciIsImJyb3dzZXI/IiwiZWFjaCIsInBpcGUiLCJwaXBlX3NldHRlciIsIm5ld19waXBlIiwiZHVwIiwid3JpdGVfcHJvYz0iLCJwcm9jIiwic3RyIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBwcmVwYXJlX2NvbnNvbGUiLCIrIiwib3V0cHV0Iiwic3BsaXQiLCJsYXN0IiwiMzAiLCJqb2luIiwiZW5kX3dpdGg/Iiwid3JpdGVfcHJvYyIsImNhbGwiLCJ0dHk9Iiwib3JpZ2luYWxfcmVhZF9wcm9jIiwiJHN0ZGluIiwicmVhZF9wcm9jIiwicmVhZF9wcm9jPSIsImZyZWV6ZSIsIjxjbGFzczpTaWxlbmNlcj4iLCJpbml0aWFsaXplIiwiQHN0ZGVyciIsInNpbGVuY2UiLCJAY29sbGVjdG9yIiwiU3RyaW5nSU8iLCJuZXciLCJ3YXJuaW5ncyIsInN0cmluZyIsIjxjbGFzczpCaW5kaW5nPiIsImlyYiIsIk9wYWw6OklSQiIsIk9wYWwiLCJzaWxlbmNlciIsIk9wYWw6OklSQjo6U2lsZW5jZXIiLCJibG9jayBpbiBpcmIiLCJibG9jayAoMiBsZXZlbHMpIGluIGlyYiIsImxvb3AiLCJibG9jayAoMyBsZXZlbHMpIGluIGlyYiIsInByaW50IiwibGluZSIsImdldHMiLCJjb2RlIiwicHV0cyIsInN0YXJ0X3dpdGg/IiwiW10iLCIzIiwiLTEiLCJtb2RlIiwiNSIsImpzX2NvZGUiLCJibG9jayAoNCBsZXZlbHMpIGluIGlyYiIsIlN5bnRheEVycm9yIiwiZSIsIk9wYWw6OklSQjo6TElORUJSRUFLUyIsIm1lc3NhZ2UiLCJlbXB0eT8iLCJ3YXJuIiwiZnVsbF9tZXNzYWdlIiwiUkVQTFV0aWxzIiwiZXZhbF9hbmRfcHJpbnQiLCJCaW5kaW5nIl0sIm1hcHBpbmdzIjoiQUFBQUEsOEJBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBT0FDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUM7SUFBQUE7O01BQUFBOzs7TUFDRUMsTUFBSUMsSUFBSkQsb0JBQUFBLHlCQUF1QkUsT0FBdkJGO0FBQUFBLFFBQUFBOzs7UUFDRSxJQUFBLFFBQVVBLENBQUNBLG9CQUFEQSxDQUFzQkcsYUFBQUEsQ0FBVUQsT0FBVkMsQ0FBaEMsQ0FBQTtVQUFBLE9BQUE7UUFBQTtRQUVBQyxVQUFVLENBQUEsUUFBR0MseUJBQW1CRixhQUFBQSxDQUFVSCxLQUFWRyxDQUF0QixDQUFBLEdBQUEsQ0FDRUgsUUFERixJQUFBLENBR0VLLHlCQUhGLENBQUE7UUFNVkMsTUFBT04sOEJBQUQsR0FBQSxNQUErQkksT0FBL0IsQ0FBQSxHQUF1Q0osR0FBdkMsR0FBQSxNQUEwQ0UsT0FBMUMsQ0FBQSxHQUFrREY7O0FBRzlEQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFD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QSxDQUFXaEQsRUFMYjJDO1FBQUFBO1FBQUFBO01BQUFBLENBQUFBLFVBQUFBLDJCQUFBQTtJQUFBQSxDQUFBQTtFQURGRCxHQUFNLElBQU5BLEVBQUFBLElBQUFBOztBQStEQXhEO0FBQ0FBO0FBQ0FBLElBQU13RixjQUFTbkMsS0FBQUEsQ0FBTXJELEdBQU5xRCxDQUFXSSxLQUFBQSxDQUFBQTtBQUMxQnpEOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQWhNQUE7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI2NTA4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9vcGFsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIjo6T2JqZWN0LnJlcXVpcmUgJ29wYWwvYmFzZSdcclxuOjpPYmplY3QucmVxdWlyZSAnb3BhbC9taW5pJ1xyXG5cclxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9rZXJuZWwvZm9ybWF0J1xyXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3N0cmluZy9lbmNvZGluZydcclxuOjpPYmplY3QuYXV0b2xvYWQgOk1hdGgsICdjb3JlbGliL21hdGgnXHJcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvY29tcGxleC9iYXNlJ1xyXG46Ok9iamVjdC5hdXRvbG9hZCA6Q29tcGxleCwgJ2NvcmVsaWIvY29tcGxleCdcclxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9yYXRpb25hbC9iYXNlJ1xyXG46Ok9iamVjdC5hdXRvbG9hZCA6UmF0aW9uYWwsICdjb3JlbGliL3JhdGlvbmFsJ1xyXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3RpbWUnXHJcbjo6T2JqZWN0LmF1dG9sb2FkIDpTdHJ1Y3QsICdjb3JlbGliL3N0cnVjdCdcclxuOjpPYmplY3QuYXV0b2xvYWQgOlNldCwgJ2NvcmVsaWIvc2V0J1xyXG46Ok9iamVjdC5hdXRvbG9hZCA6RGlyLCAnY29yZWxpYi9kaXInXHJcbjo6T2JqZWN0LmF1dG9sb2FkIDpGaWxlLCAnY29yZWxpYi9maWxlJ1xyXG5cclxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9wcm9jZXNzL2Jhc2UnXHJcbjo6T2JqZWN0LmF1dG9sb2FkIDpQcm9jZXNzLCAnY29yZWxpYi9wcm9jZXNzJ1xyXG46Ok9iamVjdC5hdXRvbG9hZCA6UmFuZG9tLCAnY29yZWxpYi9yYW5kb20nXHJcblxyXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3Vuc3VwcG9ydGVkJ1xyXG5cclxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9iaW5kaW5nJ1xyXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2lyYidcclxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJPYmplY3QiLCJyZXF1aXJlIiwiYXV0b2xvYWQiXSwibWFwcGluZ3MiOiJBQUFBQSx1QkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsT0FBUUMsU0FBQUEsQ0FBU0YsV0FBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsV0FBVEU7RUFFUkQsT0FBUUMsU0FBQUEsQ0FBU0YsdUJBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLHlCQUFURTtFQUNSRCxPQUFRRSxVQUFBQSxDQUFVLE1BQWxCLEVBQXlCSCxjQUFqQkc7RUFDUkYsT0FBUUMsU0FBQUEsQ0FBU0Ysc0JBQVRFO0VBQ1JELE9BQVFFLFVBQUFBLENBQVUsU0FBbEIsRUFBNEJILGlCQUFwQkc7RUFDUkYsT0FBUUMsU0FBQUEsQ0FBU0YsdUJBQVRFO0VBQ1JELE9BQVFFLFVBQUFBLENBQVUsVUFBbEIsRUFBNkJILGtCQUFyQkc7RUFDUkYsT0FBUUMsU0FBQUEsQ0FBU0YsY0FBVEU7RUFDUkQsT0FBUUUsVUFBQUEsQ0FBVSxRQUFsQixFQUEyQkgsZ0JBQW5CRztFQUNSRixPQUFRRSxVQUFBQSxDQUFVLEtBQWxCLEVBQXdCSCxhQUFoQkc7RUFDUkYsT0FBUUUsVUFBQUEsQ0FBVSxLQUFsQixFQUF3QkgsYUFBaEJHO0VBQ1JGLE9BQVFFLFVBQUFBLENBQVUsTUFBbEIsRUFBeUJILGNBQWpCRztFQUVSRixPQUFRQyxTQUFBQSxDQUFTRixzQkFBVEU7RUFDUkQsT0FBUUUsVUFBQUEsQ0FBVSxTQUFsQixFQUE0QkgsaUJBQXBCRztFQUNSRixPQUFRRSxVQUFBQSxDQUFVLFFBQWxCLEVBQTJCSCxnQkFBbkJHO0VBRVJGLE9BQVFDLFNBQUFBLENBQVNGLHFCQUFURTtFQUVSRCxPQUFRQyxTQUFBQSxDQUFTRixpQkFBVEU7RUFDUkYsT0FBQUMsT0FBUUMsU0FBQUEsQ0FBU0YsYUFBVEU7QUF2QlJGOztBQUFBQTsifX0seyJvZmZzZXQiOnsibGluZSI6MjY1MzcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL29wYWwucmIiXSwic291cmNlc0NvbnRlbnQiOlsiOjpPYmplY3QucmVxdWlyZSAnb3BhbC9iYXNlJ1xyXG46Ok9iamVjdC5yZXF1aXJlICdvcGFsL21pbmknXHJcblxyXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2tlcm5lbC9mb3JtYXQnXHJcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvc3RyaW5nL2VuY29kaW5nJ1xyXG46Ok9iamVjdC5hdXRvbG9hZCA6TWF0aCwgJ2NvcmVsaWIvbWF0aCdcclxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9jb21wbGV4L2Jhc2UnXHJcbjo6T2JqZWN0LmF1dG9sb2FkIDpDb21wbGV4LCAnY29yZWxpYi9jb21wbGV4J1xyXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3JhdGlvbmFsL2Jhc2UnXHJcbjo6T2JqZWN0LmF1dG9sb2FkIDpSYXRpb25hbCwgJ2NvcmVsaWIvcmF0aW9uYWwnXHJcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvdGltZSdcclxuOjpPYmplY3QuYXV0b2xvYWQgOlN0cnVjdCwgJ2NvcmVsaWIvc3RydWN0J1xyXG46Ok9iamVjdC5hdXRvbG9hZCA6U2V0LCAnY29yZWxpYi9zZXQnXHJcbjo6T2JqZWN0LmF1dG9sb2FkIDpEaXIsICdjb3JlbGliL2RpcidcclxuOjpPYmplY3QuYXV0b2xvYWQgOkZpbGUsICdjb3JlbGliL2ZpbGUnXHJcblxyXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3Byb2Nlc3MvYmFzZSdcclxuOjpPYmplY3QuYXV0b2xvYWQgOlByb2Nlc3MsICdjb3JlbGliL3Byb2Nlc3MnXHJcbjo6T2JqZWN0LmF1dG9sb2FkIDpSYW5kb20sICdjb3JlbGliL3JhbmRvbSdcclxuXHJcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvdW5zdXBwb3J0ZWQnXHJcblxyXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2JpbmRpbmcnXHJcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvaXJiJ1xyXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIk9iamVjdCIsInJlcXVpcmUiLCJhdXRvbG9hZCJdLCJtYXBwaW5ncyI6IkFBQUFBLHVCQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxPQUFRQyxTQUFBQSxDQUFTRixXQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixXQUFURTtFQUVSRCxPQUFRQyxTQUFBQSxDQUFTRix1QkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YseUJBQVRFO0VBQ1JELE9BQVFFLFVBQUFBLENBQVUsTUFBbEIsRUFBeUJILGNBQWpCRztFQUNSRixPQUFRQyxTQUFBQSxDQUFTRixzQkFBVEU7RUFDUkQsT0FBUUUsVUFBQUEsQ0FBVSxTQUFsQixFQUE0QkgsaUJBQXBCRztFQUNSRixPQUFRQyxTQUFBQSxDQUFTRix1QkFBVEU7RUFDUkQsT0FBUUUsVUFBQUEsQ0FBVSxVQUFsQixFQUE2Qkgsa0JBQXJCRztFQUNSRixPQUFRQyxTQUFBQSxDQUFTRixjQUFURTtFQUNSRCxPQUFRRSxVQUFBQSxDQUFVLFFBQWxCLEVBQTJCSCxnQkFBbkJHO0VBQ1JGLE9BQVFFLFVBQUFBLENBQVUsS0FBbEIsRUFBd0JILGFBQWhCRztFQUNSRixPQUFRRSxVQUFBQSxDQUFVLEtBQWxCLEVBQXdCSCxhQUFoQkc7RUFDUkYsT0FBUUUsVUFBQUEsQ0FBVSxNQUFsQixFQUF5QkgsY0FBakJHO0VBRVJGLE9BQVFDLFNBQUFBLENBQVNGLHNCQUFURTtFQUNSRCxPQUFRRSxVQUFBQSxDQUFVLFNBQWxCLEVBQTRCSCxpQkFBcEJHO0VBQ1JGLE9BQVFFLFVBQUFBLENBQVUsUUFBbEIsRUFBMkJILGdCQUFuQkc7RUFFUkYsT0FBUUMsU0FBQUEsQ0FBU0YscUJBQVRFO0VBRVJELE9BQVFDLFNBQUFBLENBQVNGLGlCQUFURTtFQUNSRixPQUFBQyxPQUFRQyxTQUFBQSxDQUFTRixhQUFURTtBQXZCUkY7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI2NTY0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLlxcdGVzdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdvcGFsJ1xucHV0cyAncmVhZHknXG5cbnQgPSBTdHJpbmcubmV3KCdibGEnKVxucHV0cyB0XG5wdXRzIHQuc2l6ZVxucHV0cyBgdC5sZW5ndGhgXG5cbnQgPDwgJ2hhaGEnXG5wdXRzIHRcbnB1dHMgdC5zaXplXG5wdXRzIGB0Lmxlbmd0aGBcbiJdLCJuYW1lcyI6WyI8bWFpbj4iLCJzZWxmIiwicmVxdWlyZSIsInB1dHMiLCJ0IiwiU3RyaW5nIiwibmV3Iiwic2l6ZSIsIjw8Il0sIm1hcHBpbmdzIjoiQUFBQUEsMkJBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsTUFBUkU7RUFDQUQsSUFBQUUsTUFBQUEsQ0FBS0gsT0FBTEc7RUFFQUMsSUFBSUMsWUFBTUMsS0FBQUEsQ0FBS04sS0FBTE07RUFDVkwsSUFBQUUsTUFBQUEsQ0FBS0MsQ0FBTEQ7RUFDQUYsSUFBQUUsTUFBQUEsQ0FBS0MsQ0FBQ0csTUFBQUEsQ0FBQUEsQ0FBTko7RUFDQUYsSUFBQUUsTUFBQUEsQ0FBTUgsUUFBTkc7RUFFQUMsQ0FBRUksT0FBQUEsQ0FBR1IsTUFBSFE7RUFDRlAsSUFBQUUsTUFBQUEsQ0FBS0MsQ0FBTEQ7RUFDQUYsSUFBQUUsTUFBQUEsQ0FBS0MsQ0FBQ0csTUFBQUEsQ0FBQUEsQ0FBTko7RUFDQUgsT0FBQUMsSUFBQUUsTUFBQUEsQ0FBTUgsUUFBTkc7QUFYQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI2NTgxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiKGV4aXQpIl0sInNvdXJjZXNDb250ZW50IjpbIjo6S2VybmVsLmV4aXRcbiJdLCJuYW1lcyI6WyI8bWFpbj4iLCJLZXJuZWwiLCJleGl0Il0sIm1hcHBpbmdzIjoiQUFBQUEsMkJBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQyxPQUFRQyxNQUFBQSxDQUFBQTtBQUFSRjsifX1dfQ==
